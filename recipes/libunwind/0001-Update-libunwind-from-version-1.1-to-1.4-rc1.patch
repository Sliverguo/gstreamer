From c2d56876da9748855a00a4885935372f1b71b375 Mon Sep 17 00:00:00 2001
From: guodi <di.guo@aispeech.com>
Date: Thu, 1 Aug 2019 15:26:23 +0800
Subject: [PATCH] Update libunwind from version 1.1 to 1.4-rc1

Signed-off-by: guodi <di.guo@aispeech.com>
---
 INSTALL                                    |    8 +-
 Makefile.am                                |   39 +-
 Makefile.in                                |  417 ++--
 NEWS                                       |   18 +
 README                                     |  216 +--
 aclocal.m4                                 |  693 ++++---
 config/compile                             |   99 +-
 config/config.guess                        |  184 +-
 config/config.sub                          |   97 +-
 config/depcomp                             |  487 +++--
 config/install-sh                          |   35 +-
 config/ltmain.sh                           |   32 +-
 config/missing                             |  414 ++--
 configure                                  | 1166 +++++++++---
 configure.ac                               |  130 +-
 doc/Makefile.am                            |    7 +
 doc/Makefile.in                            |  140 +-
 doc/libunwind.man                          |   14 +-
 doc/libunwind.tex                          |    6 +-
 doc/unw_apply_reg_state.man                |   90 +
 doc/unw_apply_reg_state.tex                |   63 +
 doc/unw_flush_cache.man                    |    5 +-
 doc/unw_flush_cache.tex                    |    1 +
 doc/unw_init_local.man                     |   33 +-
 doc/unw_init_local.tex                     |   23 +-
 doc/unw_init_local2.man                    |    1 +
 doc/unw_reg_states_iterate.man             |  137 ++
 doc/unw_reg_states_iterate.tex             |   83 +
 doc/unw_set_cache_size.man                 |   88 +
 doc/unw_set_cache_size.tex                 |   59 +
 doc/unw_set_caching_policy.man             |    5 +-
 doc/unw_set_caching_policy.tex             |    1 +
 include/compiler.h                         |   38 +-
 include/config.h.in                        |   19 +
 include/dwarf-eh.h                         |   36 +-
 include/dwarf.h                            |  462 ++---
 include/dwarf_i.h                          |   88 +-
 include/libunwind-aarch64.h                |  245 +++
 include/libunwind-arm.h                    |   41 +-
 include/libunwind-common.h.in              |   26 +-
 include/libunwind-coredump.h               |   16 +-
 include/libunwind-dynamic.h                |  132 +-
 include/libunwind-hppa.h                   |   28 +-
 include/libunwind-ia64.h                   |   46 +-
 include/libunwind-mips.h                   |   29 +-
 include/libunwind-ppc32.h                  |   14 +-
 include/libunwind-ppc64.h                  |   19 +-
 include/libunwind-ptrace.h                 |   14 +-
 include/libunwind-s390x.h                  |  144 ++
 include/libunwind-sh.h                     |   14 +-
 include/libunwind-tilegx.h                 |  161 ++
 include/libunwind-x86.h                    |  140 +-
 include/libunwind-x86_64.h                 |   18 +-
 include/libunwind.h                        |   38 +
 include/libunwind.h.in                     |    8 +-
 include/libunwind_i.h                      |  207 +-
 include/mempool.h                          |   22 +-
 include/remote.h                           |   24 +-
 include/tdep-aarch64/dwarf-config.h        |   52 +
 include/tdep-aarch64/jmpbuf.h              |   33 +
 include/tdep-aarch64/libunwind_i.h         |  320 ++++
 include/tdep-arm/dwarf-config.h            |    8 +-
 include/tdep-arm/ex_tables.h               |    6 +-
 include/tdep-arm/jmpbuf.h                  |    8 +-
 include/tdep-arm/libunwind_i.h             |  178 +-
 include/tdep-hppa/dwarf-config.h           |   12 +-
 include/tdep-hppa/jmpbuf.h                 |   10 +-
 include/tdep-hppa/libunwind_i.h            |  144 +-
 include/tdep-ia64/jmpbuf.h                 |   12 +-
 include/tdep-ia64/libunwind_i.h            |  162 +-
 include/tdep-ia64/rse.h                    |   20 +-
 include/tdep-ia64/script.h                 |   44 +-
 include/tdep-mips/dwarf-config.h           |    8 +-
 include/tdep-mips/jmpbuf.h                 |    8 +-
 include/tdep-mips/libunwind_i.h            |  146 +-
 include/tdep-ppc32/dwarf-config.h          |    8 +-
 include/tdep-ppc32/jmpbuf.h                |    8 +-
 include/tdep-ppc32/libunwind_i.h           |  166 +-
 include/tdep-ppc64/dwarf-config.h          |   10 +-
 include/tdep-ppc64/jmpbuf.h                |    8 +-
 include/tdep-ppc64/libunwind_i.h           |  225 ++-
 include/tdep-s390x/dwarf-config.h          |   52 +
 include/tdep-s390x/jmpbuf.h                |   35 +
 include/tdep-s390x/libunwind_i.h           |  262 +++
 include/tdep-sh/dwarf-config.h             |    8 +-
 include/tdep-sh/jmpbuf.h                   |    8 +-
 include/tdep-sh/libunwind_i.h              |  138 +-
 include/tdep-tilegx/dwarf-config.h         |   50 +
 include/tdep-tilegx/jmpbuf.h               |   33 +
 include/tdep-tilegx/libunwind_i.h          |  263 +++
 include/tdep-x86/dwarf-config.h            |   12 +-
 include/tdep-x86/jmpbuf.h                  |   18 +-
 include/tdep-x86/libunwind_i.h             |  158 +-
 include/tdep-x86_64/dwarf-config.h         |   16 +-
 include/tdep-x86_64/jmpbuf.h               |   18 +-
 include/tdep-x86_64/libunwind_i.h          |  172 +-
 include/tdep/dwarf-config.h                |    6 +-
 include/tdep/jmpbuf.h                      |    6 +-
 include/tdep/libunwind_i.h                 |   39 +
 include/tdep/libunwind_i.h.in              |    8 +-
 include/unwind.h                           |   34 +-
 src/Makefile.am                            |  214 ++-
 src/Makefile.in                            | 2834 +++++++++++++++-------------
 src/aarch64/Gapply_reg_state.c             |   37 +
 src/aarch64/Gcreate_addr_space.c           |   60 +
 src/aarch64/Gget_proc_info.c               |   39 +
 src/aarch64/Gget_save_loc.c                |  100 +
 src/aarch64/Gglobal.c                      |   57 +
 src/aarch64/Ginit.c                        |  190 ++
 src/aarch64/Ginit_local.c                  |   78 +
 src/aarch64/Ginit_remote.c                 |   45 +
 src/aarch64/Gis_signal_frame.c             |   64 +
 src/aarch64/Greg_states_iterate.c          |   37 +
 src/aarch64/Gregs.c                        |  118 ++
 src/aarch64/Gresume.c                      |  198 ++
 src/aarch64/Gstash_frame.c                 |   89 +
 src/aarch64/Gstep.c                        |  189 ++
 src/aarch64/Gtrace.c                       |  548 ++++++
 src/aarch64/Lapply_reg_state.c             |    5 +
 src/aarch64/Lcreate_addr_space.c           |    5 +
 src/aarch64/Lget_proc_info.c               |    5 +
 src/aarch64/Lget_save_loc.c                |    5 +
 src/aarch64/Lglobal.c                      |    5 +
 src/aarch64/Linit.c                        |    5 +
 src/aarch64/Linit_local.c                  |    5 +
 src/aarch64/Linit_remote.c                 |    5 +
 src/aarch64/Lis_signal_frame.c             |    5 +
 src/aarch64/Lreg_states_iterate.c          |    5 +
 src/aarch64/Lregs.c                        |    5 +
 src/aarch64/Lresume.c                      |    5 +
 src/aarch64/Lstash_frame.c                 |    5 +
 src/aarch64/Lstep.c                        |    5 +
 src/aarch64/Ltrace.c                       |    5 +
 src/aarch64/getcontext.S                   |   52 +
 src/aarch64/init.h                         |  126 ++
 src/aarch64/is_fpreg.c                     |   32 +
 src/aarch64/offsets.h                      |   49 +
 src/aarch64/regname.c                      |  106 ++
 src/aarch64/siglongjmp.S                   |   12 +
 src/aarch64/unwind_i.h                     |   64 +
 src/arm/Gapply_reg_state.c                 |   37 +
 src/arm/Gcreate_addr_space.c               |    2 +-
 src/arm/Gex_tables.c                       |  492 +++--
 src/arm/Gget_proc_info.c                   |    2 +-
 src/arm/Gget_save_loc.c                    |    4 +-
 src/arm/Gglobal.c                          |    2 +-
 src/arm/Ginit.c                            |   77 +-
 src/arm/Ginit_local.c                      |   31 +-
 src/arm/Ginit_remote.c                     |    2 +-
 src/arm/Gos-freebsd.c                      |  129 ++
 src/arm/Gos-linux.c                        |  182 ++
 src/arm/Gos-other.c                        |   48 +
 src/arm/Greg_states_iterate.c              |   37 +
 src/arm/Gregs.c                            |    8 +-
 src/arm/Gresume.c                          |   48 +-
 src/arm/Gstash_frame.c                     |   90 +
 src/arm/Gstep.c                            |  152 +-
 src/arm/Gtrace.c                           |  557 ++++++
 src/arm/Lapply_reg_state.c                 |    5 +
 src/arm/Los-freebsd.c                      |    5 +
 src/arm/Los-linux.c                        |    5 +
 src/arm/Los-other.c                        |    5 +
 src/arm/Lreg_states_iterate.c              |    5 +
 src/arm/Lstash_frame.c                     |    5 +
 src/arm/Ltrace.c                           |    6 +
 src/arm/getcontext.S                       |    9 +-
 src/arm/init.h                             |    3 +-
 src/arm/is_fpreg.c                         |   12 +-
 src/arm/offsets.h                          |   60 +-
 src/arm/regname.c                          |    2 +-
 src/arm/unwind_i.h                         |   28 +-
 src/coredump/_UCD_access_mem.c             |   24 +-
 src/coredump/_UCD_access_reg_freebsd.c     |   43 +-
 src/coredump/_UCD_access_reg_linux.c       |   24 +-
 src/coredump/_UCD_accessors.c              |   18 +-
 src/coredump/_UCD_create.c                 |    2 +-
 src/coredump/_UCD_destroy.c                |    2 +
 src/coredump/_UCD_elf_map_image.c          |   32 +-
 src/coredump/_UCD_find_proc_info.c         |   44 +-
 src/coredump/_UCD_get_proc_name.c          |    4 +-
 src/coredump/_UPT_access_fpreg.c           |    2 +-
 src/coredump/_UPT_elf.c                    |    2 +-
 src/coredump/_UPT_get_dyn_info_list_addr.c |   30 +-
 src/coredump/_UPT_put_unwind_info.c        |    2 +-
 src/coredump/_UPT_resume.c                 |    2 +-
 src/coredump/libunwind-coredump.pc.in      |    1 +
 src/dwarf/Gexpr.c                          | 1049 +++++-----
 src/dwarf/Gfde.c                           |  216 +--
 src/dwarf/Gfind_proc_info-lsb.c            |  964 +++++-----
 src/dwarf/Gfind_unwind_table.c             |  190 +-
 src/dwarf/Gparser.c                        | 1244 ++++++------
 src/dwarf/Gpe.c                            |   10 +-
 src/dwarf/global.c                         |    4 +-
 src/elf32.h                                |    2 +-
 src/elf64.h                                |    2 +-
 src/elfxx.c                                |  342 ++--
 src/elfxx.h                                |   47 +-
 src/hppa/Gapply_reg_state.c                |   37 +
 src/hppa/Gcreate_addr_space.c              |    4 +-
 src/hppa/Gget_proc_info.c                  |   10 +-
 src/hppa/Gget_save_loc.c                   |    6 +-
 src/hppa/Gglobal.c                         |    4 +-
 src/hppa/Ginit.c                           |   24 +-
 src/hppa/Ginit_local.c                     |   33 +-
 src/hppa/Ginit_remote.c                    |    4 +-
 src/hppa/Gis_signal_frame.c                |    8 +-
 src/hppa/Greg_states_iterate.c             |   37 +
 src/hppa/Gregs.c                           |   14 +-
 src/hppa/Gresume.c                         |   36 +-
 src/hppa/Gstep.c                           |   71 +-
 src/hppa/Lapply_reg_state.c                |    5 +
 src/hppa/Lreg_states_iterate.c             |    5 +
 src/hppa/init.h                            |    2 +-
 src/hppa/offsets.h                         |   24 +-
 src/hppa/regname.c                         |    4 +-
 src/hppa/unwind_i.h                        |   14 +-
 src/ia64/Gapply_reg_state.c                |   39 +
 src/ia64/Gcreate_addr_space.c              |    4 +-
 src/ia64/Gfind_unwind_table.c              |   66 +-
 src/ia64/Gget_proc_info.c                  |    4 +-
 src/ia64/Gget_save_loc.c                   |   50 +-
 src/ia64/Gglobal.c                         |   18 +-
 src/ia64/Ginit.c                           |  216 +--
 src/ia64/Ginit_local.c                     |    8 +-
 src/ia64/Ginit_remote.c                    |    4 +-
 src/ia64/Gis_signal_frame.c                |    4 +-
 src/ia64/Gparser.c                         |  628 +++---
 src/ia64/Grbs.c                            |  172 +-
 src/ia64/Greg_states_iterate.c             |   39 +
 src/ia64/Gregs.c                           |  612 +++---
 src/ia64/Gresume.c                         |  198 +-
 src/ia64/Gscript.c                         |  484 ++---
 src/ia64/Gstep.c                           |  136 +-
 src/ia64/Gtables.c                         |  240 +--
 src/ia64/Lapply_reg_state.c                |    5 +
 src/ia64/Lreg_states_iterate.c             |    5 +
 src/ia64/init.h                            |   26 +-
 src/ia64/offsets.h                         |  240 +--
 src/ia64/regname.c                         |  272 +--
 src/ia64/regs.h                            |   12 +-
 src/ia64/ucontext_i.h                      |   70 +-
 src/ia64/unwind_decoder.h                  |  294 +--
 src/ia64/unwind_i.h                        |  338 ++--
 src/libunwind-generic.pc.in                |    1 +
 src/mi/Gdestroy_addr_space.c               |    4 +-
 src/mi/Gdyn-extract.c                      |   12 +-
 src/mi/Gdyn-remote.c                       |  146 +-
 src/mi/Gfind_dynamic_proc_info.c           |   16 +-
 src/mi/Gget_accessors.c                    |    7 +-
 src/mi/Gget_fpreg.c                        |    4 +-
 src/mi/Gget_proc_info_by_ip.c              |    8 +-
 src/mi/Gget_proc_name.c                    |   72 +-
 src/mi/Gget_reg.c                          |    4 +-
 src/mi/Gput_dynamic_unwind_info.c          |    6 +-
 src/mi/Gset_cache_size.c                   |   72 +
 src/mi/Gset_caching_policy.c               |    8 +-
 src/mi/Gset_fpreg.c                        |    4 +-
 src/mi/Gset_reg.c                          |    4 +-
 src/mi/Lset_cache_size.c                   |    5 +
 src/mi/_ReadSLEB.c                         |    2 +-
 src/mi/_ReadULEB.c                         |    2 +-
 src/mi/backtrace.c                         |    6 +-
 src/mi/dyn-cancel.c                        |    2 +-
 src/mi/dyn-info-list.c                     |    4 +-
 src/mi/dyn-register.c                      |    4 +-
 src/mi/flush_cache.c                       |   23 +-
 src/mi/init.c                              |    4 +-
 src/mi/mempool.c                           |   28 +-
 src/mi/strerror.c                          |   18 +-
 src/mips/Gapply_reg_state.c                |   37 +
 src/mips/Gcreate_addr_space.c              |   10 +-
 src/mips/Gget_proc_info.c                  |   13 +-
 src/mips/Gget_save_loc.c                   |    4 +-
 src/mips/Gglobal.c                         |    2 +-
 src/mips/Ginit.c                           |   24 +-
 src/mips/Ginit_local.c                     |   31 +-
 src/mips/Ginit_remote.c                    |    2 +-
 src/mips/Gis_signal_frame.c                |   53 +-
 src/mips/Greg_states_iterate.c             |   37 +
 src/mips/Gregs.c                           |    9 +-
 src/mips/Gresume.c                         |    2 +-
 src/mips/Gstep.c                           |  188 +-
 src/mips/Lapply_reg_state.c                |    5 +
 src/mips/Lreg_states_iterate.c             |    5 +
 src/mips/init.h                            |    3 +-
 src/mips/is_fpreg.c                        |    2 +-
 src/mips/offsets.h                         |   86 +-
 src/mips/regname.c                         |    2 +-
 src/mips/unwind_i.h                        |    8 +-
 src/os-freebsd.c                           |   29 +-
 src/os-hpux.c                              |   19 +-
 src/os-linux.c                             |   22 +-
 src/os-linux.h                             |  126 +-
 src/os-qnx.c                               |  117 ++
 src/ppc/Gget_proc_info.c                   |   13 +-
 src/ppc/Gget_save_loc.c                    |    2 +-
 src/ppc/Ginit_local.c                      |   33 +-
 src/ppc/Ginit_remote.c                     |    2 +-
 src/ppc/Gis_signal_frame.c                 |   24 +-
 src/ppc32/Gapply_reg_state.c               |   37 +
 src/ppc32/Gcreate_addr_space.c             |   56 +
 src/ppc32/Gglobal.c                        |  140 +-
 src/ppc32/Ginit.c                          |   52 +-
 src/ppc32/Greg_states_iterate.c            |   37 +
 src/ppc32/Gregs.c                          |   20 +-
 src/ppc32/Gresume.c                        |    4 +-
 src/ppc32/Gstep.c                          |  430 ++---
 src/ppc32/Lapply_reg_state.c               |    5 +
 src/ppc32/Lcreate_addr_space.c             |    5 +
 src/ppc32/Lreg_states_iterate.c            |    5 +
 src/ppc32/get_func_addr.c                  |    2 +-
 src/ppc32/init.h                           |    3 +-
 src/ppc32/is_fpreg.c                       |    2 +-
 src/ppc32/regname.c                        |    2 +-
 src/ppc32/ucontext_i.h                     |   14 +-
 src/ppc32/unwind_i.h                       |    8 +-
 src/ppc64/Gapply_reg_state.c               |   37 +
 src/ppc64/Gcreate_addr_space.c             |   71 +
 src/ppc64/Gglobal.c                        |  238 +--
 src/ppc64/Ginit.c                          |   72 +-
 src/ppc64/Greg_states_iterate.c            |   37 +
 src/ppc64/Gregs.c                          |   77 +-
 src/ppc64/Gresume.c                        |   42 +-
 src/ppc64/Gstep.c                          |  728 +++----
 src/ppc64/Lapply_reg_state.c               |    5 +
 src/ppc64/Lcreate_addr_space.c             |    5 +
 src/ppc64/Lreg_states_iterate.c            |    5 +
 src/ppc64/get_func_addr.c                  |   28 +-
 src/ppc64/init.h                           |    3 +-
 src/ppc64/is_fpreg.c                       |    2 +-
 src/ppc64/regname.c                        |    2 +-
 src/ppc64/ucontext_i.h                     |   24 +-
 src/ppc64/unwind_i.h                       |   10 +-
 src/ptrace/_UPT_access_fpreg.c             |   63 +-
 src/ptrace/_UPT_access_mem.c               |   73 +-
 src/ptrace/_UPT_access_reg.c               |  271 +--
 src/ptrace/_UPT_accessors.c                |   20 +-
 src/ptrace/_UPT_create.c                   |    2 +-
 src/ptrace/_UPT_destroy.c                  |    2 +-
 src/ptrace/_UPT_elf.c                      |    2 +-
 src/ptrace/_UPT_find_proc_info.c           |   52 +-
 src/ptrace/_UPT_get_dyn_info_list_addr.c   |   30 +-
 src/ptrace/_UPT_get_proc_name.c            |    4 +-
 src/ptrace/_UPT_internal.h                 |    4 +-
 src/ptrace/_UPT_put_unwind_info.c          |    2 +-
 src/ptrace/_UPT_reg_offset.c               |  715 ++++---
 src/ptrace/_UPT_resume.c                   |    2 +-
 src/ptrace/libunwind-ptrace.pc.in          |    1 +
 src/s390x/Gapply_reg_state.c               |   37 +
 src/s390x/Gcreate_addr_space.c             |   62 +
 src/s390x/Gget_proc_info.c                 |   48 +
 src/s390x/Gget_save_loc.c                  |   86 +
 src/s390x/Gglobal.c                        |  101 +
 src/s390x/Ginit.c                          |  366 ++++
 src/s390x/Ginit_local.c                    |   81 +
 src/s390x/Ginit_remote.c                   |   57 +
 src/s390x/Gis_signal_frame.c               |   77 +
 src/s390x/Greg_states_iterate.c            |   37 +
 src/s390x/Gregs.c                          |  116 ++
 src/s390x/Gresume.c                        |  160 ++
 src/s390x/Gstep.c                          |  146 ++
 src/s390x/Lapply_reg_state.c               |    5 +
 src/s390x/Lcreate_addr_space.c             |    5 +
 src/s390x/Lget_proc_info.c                 |    5 +
 src/s390x/Lget_save_loc.c                  |    5 +
 src/s390x/Lglobal.c                        |    6 +
 src/s390x/Linit.c                          |    5 +
 src/s390x/Linit_local.c                    |    5 +
 src/s390x/Linit_remote.c                   |    5 +
 src/s390x/Lis_signal_frame.c               |    5 +
 src/s390x/Lreg_states_iterate.c            |    5 +
 src/s390x/Lregs.c                          |    5 +
 src/s390x/Lresume.c                        |    5 +
 src/s390x/Lstep.c                          |    5 +
 src/s390x/getcontext.S                     |   74 +
 src/s390x/init.h                           |   71 +
 src/s390x/is_fpreg.c                       |   36 +
 src/s390x/regname.c                        |   57 +
 src/s390x/setcontext.S                     |   76 +
 src/s390x/unwind_i.h                       |   48 +
 src/setjmp/libunwind-setjmp.pc.in          |    1 +
 src/setjmp/longjmp.c                       |   16 +-
 src/setjmp/setjmp_i.h                      |   20 +-
 src/setjmp/siglongjmp.c                    |   50 +-
 src/sh/Gapply_reg_state.c                  |   37 +
 src/sh/Gcreate_addr_space.c                |    2 +-
 src/sh/Gget_proc_info.c                    |    2 +-
 src/sh/Gget_save_loc.c                     |    4 +-
 src/sh/Gglobal.c                           |    2 +-
 src/sh/Ginit.c                             |   22 +-
 src/sh/Ginit_local.c                       |   31 +-
 src/sh/Ginit_remote.c                      |    2 +-
 src/sh/Gis_signal_frame.c                  |    4 +-
 src/sh/Greg_states_iterate.c               |   37 +
 src/sh/Gregs.c                             |    8 +-
 src/sh/Gresume.c                           |   76 +-
 src/sh/Gstep.c                             |   10 +-
 src/sh/Lapply_reg_state.c                  |    5 +
 src/sh/Lreg_states_iterate.c               |    5 +
 src/sh/init.h                              |    1 -
 src/sh/is_fpreg.c                          |    2 +-
 src/sh/offsets.h                           |   46 +-
 src/sh/regname.c                           |    2 +-
 src/sh/unwind_i.h                          |    6 +-
 src/tilegx/Gapply_reg_state.c              |   37 +
 src/tilegx/Gcreate_addr_space.c            |   65 +
 src/tilegx/Gget_proc_info.c                |   48 +
 src/tilegx/Gget_save_loc.c                 |   62 +
 src/tilegx/Gglobal.c                       |   64 +
 src/tilegx/Ginit.c                         |  167 ++
 src/tilegx/Ginit_local.c                   |   80 +
 src/tilegx/Ginit_remote.c                  |   47 +
 src/tilegx/Gis_signal_frame.c              |  115 ++
 src/tilegx/Greg_states_iterate.c           |   37 +
 src/tilegx/Gregs.c                         |   76 +
 src/tilegx/Gresume.c                       |   94 +
 src/tilegx/Gstep.c                         |   53 +
 src/tilegx/Lapply_reg_state.c              |    5 +
 src/tilegx/Lcreate_addr_space.c            |    5 +
 src/tilegx/Lget_proc_info.c                |    5 +
 src/tilegx/Lget_save_loc.c                 |    5 +
 src/tilegx/Lglobal.c                       |    5 +
 src/tilegx/Linit.c                         |    5 +
 src/tilegx/Linit_local.c                   |    5 +
 src/tilegx/Linit_remote.c                  |    5 +
 src/tilegx/Lis_signal_frame.c              |    5 +
 src/tilegx/Lreg_states_iterate.c           |    5 +
 src/tilegx/Lregs.c                         |    5 +
 src/tilegx/Lresume.c                       |    5 +
 src/tilegx/Lstep.c                         |    5 +
 src/tilegx/getcontext.S                    |   36 +
 src/tilegx/init.h                          |   63 +
 src/tilegx/is_fpreg.c                      |   33 +
 src/tilegx/offsets.h                       |   12 +
 src/tilegx/regname.c                       |   55 +
 src/tilegx/siglongjmp.S                    |    7 +
 src/tilegx/unwind_i.h                      |   46 +
 src/unwind/Backtrace.c                     |   18 +-
 src/unwind/DeleteException.c               |    4 +-
 src/unwind/FindEnclosingFunction.c         |    6 +-
 src/unwind/ForcedUnwind.c                  |    8 +-
 src/unwind/GetBSP.c                        |    4 +-
 src/unwind/GetCFA.c                        |    4 +-
 src/unwind/GetDataRelBase.c                |    4 +-
 src/unwind/GetGR.c                         |    4 +-
 src/unwind/GetIP.c                         |    4 +-
 src/unwind/GetIPInfo.c                     |    4 +-
 src/unwind/GetLanguageSpecificData.c       |    4 +-
 src/unwind/GetRegionStart.c                |    4 +-
 src/unwind/GetTextRelBase.c                |    4 +-
 src/unwind/RaiseException.c                |   58 +-
 src/unwind/Resume.c                        |    4 +-
 src/unwind/Resume_or_Rethrow.c             |    6 +-
 src/unwind/SetGR.c                         |    6 +-
 src/unwind/SetIP.c                         |    4 +-
 src/unwind/libunwind.pc.in                 |    2 +
 src/unwind/unwind-internal.h               |  118 +-
 src/x86/Gapply_reg_state.c                 |   37 +
 src/x86/Gcreate_addr_space.c               |    4 +-
 src/x86/Gget_proc_info.c                   |    8 +-
 src/x86/Gget_save_loc.c                    |    6 +-
 src/x86/Gglobal.c                          |    4 +-
 src/x86/Ginit.c                            |   28 +-
 src/x86/Ginit_local.c                      |   33 +-
 src/x86/Ginit_remote.c                     |    4 +-
 src/x86/Gos-freebsd.c                      |   72 +-
 src/x86/Gos-linux.c                        |   78 +-
 src/x86/Greg_states_iterate.c              |   37 +
 src/x86/Gregs.c                            |   30 +-
 src/x86/Gresume.c                          |   35 +-
 src/x86/Gstep.c                            |   94 +-
 src/x86/Lapply_reg_state.c                 |    5 +
 src/x86/Lreg_states_iterate.c              |    5 +
 src/x86/init.h                             |    5 +-
 src/x86/is_fpreg.c                         |    8 +-
 src/x86/offsets.h                          |  232 +--
 src/x86/regname.c                          |    2 +-
 src/x86/unwind_i.h                         |   47 +-
 src/x86_64/Gapply_reg_state.c              |   37 +
 src/x86_64/Gcreate_addr_space.c            |    4 +-
 src/x86_64/Gget_proc_info.c                |   10 +-
 src/x86_64/Gget_save_loc.c                 |    7 +-
 src/x86_64/Gglobal.c                       |    4 +-
 src/x86_64/Ginit.c                         |  212 ++-
 src/x86_64/Ginit_local.c                   |   33 +-
 src/x86_64/Ginit_remote.c                  |    4 +-
 src/x86_64/Gos-freebsd.c                   |   53 +-
 src/x86_64/Gos-linux.c                     |   40 +-
 src/x86_64/Greg_states_iterate.c           |   37 +
 src/x86_64/Gregs.c                         |   30 +-
 src/x86_64/Gresume.c                       |   39 +-
 src/x86_64/Gstash_frame.c                  |   79 +-
 src/x86_64/Gstep.c                         |  193 +-
 src/x86_64/Gtrace.c                        |   60 +-
 src/x86_64/Lapply_reg_state.c              |    5 +
 src/x86_64/Lreg_states_iterate.c           |    5 +
 src/x86_64/init.h                          |    6 +-
 src/x86_64/is_fpreg.c                      |    6 +-
 src/x86_64/offsets.h                       |    2 +-
 src/x86_64/regname.c                       |    2 +-
 src/x86_64/setcontext.S                    |   30 +-
 src/x86_64/ucontext_i.h                    |  106 +-
 src/x86_64/unwind_i.h                      |   56 +-
 tests/Gperf-simple.c                       |    2 +
 tests/Gperf-trace.c                        |    2 +
 tests/Gtest-bt.c                           |    1 +
 tests/Gtest-resume-sig.c                   |   21 +-
 tests/Gtest-trace.c                        |    9 +-
 tests/Gx64-test-dwarf-expressions.c        |   68 +
 tests/Ltest-init-local-signal-lib.c        |    6 +
 tests/Ltest-init-local-signal.c            |   60 +
 tests/Ltest-mem-validate.c                 |  145 ++
 tests/Lx64-test-dwarf-expressions.c        |    5 +
 tests/Makefile.am                          |   94 +-
 tests/Makefile.in                          | 1513 ++++++++++++---
 tests/check-namespace.sh.in                |   56 +-
 tests/crasher.c                            |    5 +
 tests/flush-cache.S                        |   14 +
 tests/mapper.c                             |    9 +-
 tests/run-coredump-unwind-mdi              |    2 +-
 tests/test-coredump-unwind.c               |    4 +-
 tests/test-flush-cache.c                   |    1 +
 tests/test-ptrace.c                        |   17 +-
 tests/test-reg-state.c                     |  133 ++
 tests/test-static-link-gen.c               |    1 +
 tests/test-static-link-loc.c               |    1 +
 tests/x64-test-dwarf-expressions.S         |   78 +
 527 files changed, 26683 insertions(+), 11993 deletions(-)
 create mode 100644 doc/unw_apply_reg_state.man
 create mode 100644 doc/unw_apply_reg_state.tex
 create mode 100644 doc/unw_init_local2.man
 create mode 100644 doc/unw_reg_states_iterate.man
 create mode 100644 doc/unw_reg_states_iterate.tex
 create mode 100644 doc/unw_set_cache_size.man
 create mode 100644 doc/unw_set_cache_size.tex
 create mode 100644 include/libunwind-aarch64.h
 create mode 100644 include/libunwind-s390x.h
 create mode 100644 include/libunwind-tilegx.h
 create mode 100644 include/libunwind.h
 create mode 100644 include/tdep-aarch64/dwarf-config.h
 create mode 100644 include/tdep-aarch64/jmpbuf.h
 create mode 100644 include/tdep-aarch64/libunwind_i.h
 create mode 100644 include/tdep-s390x/dwarf-config.h
 create mode 100644 include/tdep-s390x/jmpbuf.h
 create mode 100644 include/tdep-s390x/libunwind_i.h
 create mode 100644 include/tdep-tilegx/dwarf-config.h
 create mode 100644 include/tdep-tilegx/jmpbuf.h
 create mode 100644 include/tdep-tilegx/libunwind_i.h
 create mode 100644 include/tdep/libunwind_i.h
 create mode 100644 src/aarch64/Gapply_reg_state.c
 create mode 100644 src/aarch64/Gcreate_addr_space.c
 create mode 100644 src/aarch64/Gget_proc_info.c
 create mode 100644 src/aarch64/Gget_save_loc.c
 create mode 100644 src/aarch64/Gglobal.c
 create mode 100644 src/aarch64/Ginit.c
 create mode 100644 src/aarch64/Ginit_local.c
 create mode 100644 src/aarch64/Ginit_remote.c
 create mode 100644 src/aarch64/Gis_signal_frame.c
 create mode 100644 src/aarch64/Greg_states_iterate.c
 create mode 100644 src/aarch64/Gregs.c
 create mode 100644 src/aarch64/Gresume.c
 create mode 100644 src/aarch64/Gstash_frame.c
 create mode 100644 src/aarch64/Gstep.c
 create mode 100644 src/aarch64/Gtrace.c
 create mode 100644 src/aarch64/Lapply_reg_state.c
 create mode 100644 src/aarch64/Lcreate_addr_space.c
 create mode 100644 src/aarch64/Lget_proc_info.c
 create mode 100644 src/aarch64/Lget_save_loc.c
 create mode 100644 src/aarch64/Lglobal.c
 create mode 100644 src/aarch64/Linit.c
 create mode 100644 src/aarch64/Linit_local.c
 create mode 100644 src/aarch64/Linit_remote.c
 create mode 100644 src/aarch64/Lis_signal_frame.c
 create mode 100644 src/aarch64/Lreg_states_iterate.c
 create mode 100644 src/aarch64/Lregs.c
 create mode 100644 src/aarch64/Lresume.c
 create mode 100644 src/aarch64/Lstash_frame.c
 create mode 100644 src/aarch64/Lstep.c
 create mode 100644 src/aarch64/Ltrace.c
 create mode 100644 src/aarch64/getcontext.S
 create mode 100644 src/aarch64/init.h
 create mode 100644 src/aarch64/is_fpreg.c
 create mode 100644 src/aarch64/offsets.h
 create mode 100644 src/aarch64/regname.c
 create mode 100644 src/aarch64/siglongjmp.S
 create mode 100644 src/aarch64/unwind_i.h
 create mode 100644 src/arm/Gapply_reg_state.c
 create mode 100644 src/arm/Gos-freebsd.c
 create mode 100644 src/arm/Gos-linux.c
 create mode 100644 src/arm/Gos-other.c
 create mode 100644 src/arm/Greg_states_iterate.c
 create mode 100644 src/arm/Gstash_frame.c
 create mode 100644 src/arm/Gtrace.c
 create mode 100644 src/arm/Lapply_reg_state.c
 create mode 100644 src/arm/Los-freebsd.c
 create mode 100644 src/arm/Los-linux.c
 create mode 100644 src/arm/Los-other.c
 create mode 100644 src/arm/Lreg_states_iterate.c
 create mode 100644 src/arm/Lstash_frame.c
 create mode 100644 src/arm/Ltrace.c
 create mode 100644 src/hppa/Gapply_reg_state.c
 create mode 100644 src/hppa/Greg_states_iterate.c
 create mode 100644 src/hppa/Lapply_reg_state.c
 create mode 100644 src/hppa/Lreg_states_iterate.c
 create mode 100644 src/ia64/Gapply_reg_state.c
 create mode 100644 src/ia64/Greg_states_iterate.c
 create mode 100644 src/ia64/Lapply_reg_state.c
 create mode 100644 src/ia64/Lreg_states_iterate.c
 create mode 100644 src/mi/Gset_cache_size.c
 create mode 100644 src/mi/Lset_cache_size.c
 create mode 100644 src/mips/Gapply_reg_state.c
 create mode 100644 src/mips/Greg_states_iterate.c
 create mode 100644 src/mips/Lapply_reg_state.c
 create mode 100644 src/mips/Lreg_states_iterate.c
 create mode 100644 src/os-qnx.c
 create mode 100644 src/ppc32/Gapply_reg_state.c
 create mode 100644 src/ppc32/Gcreate_addr_space.c
 create mode 100644 src/ppc32/Greg_states_iterate.c
 create mode 100644 src/ppc32/Lapply_reg_state.c
 create mode 100644 src/ppc32/Lcreate_addr_space.c
 create mode 100644 src/ppc32/Lreg_states_iterate.c
 create mode 100644 src/ppc64/Gapply_reg_state.c
 create mode 100644 src/ppc64/Gcreate_addr_space.c
 create mode 100644 src/ppc64/Greg_states_iterate.c
 create mode 100644 src/ppc64/Lapply_reg_state.c
 create mode 100644 src/ppc64/Lcreate_addr_space.c
 create mode 100644 src/ppc64/Lreg_states_iterate.c
 create mode 100644 src/s390x/Gapply_reg_state.c
 create mode 100644 src/s390x/Gcreate_addr_space.c
 create mode 100644 src/s390x/Gget_proc_info.c
 create mode 100644 src/s390x/Gget_save_loc.c
 create mode 100644 src/s390x/Gglobal.c
 create mode 100644 src/s390x/Ginit.c
 create mode 100644 src/s390x/Ginit_local.c
 create mode 100644 src/s390x/Ginit_remote.c
 create mode 100644 src/s390x/Gis_signal_frame.c
 create mode 100644 src/s390x/Greg_states_iterate.c
 create mode 100644 src/s390x/Gregs.c
 create mode 100644 src/s390x/Gresume.c
 create mode 100644 src/s390x/Gstep.c
 create mode 100644 src/s390x/Lapply_reg_state.c
 create mode 100644 src/s390x/Lcreate_addr_space.c
 create mode 100644 src/s390x/Lget_proc_info.c
 create mode 100644 src/s390x/Lget_save_loc.c
 create mode 100644 src/s390x/Lglobal.c
 create mode 100644 src/s390x/Linit.c
 create mode 100644 src/s390x/Linit_local.c
 create mode 100644 src/s390x/Linit_remote.c
 create mode 100644 src/s390x/Lis_signal_frame.c
 create mode 100644 src/s390x/Lreg_states_iterate.c
 create mode 100644 src/s390x/Lregs.c
 create mode 100644 src/s390x/Lresume.c
 create mode 100644 src/s390x/Lstep.c
 create mode 100644 src/s390x/getcontext.S
 create mode 100644 src/s390x/init.h
 create mode 100644 src/s390x/is_fpreg.c
 create mode 100644 src/s390x/regname.c
 create mode 100644 src/s390x/setcontext.S
 create mode 100644 src/s390x/unwind_i.h
 create mode 100644 src/sh/Gapply_reg_state.c
 create mode 100644 src/sh/Greg_states_iterate.c
 create mode 100644 src/sh/Lapply_reg_state.c
 create mode 100644 src/sh/Lreg_states_iterate.c
 create mode 100644 src/tilegx/Gapply_reg_state.c
 create mode 100644 src/tilegx/Gcreate_addr_space.c
 create mode 100644 src/tilegx/Gget_proc_info.c
 create mode 100644 src/tilegx/Gget_save_loc.c
 create mode 100644 src/tilegx/Gglobal.c
 create mode 100644 src/tilegx/Ginit.c
 create mode 100644 src/tilegx/Ginit_local.c
 create mode 100644 src/tilegx/Ginit_remote.c
 create mode 100644 src/tilegx/Gis_signal_frame.c
 create mode 100644 src/tilegx/Greg_states_iterate.c
 create mode 100644 src/tilegx/Gregs.c
 create mode 100644 src/tilegx/Gresume.c
 create mode 100644 src/tilegx/Gstep.c
 create mode 100644 src/tilegx/Lapply_reg_state.c
 create mode 100644 src/tilegx/Lcreate_addr_space.c
 create mode 100644 src/tilegx/Lget_proc_info.c
 create mode 100644 src/tilegx/Lget_save_loc.c
 create mode 100644 src/tilegx/Lglobal.c
 create mode 100644 src/tilegx/Linit.c
 create mode 100644 src/tilegx/Linit_local.c
 create mode 100644 src/tilegx/Linit_remote.c
 create mode 100644 src/tilegx/Lis_signal_frame.c
 create mode 100644 src/tilegx/Lreg_states_iterate.c
 create mode 100644 src/tilegx/Lregs.c
 create mode 100644 src/tilegx/Lresume.c
 create mode 100644 src/tilegx/Lstep.c
 create mode 100644 src/tilegx/getcontext.S
 create mode 100644 src/tilegx/init.h
 create mode 100644 src/tilegx/is_fpreg.c
 create mode 100644 src/tilegx/offsets.h
 create mode 100644 src/tilegx/regname.c
 create mode 100644 src/tilegx/siglongjmp.S
 create mode 100644 src/tilegx/unwind_i.h
 create mode 100644 src/x86/Gapply_reg_state.c
 create mode 100644 src/x86/Greg_states_iterate.c
 create mode 100644 src/x86/Lapply_reg_state.c
 create mode 100644 src/x86/Lreg_states_iterate.c
 create mode 100644 src/x86_64/Gapply_reg_state.c
 create mode 100644 src/x86_64/Greg_states_iterate.c
 create mode 100644 src/x86_64/Lapply_reg_state.c
 create mode 100644 src/x86_64/Lreg_states_iterate.c
 create mode 100644 tests/Gx64-test-dwarf-expressions.c
 create mode 100644 tests/Ltest-init-local-signal-lib.c
 create mode 100644 tests/Ltest-init-local-signal.c
 create mode 100644 tests/Ltest-mem-validate.c
 create mode 100644 tests/Lx64-test-dwarf-expressions.c
 create mode 100644 tests/test-reg-state.c
 create mode 100644 tests/x64-test-dwarf-expressions.S

diff --git a/INSTALL b/INSTALL
index a1e89e1..007e939 100644
--- a/INSTALL
+++ b/INSTALL
@@ -1,7 +1,7 @@
 Installation Instructions
 *************************
 
-Copyright (C) 1994-1996, 1999-2002, 2004-2011 Free Software Foundation,
+Copyright (C) 1994-1996, 1999-2002, 2004-2013 Free Software Foundation,
 Inc.
 
    Copying and distribution of this file, with or without modification,
@@ -309,9 +309,10 @@ causes the specified `gcc' to be used as the C compiler (unless it is
 overridden in the site shell script).
 
 Unfortunately, this technique does not work for `CONFIG_SHELL' due to
-an Autoconf bug.  Until the bug is fixed you can use this workaround:
+an Autoconf limitation.  Until the limitation is lifted, you can use
+this workaround:
 
-     CONFIG_SHELL=/bin/bash /bin/bash ./configure CONFIG_SHELL=/bin/bash
+     CONFIG_SHELL=/bin/bash ./configure CONFIG_SHELL=/bin/bash
 
 `configure' Invocation
 ======================
@@ -367,4 +368,3 @@ operates.
 
 `configure' also accepts some other, not widely useful, options.  Run
 `configure --help' for more details.
-
diff --git a/Makefile.am b/Makefile.am
index d7278df..8132fa4 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,7 +1,16 @@
-include_HEADERS = include/libunwind-dynamic.h \
-    include/libunwind-ptrace.h \
-    include/libunwind-coredump.h
+include_HEADERS = include/libunwind-dynamic.h
 
+if BUILD_PTRACE
+include_HEADERS += include/libunwind-ptrace.h
+endif BUILD_PTRACE
+
+if BUILD_COREDUMP
+include_HEADERS += include/libunwind-coredump.h
+endif BUILD_COREDUMP
+
+if ARCH_AARCH64
+include_HEADERS += include/libunwind-aarch64.h
+endif
 if ARCH_ARM
 include_HEADERS += include/libunwind-arm.h
 endif
@@ -14,6 +23,9 @@ endif
 if ARCH_MIPS
 include_HEADERS += include/libunwind-mips.h
 endif
+if ARCH_TILEGX
+include_HEADERS += include/libunwind-tilegx.h
+endif
 if ARCH_X86
 include_HEADERS += include/libunwind-x86.h
 endif
@@ -29,6 +41,9 @@ endif
 if ARCH_SH
 include_HEADERS += include/libunwind-sh.h
 endif
+if ARCH_S390X
+include_HEADERS += include/libunwind-s390x.h
+endif
 
 if !REMOTE_ONLY
 include_HEADERS += include/libunwind.h include/unwind.h
@@ -36,11 +51,22 @@ endif
 
 nodist_include_HEADERS = include/libunwind-common.h
 
-SUBDIRS = src tests doc
+SUBDIRS = src
+
+if CONFIG_TESTS
+SUBDIRS += tests
+endif
+
+if CONFIG_DOCS
+SUBDIRS += doc
+endif
 
 noinst_HEADERS = include/dwarf.h include/dwarf_i.h include/dwarf-eh.h	\
 	include/compiler.h include/libunwind_i.h include/mempool.h	\
 	include/remote.h						\
+	include/tdep-aarch64/dwarf-config.h				\
+	include/tdep-aarch64/jmpbuf.h					\
+	include/tdep-aarch64/libunwind_i.h				\
 	include/tdep-arm/dwarf-config.h	include/tdep-arm/ex_tables.h	\
 	include/tdep-arm/jmpbuf.h include/tdep-arm/libunwind_i.h	\
 	include/tdep-ia64/jmpbuf.h include/tdep-ia64/rse.h 		\
@@ -49,6 +75,8 @@ noinst_HEADERS = include/dwarf.h include/dwarf_i.h include/dwarf-eh.h	\
 	include/tdep-hppa/jmpbuf.h include/tdep-hppa/dwarf-config.h	\
 	include/tdep-mips/libunwind_i.h					\
 	include/tdep-mips/jmpbuf.h include/tdep-mips/dwarf-config.h	\
+	include/tdep-tilegx/libunwind_i.h				\
+	include/tdep-tilegx/jmpbuf.h include/tdep-tilegx/dwarf-config.h	\
 	include/tdep-x86/libunwind_i.h					\
 	include/tdep-x86/jmpbuf.h include/tdep-x86/dwarf-config.h	\
 	include/tdep-x86_64/libunwind_i.h				\
@@ -59,6 +87,8 @@ noinst_HEADERS = include/dwarf.h include/dwarf_i.h include/dwarf-eh.h	\
 	include/tdep-ppc64/jmpbuf.h include/tdep-ppc64/libunwind_i.h	\
 	include/tdep-sh/dwarf-config.h					\
 	include/tdep-sh/jmpbuf.h include/tdep-sh/libunwind_i.h		\
+	include/tdep-s390x/dwarf-config.h				\
+	include/tdep-s390x/jmpbuf.h include/tdep-s390x/libunwind_i.h	\
 	include/tdep/libunwind_i.h					\
 	include/tdep/jmpbuf.h include/tdep/dwarf-config.h
 
@@ -78,3 +108,4 @@ MAINTAINERCLEANFILES = \
 	config/missing \
 	include/config.h.in \
 	include/config.h.in~
+
diff --git a/Makefile.in b/Makefile.in
index 8d8827a..1a3c049 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.13.4 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,30 +79,43 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-@ARCH_ARM_TRUE@am__append_1 = include/libunwind-arm.h
-@ARCH_IA64_TRUE@am__append_2 = include/libunwind-ia64.h
-@ARCH_HPPA_TRUE@am__append_3 = include/libunwind-hppa.h
-@ARCH_MIPS_TRUE@am__append_4 = include/libunwind-mips.h
-@ARCH_X86_TRUE@am__append_5 = include/libunwind-x86.h
-@ARCH_X86_64_TRUE@am__append_6 = include/libunwind-x86_64.h
-@ARCH_PPC32_TRUE@am__append_7 = include/libunwind-ppc32.h
-@ARCH_PPC64_TRUE@am__append_8 = include/libunwind-ppc64.h
-@ARCH_SH_TRUE@am__append_9 = include/libunwind-sh.h
-@REMOTE_ONLY_FALSE@am__append_10 = include/libunwind.h include/unwind.h
+@BUILD_PTRACE_TRUE@am__append_1 = include/libunwind-ptrace.h
+@BUILD_COREDUMP_TRUE@am__append_2 = include/libunwind-coredump.h
+@ARCH_AARCH64_TRUE@am__append_3 = include/libunwind-aarch64.h
+@ARCH_ARM_TRUE@am__append_4 = include/libunwind-arm.h
+@ARCH_IA64_TRUE@am__append_5 = include/libunwind-ia64.h
+@ARCH_HPPA_TRUE@am__append_6 = include/libunwind-hppa.h
+@ARCH_MIPS_TRUE@am__append_7 = include/libunwind-mips.h
+@ARCH_TILEGX_TRUE@am__append_8 = include/libunwind-tilegx.h
+@ARCH_X86_TRUE@am__append_9 = include/libunwind-x86.h
+@ARCH_X86_64_TRUE@am__append_10 = include/libunwind-x86_64.h
+@ARCH_PPC32_TRUE@am__append_11 = include/libunwind-ppc32.h
+@ARCH_PPC64_TRUE@am__append_12 = include/libunwind-ppc64.h
+@ARCH_SH_TRUE@am__append_13 = include/libunwind-sh.h
+@ARCH_S390X_TRUE@am__append_14 = include/libunwind-s390x.h
+@REMOTE_ONLY_FALSE@am__append_15 = include/libunwind.h include/unwind.h
+@CONFIG_TESTS_TRUE@am__append_16 = tests
+@CONFIG_DOCS_TRUE@am__append_17 = doc
 subdir = .
-DIST_COMMON = README $(am__configure_deps) $(am__include_HEADERS_DIST) \
-	$(noinst_HEADERS) $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(top_srcdir)/configure $(top_srcdir)/include/config.h.in \
+DIST_COMMON = INSTALL NEWS README AUTHORS ChangeLog \
+	$(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/configure $(am__configure_deps) \
+	$(top_srcdir)/include/config.h.in \
 	$(top_srcdir)/include/libunwind-common.h.in \
 	$(top_srcdir)/include/libunwind.h.in \
 	$(top_srcdir)/include/tdep/libunwind_i.h.in \
+	$(top_srcdir)/src/unwind/libunwind.pc.in \
 	$(top_srcdir)/src/coredump/libunwind-coredump.pc.in \
 	$(top_srcdir)/src/ptrace/libunwind-ptrace.pc.in \
 	$(top_srcdir)/src/setjmp/libunwind-setjmp.pc.in \
-	$(top_srcdir)/src/unwind/libunwind.pc.in AUTHORS COPYING \
-	ChangeLog INSTALL NEWS TODO config/compile config/config.guess \
+	$(am__include_HEADERS_DIST) $(noinst_HEADERS) COPYING TODO \
+	config/ar-lib config/compile config/config.guess \
 	config/config.sub config/depcomp config/install-sh \
-	config/ltmain.sh config/missing
+	config/missing config/ltmain.sh $(top_srcdir)/config/ar-lib \
+	$(top_srcdir)/config/compile $(top_srcdir)/config/config.guess \
+	$(top_srcdir)/config/config.sub \
+	$(top_srcdir)/config/install-sh $(top_srcdir)/config/ltmain.sh \
+	$(top_srcdir)/config/missing
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
 	$(top_srcdir)/configure.ac
@@ -73,22 +130,42 @@ CONFIG_CLEAN_FILES = include/libunwind-common.h include/libunwind.h \
 	src/coredump/libunwind-coredump.pc \
 	src/ptrace/libunwind-ptrace.pc src/setjmp/libunwind-setjmp.pc
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
-	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 am__include_HEADERS_DIST = include/libunwind-dynamic.h \
 	include/libunwind-ptrace.h include/libunwind-coredump.h \
-	include/libunwind-arm.h include/libunwind-ia64.h \
-	include/libunwind-hppa.h include/libunwind-mips.h \
+	include/libunwind-aarch64.h include/libunwind-arm.h \
+	include/libunwind-ia64.h include/libunwind-hppa.h \
+	include/libunwind-mips.h include/libunwind-tilegx.h \
 	include/libunwind-x86.h include/libunwind-x86_64.h \
 	include/libunwind-ppc32.h include/libunwind-ppc64.h \
-	include/libunwind-sh.h include/libunwind.h include/unwind.h
+	include/libunwind-sh.h include/libunwind-s390x.h \
+	include/libunwind.h include/unwind.h
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -121,12 +198,33 @@ HEADERS = $(include_HEADERS) $(nodist_include_HEADERS) \
 	$(noinst_HEADERS)
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
-	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
-	distdir dist dist-all distcheck
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
+	cscope distdir dist dist-all distcheck
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
-DIST_SUBDIRS = $(SUBDIRS)
+CSCOPE = cscope
+DIST_SUBDIRS = src tests doc
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -136,6 +234,7 @@ am__remove_distdir = \
       && rm -rf "$(distdir)" \
       || { sleep 5 && rm -rf "$(distdir)"; }; \
   else :; fi
+am__post_remove_distdir = $(am__remove_distdir)
 am__relativize = \
   dir0=`pwd`; \
   sed_first='s,^\([^/]*\)/.*$$,\1,'; \
@@ -163,18 +262,21 @@ am__relativize = \
   reldir="$$dir2"
 DIST_ARCHIVES = $(distdir).tar.gz
 GZIP_ENV = --best
+DIST_TARGETS = dist-gzip
 distuninstallcheck_listfiles = find . -type f -print
 am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \
   | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
 distcleancheck_listfiles = find . -type f -print
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AR = @AR@
 ARCH = @ARCH@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BACKTRACELIB = @BACKTRACELIB@
 CC = @CC@
 CCAS = @CCAS@
 CCASDEPMODE = @CCASDEPMODE@
@@ -206,8 +308,10 @@ INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LATEX2MAN = @LATEX2MAN@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
+LDFLAGS_NOSTARTFILES = @LDFLAGS_NOSTARTFILES@
 LDFLAGS_STATIC_LIBCXA = @LDFLAGS_STATIC_LIBCXA@
 LIBCRTS = @LIBCRTS@
 LIBLZMA = @LIBLZMA@
@@ -306,17 +410,20 @@ target_vendor = @target_vendor@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-include_HEADERS = include/libunwind-dynamic.h \
-	include/libunwind-ptrace.h include/libunwind-coredump.h \
-	$(am__append_1) $(am__append_2) $(am__append_3) \
-	$(am__append_4) $(am__append_5) $(am__append_6) \
-	$(am__append_7) $(am__append_8) $(am__append_9) \
-	$(am__append_10)
+include_HEADERS = include/libunwind-dynamic.h $(am__append_1) \
+	$(am__append_2) $(am__append_3) $(am__append_4) \
+	$(am__append_5) $(am__append_6) $(am__append_7) \
+	$(am__append_8) $(am__append_9) $(am__append_10) \
+	$(am__append_11) $(am__append_12) $(am__append_13) \
+	$(am__append_14) $(am__append_15)
 nodist_include_HEADERS = include/libunwind-common.h
-SUBDIRS = src tests doc
+SUBDIRS = src $(am__append_16) $(am__append_17)
 noinst_HEADERS = include/dwarf.h include/dwarf_i.h include/dwarf-eh.h	\
 	include/compiler.h include/libunwind_i.h include/mempool.h	\
 	include/remote.h						\
+	include/tdep-aarch64/dwarf-config.h				\
+	include/tdep-aarch64/jmpbuf.h					\
+	include/tdep-aarch64/libunwind_i.h				\
 	include/tdep-arm/dwarf-config.h	include/tdep-arm/ex_tables.h	\
 	include/tdep-arm/jmpbuf.h include/tdep-arm/libunwind_i.h	\
 	include/tdep-ia64/jmpbuf.h include/tdep-ia64/rse.h 		\
@@ -325,6 +432,8 @@ noinst_HEADERS = include/dwarf.h include/dwarf_i.h include/dwarf-eh.h	\
 	include/tdep-hppa/jmpbuf.h include/tdep-hppa/dwarf-config.h	\
 	include/tdep-mips/libunwind_i.h					\
 	include/tdep-mips/jmpbuf.h include/tdep-mips/dwarf-config.h	\
+	include/tdep-tilegx/libunwind_i.h				\
+	include/tdep-tilegx/jmpbuf.h include/tdep-tilegx/dwarf-config.h	\
 	include/tdep-x86/libunwind_i.h					\
 	include/tdep-x86/jmpbuf.h include/tdep-x86/dwarf-config.h	\
 	include/tdep-x86_64/libunwind_i.h				\
@@ -335,6 +444,8 @@ noinst_HEADERS = include/dwarf.h include/dwarf_i.h include/dwarf-eh.h	\
 	include/tdep-ppc64/jmpbuf.h include/tdep-ppc64/libunwind_i.h	\
 	include/tdep-sh/dwarf-config.h					\
 	include/tdep-sh/jmpbuf.h include/tdep-sh/libunwind_i.h		\
+	include/tdep-s390x/dwarf-config.h				\
+	include/tdep-s390x/jmpbuf.h include/tdep-s390x/libunwind_i.h	\
 	include/tdep/libunwind_i.h					\
 	include/tdep/jmpbuf.h include/tdep/dwarf-config.h
 
@@ -431,8 +542,11 @@ distclean-libtool:
 	-rm -f libtool config.lt
 install-includeHEADERS: $(include_HEADERS)
 	@$(NORMAL_INSTALL)
-	test -z "$(includedir)" || $(MKDIR_P) "$(DESTDIR)$(includedir)"
 	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(includedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(includedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -449,8 +563,11 @@ uninstall-includeHEADERS:
 	dir='$(DESTDIR)$(includedir)'; $(am__uninstall_files_from_dir)
 install-nodist_includeHEADERS: $(nodist_include_HEADERS)
 	@$(NORMAL_INSTALL)
-	test -z "$(includedir)" || $(MKDIR_P) "$(DESTDIR)$(includedir)"
 	@list='$(nodist_include_HEADERS)'; test -n "$(includedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(includedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(includedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -467,22 +584,25 @@ uninstall-nodist_includeHEADERS:
 	dir='$(DESTDIR)$(includedir)'; $(am__uninstall_files_from_dir)
 
 # This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
 	  echo "Making $$target in $$subdir"; \
 	  if test "$$subdir" = "."; then \
 	    dot_seen=yes; \
@@ -497,57 +617,12 @@ $(RECURSIVE_TARGETS):
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
-	@fail= failcom='exit 1'; \
-	for f in x $$MAKEFLAGS; do \
-	  case $$f in \
-	    *=* | --[!k]*);; \
-	    *k*) failcom='fail=yes';; \
-	  esac; \
-	done; \
-	dot_seen=no; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test "$$subdir" = "."; then :; else \
-	    rev="$$subdir $$rev"; \
-	  fi; \
-	done; \
-	rev="$$rev ."; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done && test -z "$$fail"
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
 	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
@@ -563,12 +638,7 @@ TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -580,15 +650,11 @@ TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -597,9 +663,31 @@ GTAGS:
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+clean-cscope:
+	-rm -f cscope.files
+cscope.files: clean-cscope cscopelist
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
 
 distdir: $(DISTFILES)
 	$(am__remove_distdir)
@@ -635,13 +723,10 @@ distdir: $(DISTFILES)
 	done
 	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
 	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
 	    $(am__relativize); \
 	    new_distdir=$$reldir; \
@@ -670,40 +755,36 @@ distdir: $(DISTFILES)
 	|| chmod -R a+r "$(distdir)"
 dist-gzip: distdir
 	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-bzip2: distdir
 	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-lzip: distdir
 	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz
-	$(am__remove_distdir)
-
-dist-lzma: distdir
-	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-xz: distdir
 	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-tarZ: distdir
 	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-shar: distdir
 	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
 dist-zip: distdir
 	-rm -f $(distdir).zip
 	zip -rq $(distdir).zip $(distdir)
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 
-dist dist-all: distdir
-	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
-	$(am__remove_distdir)
+dist dist-all:
+	$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'
+	$(am__post_remove_distdir)
 
 # This target untars the dist file and tries a VPATH configuration.  Then
 # it guarantees that the distribution is self-contained by making another
@@ -714,8 +795,6 @@ distcheck: dist
 	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
 	*.tar.bz2*) \
 	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
-	*.tar.lzma*) \
-	  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\
 	*.tar.lz*) \
 	  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\
 	*.tar.xz*) \
@@ -727,9 +806,9 @@ distcheck: dist
 	*.zip*) \
 	  unzip $(distdir).zip ;;\
 	esac
-	chmod -R a-w $(distdir); chmod a+w $(distdir)
-	mkdir $(distdir)/_build
-	mkdir $(distdir)/_inst
+	chmod -R a-w $(distdir)
+	chmod u+w $(distdir)
+	mkdir $(distdir)/_build $(distdir)/_inst
 	chmod a-w $(distdir)
 	test -d $(distdir)/_build || exit 0; \
 	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
@@ -761,7 +840,7 @@ distcheck: dist
 	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
 	  && cd "$$am__cwd" \
 	  || exit 1
-	$(am__remove_distdir)
+	$(am__post_remove_distdir)
 	@(echo "$(distdir) archives ready for distribution: "; \
 	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
 	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
@@ -900,26 +979,26 @@ ps-am:
 
 uninstall-am: uninstall-includeHEADERS uninstall-nodist_includeHEADERS
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
-	install-am install-strip tags-recursive
-
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am am--refresh check check-am clean clean-generic \
-	clean-libtool ctags ctags-recursive dist dist-all dist-bzip2 \
-	dist-gzip dist-lzip dist-lzma dist-shar dist-tarZ dist-xz \
-	dist-zip distcheck distclean distclean-generic distclean-hdr \
-	distclean-libtool distclean-tags distcleancheck distdir \
-	distuninstallcheck dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-includeHEADERS install-info \
-	install-info-am install-man install-nodist_includeHEADERS \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
-	ps ps-am tags tags-recursive uninstall uninstall-am \
-	uninstall-includeHEADERS uninstall-nodist_includeHEADERS
+.MAKE: $(am__recursive_targets) install-am install-strip
+
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \
+	am--refresh check check-am clean clean-cscope clean-generic \
+	clean-libtool cscope cscopelist-am ctags ctags-am dist \
+	dist-all dist-bzip2 dist-gzip dist-lzip dist-shar dist-tarZ \
+	dist-xz dist-zip distcheck distclean distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags distcleancheck \
+	distdir distuninstallcheck dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-includeHEADERS \
+	install-info install-info-am install-man \
+	install-nodist_includeHEADERS install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am uninstall-includeHEADERS \
+	uninstall-nodist_includeHEADERS
 
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff --git a/NEWS b/NEWS
index e26d1c9..ae6cbcf 100644
--- a/NEWS
+++ b/NEWS
@@ -1,5 +1,23 @@
 -*-Mode: outline-*-
 
+* News for v1.3:
+
+** Iteration of unwind register states support
+   Doug Moore <dougm@rice.edu>
+** Freebsd/Armv6 support
+   Konstantin Belousov <kib@freebsd.org>
+** Many, many dwarf bugfixes
+** Mips remote unwind support
+** aarch64 ptrace support
+
+* News for v1.2:
+
+** aarch64 port
+** dwarf parsing improvements
+** Fast stacktraces for aarch64 & arm
+** tilegx port
+** powerpc64 port
+
 * News for v1.1:
 
 ** coredump unwind support
diff --git a/README b/README
index 71a631f..2fc98d8 100644
--- a/README
+++ b/README
@@ -1,49 +1,56 @@
--*- mode: Outline -*-
+# libunwind
 
-This is version 1.0 of the unwind library.  This library supports
-several architecture/operating-system combinations:
-
- Linux/x86-64:	Works well.
- Linux/x86:	Works well.
- Linux/ARM:	Works well.
- Linux/IA-64:	Fully tested and supported.
- Linux/PARISC:	Works well, but C library missing unwind-info.
- HP-UX/IA-64:	Mostly works but known to have some serious limitations.
- Linux/PPC64:	Newly added.
- Linux/SuperH:	Newly added.
- FreeBSD/i386:	Newly added.
- FreeBSD/x86-64: Newly added (FreeBSD architecture is known as amd64).
+[![Build Status](https://travis-ci.org/libunwind/libunwind.svg?branch=master)](https://travis-ci.org/libunwind/libunwind)
 
+This is version 1.4 of the unwind library.  This library supports
+several architecture/operating-system combinations:
 
-* General Build Instructions
+| System  | Architecture | Status |
+| :------ | :----------- | :----- |
+| Linux   | x86-64       | ✓      |
+| Linux   | x86          | ✓      |
+| Linux   | ARM          | ✓      |
+| Linux   | AArch64      | ✓      |
+| Linux   | PPC64        | ✓      |
+| Linux   | SuperH       | ✓      |
+| Linux   | IA-64        | ✓      |
+| Linux   | PARISC       | Works well, but C library missing unwind-info |
+| Linux   | Tilegx       | 64-bit mode only |
+| Linux   | MIPS         | Newly added |
+| HP-UX   | IA-64        | Mostly works, but known to have serious limitations |
+| FreeBSD | x86-64       | ✓      |
+| FreeBSD | x86          | ✓      |
+| FreeBSD | AArch64      | ✓      |
+
+## General Build Instructions
 
 In general, this library can be built and installed with the following
 commands:
 
-	$ autoreconf -i # Needed only for building from git. Depends on libtool.
-	$ ./configure
-	$ make
-	$ make install prefix=PREFIX
+    $ ./autogen.sh # Needed only for building from git. Depends on libtool.
+    $ ./configure
+    $ make
+    $ make install prefix=PREFIX
 
-where PREFIX is the installation prefix.  By default, a prefix of
-/usr/local is used, such that libunwind.a is installed in
-/usr/local/lib and unwind.h is installed in /usr/local/include.  For
-testing, you may want to use a prefix of /usr/local instead.
+where `PREFIX` is the installation prefix.  By default, a prefix of
+`/usr/local` is used, such that `libunwind.a` is installed in
+`/usr/local/lib` and `unwind.h` is installed in `/usr/local/include`.  For
+testing, you may want to use a prefix of `/usr/local` instead.
 
 
-* Building with Intel compiler
+### Building with Intel compiler
 
-** Version 8 and later
+#### Version 8 and later
 
 Starting with version 8, the preferred name for the IA-64 Intel
-compiler is "icc" (same name as on x86).  Thus, the configure-line
+compiler is `icc` (same name as on x86).  Thus, the configure-line
 should look like this:
 
     $ ./configure CC=icc CFLAGS="-g -O3 -ip" CXX=icc CCAS=gcc CCASFLAGS=-g \
-		LDFLAGS="-L$PWD/src/.libs"
+        LDFLAGS="-L$PWD/src/.libs"
 
 
-* Building on HP-UX
+### Building on HP-UX
 
 For the time being, libunwind must be built with GCC on HP-UX.
 
@@ -51,14 +58,13 @@ libunwind should be configured and installed on HP-UX like this:
 
     $ ./configure CFLAGS="-g -O2 -mlp64" CXXFLAGS="-g -O2 -mlp64"
 
-Caveat: Unwinding of 32-bit (ILP32) binaries is not supported
-	at the moment.
+Caveat: Unwinding of 32-bit (ILP32) binaries is not supported at the moment.
 
-** Workaround for older versions of GCC
+### Workaround for older versions of GCC
 
-GCC v3.0 and GCC v3.2 ship with a bad version of sys/types.h.  The
+GCC v3.0 and GCC v3.2 ship with a bad version of `sys/types.h`.  The
 workaround is to issue the following commands before running
-"configure":
+`configure`:
 
     $ mkdir $top_dir/include/sys
     $ cp /usr/include/sys/types.h $top_dir/include/sys
@@ -66,148 +72,130 @@ workaround is to issue the following commands before running
 GCC v3.3.2 or later have been fixed and do not require this
 workaround.
 
-* Building for PowerPC64 / Linux
+### Building for PowerPC64 / Linux
 
 For building for power64 you should use:
 
-  $ ./configure CFLAGS="-g -O2 -m64" CXXFLAGS="-g -O2 -m64"
+    $ ./configure CFLAGS="-g -O2 -m64" CXXFLAGS="-g -O2 -m64"
 
 If your power support altivec registers:
-  $ ./configure CFLAGS="-g -O2 -m64 -maltivec" CXXFLAGS="-g -O2 -m64 -maltivec"
+
+    $ ./configure CFLAGS="-g -O2 -m64 -maltivec" CXXFLAGS="-g -O2 -m64 -maltivec"
 
 To check if your processor has support for vector registers (altivec):
+
     cat /proc/cpuinfo | grep altivec
+
 and should have something like this:
+
     cpu             : PPC970, altivec supported
 
 If libunwind seems to not work (backtracing failing), try to compile
-it with -O0, without optimizations. There are some compiler problems
+it with `-O0`, without optimizations. There are some compiler problems
 depending on the version of your gcc.
 
-* Building on FreeBSD
-
-General building instructions apply. To build and execute several tests,
-you need libexecinfo library available in ports as devel/libexecinfo.
+### Building on FreeBSD
 
-Development of the port was done of FreeBSD 8.0-STABLE. The library
-was build with the system compiler that is modified version of gcc 4.2.1,
-as well as the gcc 4.4.3.
+General building instructions apply. To build and execute several tests
+on older versions of FreeBSD, you need libexecinfo library available in
+ports as devel/libexecinfo. This port has been removed as of 2017 and is
+indeed no longer needed.
 
-* Regression Testing
+## Regression Testing
 
 After building the library, you can run a set of regression tests with:
 
-	$ make check
+    $ make check
 
-** Expected results on IA-64 Linux
+### Expected results on IA-64 Linux
 
 Unless you have a very recent C library and compiler installed, it is
 currently expected to have the following tests fail on IA-64 Linux:
 
-	Gtest-init		(should pass starting with glibc-2.3.x/gcc-3.4)
-	Ltest-init		(should pass starting with glibc-2.3.x/gcc-3.4)
-	test-ptrace		(should pass starting with glibc-2.3.x/gcc-3.4)
-	run-ia64-test-dyn1	(should pass starting with glibc-2.3.x)
+* `Gtest-init` (should pass starting with glibc-2.3.x/gcc-3.4)
+* `Ltest-init` (should pass starting with glibc-2.3.x/gcc-3.4)
+* `test-ptrace` (should pass starting with glibc-2.3.x/gcc-3.4)
+* `run-ia64-test-dyn1` (should pass starting with glibc-2.3.x)
 
 This does not mean that libunwind cannot be used with older compilers
 or C libraries, it just means that for certain corner cases, unwinding
 will fail.  Since they're corner cases, it is not likely for
 applications to trigger them.
 
-Note: If you get lots of errors in Gia64-test-nat and Lia64-test-nat, it's
-      almost certainly a sign of an old assembler.  The GNU assembler used
-      to encode previous-stack-pointer-relative offsets incorrectly.
-      This bug was fixed on 21-Sep-2004 so any later assembler will be
-      fine.
+Note: If you get lots of errors in `Gia64-test-nat` and `Lia64-test-nat`, it's
+almost certainly a sign of an old assembler.  The GNU assembler used
+to encode previous-stack-pointer-relative offsets incorrectly.
+This bug was fixed on 21-Sep-2004 so any later assembler will be
+fine.
 
-** Expected results on x86 Linux
+### Expected results on x86 Linux
 
 The following tests are expected to fail on x86 Linux:
 
-	Gtest-resume-sig	(fails to get SIGUSR2)
-	Ltest-resume-sig	(likewise)
-	Gtest-dyn1		(no dynamic unwind info support yet)
-	Ltest-dyn1		(no dynamic unwind info support yet)
-	test-setjmp		(longjmp() not implemented yet)
-	run-check-namespace	(no _Ux86_getcontext yet)
-	test-ptrace
+* `test-ptrace`
 
-** Expected results on x86-64 Linux
+### Expected results on x86-64 Linux
 
 The following tests are expected to fail on x86-64 Linux:
 
-	Gtest-dyn1		(no dynamic unwind info support yet)
-	Ltest-dyn1		(no dynamic unwind info support yet)
-	Gtest-init (see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=18743)
-	Ltest-init		(likewise)
-	test-async-sig		(crashes due to bad unwind-info?)
-	test-setjmp		(longjmp() not implemented yet)
-	run-check-namespace	(no _Ux86_64_getcontext yet)
-	run-ptrace-mapper	(??? investigate)
-	run-ptrace-misc	(see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=18748
-			 and http://gcc.gnu.org/bugzilla/show_bug.cgi?id=18749)
+* `run-ptrace-misc` (see <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=18748>
+  and <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=18749>)
 
-** Expected results on PARISC Linux
+### Expected results on PARISC Linux
 
 Caveat: GCC v3.4 or newer is needed on PA-RISC Linux.  Earlier
 versions of the compiler failed to generate the exception-handling
-program header (GNU_EH_FRAME) needed for unwinding.
+program header (`GNU_EH_FRAME`) needed for unwinding.
 
 The following tests are expected to fail on x86-64 Linux:
 
-	Gtest-bt   (backtrace truncated at kill() due to lack of unwind-info)
-	Ltest-bt   (likewise)
-	Gtest-resume-sig  (Gresume.c:my_rt_sigreturn() is wrong somehow)
-	Ltest-resume-sig  (likewise)
-	Gtest-init (likewise)
-	Ltest-init (likewise)
-	Gtest-dyn1 (no dynamic unwind info support yet)
-	Ltest-dyn1 (no dynamic unwind info support yet)
-	test-setjmp		(longjmp() not implemented yet)
-	run-check-namespace	(toolchain doesn't support HIDDEN yet)
+* `Gtest-bt` (backtrace truncated at `kill()` due to lack of unwind-info)
+* `Ltest-bt` (likewise)
+* `Gtest-resume-sig` (`Gresume.c:my_rt_sigreturn()` is wrong somehow)
+* `Ltest-resume-sig` (likewise)
+* `Gtest-init` (likewise)
+* `Ltest-init` (likewise)
+* `Gtest-dyn1` (no dynamic unwind info support yet)
+* `Ltest-dyn1` (no dynamic unwind info support yet)
+* `test-setjmp` (`longjmp()` not implemented yet)
+* `run-check-namespace` (toolchain doesn't support `HIDDEN` yet)
 
-** Expected results on HP-UX
+### Expected results on HP-UX
 
-"make check" is currently unsupported for HP-UX.  You can try to run
+`make check` is currently unsupported for HP-UX.  You can try to run
 it, but most tests will fail (and some may fail to terminate).  The
 only test programs that are known to work at this time are:
 
-     tests/bt
-     tests/Gperf-simple
-     tests/test-proc-info
-     tests/test-static-link
-     tests/Gtest-init
-     tests/Ltest-init
-     tests/Gtest-resume-sig
-     tests/Ltest-resume-sig
+* `tests/bt`
+* `tests/Gperf-simple`
+* `tests/test-proc-info`
+* `tests/test-static-link`
+* `tests/Gtest-init`
+* `tests/Ltest-init`
+* `tests/Gtest-resume-sig`
+* `tests/Ltest-resume-sig`
 
-** Expected results on PPC64 Linux
+### Expected results on PPC64 Linux
 
-"make check" should run with no more than 10 out of 24 tests failed.
+`make check` should run with no more than 10 out of 24 tests failed.
 
 
-* Performance Testing
+## Performance Testing
 
 This distribution includes a few simple performance tests which give
 some idea of the basic cost of various libunwind operations.  After
 building the library, you can run these tests with the following
 commands:
 
- $ cd tests
- $ make perf
-
-* Contacting the Developers
-
-Please direct all questions regarding this library to:
-
-	libunwind-devel@nongnu.org
+    $ cd tests
+    $ make perf
 
-You can do this by sending a mail to libunwind-request@nongnu.org with
-a body of:
+## Contacting the Developers
 
-	subscribe libunwind-devel
+Please direct all questions regarding this library to <libunwind-devel@nongnu.org>.
 
-or you can subscribe and manage your subscription via the
-web-interface at:
+You can do this by sending an email to <libunwind-request@nongnu.org> with
+a body of "subscribe libunwind-devel", or you can subscribe and manage your
+subscription via the web-interface at <https://savannah.nongnu.org/mail/?group=libunwind>.
 
-	https://savannah.nongnu.org/mail/?group=libunwind
+You can also interact on our GitHub page: <https://github.com/libunwind/libunwind>.
diff --git a/aclocal.m4 b/aclocal.m4
index e9d95e8..9b24617 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -1,8 +1,7 @@
-# generated automatically by aclocal 1.11.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.13.4 -*- Autoconf -*-
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,
-# Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -12,13 +11,14 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
+m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,
-[m4_warning([this file was generated for autoconf 2.68.
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,
+[m4_warning([this file was generated for autoconf 2.69.
 You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
+To do so, use the procedure documented by the package, typically 'autoreconf'.])])
 
 # libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
 #
@@ -2683,10 +2683,14 @@ linux* | k*bsd*-gnu | kopensolaris*-gnu)
   # before this can be enabled.
   hardcode_into_libs=yes
 
+  # Add ABI-specific directories to the system library path.
+  sys_lib_dlsearch_path_spec="/lib64 /usr/lib64 /lib /usr/lib"
+
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -2698,18 +2702,6 @@ linux* | k*bsd*-gnu | kopensolaris*-gnu)
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
-netbsdelf*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='NetBSD ld.elf_so'
-  ;;
-
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
@@ -3315,7 +3307,7 @@ linux* | k*bsd*-gnu | kopensolaris*-gnu)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-netbsd* | netbsdelf*-gnu)
+netbsd*)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
   else
@@ -4127,7 +4119,7 @@ m4_if([$1], [CXX], [
 	    ;;
 	esac
 	;;
-      netbsd* | netbsdelf*-gnu)
+      netbsd*)
 	;;
       *qnx* | *nto*)
         # QNX uses GNU C++, but need to define -shared option too, otherwise
@@ -4604,9 +4596,6 @@ m4_if([$1], [CXX], [
       ;;
     esac
     ;;
-  linux* | k*bsd*-gnu | gnu*)
-    _LT_TAGVAR(link_all_deplibs, $1)=no
-    ;;
   *)
     _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
     ;;
@@ -4669,9 +4658,6 @@ dnl Note also adjust exclude_expsyms for C++ above.
   openbsd*)
     with_gnu_ld=no
     ;;
-  linux* | k*bsd*-gnu | gnu*)
-    _LT_TAGVAR(link_all_deplibs, $1)=no
-    ;;
   esac
 
   _LT_TAGVAR(ld_shlibs, $1)=yes
@@ -4893,7 +4879,7 @@ _LT_EOF
       fi
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
@@ -5070,7 +5056,6 @@ _LT_EOF
 	if test "$aix_use_runtimelinking" = yes; then
 	  shared_flag="$shared_flag "'${wl}-G'
 	fi
-	_LT_TAGVAR(link_all_deplibs, $1)=no
       else
 	# not using gcc
 	if test "$host_cpu" = ia64; then
@@ -5375,7 +5360,7 @@ _LT_EOF
       _LT_TAGVAR(link_all_deplibs, $1)=yes
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
       else
@@ -8626,25 +8611,22 @@ m4_ifndef([_LT_PROG_F77],		[AC_DEFUN([_LT_PROG_F77])])
 m4_ifndef([_LT_PROG_FC],		[AC_DEFUN([_LT_PROG_FC])])
 m4_ifndef([_LT_PROG_CXX],		[AC_DEFUN([_LT_PROG_CXX])])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 2002-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
 # Automake X.Y traces this macro to ensure aclocal.m4 has been
 # generated from the m4 files accompanying Automake X.Y.
 # (This private macro should not be called outside this file.)
 AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.11'
+[am__api_version='1.13'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.3], [],
+m4_if([$1], [1.13.4], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -8660,21 +8642,78 @@ m4_define([_AM_AUTOCONF_VERSION], [])
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.3])dnl
+[AM_AUTOMAKE_VERSION([1.13.4])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
+# Copyright (C) 2011-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_AR([ACT-IF-FAIL])
+# -------------------------
+# Try to determine the archiver interface, and trigger the ar-lib wrapper
+# if it is needed.  If the detection of archiver interface fails, run
+# ACT-IF-FAIL (default is to abort configure with a proper error message).
+AC_DEFUN([AM_PROG_AR],
+[AC_BEFORE([$0], [LT_INIT])dnl
+AC_BEFORE([$0], [AC_PROG_LIBTOOL])dnl
+AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([ar-lib])dnl
+AC_CHECK_TOOLS([AR], [ar lib "link -lib"], [false])
+: ${AR=ar}
+
+AC_CACHE_CHECK([the archiver ($AR) interface], [am_cv_ar_interface],
+  [am_cv_ar_interface=ar
+   AC_COMPILE_IFELSE([AC_LANG_SOURCE([[int some_variable = 0;]])],
+     [am_ar_try='$AR cru libconftest.a conftest.$ac_objext >&AS_MESSAGE_LOG_FD'
+      AC_TRY_EVAL([am_ar_try])
+      if test "$ac_status" -eq 0; then
+        am_cv_ar_interface=ar
+      else
+        am_ar_try='$AR -NOLOGO -OUT:conftest.lib conftest.$ac_objext >&AS_MESSAGE_LOG_FD'
+        AC_TRY_EVAL([am_ar_try])
+        if test "$ac_status" -eq 0; then
+          am_cv_ar_interface=lib
+        else
+          am_cv_ar_interface=unknown
+        fi
+      fi
+      rm -f conftest.lib libconftest.a
+     ])
+   ])
+
+case $am_cv_ar_interface in
+ar)
+  ;;
+lib)
+  # Microsoft lib, so override with the ar-lib wrapper script.
+  # FIXME: It is wrong to rewrite AR.
+  # But if we don't then we get into trouble of one sort or another.
+  # A longer-term fix would be to have automake use am__AR in this case,
+  # and then we could set am__AR="$am_aux_dir/ar-lib \$(AR)" or something
+  # similar.
+  AR="$am_aux_dir/ar-lib $AR"
+  ;;
+unknown)
+  m4_default([$1],
+             [AC_MSG_ERROR([could not determine $AR interface])])
+  ;;
+esac
+AC_SUBST([AR])dnl
+])
+
 # Figure out how to run the assembler.                      -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
-
 # AM_PROG_AS
 # ----------
 AC_DEFUN([AM_PROG_AS],
@@ -8689,17 +8728,15 @@ _AM_IF_OPTION([no-dependencies],, [_AM_DEPENDENCIES([CCAS])])dnl
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
+# '$srcdir', '$srcdir/..', or '$srcdir/../..'.
 #
 # Of course, Automake must honor this variable whenever it calls a
 # tool from the auxiliary directory.  The problem is that $srcdir (and
@@ -8718,7 +8755,7 @@ _AM_IF_OPTION([no-dependencies],, [_AM_DEPENDENCIES([CCAS])])dnl
 #
 # The reason of the latter failure is that $top_srcdir and $ac_aux_dir
 # are both prefixed by $srcdir.  In an in-source build this is usually
-# harmless because $srcdir is `.', but things will broke when you
+# harmless because $srcdir is '.', but things will broke when you
 # start a VPATH build or use an absolute $srcdir.
 #
 # So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
@@ -8744,22 +8781,19 @@ am_aux_dir=`cd $ac_aux_dir && pwd`
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 9
-
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
 # Define a conditional.
 AC_DEFUN([AM_CONDITIONAL],
-[AC_PREREQ(2.52)dnl
- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
-	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+[AC_PREREQ([2.52])dnl
+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
 AC_SUBST([$1_TRUE])dnl
 AC_SUBST([$1_FALSE])dnl
 _AM_SUBST_NOTMAKE([$1_TRUE])dnl
@@ -8778,16 +8812,14 @@ AC_CONFIG_COMMANDS_PRE(
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,
-# 2010, 2011 Free Software Foundation, Inc.
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 12
 
-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
 # will think it sees a *use*, and therefore will trigger all it's
 # C support machinery.  Also note that it means that autoscan, seeing
@@ -8797,7 +8829,7 @@ fi])])
 # _AM_DEPENDENCIES(NAME)
 # ----------------------
 # See how the compiler implements dependency checking.
-# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# NAME is "CC", "CXX", "OBJC", "OBJCXX", "UPC", or "GJC".
 # We try a few techniques and use that to set a single cache variable.
 #
 # We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
@@ -8810,12 +8842,13 @@ AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
 AC_REQUIRE([AM_MAKE_INCLUDE])dnl
 AC_REQUIRE([AM_DEP_TRACK])dnl
 
-ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
-       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
-       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
-       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
-       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
-                   [depcc="$$1"   am_compiler_list=])
+m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
+      [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
+      [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+      [$1], [OBJCXX], [depcc="$OBJCXX" am_compiler_list='gcc3 gcc'],
+      [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
+      [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                    [depcc="$$1"   am_compiler_list=])
 
 AC_CACHE_CHECK([dependency style of $depcc],
                [am_cv_$1_dependencies_compiler_type],
@@ -8823,8 +8856,8 @@ AC_CACHE_CHECK([dependency style of $depcc],
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -8864,16 +8897,16 @@ AC_CACHE_CHECK([dependency style of $depcc],
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -8882,8 +8915,8 @@ AC_CACHE_CHECK([dependency style of $depcc],
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -8891,7 +8924,7 @@ AC_CACHE_CHECK([dependency style of $depcc],
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -8939,7 +8972,7 @@ AM_CONDITIONAL([am__fastdep$1], [
 # AM_SET_DEPDIR
 # -------------
 # Choose a directory name for dependency files.
-# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES.
 AC_DEFUN([AM_SET_DEPDIR],
 [AC_REQUIRE([AM_SET_LEADING_DOT])dnl
 AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
@@ -8949,9 +8982,13 @@ AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
 # AM_DEP_TRACK
 # ------------
 AC_DEFUN([AM_DEP_TRACK],
-[AC_ARG_ENABLE(dependency-tracking,
-[  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors])
+[AC_ARG_ENABLE([dependency-tracking], [dnl
+AS_HELP_STRING(
+  [--enable-dependency-tracking],
+  [do not reject slow dependency extractors])
+AS_HELP_STRING(
+  [--disable-dependency-tracking],
+  [speeds up one-time build])])
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
@@ -8966,20 +9003,18 @@ _AM_SUBST_NOTMAKE([am__nodep])dnl
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-#serial 5
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
 AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
 [{
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # Older Autoconf quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
   # if we detect the quoting.
   case $CONFIG_FILES in
@@ -8992,7 +9027,7 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -9004,21 +9039,19 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
+    test -z "$am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`AS_DIRNAME(["$file"])`
@@ -9036,7 +9069,7 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
 # This macro should only be invoked once -- use via AC_REQUIRE.
 #
 # This code is only required when automatic dependency tracking
-# is enabled.  FIXME.  This creates each `.P' file that we will
+# is enabled.  FIXME.  This creates each '.P' file that we will
 # need in order to bootstrap the dependency handling code.
 AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 [AC_CONFIG_COMMANDS([depfiles],
@@ -9046,15 +9079,12 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 16
-
 # This macro actually does too much.  Some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
 
@@ -9070,7 +9100,7 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 # arguments mandatory, and then we can depend on a new Autoconf
 # release and drop the old call support.
 AC_DEFUN([AM_INIT_AUTOMAKE],
-[AC_PREREQ([2.62])dnl
+[AC_PREREQ([2.65])dnl
 dnl Autoconf wants to disallow AM_ names.  We explicitly allow
 dnl the ones we care about.
 m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
@@ -9099,31 +9129,40 @@ AC_SUBST([CYGPATH_W])
 # Define the identity of the package.
 dnl Distinguish between old-style and new-style calls.
 m4_ifval([$2],
-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+[AC_DIAGNOSE([obsolete],
+             [$0: two- and three-arguments forms are deprecated.])
+m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
  AC_SUBST([PACKAGE], [$1])dnl
  AC_SUBST([VERSION], [$2])],
 [_AM_SET_OPTIONS([$1])dnl
 dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+m4_if(
+  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
+  [ok:ok],,
   [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
  AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
  AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
 
 _AM_IF_OPTION([no-define],,
-[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
- AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+[AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
+ AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl
 
 # Some tools Automake needs.
 AC_REQUIRE([AM_SANITY_CHECK])dnl
 AC_REQUIRE([AC_ARG_PROGRAM])dnl
-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
-AM_MISSING_PROG(AUTOCONF, autoconf)
-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
-AM_MISSING_PROG(AUTOHEADER, autoheader)
-AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
+AM_MISSING_PROG([AUTOCONF], [autoconf])
+AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
+AM_MISSING_PROG([AUTOHEADER], [autoheader])
+AM_MISSING_PROG([MAKEINFO], [makeinfo])
 AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
 AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
-AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+AC_REQUIRE([AC_PROG_MKDIR_P])dnl
+# For better backward compatibility.  To be removed once Automake 1.9.x
+# dies out for good.  For more background, see:
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+AC_SUBST([mkdir_p], ['$(MKDIR_P)'])
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
 AC_REQUIRE([AC_PROG_AWK])dnl
@@ -9134,28 +9173,32 @@ _AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
 			     [_AM_PROG_TAR([v7])])])
 _AM_IF_OPTION([no-dependencies],,
 [AC_PROVIDE_IFELSE([AC_PROG_CC],
-		  [_AM_DEPENDENCIES(CC)],
-		  [define([AC_PROG_CC],
-			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+		  [_AM_DEPENDENCIES([CC])],
+		  [m4_define([AC_PROG_CC],
+			     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_CXX],
-		  [_AM_DEPENDENCIES(CXX)],
-		  [define([AC_PROG_CXX],
-			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+		  [_AM_DEPENDENCIES([CXX])],
+		  [m4_define([AC_PROG_CXX],
+			     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_OBJC],
-		  [_AM_DEPENDENCIES(OBJC)],
-		  [define([AC_PROG_OBJC],
-			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
+		  [_AM_DEPENDENCIES([OBJC])],
+		  [m4_define([AC_PROG_OBJC],
+			     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],
+		  [_AM_DEPENDENCIES([OBJCXX])],
+		  [m4_define([AC_PROG_OBJCXX],
+			     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl
 ])
-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
+AC_REQUIRE([AM_SILENT_RULES])dnl
+dnl The testsuite driver may need to know about EXEEXT, so add the
+dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This
+dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.
 AC_CONFIG_COMMANDS_PRE(dnl
 [m4_provide_if([_AM_COMPILER_EXEEXT],
   [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
 ])
 
-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
 dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
 dnl mangled by Autoconf and run in a shell conditional statement.
 m4_define([_AC_COMPILER_EXEEXT],
@@ -9183,15 +9226,12 @@ for _am_header in $config_headers :; do
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
@@ -9205,16 +9245,14 @@ if test x"${install_sh}" != xset; then
     install_sh="\${SHELL} $am_aux_dir/install-sh"
   esac
 fi
-AC_SUBST(install_sh)])
+AC_SUBST([install_sh])])
 
-# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2003-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
-
 # Check whether the underlying file-system supports filenames
 # with a leading dot.  For instance MS-DOS doesn't.
 AC_DEFUN([AM_SET_LEADING_DOT],
@@ -9231,20 +9269,17 @@ AC_SUBST([am__leading_dot])])
 # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,
-# 2011 Free Software Foundation, Inc.
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
-
 # AM_MAINTAINER_MODE([DEFAULT-MODE])
 # ----------------------------------
 # Control maintainer-specific portions of Makefiles.
-# Default is to disable them, unless `enable' is passed literally.
-# For symmetry, `disable' may be passed as well.  Anyway, the user
+# Default is to disable them, unless 'enable' is passed literally.
+# For symmetry, 'disable' may be passed as well.  Anyway, the user
 # can override the default with the --enable/--disable switch.
 AC_DEFUN([AM_MAINTAINER_MODE],
 [m4_case(m4_default([$1], [disable]),
@@ -9255,10 +9290,11 @@ AC_DEFUN([AM_MAINTAINER_MODE],
 AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
   dnl maintainer-mode's default is 'disable' unless 'enable' is passed
   AC_ARG_ENABLE([maintainer-mode],
-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer],
-      [USE_MAINTAINER_MODE=$enableval],
-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
+    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],
+      am_maintainer_other[ make rules and dependencies not useful
+      (and sometimes confusing) to the casual installer])],
+    [USE_MAINTAINER_MODE=$enableval],
+    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
   AC_MSG_RESULT([$USE_MAINTAINER_MODE])
   AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
   MAINT=$MAINTAINER_MODE_TRUE
@@ -9266,18 +9302,14 @@ AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
 ]
 )
 
-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
-
 # Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 4
-
 # AM_MAKE_INCLUDE()
 # -----------------
 # Check to see how make treats includes.
@@ -9295,7 +9327,7 @@ am__quote=
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -9320,15 +9352,12 @@ AC_MSG_RESULT([$_am_result])
 rm -f confinc confmf
 ])
 
-# Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 6
-
 # AM_PROG_CC_C_O
 # --------------
 # Like AC_PROG_CC_C_O, but changed for automake.
@@ -9357,15 +9386,12 @@ m4_define([AC_PROG_CC],
 
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 6
-
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
 AC_DEFUN([AM_MISSING_PROG],
@@ -9373,11 +9399,10 @@ AC_DEFUN([AM_MISSING_PROG],
 $1=${$1-"${am_missing_run}$2"}
 AC_SUBST($1)])
 
-
 # AM_MISSING_HAS_RUN
 # ------------------
-# Define MISSING if not defined so far and test if it supports --run.
-# If it does, set am_missing_run to use it, otherwise, to nothing.
+# Define MISSING if not defined so far and test if it is modern enough.
+# If it is, set am_missing_run to use it, otherwise, to nothing.
 AC_DEFUN([AM_MISSING_HAS_RUN],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
 AC_REQUIRE_AUX_FILE([missing])dnl
@@ -9390,54 +9415,22 @@ if test x"${MISSING+set}" != xset; then
   esac
 fi
 # Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
+if eval "$MISSING --is-lightweight"; then
+  am_missing_run="$MISSING "
 else
   am_missing_run=
-  AC_MSG_WARN([`missing' script is too old or missing])
+  AC_MSG_WARN(['missing' script is too old or missing])
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,
-# Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 1
-
-# AM_PROG_MKDIR_P
-# ---------------
-# Check for `mkdir -p'.
-AC_DEFUN([AM_PROG_MKDIR_P],
-[AC_PREREQ([2.60])dnl
-AC_REQUIRE([AC_PROG_MKDIR_P])dnl
-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
-dnl while keeping a definition of mkdir_p for backward compatibility.
-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
-dnl Makefile.ins that do not define MKDIR_P, so we do our own
-dnl adjustment using top_builddir (which is defined more often than
-dnl MKDIR_P).
-AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
-case $mkdir_p in
-  [[\\/$]]* | ?:[[\\/]]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-])
-
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
-
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
 AC_DEFUN([_AM_MANGLE_OPTION],
@@ -9447,7 +9440,7 @@ AC_DEFUN([_AM_MANGLE_OPTION],
 # --------------------
 # Set option NAME.  Presently that only means defining a flag for this option.
 AC_DEFUN([_AM_SET_OPTION],
-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+[m4_define(_AM_MANGLE_OPTION([$1]), [1])])
 
 # _AM_SET_OPTIONS(OPTIONS)
 # ------------------------
@@ -9463,22 +9456,16 @@ AC_DEFUN([_AM_IF_OPTION],
 
 # Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
-
 # AM_SANITY_CHECK
 # ---------------
 AC_DEFUN([AM_SANITY_CHECK],
 [AC_MSG_CHECKING([whether build environment is sane])
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
@@ -9489,32 +9476,40 @@ case `pwd` in
 esac
 case $srcdir in
   *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
+    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$[*]" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$[*]" != "X $srcdir/configure conftest.file" \
-      && test "$[*]" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
-alias in your environment])
-   fi
-
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$[*]" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$[*]" != "X $srcdir/configure conftest.file" \
+	&& test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment])
+     fi
+     if test "$[2]" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$[2]" = conftest.file
    )
 then
@@ -9524,46 +9519,118 @@ else
    AC_MSG_ERROR([newly created file is older than distributed files!
 Check your system clock])
 fi
-AC_MSG_RESULT(yes)])
+AC_MSG_RESULT([yes])
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+AC_CONFIG_COMMANDS_PRE(
+  [AC_MSG_CHECKING([that generated files are newer than configure])
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   AC_MSG_RESULT([done])])
+rm -f conftest.file
+])
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2009-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# AM_SILENT_RULES([DEFAULT])
+# --------------------------
+# Enable less verbose build rules; with the default set to DEFAULT
+# ("yes" being less verbose, "no" or empty being verbose).
+AC_DEFUN([AM_SILENT_RULES],
+[AC_ARG_ENABLE([silent-rules], [dnl
+AS_HELP_STRING(
+  [--enable-silent-rules],
+  [less verbose build output (undo: "make V=1")])
+AS_HELP_STRING(
+  [--disable-silent-rules],
+  [verbose build output (undo: "make V=0")])dnl
+])
+case $enable_silent_rules in @%:@ (((
+  yes) AM_DEFAULT_VERBOSITY=0;;
+   no) AM_DEFAULT_VERBOSITY=1;;
+    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;
+esac
+dnl
+dnl A few 'make' implementations (e.g., NonStop OS and NextStep)
+dnl do not support nested variable expansions.
+dnl See automake bug#9928 and bug#10237.
+am_make=${MAKE-make}
+AC_CACHE_CHECK([whether $am_make supports nested variables],
+   [am_cv_make_support_nested_variables],
+   [if AS_ECHO([['TRUE=$(BAR$(V))
+BAR0=false
+BAR1=true
+V=1
+am__doit:
+	@$(TRUE)
+.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then
+  am_cv_make_support_nested_variables=yes
+else
+  am_cv_make_support_nested_variables=no
+fi])
+if test $am_cv_make_support_nested_variables = yes; then
+  dnl Using '$V' instead of '$(V)' breaks IRIX make.
+  AM_V='$(V)'
+  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
+else
+  AM_V=$AM_DEFAULT_VERBOSITY
+  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
+fi
+AC_SUBST([AM_V])dnl
+AM_SUBST_NOTMAKE([AM_V])dnl
+AC_SUBST([AM_DEFAULT_V])dnl
+AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl
+AC_SUBST([AM_DEFAULT_VERBOSITY])dnl
+AM_BACKSLASH='\'
+AC_SUBST([AM_BACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
+])
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_PROG_INSTALL_STRIP
 # ---------------------
-# One issue with vendor `install' (even GNU) is that you can't
+# One issue with vendor 'install' (even GNU) is that you can't
 # specify the program used to strip binaries.  This is especially
 # annoying in cross-compiling environments, where the build's strip
 # is unlikely to handle the host's binaries.
 # Fortunately install-sh will honor a STRIPPROG variable, so we
-# always use install-sh in `make install-strip', and initialize
+# always use install-sh in "make install-strip", and initialize
 # STRIPPROG with the value of the STRIP variable (set by the user).
 AC_DEFUN([AM_PROG_INSTALL_STRIP],
 [AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+# will honor the 'STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
 if test "$cross_compiling" != no; then
   AC_CHECK_TOOL([STRIP], [strip], :)
 fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.
+# Copyright (C) 2006-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 3
-
 # _AM_SUBST_NOTMAKE(VARIABLE)
 # ---------------------------
 # Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
@@ -9577,18 +9644,16 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.
+# Copyright (C) 2004-2013 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
-
 # _AM_PROG_TAR(FORMAT)
 # --------------------
 # Check how to create a tarball in format FORMAT.
-# FORMAT should be one of `v7', `ustar', or `pax'.
+# FORMAT should be one of 'v7', 'ustar', or 'pax'.
 #
 # Substitute a variable $(am__tar) that is a command
 # writing to stdout a FORMAT-tarball containing the directory
@@ -9598,76 +9663,114 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 # Substitute a variable $(am__untar) that extract such
 # a tarball read from stdin.
 #     $(am__untar) < result.tar
+#
 AC_DEFUN([_AM_PROG_TAR],
 [# Always define AMTAR for backward compatibility.  Yes, it's still used
 # in the wild :-(  We should find a proper way to deprecate it ...
 AC_SUBST([AMTAR], ['$${TAR-tar}'])
-m4_if([$1], [v7],
-     [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
-     [m4_case([$1], [ustar],, [pax],,
-              [m4_fatal([Unknown tar format])])
-AC_MSG_CHECKING([how to create a $1 tar archive])
-# Loop over all known methods to create a tar archive until one works.
+
+# We'll loop over all known methods to create a tar archive until one works.
 _am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
-_am_tools=${am_cv_prog_tar_$1-$_am_tools}
-# Do not fold the above two line into one, because Tru64 sh and
-# Solaris sh will not grok spaces in the rhs of `-'.
-for _am_tool in $_am_tools
-do
-  case $_am_tool in
-  gnutar)
-    for _am_tar in tar gnutar gtar;
-    do
-      AM_RUN_LOG([$_am_tar --version]) && break
-    done
-    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
-    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
-    am__untar="$_am_tar -xf -"
-    ;;
-  plaintar)
-    # Must skip GNU tar: if it does not support --format= it doesn't create
-    # ustar tarball either.
-    (tar --version) >/dev/null 2>&1 && continue
-    am__tar='tar chf - "$$tardir"'
-    am__tar_='tar chf - "$tardir"'
-    am__untar='tar xf -'
-    ;;
-  pax)
-    am__tar='pax -L -x $1 -w "$$tardir"'
-    am__tar_='pax -L -x $1 -w "$tardir"'
-    am__untar='pax -r'
-    ;;
-  cpio)
-    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
-    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
-    am__untar='cpio -i -H $1 -d'
-    ;;
-  none)
-    am__tar=false
-    am__tar_=false
-    am__untar=false
-    ;;
-  esac
 
-  # If the value was cached, stop now.  We just wanted to have am__tar
-  # and am__untar set.
-  test -n "${am_cv_prog_tar_$1}" && break
+m4_if([$1], [v7],
+  [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
+
+  [m4_case([$1],
+    [ustar],
+     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.
+      # There is notably a 21 bits limit for the UID and the GID.  In fact,
+      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343
+      # and bug#13588).
+      am_max_uid=2097151 # 2^21 - 1
+      am_max_gid=$am_max_uid
+      # The $UID and $GID variables are not portable, so we need to resort
+      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls
+      # below are definitely unexpected, so allow the users to see them
+      # (that is, avoid stderr redirection).
+      am_uid=`id -u || echo unknown`
+      am_gid=`id -g || echo unknown`
+      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])
+      if test $am_uid -le $am_max_uid; then
+         AC_MSG_RESULT([yes])
+      else
+         AC_MSG_RESULT([no])
+         _am_tools=none
+      fi
+      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])
+      if test $am_gid -le $am_max_gid; then
+         AC_MSG_RESULT([yes])
+      else
+        AC_MSG_RESULT([no])
+        _am_tools=none
+      fi],
 
-  # tar/untar a dummy directory, and stop if the command works
-  rm -rf conftest.dir
-  mkdir conftest.dir
-  echo GrepMe > conftest.dir/file
-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  [pax],
+    [],
+
+  [m4_fatal([Unknown tar format])])
+
+  AC_MSG_CHECKING([how to create a $1 tar archive])
+
+  # Go ahead even if we have the value already cached.  We do so because we
+  # need to set the values for the 'am__tar' and 'am__untar' variables.
+  _am_tools=${am_cv_prog_tar_$1-$_am_tools}
+
+  for _am_tool in $_am_tools; do
+    case $_am_tool in
+    gnutar)
+      for _am_tar in tar gnutar gtar; do
+        AM_RUN_LOG([$_am_tar --version]) && break
+      done
+      am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+      am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+      am__untar="$_am_tar -xf -"
+      ;;
+    plaintar)
+      # Must skip GNU tar: if it does not support --format= it doesn't create
+      # ustar tarball either.
+      (tar --version) >/dev/null 2>&1 && continue
+      am__tar='tar chf - "$$tardir"'
+      am__tar_='tar chf - "$tardir"'
+      am__untar='tar xf -'
+      ;;
+    pax)
+      am__tar='pax -L -x $1 -w "$$tardir"'
+      am__tar_='pax -L -x $1 -w "$tardir"'
+      am__untar='pax -r'
+      ;;
+    cpio)
+      am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+      am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+      am__untar='cpio -i -H $1 -d'
+      ;;
+    none)
+      am__tar=false
+      am__tar_=false
+      am__untar=false
+      ;;
+    esac
+
+    # If the value was cached, stop now.  We just wanted to have am__tar
+    # and am__untar set.
+    test -n "${am_cv_prog_tar_$1}" && break
+
+    # tar/untar a dummy directory, and stop if the command works.
+    rm -rf conftest.dir
+    mkdir conftest.dir
+    echo GrepMe > conftest.dir/file
+    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+    rm -rf conftest.dir
+    if test -s conftest.tar; then
+      AM_RUN_LOG([$am__untar <conftest.tar])
+      AM_RUN_LOG([cat conftest.dir/file])
+      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+    fi
+  done
   rm -rf conftest.dir
-  if test -s conftest.tar; then
-    AM_RUN_LOG([$am__untar <conftest.tar])
-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
-  fi
-done
-rm -rf conftest.dir
 
-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
-AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+  AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+
 AC_SUBST([am__tar])
 AC_SUBST([am__untar])
 ]) # _AM_PROG_TAR
diff --git a/config/compile b/config/compile
index b1f4749..531136b 100755
--- a/config/compile
+++ b/config/compile
@@ -1,10 +1,9 @@
 #! /bin/sh
 # Wrapper for compilers which do not understand '-c -o'.
 
-scriptversion=2012-01-04.17; # UTC
+scriptversion=2012-10-14.11; # UTC
 
-# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2009, 2010, 2012 Free
-# Software Foundation, Inc.
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
 # Written by Tom Tromey <tromey@cygnus.com>.
 #
 # This program is free software; you can redistribute it and/or modify
@@ -79,6 +78,53 @@ func_file_conv ()
   esac
 }
 
+# func_cl_dashL linkdir
+# Make cl look for libraries in LINKDIR
+func_cl_dashL ()
+{
+  func_file_conv "$1"
+  if test -z "$lib_path"; then
+    lib_path=$file
+  else
+    lib_path="$lib_path;$file"
+  fi
+  linker_opts="$linker_opts -LIBPATH:$file"
+}
+
+# func_cl_dashl library
+# Do a library search-path lookup for cl
+func_cl_dashl ()
+{
+  lib=$1
+  found=no
+  save_IFS=$IFS
+  IFS=';'
+  for dir in $lib_path $LIB
+  do
+    IFS=$save_IFS
+    if $shared && test -f "$dir/$lib.dll.lib"; then
+      found=yes
+      lib=$dir/$lib.dll.lib
+      break
+    fi
+    if test -f "$dir/$lib.lib"; then
+      found=yes
+      lib=$dir/$lib.lib
+      break
+    fi
+    if test -f "$dir/lib$lib.a"; then
+      found=yes
+      lib=$dir/lib$lib.a
+      break
+    fi
+  done
+  IFS=$save_IFS
+
+  if test "$found" != yes; then
+    lib=$lib.lib
+  fi
+}
+
 # func_cl_wrapper cl arg...
 # Adjust compile command to suit cl
 func_cl_wrapper ()
@@ -109,43 +155,34 @@ func_cl_wrapper ()
 	      ;;
 	  esac
 	  ;;
+	-I)
+	  eat=1
+	  func_file_conv "$2" mingw
+	  set x "$@" -I"$file"
+	  shift
+	  ;;
 	-I*)
 	  func_file_conv "${1#-I}" mingw
 	  set x "$@" -I"$file"
 	  shift
 	  ;;
+	-l)
+	  eat=1
+	  func_cl_dashl "$2"
+	  set x "$@" "$lib"
+	  shift
+	  ;;
 	-l*)
-	  lib=${1#-l}
-	  found=no
-	  save_IFS=$IFS
-	  IFS=';'
-	  for dir in $lib_path $LIB
-	  do
-	    IFS=$save_IFS
-	    if $shared && test -f "$dir/$lib.dll.lib"; then
-	      found=yes
-	      set x "$@" "$dir/$lib.dll.lib"
-	      break
-	    fi
-	    if test -f "$dir/$lib.lib"; then
-	      found=yes
-	      set x "$@" "$dir/$lib.lib"
-	      break
-	    fi
-	  done
-	  IFS=$save_IFS
-
-	  test "$found" != yes && set x "$@" "$lib.lib"
+	  func_cl_dashl "${1#-l}"
+	  set x "$@" "$lib"
 	  shift
 	  ;;
+	-L)
+	  eat=1
+	  func_cl_dashL "$2"
+	  ;;
 	-L*)
-	  func_file_conv "${1#-L}"
-	  if test -z "$lib_path"; then
-	    lib_path=$file
-	  else
-	    lib_path="$lib_path;$file"
-	  fi
-	  linker_opts="$linker_opts -LIBPATH:$file"
+	  func_cl_dashL "${1#-L}"
 	  ;;
 	-static)
 	  shared=false
diff --git a/config/config.guess b/config/config.guess
index d622a44..b79252d 100755
--- a/config/config.guess
+++ b/config/config.guess
@@ -1,14 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012 Free Software Foundation, Inc.
+#   Copyright 1992-2013 Free Software Foundation, Inc.
 
-timestamp='2012-02-10'
+timestamp='2013-06-10'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -22,19 +20,17 @@ timestamp='2012-02-10'
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner.
 #
 # You can get the latest version of this script from:
 # http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+#
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -54,9 +50,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-Free Software Foundation, Inc.
+Copyright 1992-2013 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -138,6 +132,27 @@ UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
@@ -200,6 +215,10 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
 	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
+	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
@@ -302,7 +321,7 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
@@ -801,6 +820,9 @@ EOF
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit ;;
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
@@ -852,21 +874,21 @@ EOF
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
     aarch64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
@@ -879,59 +901,54 @@ EOF
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
 	    else
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabihf
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     hexagon:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
@@ -950,54 +967,63 @@ EOF
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
+    or1k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     or32:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-${LIBC}
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+	echo powerpc-unknown-linux-${LIBC}
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-${LIBC}
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     tile*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -1201,6 +1227,9 @@ EOF
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
 	echo i586-pc-haiku
 	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
 	exit ;;
@@ -1227,19 +1256,21 @@ EOF
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
@@ -1256,7 +1287,7 @@ EOF
     NEO-?:NONSTOP_KERNEL:*:*)
 	echo neo-tandem-nsk${UNAME_RELEASE}
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
+    NSE-*:NONSTOP_KERNEL:*:*)
 	echo nse-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     NSR-?:NONSTOP_KERNEL:*:*)
@@ -1330,9 +1361,6 @@ EOF
 	exit ;;
 esac
 
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
 eval $set_cc_for_build
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
diff --git a/config/config.sub b/config/config.sub
index c894da4..c765b34 100755
--- a/config/config.sub
+++ b/config/config.sub
@@ -1,24 +1,18 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012 Free Software Foundation, Inc.
+#   Copyright 1992-2013 Free Software Foundation, Inc.
 
-timestamp='2012-02-10'
+timestamp='2013-04-24'
 
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, see <http://www.gnu.org/licenses/>.
@@ -26,11 +20,12 @@ timestamp='2012-02-10'
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted GNU ChangeLog entry.
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -73,9 +68,7 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-Free Software Foundation, Inc.
+Copyright 1992-2013 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -123,7 +116,7 @@ esac
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
-  linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
   knetbsd*-gnu* | netbsd*-gnu* | \
   kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
@@ -156,7 +149,7 @@ case $os in
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray | -microblaze)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
@@ -225,6 +218,12 @@ case $os in
 	-isc*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-lynx*178)
+		os=-lynxos178
+		;;
+	-lynx*5)
+		os=-lynxos5
+		;;
 	-lynx*)
 		os=-lynxos
 		;;
@@ -253,8 +252,10 @@ case $basic_machine in
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
-        | be32 | be64 \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| be32 | be64 \
 	| bfin \
 	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx \
@@ -267,7 +268,7 @@ case $basic_machine in
 	| le32 | le64 \
 	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
@@ -285,16 +286,17 @@ case $basic_machine in
 	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
 	| moxie \
 	| mt \
 	| msp430 \
 	| nds32 | nds32le | nds32be \
-	| nios | nios2 \
+	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
 	| open8 \
-	| or32 \
+	| or1k | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
@@ -364,7 +366,7 @@ case $basic_machine in
 	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
 	| be32-* | be64-* \
@@ -383,7 +385,8 @@ case $basic_machine in
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -401,12 +404,13 @@ case $basic_machine in
 	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
 	| nds32-* | nds32le-* | nds32be-* \
-	| nios-* | nios2-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
 	| open8-* \
 	| orion-* \
@@ -782,9 +786,13 @@ case $basic_machine in
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
-	microblaze)
+	microblaze*)
 		basic_machine=microblaze-xilinx
 		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
 	mingw32)
 		basic_machine=i386-pc
 		os=-mingw32
@@ -998,7 +1006,7 @@ case $basic_machine in
 		;;
 	ppc64)	basic_machine=powerpc64-unknown
 		;;
-	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+	ppc64-* | ppc64p7-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
 		basic_machine=powerpc64le-unknown
@@ -1013,7 +1021,11 @@ case $basic_machine in
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
-	rdos)
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
+		;;
+	rdos32)
 		basic_machine=i386-pc
 		os=-rdos
 		;;
@@ -1340,21 +1352,21 @@ case $os in
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
-	      | -sym* | -kopensolaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* | -aros* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* | -cegcc* \
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-android* \
-	      | -linux-newlib* | -linux-uclibc* \
+	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
 	      | -uxpv* | -beos* | -mpeix* | -udk* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
@@ -1486,9 +1498,6 @@ case $os in
 	-aros*)
 		os=-aros
 		;;
-	-kaos*)
-		os=-kaos
-		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
@@ -1537,6 +1546,9 @@ case $basic_machine in
 	c4x-* | tic4x-*)
 		os=-coff
 		;;
+	hexagon-*)
+		os=-elf
+		;;
 	tic54x-*)
 		os=-coff
 		;;
@@ -1577,6 +1589,9 @@ case $basic_machine in
 	mips*-*)
 		os=-elf
 		;;
+	or1k-*)
+		os=-elf
+		;;
 	or32-*)
 		os=-coff
 		;;
diff --git a/config/depcomp b/config/depcomp
index bd0ac08..4ebd5b3 100755
--- a/config/depcomp
+++ b/config/depcomp
@@ -1,10 +1,9 @@
 #! /bin/sh
 # depcomp - compile a program generating dependencies as side-effects
 
-scriptversion=2011-12-04.11; # UTC
+scriptversion=2013-05-30.07; # UTC
 
-# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007, 2009, 2010,
-# 2011 Free Software Foundation, Inc.
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -28,9 +27,9 @@ scriptversion=2011-12-04.11; # UTC
 
 case $1 in
   '')
-     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
-     exit 1;
-     ;;
+    echo "$0: No command.  Try '$0 --help' for more information." 1>&2
+    exit 1;
+    ;;
   -h | --h*)
     cat <<\EOF
 Usage: depcomp [--help] [--version] PROGRAM [ARGS]
@@ -40,8 +39,8 @@ as side-effects.
 
 Environment variables:
   depmode     Dependency tracking mode.
-  source      Source file read by `PROGRAMS ARGS'.
-  object      Object file output by `PROGRAMS ARGS'.
+  source      Source file read by 'PROGRAMS ARGS'.
+  object      Object file output by 'PROGRAMS ARGS'.
   DEPDIR      directory where to store dependencies.
   depfile     Dependency file to output.
   tmpdepfile  Temporary file to use when outputting dependencies.
@@ -57,6 +56,66 @@ EOF
     ;;
 esac
 
+# Get the directory component of the given path, and save it in the
+# global variables '$dir'.  Note that this directory component will
+# be either empty or ending with a '/' character.  This is deliberate.
+set_dir_from ()
+{
+  case $1 in
+    */*) dir=`echo "$1" | sed -e 's|/[^/]*$|/|'`;;
+      *) dir=;;
+  esac
+}
+
+# Get the suffix-stripped basename of the given path, and save it the
+# global variable '$base'.
+set_base_from ()
+{
+  base=`echo "$1" | sed -e 's|^.*/||' -e 's/\.[^.]*$//'`
+}
+
+# If no dependency file was actually created by the compiler invocation,
+# we still have to create a dummy depfile, to avoid errors with the
+# Makefile "include basename.Plo" scheme.
+make_dummy_depfile ()
+{
+  echo "#dummy" > "$depfile"
+}
+
+# Factor out some common post-processing of the generated depfile.
+# Requires the auxiliary global variable '$tmpdepfile' to be set.
+aix_post_process_depfile ()
+{
+  # If the compiler actually managed to produce a dependency file,
+  # post-process it.
+  if test -f "$tmpdepfile"; then
+    # Each line is of the form 'foo.o: dependency.h'.
+    # Do two passes, one to just change these to
+    #   $object: dependency.h
+    # and one to simply output
+    #   dependency.h:
+    # which is needed to avoid the deleted-header problem.
+    { sed -e "s,^.*\.[$lower]*:,$object:," < "$tmpdepfile"
+      sed -e "s,^.*\.[$lower]*:[$tab ]*,," -e 's,$,:,' < "$tmpdepfile"
+    } > "$depfile"
+    rm -f "$tmpdepfile"
+  else
+    make_dummy_depfile
+  fi
+}
+
+# A tabulation character.
+tab='	'
+# A newline character.
+nl='
+'
+# Character ranges might be problematic outside the C locale.
+# These definitions help.
+upper=ABCDEFGHIJKLMNOPQRSTUVWXYZ
+lower=abcdefghijklmnopqrstuvwxyz
+digits=0123456789
+alpha=${upper}${lower}
+
 if test -z "$depmode" || test -z "$source" || test -z "$object"; then
   echo "depcomp: Variables source, object and depmode must be set" 1>&2
   exit 1
@@ -69,6 +128,9 @@ tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
 
 rm -f "$tmpdepfile"
 
+# Avoid interferences from the environment.
+gccflag= dashmflag=
+
 # Some modes work just like other modes, but use different flags.  We
 # parameterize here, but still list the modes in the big case below,
 # to make depend.m4 easier to write.  Note that we *cannot* use a case
@@ -80,26 +142,32 @@ if test "$depmode" = hp; then
 fi
 
 if test "$depmode" = dashXmstdout; then
-   # This is just like dashmstdout with a different argument.
-   dashmflag=-xM
-   depmode=dashmstdout
+  # This is just like dashmstdout with a different argument.
+  dashmflag=-xM
+  depmode=dashmstdout
 fi
 
 cygpath_u="cygpath -u -f -"
 if test "$depmode" = msvcmsys; then
-   # This is just like msvisualcpp but w/o cygpath translation.
-   # Just convert the backslash-escaped backslashes to single forward
-   # slashes to satisfy depend.m4
-   cygpath_u='sed s,\\\\,/,g'
-   depmode=msvisualcpp
+  # This is just like msvisualcpp but w/o cygpath translation.
+  # Just convert the backslash-escaped backslashes to single forward
+  # slashes to satisfy depend.m4
+  cygpath_u='sed s,\\\\,/,g'
+  depmode=msvisualcpp
 fi
 
 if test "$depmode" = msvc7msys; then
-   # This is just like msvc7 but w/o cygpath translation.
-   # Just convert the backslash-escaped backslashes to single forward
-   # slashes to satisfy depend.m4
-   cygpath_u='sed s,\\\\,/,g'
-   depmode=msvc7
+  # This is just like msvc7 but w/o cygpath translation.
+  # Just convert the backslash-escaped backslashes to single forward
+  # slashes to satisfy depend.m4
+  cygpath_u='sed s,\\\\,/,g'
+  depmode=msvc7
+fi
+
+if test "$depmode" = xlc; then
+  # IBM C/C++ Compilers xlc/xlC can output gcc-like dependency information.
+  gccflag=-qmakedep=gcc,-MF
+  depmode=gcc
 fi
 
 case "$depmode" in
@@ -122,8 +190,7 @@ gcc3)
   done
   "$@"
   stat=$?
-  if test $stat -eq 0; then :
-  else
+  if test $stat -ne 0; then
     rm -f "$tmpdepfile"
     exit $stat
   fi
@@ -131,13 +198,17 @@ gcc3)
   ;;
 
 gcc)
+## Note that this doesn't just cater to obsosete pre-3.x GCC compilers.
+## but also to in-use compilers like IMB xlc/xlC and the HP C compiler.
+## (see the conditional assignment to $gccflag above).
 ## There are various ways to get dependency output from gcc.  Here's
 ## why we pick this rather obscure method:
 ## - Don't want to use -MD because we'd like the dependencies to end
 ##   up in a subdir.  Having to rename by hand is ugly.
 ##   (We might end up doing this anyway to support other compilers.)
 ## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
-##   -MM, not -M (despite what the docs say).
+##   -MM, not -M (despite what the docs say).  Also, it might not be
+##   supported by the other compilers which use the 'gcc' depmode.
 ## - Using -M directly means running the compiler twice (even worse
 ##   than renaming).
   if test -z "$gccflag"; then
@@ -145,33 +216,31 @@ gcc)
   fi
   "$@" -Wp,"$gccflag$tmpdepfile"
   stat=$?
-  if test $stat -eq 0; then :
-  else
+  if test $stat -ne 0; then
     rm -f "$tmpdepfile"
     exit $stat
   fi
   rm -f "$depfile"
   echo "$object : \\" > "$depfile"
-  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
-## The second -e expression handles DOS-style file names with drive letters.
+  # The second -e expression handles DOS-style file names with drive
+  # letters.
   sed -e 's/^[^:]*: / /' \
       -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
-## This next piece of magic avoids the `deleted header file' problem.
+## This next piece of magic avoids the "deleted header file" problem.
 ## The problem is that when a header file which appears in a .P file
 ## is deleted, the dependency causes make to die (because there is
 ## typically no way to rebuild the header).  We avoid this by adding
 ## dummy dependencies for each header file.  Too bad gcc doesn't do
 ## this for us directly.
-  tr ' ' '
-' < "$tmpdepfile" |
-## Some versions of gcc put a space before the `:'.  On the theory
+## Some versions of gcc put a space before the ':'.  On the theory
 ## that the space means something, we add a space to the output as
 ## well.  hp depmode also adds that space, but also prefixes the VPATH
 ## to the object.  Take care to not repeat it in the output.
 ## Some versions of the HPUX 10.20 sed can't process this invocation
 ## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e "s|.*$object$||" -e '/:$/d' \
-      | sed -e 's/$/ :/' >> "$depfile"
+  tr ' ' "$nl" < "$tmpdepfile" \
+    | sed -e 's/^\\$//' -e '/^$/d' -e "s|.*$object$||" -e '/:$/d' \
+    | sed -e 's/$/ :/' >> "$depfile"
   rm -f "$tmpdepfile"
   ;;
 
@@ -189,8 +258,7 @@ sgi)
     "$@" -MDupdate "$tmpdepfile"
   fi
   stat=$?
-  if test $stat -eq 0; then :
-  else
+  if test $stat -ne 0; then
     rm -f "$tmpdepfile"
     exit $stat
   fi
@@ -198,43 +266,41 @@ sgi)
 
   if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
     echo "$object : \\" > "$depfile"
-
     # Clip off the initial element (the dependent).  Don't try to be
     # clever and replace this with sed code, as IRIX sed won't handle
     # lines with more than a fixed number of characters (4096 in
     # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
-    # the IRIX cc adds comments like `#:fec' to the end of the
+    # the IRIX cc adds comments like '#:fec' to the end of the
     # dependency line.
-    tr ' ' '
-' < "$tmpdepfile" \
-    | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' | \
-    tr '
-' ' ' >> "$depfile"
+    tr ' ' "$nl" < "$tmpdepfile" \
+      | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' \
+      | tr "$nl" ' ' >> "$depfile"
     echo >> "$depfile"
-
     # The second pass generates a dummy entry for each header file.
-    tr ' ' '
-' < "$tmpdepfile" \
-   | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
-   >> "$depfile"
+    tr ' ' "$nl" < "$tmpdepfile" \
+      | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+      >> "$depfile"
   else
-    # The sourcefile does not contain any dependencies, so just
-    # store a dummy comment line, to avoid errors with the Makefile
-    # "include basename.Plo" scheme.
-    echo "#dummy" > "$depfile"
+    make_dummy_depfile
   fi
   rm -f "$tmpdepfile"
   ;;
 
+xlc)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
 aix)
   # The C for AIX Compiler uses -M and outputs the dependencies
   # in a .u file.  In older versions, this file always lives in the
-  # current directory.  Also, the AIX compiler puts `$object:' at the
+  # current directory.  Also, the AIX compiler puts '$object:' at the
   # start of each line; $object doesn't have directory information.
   # Version 6 uses the directory in both cases.
-  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
-  test "x$dir" = "x$object" && dir=
-  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  set_dir_from "$object"
+  set_base_from "$object"
   if test "$libtool" = yes; then
     tmpdepfile1=$dir$base.u
     tmpdepfile2=$base.u
@@ -247,9 +313,7 @@ aix)
     "$@" -M
   fi
   stat=$?
-
-  if test $stat -eq 0; then :
-  else
+  if test $stat -ne 0; then
     rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
     exit $stat
   fi
@@ -258,44 +322,100 @@ aix)
   do
     test -f "$tmpdepfile" && break
   done
-  if test -f "$tmpdepfile"; then
-    # Each line is of the form `foo.o: dependent.h'.
-    # Do two passes, one to just change these to
-    # `$object: dependent.h' and one to simply `dependent.h:'.
-    sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
-    # That's a tab and a space in the [].
-    sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
-  else
-    # The sourcefile does not contain any dependencies, so just
-    # store a dummy comment line, to avoid errors with the Makefile
-    # "include basename.Plo" scheme.
-    echo "#dummy" > "$depfile"
+  aix_post_process_depfile
+  ;;
+
+tcc)
+  # tcc (Tiny C Compiler) understand '-MD -MF file' since version 0.9.26
+  # FIXME: That version still under development at the moment of writing.
+  #        Make that this statement remains true also for stable, released
+  #        versions.
+  # It will wrap lines (doesn't matter whether long or short) with a
+  # trailing '\', as in:
+  #
+  #   foo.o : \
+  #    foo.c \
+  #    foo.h \
+  #
+  # It will put a trailing '\' even on the last line, and will use leading
+  # spaces rather than leading tabs (at least since its commit 0394caf7
+  # "Emit spaces for -MD").
+  "$@" -MD -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile"
+    exit $stat
   fi
+  rm -f "$depfile"
+  # Each non-empty line is of the form 'foo.o : \' or ' dep.h \'.
+  # We have to change lines of the first kind to '$object: \'.
+  sed -e "s|.*:|$object :|" < "$tmpdepfile" > "$depfile"
+  # And for each line of the second kind, we have to emit a 'dep.h:'
+  # dummy dependency, to avoid the deleted-header problem.
+  sed -n -e 's|^  *\(.*\) *\\$|\1:|p' < "$tmpdepfile" >> "$depfile"
   rm -f "$tmpdepfile"
   ;;
 
-icc)
-  # Intel's C compiler understands `-MD -MF file'.  However on
-  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
-  # ICC 7.0 will fill foo.d with something like
-  #    foo.o: sub/foo.c
-  #    foo.o: sub/foo.h
-  # which is wrong.  We want:
-  #    sub/foo.o: sub/foo.c
-  #    sub/foo.o: sub/foo.h
-  #    sub/foo.c:
-  #    sub/foo.h:
-  # ICC 7.1 will output
+## The order of this option in the case statement is important, since the
+## shell code in configure will try each of these formats in the order
+## listed in this file.  A plain '-MD' option would be understood by many
+## compilers, so we must ensure this comes after the gcc and icc options.
+pgcc)
+  # Portland's C compiler understands '-MD'.
+  # Will always output deps to 'file.d' where file is the root name of the
+  # source file under compilation, even if file resides in a subdirectory.
+  # The object file name does not affect the name of the '.d' file.
+  # pgcc 10.2 will output
   #    foo.o: sub/foo.c sub/foo.h
-  # and will wrap long lines using \ :
+  # and will wrap long lines using '\' :
   #    foo.o: sub/foo.c ... \
   #     sub/foo.h ... \
   #     ...
+  set_dir_from "$object"
+  # Use the source, not the object, to determine the base name, since
+  # that's sadly what pgcc will do too.
+  set_base_from "$source"
+  tmpdepfile=$base.d
+
+  # For projects that build the same source file twice into different object
+  # files, the pgcc approach of using the *source* file root name can cause
+  # problems in parallel builds.  Use a locking strategy to avoid stomping on
+  # the same $tmpdepfile.
+  lockdir=$base.d-lock
+  trap "
+    echo '$0: caught signal, cleaning up...' >&2
+    rmdir '$lockdir'
+    exit 1
+  " 1 2 13 15
+  numtries=100
+  i=$numtries
+  while test $i -gt 0; do
+    # mkdir is a portable test-and-set.
+    if mkdir "$lockdir" 2>/dev/null; then
+      # This process acquired the lock.
+      "$@" -MD
+      stat=$?
+      # Release the lock.
+      rmdir "$lockdir"
+      break
+    else
+      # If the lock is being held by a different process, wait
+      # until the winning process is done or we timeout.
+      while test -d "$lockdir" && test $i -gt 0; do
+        sleep 1
+        i=`expr $i - 1`
+      done
+    fi
+    i=`expr $i - 1`
+  done
+  trap - 1 2 13 15
+  if test $i -le 0; then
+    echo "$0: failed to acquire lock after $numtries attempts" >&2
+    echo "$0: check lockdir '$lockdir'" >&2
+    exit 1
+  fi
 
-  "$@" -MD -MF "$tmpdepfile"
-  stat=$?
-  if test $stat -eq 0; then :
-  else
+  if test $stat -ne 0; then
     rm -f "$tmpdepfile"
     exit $stat
   fi
@@ -307,8 +427,8 @@ icc)
   sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
   # Some versions of the HPUX 10.20 sed can't process this invocation
   # correctly.  Breaking it into two sed invocations is a workaround.
-  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
-    sed -e 's/$/ :/' >> "$depfile"
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" \
+    | sed -e 's/$/ :/' >> "$depfile"
   rm -f "$tmpdepfile"
   ;;
 
@@ -319,9 +439,8 @@ hp2)
   # 'foo.d', which lands next to the object file, wherever that
   # happens to be.
   # Much of this is similar to the tru64 case; see comments there.
-  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
-  test "x$dir" = "x$object" && dir=
-  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  set_dir_from  "$object"
+  set_base_from "$object"
   if test "$libtool" = yes; then
     tmpdepfile1=$dir$base.d
     tmpdepfile2=$dir.libs/$base.d
@@ -332,8 +451,7 @@ hp2)
     "$@" +Maked
   fi
   stat=$?
-  if test $stat -eq 0; then :
-  else
+  if test $stat -ne 0; then
      rm -f "$tmpdepfile1" "$tmpdepfile2"
      exit $stat
   fi
@@ -343,77 +461,61 @@ hp2)
     test -f "$tmpdepfile" && break
   done
   if test -f "$tmpdepfile"; then
-    sed -e "s,^.*\.[a-z]*:,$object:," "$tmpdepfile" > "$depfile"
-    # Add `dependent.h:' lines.
+    sed -e "s,^.*\.[$lower]*:,$object:," "$tmpdepfile" > "$depfile"
+    # Add 'dependent.h:' lines.
     sed -ne '2,${
-	       s/^ *//
-	       s/ \\*$//
-	       s/$/:/
-	       p
-	     }' "$tmpdepfile" >> "$depfile"
+               s/^ *//
+               s/ \\*$//
+               s/$/:/
+               p
+             }' "$tmpdepfile" >> "$depfile"
   else
-    echo "#dummy" > "$depfile"
+    make_dummy_depfile
   fi
   rm -f "$tmpdepfile" "$tmpdepfile2"
   ;;
 
 tru64)
-   # The Tru64 compiler uses -MD to generate dependencies as a side
-   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
-   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
-   # dependencies in `foo.d' instead, so we check for that too.
-   # Subdirectories are respected.
-   dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
-   test "x$dir" = "x$object" && dir=
-   base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
-
-   if test "$libtool" = yes; then
-      # With Tru64 cc, shared objects can also be used to make a
-      # static library.  This mechanism is used in libtool 1.4 series to
-      # handle both shared and static libraries in a single compilation.
-      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
-      #
-      # With libtool 1.5 this exception was removed, and libtool now
-      # generates 2 separate objects for the 2 libraries.  These two
-      # compilations output dependencies in $dir.libs/$base.o.d and
-      # in $dir$base.o.d.  We have to check for both files, because
-      # one of the two compilations can be disabled.  We should prefer
-      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
-      # automatically cleaned when .libs/ is deleted, while ignoring
-      # the former would cause a distcleancheck panic.
-      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
-      tmpdepfile2=$dir$base.o.d          # libtool 1.5
-      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
-      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
-      "$@" -Wc,-MD
-   else
-      tmpdepfile1=$dir$base.o.d
-      tmpdepfile2=$dir$base.d
-      tmpdepfile3=$dir$base.d
-      tmpdepfile4=$dir$base.d
-      "$@" -MD
-   fi
-
-   stat=$?
-   if test $stat -eq 0; then :
-   else
-      rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
-      exit $stat
-   fi
-
-   for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
-   do
-     test -f "$tmpdepfile" && break
-   done
-   if test -f "$tmpdepfile"; then
-      sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
-      # That's a tab and a space in the [].
-      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
-   else
-      echo "#dummy" > "$depfile"
-   fi
-   rm -f "$tmpdepfile"
-   ;;
+  # The Tru64 compiler uses -MD to generate dependencies as a side
+  # effect.  'cc -MD -o foo.o ...' puts the dependencies into 'foo.o.d'.
+  # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+  # dependencies in 'foo.d' instead, so we check for that too.
+  # Subdirectories are respected.
+  set_dir_from  "$object"
+  set_base_from "$object"
+
+  if test "$libtool" = yes; then
+    # Libtool generates 2 separate objects for the 2 libraries.  These
+    # two compilations output dependencies in $dir.libs/$base.o.d and
+    # in $dir$base.o.d.  We have to check for both files, because
+    # one of the two compilations can be disabled.  We should prefer
+    # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+    # automatically cleaned when .libs/ is deleted, while ignoring
+    # the former would cause a distcleancheck panic.
+    tmpdepfile1=$dir$base.o.d          # libtool 1.5
+    tmpdepfile2=$dir.libs/$base.o.d    # Likewise.
+    tmpdepfile3=$dir.libs/$base.d      # Compaq CCC V6.2-504
+    "$@" -Wc,-MD
+  else
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir$base.d
+    tmpdepfile3=$dir$base.d
+    "$@" -MD
+  fi
+
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  # Same post-processing that is required for AIX mode.
+  aix_post_process_depfile
+  ;;
 
 msvc7)
   if test "$libtool" = yes; then
@@ -424,8 +526,7 @@ msvc7)
   "$@" $showIncludes > "$tmpdepfile"
   stat=$?
   grep -v '^Note: including file: ' "$tmpdepfile"
-  if test "$stat" = 0; then :
-  else
+  if test $stat -ne 0; then
     rm -f "$tmpdepfile"
     exit $stat
   fi
@@ -443,14 +544,15 @@ msvc7)
   p
 }' | $cygpath_u | sort -u | sed -n '
 s/ /\\ /g
-s/\(.*\)/	\1 \\/p
+s/\(.*\)/'"$tab"'\1 \\/p
 s/.\(.*\) \\/\1:/
 H
 $ {
-  s/.*/	/
+  s/.*/'"$tab"'/
   G
   p
 }' >> "$depfile"
+  echo >> "$depfile" # make sure the fragment doesn't end with a backslash
   rm -f "$tmpdepfile"
   ;;
 
@@ -478,7 +580,7 @@ dashmstdout)
     shift
   fi
 
-  # Remove `-o $object'.
+  # Remove '-o $object'.
   IFS=" "
   for arg
   do
@@ -498,18 +600,18 @@ dashmstdout)
   done
 
   test -z "$dashmflag" && dashmflag=-M
-  # Require at least two characters before searching for `:'
+  # Require at least two characters before searching for ':'
   # in the target name.  This is to cope with DOS-style filenames:
-  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
+  # a dependency such as 'c:/foo/bar' could be seen as target 'c' otherwise.
   "$@" $dashmflag |
-    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'"$object"'\: :' > "$tmpdepfile"
+    sed "s|^[$tab ]*[^:$tab ][^:][^:]*:[$tab ]*|$object: |" > "$tmpdepfile"
   rm -f "$depfile"
   cat < "$tmpdepfile" > "$depfile"
-  tr ' ' '
-' < "$tmpdepfile" | \
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this sed invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  tr ' ' "$nl" < "$tmpdepfile" \
+    | sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' \
+    | sed -e 's/$/ :/' >> "$depfile"
   rm -f "$tmpdepfile"
   ;;
 
@@ -562,11 +664,12 @@ makedepend)
   # makedepend may prepend the VPATH from the source file name to the object.
   # No need to regex-escape $object, excess matching of '.' is harmless.
   sed "s|^.*\($object *:\)|\1|" "$tmpdepfile" > "$depfile"
-  sed '1,2d' "$tmpdepfile" | tr ' ' '
-' | \
-## Some versions of the HPUX 10.20 sed can't process this invocation
-## correctly.  Breaking it into two sed invocations is a workaround.
-    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process the last invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed '1,2d' "$tmpdepfile" \
+    | tr ' ' "$nl" \
+    | sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' \
+    | sed -e 's/$/ :/' >> "$depfile"
   rm -f "$tmpdepfile" "$tmpdepfile".bak
   ;;
 
@@ -583,7 +686,7 @@ cpp)
     shift
   fi
 
-  # Remove `-o $object'.
+  # Remove '-o $object'.
   IFS=" "
   for arg
   do
@@ -602,10 +705,10 @@ cpp)
     esac
   done
 
-  "$@" -E |
-    sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
-       -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' |
-    sed '$ s: \\$::' > "$tmpdepfile"
+  "$@" -E \
+    | sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+             -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+    | sed '$ s: \\$::' > "$tmpdepfile"
   rm -f "$depfile"
   echo "$object : \\" > "$depfile"
   cat < "$tmpdepfile" >> "$depfile"
@@ -637,23 +740,23 @@ msvisualcpp)
       shift
       ;;
     "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
-	set fnord "$@"
-	shift
-	shift
-	;;
+        set fnord "$@"
+        shift
+        shift
+        ;;
     *)
-	set fnord "$@" "$arg"
-	shift
-	shift
-	;;
+        set fnord "$@" "$arg"
+        shift
+        shift
+        ;;
     esac
   done
   "$@" -E 2>/dev/null |
   sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::\1:p' | $cygpath_u | sort -u > "$tmpdepfile"
   rm -f "$depfile"
   echo "$object : \\" > "$depfile"
-  sed < "$tmpdepfile" -n -e 's% %\\ %g' -e '/^\(.*\)$/ s::	\1 \\:p' >> "$depfile"
-  echo "	" >> "$depfile"
+  sed < "$tmpdepfile" -n -e 's% %\\ %g' -e '/^\(.*\)$/ s::'"$tab"'\1 \\:p' >> "$depfile"
+  echo "$tab" >> "$depfile"
   sed < "$tmpdepfile" -n -e 's% %\\ %g' -e '/^\(.*\)$/ s::\1\::p' >> "$depfile"
   rm -f "$tmpdepfile"
   ;;
diff --git a/config/install-sh b/config/install-sh
index 6781b98..377bb86 100755
--- a/config/install-sh
+++ b/config/install-sh
@@ -1,7 +1,7 @@
 #!/bin/sh
 # install - install a program, script, or datafile
 
-scriptversion=2009-04-28.21; # UTC
+scriptversion=2011-11-20.07; # UTC
 
 # This originates from X11R5 (mit/util/scripts/install.sh), which was
 # later released in X11R6 (xc/config/util/install.sh) with the
@@ -35,7 +35,7 @@ scriptversion=2009-04-28.21; # UTC
 # FSF changes to this file are in the public domain.
 #
 # Calling this script install-sh is preferred over install.sh, to prevent
-# `make' implicit rules from creating a file called install from it
+# 'make' implicit rules from creating a file called install from it
 # when there is no Makefile.
 #
 # This script is compatible with the BSD install script, but was written
@@ -156,6 +156,10 @@ while test $# -ne 0; do
     -s) stripcmd=$stripprog;;
 
     -t) dst_arg=$2
+	# Protect names problematic for 'test' and other utilities.
+	case $dst_arg in
+	  -* | [=\(\)!]) dst_arg=./$dst_arg;;
+	esac
 	shift;;
 
     -T) no_target_directory=true;;
@@ -186,6 +190,10 @@ if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
     fi
     shift # arg
     dst_arg=$arg
+    # Protect names problematic for 'test' and other utilities.
+    case $dst_arg in
+      -* | [=\(\)!]) dst_arg=./$dst_arg;;
+    esac
   done
 fi
 
@@ -194,13 +202,17 @@ if test $# -eq 0; then
     echo "$0: no input file specified." >&2
     exit 1
   fi
-  # It's OK to call `install-sh -d' without argument.
+  # It's OK to call 'install-sh -d' without argument.
   # This can happen when creating conditional directories.
   exit 0
 fi
 
 if test -z "$dir_arg"; then
-  trap '(exit $?); exit' 1 2 13 15
+  do_exit='(exit $ret); exit $ret'
+  trap "ret=129; $do_exit" 1
+  trap "ret=130; $do_exit" 2
+  trap "ret=141; $do_exit" 13
+  trap "ret=143; $do_exit" 15
 
   # Set umask so as not to create temps with too-generous modes.
   # However, 'strip' requires both read and write access to temps.
@@ -228,9 +240,9 @@ fi
 
 for src
 do
-  # Protect names starting with `-'.
+  # Protect names problematic for 'test' and other utilities.
   case $src in
-    -*) src=./$src;;
+    -* | [=\(\)!]) src=./$src;;
   esac
 
   if test -n "$dir_arg"; then
@@ -252,12 +264,7 @@ do
       echo "$0: no destination specified." >&2
       exit 1
     fi
-
     dst=$dst_arg
-    # Protect names starting with `-'.
-    case $dst in
-      -*) dst=./$dst;;
-    esac
 
     # If destination is a directory, append the input filename; won't work
     # if double slashes aren't ignored.
@@ -347,7 +354,7 @@ do
 	      if test -z "$dir_arg" || {
 		   # Check for POSIX incompatibilities with -m.
 		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
-		   # other-writeable bit of parent directory when it shouldn't.
+		   # other-writable bit of parent directory when it shouldn't.
 		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
 		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
 		   case $ls_ld_tmpdir in
@@ -385,7 +392,7 @@ do
 
       case $dstdir in
 	/*) prefix='/';;
-	-*) prefix='./';;
+	[-=\(\)!]*) prefix='./';;
 	*)  prefix='';;
       esac
 
@@ -403,7 +410,7 @@ do
 
       for d
       do
-	test -z "$d" && continue
+	test X"$d" = X && continue
 
 	prefix=$prefix$d
 	if test -d "$prefix"; then
diff --git a/config/ltmain.sh b/config/ltmain.sh
index c2852d8..63ae69d 100644
--- a/config/ltmain.sh
+++ b/config/ltmain.sh
@@ -70,7 +70,7 @@
 #         compiler:		$LTCC
 #         compiler flags:		$LTCFLAGS
 #         linker:		$LD (gnu? $with_gnu_ld)
-#         $progname:	(GNU libtool) 2.4.2 Debian-2.4.2-1ubuntu1
+#         $progname:	(GNU libtool) 2.4.2
 #         automake:	$automake_version
 #         autoconf:	$autoconf_version
 #
@@ -80,7 +80,7 @@
 
 PROGRAM=libtool
 PACKAGE=libtool
-VERSION="2.4.2 Debian-2.4.2-1ubuntu1"
+VERSION=2.4.2
 TIMESTAMP=""
 package_revision=1.3337
 
@@ -6124,10 +6124,7 @@ func_mode_link ()
 	case $pass in
 	dlopen) libs="$dlfiles" ;;
 	dlpreopen) libs="$dlprefiles" ;;
-	link)
-	  libs="$deplibs %DEPLIBS%"
-	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
-	  ;;
+	link) libs="$deplibs %DEPLIBS% $dependency_libs" ;;
 	esac
       fi
       if test "$linkmode,$pass" = "lib,dlpreopen"; then
@@ -6447,19 +6444,19 @@ func_mode_link ()
 	    # It is a libtool convenience library, so add in its objects.
 	    func_append convenience " $ladir/$objdir/$old_library"
 	    func_append old_convenience " $ladir/$objdir/$old_library"
-	    tmp_libs=
-	    for deplib in $dependency_libs; do
-	      deplibs="$deplib $deplibs"
-	      if $opt_preserve_dup_deps ; then
-		case "$tmp_libs " in
-		*" $deplib "*) func_append specialdeplibs " $deplib" ;;
-		esac
-	      fi
-	      func_append tmp_libs " $deplib"
-	    done
 	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
 	    func_fatal_error "\`$lib' is not a convenience library"
 	  fi
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    deplibs="$deplib $deplibs"
+	    if $opt_preserve_dup_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) func_append specialdeplibs " $deplib" ;;
+	      esac
+	    fi
+	    func_append tmp_libs " $deplib"
+	  done
 	  continue
 	fi # $pass = conv
 
@@ -7352,9 +7349,6 @@ func_mode_link ()
 	    revision="$number_minor"
 	    lt_irix_increment=no
 	    ;;
-	  *)
-	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
-	    ;;
 	  esac
 	  ;;
 	no)
diff --git a/config/missing b/config/missing
index 86a8fc3..cdea514 100755
--- a/config/missing
+++ b/config/missing
@@ -1,11 +1,10 @@
 #! /bin/sh
-# Common stub for a few missing GNU programs while installing.
+# Common wrapper for a few potentially missing GNU programs.
 
-scriptversion=2012-01-06.13; # UTC
+scriptversion=2012-06-26.16; # UTC
 
-# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006,
-# 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
-# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Originally written by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -26,68 +25,40 @@ scriptversion=2012-01-06.13; # UTC
 # the same distribution terms that you use for the rest of that program.
 
 if test $# -eq 0; then
-  echo 1>&2 "Try \`$0 --help' for more information"
+  echo 1>&2 "Try '$0 --help' for more information"
   exit 1
 fi
 
-run=:
-sed_output='s/.* --output[ =]\([^ ]*\).*/\1/p'
-sed_minuso='s/.* -o \([^ ]*\).*/\1/p'
-
-# In the cases where this matters, `missing' is being run in the
-# srcdir already.
-if test -f configure.ac; then
-  configure_ac=configure.ac
-else
-  configure_ac=configure.in
-fi
+case $1 in
 
-msg="missing on your system"
+  --is-lightweight)
+    # Used by our autoconf macros to check whether the available missing
+    # script is modern enough.
+    exit 0
+    ;;
 
-case $1 in
---run)
-  # Try to run requested program, and just exit if it succeeds.
-  run=
-  shift
-  "$@" && exit 0
-  # Exit code 63 means version mismatch.  This often happens
-  # when the user try to use an ancient version of a tool on
-  # a file that requires a minimum version.  In this case we
-  # we should proceed has if the program had been absent, or
-  # if --run hadn't been passed.
-  if test $? = 63; then
-    run=:
-    msg="probably too old"
-  fi
-  ;;
+  --run)
+    # Back-compat with the calling convention used by older automake.
+    shift
+    ;;
 
   -h|--h|--he|--hel|--help)
     echo "\
 $0 [OPTION]... PROGRAM [ARGUMENT]...
 
-Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
-error status if there is no known handling for PROGRAM.
+Run 'PROGRAM [ARGUMENT]...', returning a proper advice when this fails due
+to PROGRAM being missing or too old.
 
 Options:
   -h, --help      display this help and exit
   -v, --version   output version information and exit
-  --run           try to run the given command, and emulate it if it fails
 
 Supported PROGRAM values:
-  aclocal      touch file \`aclocal.m4'
-  autoconf     touch file \`configure'
-  autoheader   touch file \`config.h.in'
-  autom4te     touch the output file, or create a stub one
-  automake     touch all \`Makefile.in' files
-  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
-  flex         create \`lex.yy.c', if possible, from existing .c
-  help2man     touch the output file
-  lex          create \`lex.yy.c', if possible, from existing .c
-  makeinfo     touch the output file
-  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
+  aclocal   autoconf  autoheader   autom4te  automake  makeinfo
+  bison     yacc      flex         lex       help2man
 
-Version suffixes to PROGRAM as well as the prefixes \`gnu-', \`gnu', and
-\`g' are ignored when checking the name.
+Version suffixes to PROGRAM as well as the prefixes 'gnu-', 'gnu', and
+'g' are ignored when checking the name.
 
 Send bug reports to <bug-automake@gnu.org>."
     exit $?
@@ -99,228 +70,141 @@ Send bug reports to <bug-automake@gnu.org>."
     ;;
 
   -*)
-    echo 1>&2 "$0: Unknown \`$1' option"
-    echo 1>&2 "Try \`$0 --help' for more information"
+    echo 1>&2 "$0: unknown '$1' option"
+    echo 1>&2 "Try '$0 --help' for more information"
     exit 1
     ;;
 
 esac
 
-# normalize program name to check for.
-program=`echo "$1" | sed '
-  s/^gnu-//; t
-  s/^gnu//; t
-  s/^g//; t'`
-
-# Now exit if we have it, but it failed.  Also exit now if we
-# don't have it and --version was passed (most likely to detect
-# the program).  This is about non-GNU programs, so use $1 not
-# $program.
-case $1 in
-  lex*|yacc*)
-    # Not GNU programs, they don't have --version.
-    ;;
-
-  *)
-    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
-       # We have it, but it failed.
-       exit 1
-    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
-       # Could not run --version or --help.  This is probably someone
-       # running `$TOOL --version' or `$TOOL --help' to check whether
-       # $TOOL exists and not knowing $TOOL uses missing.
-       exit 1
-    fi
-    ;;
-esac
-
-# If it does not exist, or fails to run (possibly an outdated version),
-# try to emulate it.
-case $program in
-  aclocal*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
-         to install the \`Automake' and \`Perl' packages.  Grab them from
-         any GNU archive site."
-    touch aclocal.m4
-    ;;
-
-  autoconf*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`${configure_ac}'.  You might want to install the
-         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
-         archive site."
-    touch configure
-    ;;
-
-  autoheader*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
-         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
-         from any GNU archive site."
-    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
-    test -z "$files" && files="config.h"
-    touch_files=
-    for f in $files; do
-      case $f in
-      *:*) touch_files="$touch_files "`echo "$f" |
-				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
-      *) touch_files="$touch_files $f.in";;
-      esac
-    done
-    touch $touch_files
-    ;;
-
-  automake*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
-         You might want to install the \`Automake' and \`Perl' packages.
-         Grab them from any GNU archive site."
-    find . -type f -name Makefile.am -print |
-	   sed 's/\.am$/.in/' |
-	   while read f; do touch "$f"; done
-    ;;
-
-  autom4te*)
-    echo 1>&2 "\
-WARNING: \`$1' is needed, but is $msg.
-         You might have modified some files without having the
-         proper tools for further handling them.
-         You can get \`$1' as part of \`Autoconf' from any GNU
-         archive site."
-
-    file=`echo "$*" | sed -n "$sed_output"`
-    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
-    if test -f "$file"; then
-	touch $file
-    else
-	test -z "$file" || exec >$file
-	echo "#! /bin/sh"
-	echo "# Created by GNU Automake missing as a replacement of"
-	echo "#  $ $@"
-	echo "exit 0"
-	chmod +x $file
-	exit 1
-    fi
-    ;;
-
-  bison*|yacc*)
-    echo 1>&2 "\
-WARNING: \`$1' $msg.  You should only need it if
-         you modified a \`.y' file.  You may need the \`Bison' package
-         in order for those modifications to take effect.  You can get
-         \`Bison' from any GNU archive site."
-    rm -f y.tab.c y.tab.h
-    if test $# -ne 1; then
-        eval LASTARG=\${$#}
-	case $LASTARG in
-	*.y)
-	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
-	    if test -f "$SRCFILE"; then
-	         cp "$SRCFILE" y.tab.c
-	    fi
-	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
-	    if test -f "$SRCFILE"; then
-	         cp "$SRCFILE" y.tab.h
-	    fi
-	  ;;
-	esac
-    fi
-    if test ! -f y.tab.h; then
-	echo >y.tab.h
-    fi
-    if test ! -f y.tab.c; then
-	echo 'main() { return 0; }' >y.tab.c
-    fi
-    ;;
-
-  lex*|flex*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified a \`.l' file.  You may need the \`Flex' package
-         in order for those modifications to take effect.  You can get
-         \`Flex' from any GNU archive site."
-    rm -f lex.yy.c
-    if test $# -ne 1; then
-        eval LASTARG=\${$#}
-	case $LASTARG in
-	*.l)
-	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
-	    if test -f "$SRCFILE"; then
-	         cp "$SRCFILE" lex.yy.c
-	    fi
-	  ;;
-	esac
-    fi
-    if test ! -f lex.yy.c; then
-	echo 'main() { return 0; }' >lex.yy.c
-    fi
-    ;;
-
-  help2man*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-	 you modified a dependency of a manual page.  You may need the
-	 \`Help2man' package in order for those modifications to take
-	 effect.  You can get \`Help2man' from any GNU archive site."
-
-    file=`echo "$*" | sed -n "$sed_output"`
-    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
-    if test -f "$file"; then
-	touch $file
-    else
-	test -z "$file" || exec >$file
-	echo ".ab help2man is required to generate this page"
-	exit $?
-    fi
-    ;;
-
-  makeinfo*)
-    echo 1>&2 "\
-WARNING: \`$1' is $msg.  You should only need it if
-         you modified a \`.texi' or \`.texinfo' file, or any other file
-         indirectly affecting the aspect of the manual.  The spurious
-         call might also be the consequence of using a buggy \`make' (AIX,
-         DU, IRIX).  You might want to install the \`Texinfo' package or
-         the \`GNU make' package.  Grab either from any GNU archive site."
-    # The file to touch is that specified with -o ...
-    file=`echo "$*" | sed -n "$sed_output"`
-    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
-    if test -z "$file"; then
-      # ... or it is the one specified with @setfilename ...
-      infile=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
-      file=`sed -n '
-	/^@setfilename/{
-	  s/.* \([^ ]*\) *$/\1/
-	  p
-	  q
-	}' $infile`
-      # ... or it is derived from the source name (dir/f.texi becomes f.info)
-      test -z "$file" && file=`echo "$infile" | sed 's,.*/,,;s,.[^.]*$,,'`.info
-    fi
-    # If the file does not exist, the user really needs makeinfo;
-    # let's fail without touching anything.
-    test -f $file || exit 1
-    touch $file
-    ;;
+# Run the given program, remember its exit status.
+"$@"; st=$?
+
+# If it succeeded, we are done.
+test $st -eq 0 && exit 0
+
+# Also exit now if we it failed (or wasn't found), and '--version' was
+# passed; such an option is passed most likely to detect whether the
+# program is present and works.
+case $2 in --version|--help) exit $st;; esac
+
+# Exit code 63 means version mismatch.  This often happens when the user
+# tries to use an ancient version of a tool on a file that requires a
+# minimum version.
+if test $st -eq 63; then
+  msg="probably too old"
+elif test $st -eq 127; then
+  # Program was missing.
+  msg="missing on your system"
+else
+  # Program was found and executed, but failed.  Give up.
+  exit $st
+fi
 
-  *)
-    echo 1>&2 "\
-WARNING: \`$1' is needed, and is $msg.
-         You might have modified some files without having the
-         proper tools for further handling them.  Check the \`README' file,
-         it often tells you about the needed prerequisites for installing
-         this package.  You may also peek at any GNU archive site, in case
-         some other package would contain this missing \`$1' program."
-    exit 1
+perl_URL=http://www.perl.org/
+flex_URL=http://flex.sourceforge.net/
+gnu_software_URL=http://www.gnu.org/software
+
+program_details ()
+{
+  case $1 in
+    aclocal|automake)
+      echo "The '$1' program is part of the GNU Automake package:"
+      echo "<$gnu_software_URL/automake>"
+      echo "It also requires GNU Autoconf, GNU m4 and Perl in order to run:"
+      echo "<$gnu_software_URL/autoconf>"
+      echo "<$gnu_software_URL/m4/>"
+      echo "<$perl_URL>"
+      ;;
+    autoconf|autom4te|autoheader)
+      echo "The '$1' program is part of the GNU Autoconf package:"
+      echo "<$gnu_software_URL/autoconf/>"
+      echo "It also requires GNU m4 and Perl in order to run:"
+      echo "<$gnu_software_URL/m4/>"
+      echo "<$perl_URL>"
+      ;;
+  esac
+}
+
+give_advice ()
+{
+  # Normalize program name to check for.
+  normalized_program=`echo "$1" | sed '
+    s/^gnu-//; t
+    s/^gnu//; t
+    s/^g//; t'`
+
+  printf '%s\n' "'$1' is $msg."
+
+  configure_deps="'configure.ac' or m4 files included by 'configure.ac'"
+  case $normalized_program in
+    autoconf*)
+      echo "You should only need it if you modified 'configure.ac',"
+      echo "or m4 files included by it."
+      program_details 'autoconf'
+      ;;
+    autoheader*)
+      echo "You should only need it if you modified 'acconfig.h' or"
+      echo "$configure_deps."
+      program_details 'autoheader'
+      ;;
+    automake*)
+      echo "You should only need it if you modified 'Makefile.am' or"
+      echo "$configure_deps."
+      program_details 'automake'
+      ;;
+    aclocal*)
+      echo "You should only need it if you modified 'acinclude.m4' or"
+      echo "$configure_deps."
+      program_details 'aclocal'
+      ;;
+   autom4te*)
+      echo "You might have modified some maintainer files that require"
+      echo "the 'automa4te' program to be rebuilt."
+      program_details 'autom4te'
+      ;;
+    bison*|yacc*)
+      echo "You should only need it if you modified a '.y' file."
+      echo "You may want to install the GNU Bison package:"
+      echo "<$gnu_software_URL/bison/>"
+      ;;
+    lex*|flex*)
+      echo "You should only need it if you modified a '.l' file."
+      echo "You may want to install the Fast Lexical Analyzer package:"
+      echo "<$flex_URL>"
+      ;;
+    help2man*)
+      echo "You should only need it if you modified a dependency" \
+           "of a man page."
+      echo "You may want to install the GNU Help2man package:"
+      echo "<$gnu_software_URL/help2man/>"
     ;;
-esac
-
-exit 0
+    makeinfo*)
+      echo "You should only need it if you modified a '.texi' file, or"
+      echo "any other file indirectly affecting the aspect of the manual."
+      echo "You might want to install the Texinfo package:"
+      echo "<$gnu_software_URL/texinfo/>"
+      echo "The spurious makeinfo call might also be the consequence of"
+      echo "using a buggy 'make' (AIX, DU, IRIX), in which case you might"
+      echo "want to install GNU make:"
+      echo "<$gnu_software_URL/make/>"
+      ;;
+    *)
+      echo "You might have modified some files without having the proper"
+      echo "tools for further handling them.  Check the 'README' file, it"
+      echo "often tells you about the needed prerequisites for installing"
+      echo "this package.  You may also peek at any GNU archive site, in"
+      echo "case some other package contains this missing '$1' program."
+      ;;
+  esac
+}
+
+give_advice "$1" | sed -e '1s/^/WARNING: /' \
+                       -e '2,$s/^/         /' >&2
+
+# Propagate the correct exit status (expected to be 127 for a program
+# not found, 63 for a program that failed due to version mismatch).
+exit $st
 
 # Local variables:
 # eval: (add-hook 'write-file-hooks 'time-stamp)
diff --git a/configure b/configure
index 94f0f27..4e0c17c 100755
--- a/configure
+++ b/configure
@@ -1,13 +1,11 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for libunwind 1.1.
+# Generated by GNU Autoconf 2.69 for libunwind 1.4-rc1.
 #
 # Report bugs to <libunwind-devel@nongnu.org>.
 #
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -136,6 +134,31 @@ export LANGUAGE
 # CDPATH.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
   as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
@@ -169,7 +192,8 @@ if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
 else
   exitcode=1; echo positional parameters were not saved.
 fi
-test x\$exitcode = x0 || exit 1"
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
@@ -222,21 +246,25 @@ IFS=$as_save_IFS
 
 
       if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
 fi
 
     if test x$as_have_required = xno; then :
@@ -339,6 +367,14 @@ $as_echo X"$as_dir" |
 
 
 } # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
@@ -460,6 +496,10 @@ as_cr_alnum=$as_cr_Letters$as_cr_digits
   chmod +x "$as_me.lineno" ||
     { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
   # original and so on.  Autoconf is especially sensitive to this).
@@ -494,16 +534,16 @@ if (echo >conf$$.file) 2>/dev/null; then
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -515,28 +555,8 @@ else
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -570,8 +590,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='libunwind'
 PACKAGE_TARNAME='libunwind'
-PACKAGE_VERSION='1.1'
-PACKAGE_STRING='libunwind 1.1'
+PACKAGE_VERSION='1.4-rc1'
+PACKAGE_STRING='libunwind 1.4-rc1'
 PACKAGE_BUGREPORT='libunwind-devel@nongnu.org'
 PACKAGE_URL=''
 
@@ -616,6 +636,12 @@ ac_subst_vars='am__EXEEXT_FALSE
 am__EXEEXT_TRUE
 LTLIBOBJS
 LIBOBJS
+CONFIG_TESTS_FALSE
+CONFIG_TESTS_TRUE
+CONFIG_DOCS_FALSE
+CONFIG_DOCS_TRUE
+LATEX2MAN
+BACKTRACELIB
 DLLIB
 enable_debug_frame
 enable_cxx_exceptions
@@ -624,6 +650,7 @@ PKG_EXTRA
 PKG_MINOR
 PKG_MAJOR
 LIBCRTS
+LDFLAGS_NOSTARTFILES
 LDFLAGS_STATIC_LIBCXA
 ARCH
 arch
@@ -641,12 +668,18 @@ USE_ELF64_FALSE
 USE_ELF64_TRUE
 USE_ELF32_FALSE
 USE_ELF32_TRUE
+OS_QNX_FALSE
+OS_QNX_TRUE
 OS_FREEBSD_FALSE
 OS_FREEBSD_TRUE
 OS_HPUX_FALSE
 OS_HPUX_TRUE
 OS_LINUX_FALSE
 OS_LINUX_TRUE
+ARCH_S390X_FALSE
+ARCH_S390X_TRUE
+ARCH_TILEGX_FALSE
+ARCH_TILEGX_TRUE
 ARCH_SH_FALSE
 ARCH_SH_TRUE
 ARCH_PPC64_FALSE
@@ -665,8 +698,16 @@ ARCH_IA64_FALSE
 ARCH_IA64_TRUE
 ARCH_ARM_FALSE
 ARCH_ARM_TRUE
+ARCH_AARCH64_FALSE
+ARCH_AARCH64_TRUE
 REMOTE_ONLY_FALSE
 REMOTE_ONLY_TRUE
+NO_PTRACE_TEST_FALSE
+NO_PTRACE_TEST_TRUE
+BUILD_SETJMP_FALSE
+BUILD_SETJMP_TRUE
+BUILD_PTRACE_FALSE
+BUILD_PTRACE_TRUE
 BUILD_COREDUMP_FALSE
 BUILD_COREDUMP_TRUE
 USE_ALTIVEC_FALSE
@@ -685,8 +726,6 @@ NMEDIT
 DSYMUTIL
 MANIFEST_TOOL
 RANLIB
-ac_ct_AR
-AR
 DLLTOOL
 OBJDUMP
 LN_S
@@ -699,6 +738,8 @@ EGREP
 GREP
 SED
 LIBTOOL
+ac_ct_AR
+AR
 am__fastdepCXX_FALSE
 am__fastdepCXX_TRUE
 CXXDEPMODE
@@ -725,6 +766,10 @@ CC
 MAINT
 MAINTAINER_MODE_FALSE
 MAINTAINER_MODE_TRUE
+AM_BACKSLASH
+AM_DEFAULT_VERBOSITY
+AM_DEFAULT_V
+AM_V
 am__untar
 am__tar
 AMTAR
@@ -801,6 +846,7 @@ SHELL'
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
+enable_silent_rules
 enable_maintainer_mode
 enable_dependency_tracking
 enable_shared
@@ -811,6 +857,10 @@ with_gnu_ld
 with_sysroot
 enable_libtool_lock
 enable_coredump
+enable_ptrace
+enable_setjmp
+enable_documentation
+enable_tests
 enable_debug
 enable_cxx_exceptions
 enable_debug_frame
@@ -818,6 +868,7 @@ enable_block_signals
 enable_conservative_checks
 enable_msabi_support
 enable_minidebuginfo
+enable_per_thread_cache
 '
       ac_precious_vars='build_alias
 host_alias
@@ -1289,8 +1340,6 @@ target=$target_alias
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used" >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1376,7 +1425,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures libunwind 1.1 to adapt to many kinds of systems.
+\`configure' configures libunwind 1.4-rc1 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1447,7 +1496,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of libunwind 1.1:";;
+     short | recursive ) echo "Configuration of libunwind 1.4-rc1:";;
    esac
   cat <<\_ACEOF
 
@@ -1455,16 +1504,25 @@ Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --enable-maintainer-mode  enable make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer
-  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-silent-rules   less verbose build output (undo: "make V=1")
+  --disable-silent-rules  verbose build output (undo: "make V=0")
+  --enable-maintainer-mode
+                          enable make rules and dependencies not useful (and
+                          sometimes confusing) to the casual installer
+  --enable-dependency-tracking
+                          do not reject slow dependency extractors
+  --disable-dependency-tracking
+                          speeds up one-time build
   --enable-shared[=PKGS]  build shared libraries [default=yes]
   --enable-static[=PKGS]  build static libraries [default=yes]
   --enable-fast-install[=PKGS]
                           optimize for fast installation [default=yes]
   --disable-libtool-lock  avoid locking (might break parallel builds)
   --enable-coredump       building libunwind-coredump library
+  --enable-ptrace         building libunwind-ptrace library
+  --enable-setjmp         building libunwind-setjmp library
+  --disable-documentation Disable generating the man pages
+  --disable-tests         Disable tests build
   --enable-debug          turn on debug support (slows down execution)
   --enable-cxx-exceptions use libunwind to handle C++ exceptions
   --enable-debug-frame    Load the ".debug_frame" section if available
@@ -1473,6 +1531,10 @@ Optional Features:
                           Validate all memory addresses before use
   --enable-msabi-support  Enables support for Microsoft ABI extensions
   --enable-minidebuginfo  Enables support for LZMA-compressed symbol tables
+  --enable-per-thread-cache
+                          build with support for UNW_CACHE_PER_THREAD (which
+                          imposes a hight TLS memory usage) (default:
+                          disabled)
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -1564,10 +1626,10 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-libunwind configure 1.1
-generated by GNU Autoconf 2.68
+libunwind configure 1.4-rc1
+generated by GNU Autoconf 2.69
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1681,7 +1743,7 @@ $as_echo "$ac_try_echo"; } >&5
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
+	 test -x conftest$ac_exeext
        }; then :
   ac_retval=0
 else
@@ -1941,7 +2003,7 @@ $as_echo "$ac_try_echo"; } >&5
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
+	 test -x conftest$ac_exeext
        }; then :
   ac_retval=0
 else
@@ -2122,7 +2184,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2138,7 +2201,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2164,7 +2228,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) < 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2180,7 +2245,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2214,7 +2280,8 @@ int
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2389,8 +2456,8 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by libunwind $as_me 1.1, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+It was created by libunwind $as_me 1.4-rc1, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
@@ -2877,7 +2944,7 @@ test -n "$target_alias" &&
   test "$program_prefix$program_suffix$program_transform_name" = \
     NONENONEs,x,x, &&
   program_prefix=${target_alias}-
-am__api_version='1.11'
+am__api_version='1.13'
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
@@ -2916,7 +2983,7 @@ case $as_dir/ in #((
     # by default.
     for ac_prog in ginstall scoinst install; do
       for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
 	  if test $ac_prog = install &&
 	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
 	    # AIX install.  It has an incompatible calling convention.
@@ -2974,9 +3041,6 @@ test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
 $as_echo_n "checking whether build environment is sane... " >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
@@ -2987,32 +3051,40 @@ case `pwd` in
 esac
 case $srcdir in
   *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+    as_fn_error $? "unsafe srcdir value: '$srcdir'" "$LINENO" 5;;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" "$LINENO" 5
-   fi
-
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$*" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$*" != "X $srcdir/configure conftest.file" \
+	&& test "$*" != "X conftest.file $srcdir/configure"; then
+
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment" "$LINENO" 5
+     fi
+     if test "$2" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$2" = conftest.file
    )
 then
@@ -3024,6 +3096,16 @@ Check your system clock" "$LINENO" 5
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+
+rm -f conftest.file
+
 test "$program_prefix" != NONE &&
   program_transform_name="s&^&$program_prefix&;$program_transform_name"
 # Use a double $ so make ignores it.
@@ -3046,12 +3128,12 @@ if test x"${MISSING+set}" != xset; then
   esac
 fi
 # Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
+if eval "$MISSING --is-lightweight"; then
+  am_missing_run="$MISSING "
 else
   am_missing_run=
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
-$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: 'missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: 'missing' script is too old or missing" >&2;}
 fi
 
 if test x"${install_sh}" != xset; then
@@ -3063,10 +3145,10 @@ if test x"${install_sh}" != xset; then
   esac
 fi
 
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
+# will honor the 'STRIP' environment variable to overrule this program.
 if test "$cross_compiling" != no; then
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
@@ -3085,7 +3167,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_STRIP="${ac_tool_prefix}strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3125,7 +3207,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_STRIP="strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3176,7 +3258,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_prog in mkdir gmkdir; do
 	 for ac_exec_ext in '' $ac_executable_extensions; do
-	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext" || continue
 	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
 	     'mkdir (GNU coreutils) '* | \
 	     'mkdir (coreutils) '* | \
@@ -3205,12 +3287,6 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
 $as_echo "$MKDIR_P" >&6; }
 
-mkdir_p="$MKDIR_P"
-case $mkdir_p in
-  [\\/$]* | ?:[\\/]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-
 for ac_prog in gawk mawk nawk awk
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
@@ -3229,7 +3305,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_AWK="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3293,6 +3369,45 @@ else
 fi
 rmdir .tst 2>/dev/null
 
+# Check whether --enable-silent-rules was given.
+if test "${enable_silent_rules+set}" = set; then :
+  enableval=$enable_silent_rules;
+fi
+
+case $enable_silent_rules in # (((
+  yes) AM_DEFAULT_VERBOSITY=0;;
+   no) AM_DEFAULT_VERBOSITY=1;;
+    *) AM_DEFAULT_VERBOSITY=1;;
+esac
+am_make=${MAKE-make}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $am_make supports nested variables" >&5
+$as_echo_n "checking whether $am_make supports nested variables... " >&6; }
+if ${am_cv_make_support_nested_variables+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if $as_echo 'TRUE=$(BAR$(V))
+BAR0=false
+BAR1=true
+V=1
+am__doit:
+	@$(TRUE)
+.PHONY: am__doit' | $am_make -f - >/dev/null 2>&1; then
+  am_cv_make_support_nested_variables=yes
+else
+  am_cv_make_support_nested_variables=no
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_make_support_nested_variables" >&5
+$as_echo "$am_cv_make_support_nested_variables" >&6; }
+if test $am_cv_make_support_nested_variables = yes; then
+    AM_V='$(V)'
+  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
+else
+  AM_V=$AM_DEFAULT_VERBOSITY
+  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
+fi
+AM_BACKSLASH='\'
+
 if test "`cd $srcdir && pwd`" != "`pwd`"; then
   # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
   # is not polluted with repeated "-I."
@@ -3315,7 +3430,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='libunwind'
- VERSION='1.1'
+ VERSION='1.4-rc1'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -3343,12 +3458,22 @@ AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
 
 MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
+# For better backward compatibility.  To be removed once Automake 1.9.x
+# dies out for good.  For more background, see:
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+mkdir_p='$(MKDIR_P)'
+
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
 # Always define AMTAR for backward compatibility.  Yes, it's still used
 # in the wild :-(  We should find a proper way to deprecate it ...
 AMTAR='$${TAR-tar}'
 
+
+# We'll loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar  pax cpio none'
+
 am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
 
 
@@ -3356,6 +3481,7 @@ am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
 
 
 
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
 $as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
     # Check whether --enable-maintainer-mode was given.
@@ -3403,7 +3529,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3443,7 +3569,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3496,7 +3622,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3537,7 +3663,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
@@ -3595,7 +3721,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3639,7 +3765,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4085,8 +4211,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
+struct stat;
 /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
 struct buf { int x; };
 FILE * (*rcsopen) (struct buf *, struct stat *, int);
@@ -4189,7 +4314,7 @@ am__quote=
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -4245,8 +4370,8 @@ else
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -4281,16 +4406,16 @@ else
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -4299,8 +4424,8 @@ else
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -4308,7 +4433,7 @@ else
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -4390,7 +4515,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4434,7 +4559,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CXX="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4630,8 +4755,8 @@ else
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -4666,16 +4791,16 @@ else
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -4684,8 +4809,8 @@ else
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -4693,7 +4818,7 @@ else
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -4779,6 +4904,167 @@ $as_echo "no" >&6; }
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
+
+if test -n "$ac_tool_prefix"; then
+  for ac_prog in ar lib "link -lib"
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AR="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$AR" && break
+  done
+fi
+if test -z "$AR"; then
+  ac_ct_AR=$AR
+  for ac_prog in ar lib "link -lib"
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_AR="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_AR" && break
+done
+
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+fi
+
+: ${AR=ar}
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the archiver ($AR) interface" >&5
+$as_echo_n "checking the archiver ($AR) interface... " >&6; }
+if ${am_cv_ar_interface+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  am_cv_ar_interface=ar
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int some_variable = 0;
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  am_ar_try='$AR cru libconftest.a conftest.$ac_objext >&5'
+      { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$am_ar_try\""; } >&5
+  (eval $am_ar_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+      if test "$ac_status" -eq 0; then
+        am_cv_ar_interface=ar
+      else
+        am_ar_try='$AR -NOLOGO -OUT:conftest.lib conftest.$ac_objext >&5'
+        { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$am_ar_try\""; } >&5
+  (eval $am_ar_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+        if test "$ac_status" -eq 0; then
+          am_cv_ar_interface=lib
+        else
+          am_cv_ar_interface=unknown
+        fi
+      fi
+      rm -f conftest.lib libconftest.a
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_ar_interface" >&5
+$as_echo "$am_cv_ar_interface" >&6; }
+
+case $am_cv_ar_interface in
+ar)
+  ;;
+lib)
+  # Microsoft lib, so override with the ar-lib wrapper script.
+  # FIXME: It is wrong to rewrite AR.
+  # But if we don't then we get into trouble of one sort or another.
+  # A longer-term fix would be to have automake use am__AR in this case,
+  # and then we could set am__AR="$am_aux_dir/ar-lib \$(AR)" or something
+  # similar.
+  AR="$am_aux_dir/ar-lib $AR"
+  ;;
+unknown)
+  as_fn_error $? "could not determine $AR interface" "$LINENO" 5
+  ;;
+esac
+
 case `pwd` in
   *\ * | *\	*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
@@ -4895,7 +5181,7 @@ do
     for ac_prog in sed gsed; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
+      as_fn_executable_p "$ac_path_SED" || continue
 # Check for GNU ac_path_SED and select it if it is found.
   # Check for GNU $ac_path_SED
 case `"$ac_path_SED" --version 2>&1` in
@@ -4971,7 +5257,7 @@ do
     for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+      as_fn_executable_p "$ac_path_GREP" || continue
 # Check for GNU ac_path_GREP and select it if it is found.
   # Check for GNU $ac_path_GREP
 case `"$ac_path_GREP" --version 2>&1` in
@@ -5037,7 +5323,7 @@ do
     for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+      as_fn_executable_p "$ac_path_EGREP" || continue
 # Check for GNU ac_path_EGREP and select it if it is found.
   # Check for GNU $ac_path_EGREP
 case `"$ac_path_EGREP" --version 2>&1` in
@@ -5104,7 +5390,7 @@ do
     for ac_prog in fgrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
+      as_fn_executable_p "$ac_path_FGREP" || continue
 # Check for GNU ac_path_FGREP and select it if it is found.
   # Check for GNU $ac_path_FGREP
 case `"$ac_path_FGREP" --version 2>&1` in
@@ -5360,7 +5646,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5404,7 +5690,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5828,7 +6114,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5868,7 +6154,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_OBJDUMP="objdump"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6040,7 +6326,7 @@ linux* | k*bsd*-gnu | kopensolaris*-gnu)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-netbsd* | netbsdelf*-gnu)
+netbsd*)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
   else
@@ -6174,7 +6460,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_DLLTOOL="${ac_tool_prefix}dlltool"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6214,7 +6500,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_DLLTOOL="dlltool"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6298,7 +6584,6 @@ test -z "$sharedlib_from_linklib_cmd" && sharedlib_from_linklib_cmd=$ECHO
 
 
 
-
 if test -n "$ac_tool_prefix"; then
   for ac_prog in ar
   do
@@ -6318,7 +6603,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_AR="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6362,7 +6647,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_AR="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6487,7 +6772,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_STRIP="${ac_tool_prefix}strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6527,7 +6812,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_STRIP="strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6586,7 +6871,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6626,7 +6911,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7275,7 +7560,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_MANIFEST_TOOL="${ac_tool_prefix}mt"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7315,7 +7600,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_MANIFEST_TOOL="mt"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7395,7 +7680,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7435,7 +7720,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7487,7 +7772,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7527,7 +7812,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_NMEDIT="nmedit"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7579,7 +7864,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7619,7 +7904,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_LIPO="lipo"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7671,7 +7956,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7711,7 +7996,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_OTOOL="otool"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7763,7 +8048,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7803,7 +8088,7 @@ do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_OTOOL64="otool64"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -9448,9 +9733,6 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
   openbsd*)
     with_gnu_ld=no
     ;;
-  linux* | k*bsd*-gnu | gnu*)
-    link_all_deplibs=no
-    ;;
   esac
 
   ld_shlibs=yes
@@ -9672,7 +9954,7 @@ _LT_EOF
       fi
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
@@ -9849,7 +10131,6 @@ _LT_EOF
 	if test "$aix_use_runtimelinking" = yes; then
 	  shared_flag="$shared_flag "'${wl}-G'
 	fi
-	link_all_deplibs=no
       else
 	# not using gcc
 	if test "$host_cpu" = ia64; then
@@ -10303,7 +10584,7 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
       link_all_deplibs=yes
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
       else
@@ -11316,10 +11597,14 @@ fi
   # before this can be enabled.
   hardcode_into_libs=yes
 
+  # Add ABI-specific directories to the system library path.
+  sys_lib_dlsearch_path_spec="/lib64 /usr/lib64 /lib /usr/lib"
+
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -11331,18 +11616,6 @@ fi
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
-netbsdelf*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='NetBSD ld.elf_so'
-  ;;
-
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
@@ -14178,7 +14451,7 @@ lt_prog_compiler_static_CXX=
 	    ;;
 	esac
 	;;
-      netbsd* | netbsdelf*-gnu)
+      netbsd*)
 	;;
       *qnx* | *nto*)
         # QNX uses GNU C++, but need to define -shared option too, otherwise
@@ -14549,9 +14822,6 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
       ;;
     esac
     ;;
-  linux* | k*bsd*-gnu | gnu*)
-    link_all_deplibs_CXX=no
-    ;;
   *)
     export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
     ;;
@@ -15162,10 +15432,14 @@ fi
   # before this can be enabled.
   hardcode_into_libs=yes
 
+  # Add ABI-specific directories to the system library path.
+  sys_lib_dlsearch_path_spec="/lib64 /usr/lib64 /lib /usr/lib"
+
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+    sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec $lt_ld_extra"
+
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -15177,18 +15451,6 @@ fi
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
-netbsdelf*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='NetBSD ld.elf_so'
-  ;;
-
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
@@ -15534,8 +15796,8 @@ else
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -15568,16 +15830,16 @@ else
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -15586,8 +15848,8 @@ else
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -15595,7 +15857,7 @@ else
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -16019,7 +16281,7 @@ fi
 
 for ac_header in asm/ptrace_offsets.h endian.h sys/endian.h execinfo.h \
 		ia64intrin.h sys/uc_access.h unistd.h signal.h sys/types.h \
-		sys/procfs.h sys/ptrace.h byteswap.h
+		sys/procfs.h sys/ptrace.h byteswap.h elf.h sys/elf.h link.h sys/link.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
@@ -16044,11 +16306,11 @@ else
 int
 main ()
 {
-/* FIXME: Include the comments suggested by Paul. */
+
 #ifndef __cplusplus
-  /* Ultrix mips cc rejects this.  */
+  /* Ultrix mips cc rejects this sort of thing.  */
   typedef int charset[2];
-  const charset cs;
+  const charset cs = { 0, 0 };
   /* SunOS 4.1.1 cc rejects this.  */
   char const *const *pcpcc;
   char **ppc;
@@ -16065,8 +16327,9 @@ main ()
   ++pcpcc;
   ppc = (char**) pcpcc;
   pcpcc = (char const *const *) ppc;
-  { /* SCO 3.2v4 cc rejects this.  */
-    char *t;
+  { /* SCO 3.2v4 cc rejects this sort of thing.  */
+    char tx;
+    char *t = &tx;
     char const *s = 0 ? (char *) 0 : (char const *) 0;
 
     *t++ = 0;
@@ -16082,10 +16345,10 @@ main ()
     iptr p = 0;
     ++p;
   }
-  { /* AIX XL C 1.02.0.0 rejects this saying
+  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
        "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
-    struct s { int j; const int *ap[3]; };
-    struct s *b; b->j = 5;
+    struct s { int j; const int *ap[3]; } bx;
+    struct s *b = &bx; b->j = 5;
   }
   { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
     const int foo = 10;
@@ -16275,6 +16538,22 @@ fi
 cat >>confdefs.h <<_ACEOF
 #define HAVE_DECL_PTRACE_POKEDATA $ac_have_decl
 _ACEOF
+ac_fn_c_check_decl "$LINENO" "PTRACE_SETREGSET" "ac_cv_have_decl_PTRACE_SETREGSET" "$ac_includes_default
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#include <sys/ptrace.h>
+
+"
+if test "x$ac_cv_have_decl_PTRACE_SETREGSET" = xyes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_PTRACE_SETREGSET $ac_have_decl
+_ACEOF
 ac_fn_c_check_decl "$LINENO" "PTRACE_TRACEME" "ac_cv_have_decl_PTRACE_TRACEME" "$ac_includes_default
 #if HAVE_SYS_TYPES_H
 #include <sys/types.h>
@@ -16512,6 +16791,8 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
     case $build_cpu in #(
+  aarch64*) :
+    build_arch=aarch64 ;; #(
   arm*) :
     build_arch=arm ;; #(
   i?86) :
@@ -16526,12 +16807,16 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     build_arch=sh ;; #(
   amd64) :
     build_arch=x86_64 ;; #(
+  tile*) :
+    build_arch=tilegx ;; #(
   *) :
     build_arch=$build_cpu ;;
 esac
 
 
     case $host_cpu in #(
+  aarch64*) :
+    host_arch=aarch64 ;; #(
   arm*) :
     host_arch=arm ;; #(
   i?86) :
@@ -16546,12 +16831,16 @@ esac
     host_arch=sh ;; #(
   amd64) :
     host_arch=x86_64 ;; #(
+  tile*) :
+    host_arch=tilegx ;; #(
   *) :
     host_arch=$host_cpu ;;
 esac
 
 
     case $target_cpu in #(
+  aarch64*) :
+    target_arch=aarch64 ;; #(
   arm*) :
     target_arch=arm ;; #(
   i?86) :
@@ -16566,17 +16855,35 @@ esac
     target_arch=sh ;; #(
   amd64) :
     target_arch=x86_64 ;; #(
+  tile*) :
+    target_arch=tilegx ;; #(
   *) :
     target_arch=$target_cpu ;;
 esac
 
 
+# Check for Android
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Android" >&5
+$as_echo_n "checking for Android... " >&6; }
+android="no"
+case "$host_os" in
+  *android*)
+    android="yes"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    ;;
+  *)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+esac
+
 # Check whether --enable-coredump was given.
 if test "${enable_coredump+set}" = set; then :
   enableval=$enable_coredump;
 else
   case $host_arch in #(
-  arm*|mips*|sh*|x86*) :
+  aarch64*|arm*|mips*|sh*|x86*|tile*) :
     enable_coredump=yes ;; #(
   *) :
     enable_coredump=no ;;
@@ -16590,6 +16897,61 @@ $as_echo_n "checking if we should build libunwind-coredump... " >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_coredump" >&5
 $as_echo "$enable_coredump" >&6; }
 
+# Check whether --enable-ptrace was given.
+if test "${enable_ptrace+set}" = set; then :
+  enableval=$enable_ptrace;
+else
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/ptrace.h" "ac_cv_header_sys_ptrace_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_ptrace_h" = xyes; then :
+  enable_ptrace=yes
+else
+  enable_ptrace=no
+fi
+
+
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we should build libunwind-ptrace" >&5
+$as_echo_n "checking if we should build libunwind-ptrace... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_ptrace" >&5
+$as_echo "$enable_ptrace" >&6; }
+
+# Check whether --enable-setjmp was given.
+if test "${enable_setjmp+set}" = set; then :
+  enableval=$enable_setjmp;
+else
+  if test x$target_arch == x$host_arch; then :
+  enable_setjmp=yes
+else
+  enable_setjmp=no
+fi
+
+fi
+
+
+# Check whether --enable-documentation was given.
+if test "${enable_documentation+set}" = set; then :
+  enableval=$enable_documentation;
+else
+  enable_documentation=yes
+fi
+
+
+# Check whether --enable-tests was given.
+if test "${enable_tests+set}" = set; then :
+  enableval=$enable_tests;
+else
+  enable_tests=yes
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we should build libunwind-setjmp" >&5
+$as_echo_n "checking if we should build libunwind-setjmp... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_setjmp" >&5
+$as_echo "$enable_setjmp" >&6; }
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for build architecture" >&5
 $as_echo_n "checking for build architecture... " >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $build_arch" >&5
@@ -16615,6 +16977,30 @@ else
   BUILD_COREDUMP_FALSE=
 fi
 
+ if test x$enable_ptrace = xyes; then
+  BUILD_PTRACE_TRUE=
+  BUILD_PTRACE_FALSE='#'
+else
+  BUILD_PTRACE_TRUE='#'
+  BUILD_PTRACE_FALSE=
+fi
+
+ if test x$enable_setjmp = xyes; then
+  BUILD_SETJMP_TRUE=
+  BUILD_SETJMP_FALSE='#'
+else
+  BUILD_SETJMP_TRUE='#'
+  BUILD_SETJMP_FALSE=
+fi
+
+ if test x$build_arch != x$host_arch; then
+  NO_PTRACE_TEST_TRUE=
+  NO_PTRACE_TEST_FALSE='#'
+else
+  NO_PTRACE_TEST_TRUE='#'
+  NO_PTRACE_TEST_FALSE=
+fi
+
  if test x$target_arch != x$host_arch; then
   REMOTE_ONLY_TRUE=
   REMOTE_ONLY_FALSE='#'
@@ -16623,6 +17009,14 @@ else
   REMOTE_ONLY_FALSE=
 fi
 
+ if test x$target_arch = xaarch64; then
+  ARCH_AARCH64_TRUE=
+  ARCH_AARCH64_FALSE='#'
+else
+  ARCH_AARCH64_TRUE='#'
+  ARCH_AARCH64_FALSE=
+fi
+
  if test x$target_arch = xarm; then
   ARCH_ARM_TRUE=
   ARCH_ARM_FALSE='#'
@@ -16695,6 +17089,22 @@ else
   ARCH_SH_FALSE=
 fi
 
+ if test x$target_arch = xtilegx; then
+  ARCH_TILEGX_TRUE=
+  ARCH_TILEGX_FALSE='#'
+else
+  ARCH_TILEGX_TRUE='#'
+  ARCH_TILEGX_FALSE=
+fi
+
+ if test x$target_arch = xs390x; then
+  ARCH_S390X_TRUE=
+  ARCH_S390X_FALSE='#'
+else
+  ARCH_S390X_TRUE='#'
+  ARCH_S390X_FALSE=
+fi
+
  if expr x$target_os : xlinux >/dev/null; then
   OS_LINUX_TRUE=
   OS_LINUX_FALSE='#'
@@ -16719,13 +17129,21 @@ else
   OS_FREEBSD_FALSE=
 fi
 
+ if expr x$target_os : xnto-qnx >/dev/null; then
+  OS_QNX_TRUE=
+  OS_QNX_FALSE='#'
+else
+  OS_QNX_TRUE='#'
+  OS_QNX_FALSE=
+fi
+
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ELF helper width" >&5
 $as_echo_n "checking for ELF helper width... " >&6; }
 case "${target_arch}" in
 (arm|hppa|ppc32|x86|sh) use_elf32=yes; { $as_echo "$as_me:${as_lineno-$LINENO}: result: 32" >&5
 $as_echo "32" >&6; };;
-(ia64|ppc64|x86_64)    use_elf64=yes; { $as_echo "$as_me:${as_lineno-$LINENO}: result: 64" >&5
+(aarch64|ia64|ppc64|x86_64|s390x|tilegx)  use_elf64=yes; { $as_echo "$as_me:${as_lineno-$LINENO}: result: 64" >&5
 $as_echo "64" >&6; };;
 (mips)                 use_elfxx=yes; { $as_echo "$as_me:${as_lineno-$LINENO}: result: xx" >&5
 $as_echo "xx" >&6; };;
@@ -16817,8 +17235,10 @@ else
 # C++ exception handling doesn't work too well on x86
 case $target_arch in
   x86*) enable_cxx_exceptions=no;;
+  aarch64*) enable_cxx_exceptions=no;;
   arm*) enable_cxx_exceptions=no;;
   mips*) enable_cxx_exceptions=no;;
+  tile*) enable_cxx_exceptions=no;;
   *) enable_cxx_exceptions=yes;;
 esac
 
@@ -16845,6 +17265,7 @@ else
 
 case "${target_arch}" in
   (arm) enable_debug_frame=yes;;
+  (aarch64) enable_debug_frame=yes;;
   (*)   enable_debug_frame=no;;
 esac
 fi
@@ -16906,6 +17327,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_msabi_support" >&5
 $as_echo "$enable_msabi_support" >&6; }
 
+LIBLZMA=
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to support LZMA-compressed symbol tables" >&5
 $as_echo_n "checking whether to support LZMA-compressed symbol tables... " >&6; }
 # Check whether --enable-minidebuginfo was given.
@@ -16955,8 +17377,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lzma_lzma_mf_is_supported" >&5
 $as_echo "$ac_cv_lib_lzma_lzma_mf_is_supported" >&6; }
 if test "x$ac_cv_lib_lzma_lzma_mf_is_supported" = xyes; then :
-  LIBLZMA=-lzma
-
+  LIBLZMA=-llzma
 
 $as_echo "#define HAVE_LZMA 1" >>confdefs.h
 
@@ -16971,6 +17392,7 @@ See \`config.log' for more details" "$LINENO" 5; }
 fi
 
 fi
+
  if test x$enable_minidebuginfo = xyes; then
   HAVE_LZMA_TRUE=
   HAVE_LZMA_FALSE='#'
@@ -16980,7 +17402,18 @@ else
 fi
 
 
-if test "x$enable___thread" != xno; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to support UNW_CACHE_PER_THREAD" >&5
+$as_echo_n "checking whether to support UNW_CACHE_PER_THREAD... " >&6; }
+# Check whether --enable-per-thread-cache was given.
+if test "${enable_per_thread_cache+set}" = set; then :
+  enableval=$enable_per_thread_cache;
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_per_thread_cache" >&5
+$as_echo "$enable_per_thread_cache" >&6; }
+if test x$enable_per_thread_cache = xyes; then :
+
+  if test "x$enable___thread" != xno; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __thread" >&5
 $as_echo_n "checking for __thread... " >&6; }
 if ${libc_cv_gcc___thread+:} false; then :
@@ -17011,6 +17444,16 @@ $as_echo "#define HAVE___THREAD 1" >>confdefs.h
 else
   libc_cv_gcc___thread=no
 fi
+  if test x$libc_cv_gcc___thread = xno; then :
+
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "UNW_CACHE_PER_THREAD requires __thread
+See \`config.log' for more details" "$LINENO" 5; }
+
+fi
+
+fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Intel compiler" >&5
 $as_echo_n "checking for Intel compiler... " >&6; }
@@ -17036,11 +17479,21 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 if test x$GCC = xyes -a x$intel_compiler != xyes; then
   CFLAGS="${CFLAGS} -fexceptions -Wall -Wsign-compare"
-  LIBCRTS="-lgcc"
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $intel_compiler" >&5
 $as_echo "$intel_compiler" >&6; }
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for QCC compiler" >&5
+$as_echo_n "checking for QCC compiler... " >&6; }
+case $CC in #(
+  qcc*|QCC*) :
+    qcc_compiler=yes ;; #(
+  *) :
+    qcc_compiler=no ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $qcc_compiler" >&5
+$as_echo "$qcc_compiler" >&6; }
+
 if test x$intel_compiler = xyes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linker supports -static-libcxa" >&5
 $as_echo_n "checking if linker supports -static-libcxa... " >&6; }
@@ -17072,6 +17525,16 @@ rm -f core conftest.err conftest.$ac_objext \
 $as_echo "$have_static_libcxa" >&6; }
 fi
 
+if test x$qcc_compiler = xyes; then
+    LDFLAGS_NOSTARTFILES="-XCClinker -Wc,-nostartfiles"
+else
+    LDFLAGS_NOSTARTFILES="-XCClinker -nostartfiles"
+fi
+
+if test x$GCC = xyes -a x$intel_compiler != xyes -a x$qcc_compiler != xyes -a x$android != xyes; then
+  LIBCRTS="-lgcc_s"
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __builtin___clear_cache" >&5
 $as_echo_n "checking for __builtin___clear_cache... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -17100,6 +17563,34 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have__builtin___clear_cache" >&5
 $as_echo "$have__builtin___clear_cache" >&6; }
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for __builtin_unreachable" >&5
+$as_echo_n "checking for __builtin_unreachable... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+__builtin_unreachable()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  have__builtin_unreachable=yes
+else
+  have__builtin_unreachable=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test x$have__builtin_unreachable = xyes; then
+
+$as_echo "#define HAVE__BUILTIN_UNREACHABLE 1" >>confdefs.h
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $have__builtin_unreachable" >&5
+$as_echo "$have__builtin_unreachable" >&6; }
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __sync atomics" >&5
 $as_echo_n "checking for __sync atomics... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -17137,8 +17628,8 @@ arch="$target_arch"
 ARCH=`echo $target_arch | tr a-z A-Z`
 
 PKG_MAJOR=1
-PKG_MINOR=1
-PKG_EXTRA=
+PKG_MINOR=4
+PKG_EXTRA=-rc1
 PKG_MAINTAINER=libunwind-devel@nongnu.org
 
 old_LIBS="$LIBS"
@@ -17200,6 +17691,12 @@ if test "$ac_res" != no; then :
 fi
 
 LIBS="$old_LIBS"
+case "$ac_cv_search_backtrace" in
+  -l*) BACKTRACELIB=$ac_cv_search_backtrace;;
+  *) BACKTRACELIB="";;
+esac
+
+
 
 
 
@@ -17215,7 +17712,80 @@ LIBS="$old_LIBS"
 
 
 
-ac_config_files="$ac_config_files Makefile src/Makefile tests/Makefile tests/check-namespace.sh doc/Makefile doc/common.tex include/libunwind-common.h include/libunwind.h include/tdep/libunwind_i.h"
+
+# Extract the first word of "latex2man", so it can be a program name with args.
+set dummy latex2man; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_LATEX2MAN+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $LATEX2MAN in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_LATEX2MAN="$LATEX2MAN" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_LATEX2MAN="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+LATEX2MAN=$ac_cv_path_LATEX2MAN
+if test -n "$LATEX2MAN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LATEX2MAN" >&5
+$as_echo "$LATEX2MAN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+if test "x$LATEX2MAN" = "x"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: latex2man not found. Install latex2man. Disabling docs." >&5
+$as_echo "$as_me: WARNING: latex2man not found. Install latex2man. Disabling docs." >&2;}
+  enable_documentation="no";
+fi
+
+ if test x$enable_documentation = xyes; then
+  CONFIG_DOCS_TRUE=
+  CONFIG_DOCS_FALSE='#'
+else
+  CONFIG_DOCS_TRUE='#'
+  CONFIG_DOCS_FALSE=
+fi
+
+if test "x$enable_documentation" = "xyes"; then
+  ac_config_files="$ac_config_files doc/Makefile doc/common.tex"
+
+fi
+
+ if test x$enable_tests = xyes; then
+  CONFIG_TESTS_TRUE=
+  CONFIG_TESTS_FALSE='#'
+else
+  CONFIG_TESTS_TRUE='#'
+  CONFIG_TESTS_FALSE=
+fi
+
+if test "x$enable_tests" = "xyes"; then
+  ac_config_files="$ac_config_files tests/Makefile tests/check-namespace.sh"
+
+fi
+
+ac_config_files="$ac_config_files Makefile src/Makefile include/libunwind-common.h include/libunwind.h include/tdep/libunwind_i.h"
 
 ac_config_files="$ac_config_files src/unwind/libunwind.pc src/coredump/libunwind-coredump.pc src/ptrace/libunwind-ptrace.pc src/setjmp/libunwind-setjmp.pc src/libunwind-generic.pc"
 
@@ -17328,6 +17898,14 @@ LIBOBJS=$ac_libobjs
 LTLIBOBJS=$ac_ltlibobjs
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
+$as_echo_n "checking that generated files are newer than configure... " >&6; }
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
+$as_echo "done" >&6; }
  if test -n "$EXEEXT"; then
   am__EXEEXT_TRUE=
   am__EXEEXT_FALSE='#'
@@ -17364,10 +17942,26 @@ if test -z "${BUILD_COREDUMP_TRUE}" && test -z "${BUILD_COREDUMP_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_COREDUMP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${BUILD_PTRACE_TRUE}" && test -z "${BUILD_PTRACE_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PTRACE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${BUILD_SETJMP_TRUE}" && test -z "${BUILD_SETJMP_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_SETJMP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${NO_PTRACE_TEST_TRUE}" && test -z "${NO_PTRACE_TEST_FALSE}"; then
+  as_fn_error $? "conditional \"NO_PTRACE_TEST\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${REMOTE_ONLY_TRUE}" && test -z "${REMOTE_ONLY_FALSE}"; then
   as_fn_error $? "conditional \"REMOTE_ONLY\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${ARCH_AARCH64_TRUE}" && test -z "${ARCH_AARCH64_FALSE}"; then
+  as_fn_error $? "conditional \"ARCH_AARCH64\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${ARCH_ARM_TRUE}" && test -z "${ARCH_ARM_FALSE}"; then
   as_fn_error $? "conditional \"ARCH_ARM\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -17404,6 +17998,14 @@ if test -z "${ARCH_SH_TRUE}" && test -z "${ARCH_SH_FALSE}"; then
   as_fn_error $? "conditional \"ARCH_SH\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${ARCH_TILEGX_TRUE}" && test -z "${ARCH_TILEGX_FALSE}"; then
+  as_fn_error $? "conditional \"ARCH_TILEGX\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${ARCH_S390X_TRUE}" && test -z "${ARCH_S390X_FALSE}"; then
+  as_fn_error $? "conditional \"ARCH_S390X\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${OS_LINUX_TRUE}" && test -z "${OS_LINUX_FALSE}"; then
   as_fn_error $? "conditional \"OS_LINUX\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -17416,6 +18018,10 @@ if test -z "${OS_FREEBSD_TRUE}" && test -z "${OS_FREEBSD_FALSE}"; then
   as_fn_error $? "conditional \"OS_FREEBSD\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${OS_QNX_TRUE}" && test -z "${OS_QNX_FALSE}"; then
+  as_fn_error $? "conditional \"OS_QNX\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${USE_ELF32_TRUE}" && test -z "${USE_ELF32_FALSE}"; then
   as_fn_error $? "conditional \"USE_ELF32\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -17440,6 +18046,14 @@ if test -z "${HAVE_LZMA_TRUE}" && test -z "${HAVE_LZMA_FALSE}"; then
   as_fn_error $? "conditional \"HAVE_LZMA\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${CONFIG_DOCS_TRUE}" && test -z "${CONFIG_DOCS_FALSE}"; then
+  as_fn_error $? "conditional \"CONFIG_DOCS\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${CONFIG_TESTS_TRUE}" && test -z "${CONFIG_TESTS_FALSE}"; then
+  as_fn_error $? "conditional \"CONFIG_TESTS\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 
 : "${CONFIG_STATUS=./config.status}"
 ac_write_fail=0
@@ -17738,16 +18352,16 @@ if (echo >conf$$.file) 2>/dev/null; then
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -17807,28 +18421,16 @@ else
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -17849,8 +18451,8 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by libunwind $as_me 1.1, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+This file was extended by libunwind $as_me 1.4-rc1, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -17915,11 +18517,11 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-libunwind config.status 1.1
-configured by $0, generated by GNU Autoconf 2.68,
+libunwind config.status 1.4-rc1
+configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -18010,7 +18612,7 @@ fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
   \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
@@ -18422,12 +19024,12 @@ do
     "include/config.h") CONFIG_HEADERS="$CONFIG_HEADERS include/config.h" ;;
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-    "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
-    "tests/Makefile") CONFIG_FILES="$CONFIG_FILES tests/Makefile" ;;
-    "tests/check-namespace.sh") CONFIG_FILES="$CONFIG_FILES tests/check-namespace.sh" ;;
     "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
     "doc/common.tex") CONFIG_FILES="$CONFIG_FILES doc/common.tex" ;;
+    "tests/Makefile") CONFIG_FILES="$CONFIG_FILES tests/Makefile" ;;
+    "tests/check-namespace.sh") CONFIG_FILES="$CONFIG_FILES tests/check-namespace.sh" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
     "include/libunwind-common.h") CONFIG_FILES="$CONFIG_FILES include/libunwind-common.h" ;;
     "include/libunwind.h") CONFIG_FILES="$CONFIG_FILES include/libunwind.h" ;;
     "include/tdep/libunwind_i.h") CONFIG_FILES="$CONFIG_FILES include/tdep/libunwind_i.h" ;;
@@ -19032,7 +19634,7 @@ $as_echo "$as_me: executing $ac_file commands" >&6;}
 
   case $ac_file$ac_mode in
     "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # Older Autoconf quotes --file arguments for eval, but not when files
   # are listed without --file.  Let's play safe and only enable the eval
   # if we detect the quoting.
   case $CONFIG_FILES in
@@ -19045,7 +19647,7 @@ $as_echo "$as_me: executing $ac_file commands" >&6;}
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -19079,21 +19681,19 @@ $as_echo X"$mf" |
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
+    test -z "$am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`$as_dirname -- "$file" ||
diff --git a/configure.ac b/configure.ac
index cffe19b..dfe4014 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,6 +1,6 @@
 define(pkg_major, 1)
-define(pkg_minor, 1)
-define(pkg_extra, )
+define(pkg_minor, 4)
+define(pkg_extra, -rc1)
 define(pkg_maintainer, libunwind-devel@nongnu.org)
 define(mkvers, $1.$2$3)
 dnl Process this file with autoconf to produce a configure script.
@@ -17,6 +17,7 @@ AC_PROG_CC
 AC_PROG_CXX
 AC_PROG_INSTALL
 AC_PROG_MAKE_SET
+m4_ifdef([AM_PROG_AR], [AM_PROG_AR])
 LT_INIT
 AM_PROG_AS
 AM_PROG_CC_C_O
@@ -37,7 +38,7 @@ dnl Checks for header files.
 AC_HEADER_STDC
 AC_CHECK_HEADERS(asm/ptrace_offsets.h endian.h sys/endian.h execinfo.h \
 		ia64intrin.h sys/uc_access.h unistd.h signal.h sys/types.h \
-		sys/procfs.h sys/ptrace.h byteswap.h)
+		sys/procfs.h sys/ptrace.h byteswap.h elf.h sys/elf.h link.h sys/link.h)
 
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_C_CONST
@@ -55,7 +56,7 @@ AC_CHECK_TYPES([struct elf_prstatus, struct prstatus], [], [],
 #endif
 ])
 
-AC_CHECK_DECLS([PTRACE_POKEUSER, PTRACE_POKEDATA,
+AC_CHECK_DECLS([PTRACE_POKEUSER, PTRACE_POKEDATA, PTRACE_SETREGSET,
 PTRACE_TRACEME, PTRACE_CONT, PTRACE_SINGLESTEP,
 PTRACE_SYSCALL, PT_IO, PT_GETREGS,
 PT_GETFPREGS, PT_CONTINUE, PT_TRACE_ME,
@@ -88,6 +89,7 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
 
 AC_DEFUN([SET_ARCH],[
     AS_CASE([$1],
+        [aarch64*],[$2=aarch64],
         [arm*],[$2=arm],
         [i?86],[$2=x86],
         [hppa*],[$2=hppa],
@@ -95,6 +97,7 @@ AC_DEFUN([SET_ARCH],[
         [powerpc*],[$2=ppc$ppc_bits],
         [sh*],[$2=sh],
         [amd64],[$2=x86_64],
+        [tile*],[$2=tilegx],
         [$2=$1])
 ]) dnl SET_ARCH
 
@@ -102,14 +105,51 @@ SET_ARCH([$build_cpu],[build_arch])
 SET_ARCH([$host_cpu],[host_arch])
 SET_ARCH([$target_cpu],[target_arch])
 
+# Check for Android
+AC_MSG_CHECKING([for Android])
+android="no"
+case "$host_os" in
+  *android*)
+    android="yes"
+    AC_MSG_RESULT([yes])
+    ;;
+  *)
+    AC_MSG_RESULT([no])
+    ;;
+esac
+
 AC_ARG_ENABLE(coredump,
 	AS_HELP_STRING([--enable-coredump],[building libunwind-coredump library]),,
-        [AS_CASE([$host_arch], [arm*|mips*|sh*|x86*], [enable_coredump=yes], [enable_coredump=no])]
+        [AS_CASE([$host_arch], [aarch64*|arm*|mips*|sh*|x86*|tile*], [enable_coredump=yes], [enable_coredump=no])]
 )
 
 AC_MSG_CHECKING([if we should build libunwind-coredump])
 AC_MSG_RESULT([$enable_coredump])
 
+AC_ARG_ENABLE(ptrace,
+	AS_HELP_STRING([--enable-ptrace],[building libunwind-ptrace library]),,
+        [AC_CHECK_HEADER([sys/ptrace.h], [enable_ptrace=yes], [enable_ptrace=no])]
+)
+
+AC_MSG_CHECKING([if we should build libunwind-ptrace])
+AC_MSG_RESULT([$enable_ptrace])
+
+AC_ARG_ENABLE(setjmp,
+	AS_HELP_STRING([--enable-setjmp],[building libunwind-setjmp library]),,
+        [AS_IF([test x$target_arch == x$host_arch], [enable_setjmp=yes], [enable_setjmp=no])]
+)
+
+AC_ARG_ENABLE(documentation,
+	AS_HELP_STRING([--disable-documentation],[Disable generating the man pages]),,
+	[enable_documentation=yes])
+
+AC_ARG_ENABLE(tests,
+ AS_HELP_STRING([--disable-tests],[Disable tests build]),,
+ [enable_tests=yes])
+
+AC_MSG_CHECKING([if we should build libunwind-setjmp])
+AC_MSG_RESULT([$enable_setjmp])
+
 AC_MSG_CHECKING([for build architecture])
 AC_MSG_RESULT([$build_arch])
 AC_MSG_CHECKING([for host architecture])
@@ -120,7 +160,11 @@ AC_MSG_CHECKING([for target operating system])
 AC_MSG_RESULT([$target_os])
 
 AM_CONDITIONAL(BUILD_COREDUMP, test x$enable_coredump = xyes)
+AM_CONDITIONAL(BUILD_PTRACE, test x$enable_ptrace = xyes)
+AM_CONDITIONAL(BUILD_SETJMP, test x$enable_setjmp = xyes)
+AM_CONDITIONAL(NO_PTRACE_TEST, test x$build_arch != x$host_arch)
 AM_CONDITIONAL(REMOTE_ONLY, test x$target_arch != x$host_arch)
+AM_CONDITIONAL(ARCH_AARCH64, test x$target_arch = xaarch64)
 AM_CONDITIONAL(ARCH_ARM, test x$target_arch = xarm)
 AM_CONDITIONAL(ARCH_IA64, test x$target_arch = xia64)
 AM_CONDITIONAL(ARCH_HPPA, test x$target_arch = xhppa)
@@ -130,14 +174,17 @@ AM_CONDITIONAL(ARCH_X86_64, test x$target_arch = xx86_64)
 AM_CONDITIONAL(ARCH_PPC32, test x$target_arch = xppc32)
 AM_CONDITIONAL(ARCH_PPC64, test x$target_arch = xppc64)
 AM_CONDITIONAL(ARCH_SH, test x$target_arch = xsh)
+AM_CONDITIONAL(ARCH_TILEGX, test x$target_arch = xtilegx)
+AM_CONDITIONAL(ARCH_S390X, test x$target_arch = xs390x)
 AM_CONDITIONAL(OS_LINUX, expr x$target_os : xlinux >/dev/null)
 AM_CONDITIONAL(OS_HPUX, expr x$target_os : xhpux >/dev/null)
 AM_CONDITIONAL(OS_FREEBSD, expr x$target_os : xfreebsd >/dev/null)
+AM_CONDITIONAL(OS_QNX, expr x$target_os : xnto-qnx >/dev/null)
 
 AC_MSG_CHECKING([for ELF helper width])
 case "${target_arch}" in
 (arm|hppa|ppc32|x86|sh) use_elf32=yes; AC_MSG_RESULT([32]);;
-(ia64|ppc64|x86_64)    use_elf64=yes; AC_MSG_RESULT([64]);;
+(aarch64|ia64|ppc64|x86_64|s390x|tilegx)  use_elf64=yes; AC_MSG_RESULT([64]);;
 (mips)                 use_elfxx=yes; AC_MSG_RESULT([xx]);;
 *)                     AC_MSG_ERROR([Unknown ELF target: ${target_arch}])
 esac
@@ -186,8 +233,10 @@ AS_HELP_STRING([--enable-cxx-exceptions],[use libunwind to handle C++ exceptions
 # C++ exception handling doesn't work too well on x86
 case $target_arch in
   x86*) enable_cxx_exceptions=no;;
+  aarch64*) enable_cxx_exceptions=no;;
   arm*) enable_cxx_exceptions=no;;
   mips*) enable_cxx_exceptions=no;;
+  tile*) enable_cxx_exceptions=no;;
   *) enable_cxx_exceptions=yes;;
 esac
 ])
@@ -200,6 +249,7 @@ AC_ARG_ENABLE(debug_frame,
 AS_HELP_STRING([--enable-debug-frame],[Load the ".debug_frame" section if available]),, [
 case "${target_arch}" in
   (arm) enable_debug_frame=yes;;
+  (aarch64) enable_debug_frame=yes;;
   (*)   enable_debug_frame=no;;
 esac])
 if test x$enable_debug_frame = xyes; then
@@ -234,22 +284,33 @@ if test x$enable_msabi_support = xyes; then
 fi
 AC_MSG_RESULT([$enable_msabi_support])
 
+LIBLZMA=
 AC_MSG_CHECKING([whether to support LZMA-compressed symbol tables])
 AC_ARG_ENABLE(minidebuginfo,
 AS_HELP_STRING([--enable-minidebuginfo], [Enables support for LZMA-compressed symbol tables]),, [enable_minidebuginfo=auto])
 AC_MSG_RESULT([$enable_minidebuginfo])
 if test x$enable_minidebuginfo != xno; then
    AC_CHECK_LIB([lzma], [lzma_mf_is_supported],
-   [AC_SUBST([LIBLZMA], [-lzma])
+   [LIBLZMA=-llzma
     AC_DEFINE([HAVE_LZMA], [1], [Define if you have liblzma])
     enable_minidebuginfo=yes],
    [if test x$enable_minidebuginfo = xyes; then
       AC_MSG_FAILURE([liblzma not found])
     fi])
 fi
+AC_SUBST([LIBLZMA])
 AM_CONDITIONAL(HAVE_LZMA, test x$enable_minidebuginfo = xyes)
 
-LIBUNWIND___THREAD
+AC_MSG_CHECKING([whether to support UNW_CACHE_PER_THREAD])
+AC_ARG_ENABLE([per-thread-cache],
+AS_HELP_STRING([--enable-per-thread-cache], [build with support for UNW_CACHE_PER_THREAD (which imposes a hight TLS memory usage) (default: disabled)]))
+AC_MSG_RESULT([$enable_per_thread_cache])
+AS_IF([test x$enable_per_thread_cache = xyes], [
+  LIBUNWIND___THREAD
+  AS_IF([test x$libc_cv_gcc___thread = xno], [
+    AC_MSG_FAILURE([UNW_CACHE_PER_THREAD requires __thread])
+  ])
+])
 
 AC_MSG_CHECKING([for Intel compiler])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[#ifndef __INTEL_COMPILER
@@ -258,10 +319,13 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[#ifndef __INTEL_COMPILER
 
 if test x$GCC = xyes -a x$intel_compiler != xyes; then
   CFLAGS="${CFLAGS} -fexceptions -Wall -Wsign-compare"
-  LIBCRTS="-lgcc"
 fi
 AC_MSG_RESULT([$intel_compiler])
 
+AC_MSG_CHECKING([for QCC compiler])
+AS_CASE([$CC], [qcc*|QCC*], [qcc_compiler=yes], [qcc_compiler=no])
+AC_MSG_RESULT([$qcc_compiler])
+
 if test x$intel_compiler = xyes; then
   AC_MSG_CHECKING([if linker supports -static-libcxa])
   save_LDFLAGS="$LDFLAGS"
@@ -274,6 +338,16 @@ if test x$intel_compiler = xyes; then
   AC_MSG_RESULT([$have_static_libcxa])
 fi
 
+if test x$qcc_compiler = xyes; then
+    LDFLAGS_NOSTARTFILES="-XCClinker -Wc,-nostartfiles"
+else
+    LDFLAGS_NOSTARTFILES="-XCClinker -nostartfiles"
+fi
+
+if test x$GCC = xyes -a x$intel_compiler != xyes -a x$qcc_compiler != xyes -a x$android != xyes; then
+  LIBCRTS="-lgcc_s"
+fi
+
 AC_MSG_CHECKING([for __builtin___clear_cache])
 AC_LINK_IFELSE(
   [AC_LANG_PROGRAM([[]], [[__builtin___clear_cache(0, 0)]])],
@@ -285,6 +359,17 @@ if test x$have__builtin___clear_cache = xyes; then
 fi
 AC_MSG_RESULT([$have__builtin___clear_cache])
 
+AC_MSG_CHECKING([for __builtin_unreachable])
+AC_LINK_IFELSE(
+  [AC_LANG_PROGRAM([[]], [[__builtin_unreachable()]])],
+  [have__builtin_unreachable=yes],
+  [have__builtin_unreachable=no])
+if test x$have__builtin_unreachable = xyes; then
+  AC_DEFINE([HAVE__BUILTIN_UNREACHABLE], [1],
+            [Defined if __builtin_unreachable() is available])
+fi
+AC_MSG_RESULT([$have__builtin_unreachable])
+
 AC_MSG_CHECKING([for __sync atomics])
 AC_LINK_IFELSE(
   [AC_LANG_PROGRAM([[]], [[
@@ -314,12 +399,18 @@ old_LIBS="$LIBS"
 LIBS=""
 AC_SEARCH_LIBS(backtrace, execinfo)
 LIBS="$old_LIBS"
+case "$ac_cv_search_backtrace" in
+  -l*) BACKTRACELIB=$ac_cv_search_backtrace;;
+  *) BACKTRACELIB="";;
+esac
+
 
 AC_SUBST(build_arch)
 AC_SUBST(target_os)
 AC_SUBST(arch)
 AC_SUBST(ARCH)
 AC_SUBST(LDFLAGS_STATIC_LIBCXA)
+AC_SUBST(LDFLAGS_NOSTARTFILES)
 AC_SUBST(LIBCRTS)
 AC_SUBST(PKG_MAJOR)
 AC_SUBST(PKG_MINOR)
@@ -328,9 +419,26 @@ AC_SUBST(PKG_MAINTAINER)
 AC_SUBST(enable_cxx_exceptions)
 AC_SUBST(enable_debug_frame)
 AC_SUBST(DLLIB)
+AC_SUBST(BACKTRACELIB)
+
+AC_PATH_PROG([LATEX2MAN],[latex2man])
+if test "x$LATEX2MAN" = "x"; then
+  AC_MSG_WARN([latex2man not found. Install latex2man. Disabling docs.])
+  enable_documentation="no";
+fi
+
+AM_CONDITIONAL([CONFIG_DOCS], [test x$enable_documentation = xyes])
+if test "x$enable_documentation" = "xyes"; then
+  AC_CONFIG_FILES(doc/Makefile doc/common.tex)
+fi
+
+AM_CONDITIONAL([CONFIG_TESTS], [test x$enable_tests = xyes])
+if test "x$enable_tests" = "xyes"; then
+  AC_CONFIG_FILES(tests/Makefile tests/check-namespace.sh)
+fi
 
-AC_CONFIG_FILES(Makefile src/Makefile tests/Makefile tests/check-namespace.sh
-		doc/Makefile doc/common.tex include/libunwind-common.h
+AC_CONFIG_FILES(Makefile src/Makefile
+                include/libunwind-common.h
                 include/libunwind.h include/tdep/libunwind_i.h)
 AC_CONFIG_FILES(src/unwind/libunwind.pc src/coredump/libunwind-coredump.pc
                 src/ptrace/libunwind-ptrace.pc src/setjmp/libunwind-setjmp.pc
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 2534066..bfe4669 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,6 +1,7 @@
 # man pages that go into section 3:
 man3_MANS = libunwind.man libunwind-dynamic.man libunwind-ia64.man	\
 	libunwind-ptrace.man libunwind-setjmp.man			\
+	unw_apply_reg_state.man						\
 	unw_backtrace.man						\
 	unw_flush_cache.man						\
 	unw_get_accessors.man						\
@@ -11,12 +12,15 @@ man3_MANS = libunwind.man libunwind-dynamic.man libunwind-ia64.man	\
 	unw_get_reg.man							\
 	unw_getcontext.man						\
 	unw_init_local.man unw_init_remote.man				\
+	unw_init_local2.man						\
 	unw_is_fpreg.man						\
 	unw_is_signal_frame.man						\
 	unw_create_addr_space.man					\
 	unw_destroy_addr_space.man					\
 	unw_regname.man unw_resume.man					\
+	unw_reg_states_iterate.man					\
 	unw_set_caching_policy.man					\
+	unw_set_cache_size.man						\
 	unw_set_fpreg.man						\
 	unw_set_reg.man							\
 	unw_step.man							\
@@ -27,6 +31,7 @@ man3_MANS = libunwind.man libunwind-dynamic.man libunwind-ia64.man	\
 EXTRA_DIST = NOTES libunwind.trans					\
 	libunwind.tex libunwind-dynamic.tex libunwind-ia64.tex		\
 	libunwind-ptrace.tex libunwind-setjmp.tex			\
+	unw_apply_reg_state.tex						\
 	unw_backtrace.tex						\
 	unw_flush_cache.tex						\
 	unw_get_accessors.tex						\
@@ -41,6 +46,8 @@ EXTRA_DIST = NOTES libunwind.trans					\
 	unw_is_signal_frame.tex						\
 	unw_create_addr_space.tex unw_destroy_addr_space.tex		\
 	unw_regname.tex unw_resume.tex unw_set_caching_policy.tex	\
+	unw_reg_states_iterate.tex					\
+	unw_set_cache_size.tex						\
 	unw_set_fpreg.tex						\
 	unw_set_reg.tex							\
 	unw_step.tex							\
diff --git a/doc/Makefile.in b/doc/Makefile.in
index cddcb3b..e9080e9 100644
--- a/doc/Makefile.in
+++ b/doc/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.13.4 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +14,51 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,7 +79,7 @@ build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
 subdir = doc
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(srcdir)/common.tex.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
@@ -46,8 +90,25 @@ mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/config.h
 CONFIG_CLEAN_FILES = common.tex
 CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 SOURCES =
 DIST_SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -79,15 +140,18 @@ man3dir = $(mandir)/man3
 am__installdirs = "$(DESTDIR)$(man3dir)"
 NROFF = nroff
 MANS = $(man3_MANS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AR = @AR@
 ARCH = @ARCH@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BACKTRACELIB = @BACKTRACELIB@
 CC = @CC@
 CCAS = @CCAS@
 CCASDEPMODE = @CCASDEPMODE@
@@ -119,8 +183,10 @@ INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LATEX2MAN = @LATEX2MAN@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
+LDFLAGS_NOSTARTFILES = @LDFLAGS_NOSTARTFILES@
 LDFLAGS_STATIC_LIBCXA = @LDFLAGS_STATIC_LIBCXA@
 LIBCRTS = @LIBCRTS@
 LIBLZMA = @LIBLZMA@
@@ -223,6 +289,7 @@ top_srcdir = @top_srcdir@
 # man pages that go into section 3:
 man3_MANS = libunwind.man libunwind-dynamic.man libunwind-ia64.man	\
 	libunwind-ptrace.man libunwind-setjmp.man			\
+	unw_apply_reg_state.man						\
 	unw_backtrace.man						\
 	unw_flush_cache.man						\
 	unw_get_accessors.man						\
@@ -233,12 +300,15 @@ man3_MANS = libunwind.man libunwind-dynamic.man libunwind-ia64.man	\
 	unw_get_reg.man							\
 	unw_getcontext.man						\
 	unw_init_local.man unw_init_remote.man				\
+	unw_init_local2.man						\
 	unw_is_fpreg.man						\
 	unw_is_signal_frame.man						\
 	unw_create_addr_space.man					\
 	unw_destroy_addr_space.man					\
 	unw_regname.man unw_resume.man					\
+	unw_reg_states_iterate.man					\
 	unw_set_caching_policy.man					\
+	unw_set_cache_size.man						\
 	unw_set_fpreg.man						\
 	unw_set_reg.man							\
 	unw_step.man							\
@@ -249,6 +319,7 @@ man3_MANS = libunwind.man libunwind-dynamic.man libunwind-ia64.man	\
 EXTRA_DIST = NOTES libunwind.trans					\
 	libunwind.tex libunwind-dynamic.tex libunwind-ia64.tex		\
 	libunwind-ptrace.tex libunwind-setjmp.tex			\
+	unw_apply_reg_state.tex						\
 	unw_backtrace.tex						\
 	unw_flush_cache.tex						\
 	unw_get_accessors.tex						\
@@ -263,6 +334,8 @@ EXTRA_DIST = NOTES libunwind.trans					\
 	unw_is_signal_frame.tex						\
 	unw_create_addr_space.tex unw_destroy_addr_space.tex		\
 	unw_regname.tex unw_resume.tex unw_set_caching_policy.tex	\
+	unw_reg_states_iterate.tex					\
+	unw_set_cache_size.tex						\
 	unw_set_fpreg.tex						\
 	unw_set_reg.tex							\
 	unw_step.tex							\
@@ -320,9 +393,18 @@ clean-libtool:
 	-rm -rf .libs _libs
 install-man3: $(man3_MANS)
 	@$(NORMAL_INSTALL)
-	test -z "$(man3dir)" || $(MKDIR_P) "$(DESTDIR)$(man3dir)"
-	@list='$(man3_MANS)'; test -n "$(man3dir)" || exit 0; \
-	{ for i in $$list; do echo "$$i"; done; \
+	@list1='$(man3_MANS)'; \
+	list2=''; \
+	test -n "$(man3dir)" \
+	  && test -n "`echo $$list1$$list2`" \
+	  || exit 0; \
+	echo " $(MKDIR_P) '$(DESTDIR)$(man3dir)'"; \
+	$(MKDIR_P) "$(DESTDIR)$(man3dir)" || exit 1; \
+	{ for i in $$list1; do echo "$$i"; done;  \
+	if test -n "$$list2"; then \
+	  for i in $$list2; do echo "$$i"; done \
+	    | sed -n '/\.3[a-z]*$$/p'; \
+	fi; \
 	} | while read p; do \
 	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; echo "$$p"; \
@@ -350,27 +432,14 @@ uninstall-man3:
 	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^3][0-9a-z]*$$,3,;x' \
 	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
 	dir='$(DESTDIR)$(man3dir)'; $(am__uninstall_files_from_dir)
-tags: TAGS
-TAGS:
+tags TAGS:
+
+ctags CTAGS:
 
-ctags: CTAGS
-CTAGS:
+cscope cscopelist:
 
 
 distdir: $(DISTFILES)
-	@list='$(MANS)'; if test -n "$$list"; then \
-	  list=`for p in $$list; do \
-	    if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
-	    if test -f "$$d$$p"; then echo "$$d$$p"; else :; fi; done`; \
-	  if test -n "$$list" && \
-	    grep 'ab help2man is required to generate this page' $$list >/dev/null; then \
-	    echo "error: found man pages containing the \`missing help2man' replacement text:" >&2; \
-	    grep -l 'ab help2man is required to generate this page' $$list | sed 's/^/         /' >&2; \
-	    echo "       to fix them, install help2man, remove and regenerate the man pages;" >&2; \
-	    echo "       typically \`make maintainer-clean' will remove them" >&2; \
-	    exit 1; \
-	  else :; fi; \
-	else :; fi
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -505,16 +574,17 @@ uninstall-man: uninstall-man3
 .MAKE: install-am install-strip
 
 .PHONY: all all-am check check-am clean clean-generic clean-libtool \
-	distclean distclean-generic distclean-libtool distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-man3 \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	uninstall uninstall-am uninstall-man uninstall-man3
+	cscopelist-am ctags-am distclean distclean-generic \
+	distclean-libtool distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-man3 install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
+	ps ps-am tags-am uninstall uninstall-am uninstall-man \
+	uninstall-man3
 
 
 .tex.man:
diff --git a/doc/libunwind.man b/doc/libunwind.man
index c6046e2..02ab6b8 100644
--- a/doc/libunwind.man
+++ b/doc/libunwind.man
@@ -1,5 +1,5 @@
 '\" t
-.\" Manual page created with latex2man on Thu Aug 16 09:44:43 MDT 2007
+.\" Manual page created with latex2man on Thu Jan 12 06:50:29 PST 2017
 .\" NOTE: This file is generated, DO NOT EDIT.
 .de Vb
 .ft CW
@@ -10,7 +10,7 @@
 
 .fi
 ..
-.TH "LIBUNWIND" "3" "16 August 2007" "Programming Library " "Programming Library "
+.TH "LIBUNWIND" "3" "12 January 2017" "Programming Library " "Programming Library "
 .SH NAME
 libunwind
 \-\- a (mostly) platform\-independent unwind API 
@@ -82,6 +82,11 @@ int
 unw_set_caching_policy(unw_addr_space_t,
 unw_caching_policy_t);
 .br
+int
+unw_set_cache_size(unw_addr_space_t,
+size_t,
+int);
+.br
 .PP
 const char *unw_regname(unw_regnum_t);
 .br
@@ -428,7 +433,9 @@ UNW_CACHE_NONE,
 it is possible to turn off caching 
 completely, therefore eliminating the risk of stale data alltogether 
 (at the cost of slower execution). By default, caching is enabled for 
-local unwinding only. 
+local unwinding only. The cache size can be dynamically changed with 
+unw_set_cache_size(),
+which also fluches the current cache. 
 .PP
 .SH FILES
 
@@ -482,6 +489,7 @@ unw_is_signal_frame(3),
 unw_regname(3),
 unw_resume(3),
 unw_set_caching_policy(3),
+unw_set_cache_size(3),
 unw_set_fpreg(3),
 unw_set_reg(3),
 unw_step(3),
diff --git a/doc/libunwind.tex b/doc/libunwind.tex
index 534bd4d..6cbb476 100644
--- a/doc/libunwind.tex
+++ b/doc/libunwind.tex
@@ -43,6 +43,8 @@
 \Type{void} \Func{unw\_flush\_cache}(\Type{unw\_addr\_space\_t}, \Type{unw\_word\_t}, \Type{unw\_word\_t});\\
 \noindent
 \Type{int} \Func{unw\_set\_caching\_policy}(\Type{unw\_addr\_space\_t}, \Type{unw\_caching\_policy\_t});\\
+\noindent
+\Type{int} \Func{unw\_set\_cache\_size}(\Type{unw\_addr\_space\_t}, \Type{size\_t}, \Type{int});\\
 
 \noindent
 \Type{const char *}\Func{unw\_regname}(\Type{unw\_regnum\_t});\\
@@ -293,7 +295,8 @@ object.  In particular, by selecting the policy
 \Const{UNW\_CACHE\_NONE}, it is possible to turn off caching
 completely, therefore eliminating the risk of stale data alltogether
 (at the cost of slower execution).  By default, caching is enabled for
-local unwinding only.
+local unwinding only.  The cache size can be dynamically changed with
+\Func{unw\_set\_cache\_size}(), which also fluches the current cache.
 
 
 \section{Files}
@@ -337,6 +340,7 @@ local unwinding only.
 \SeeAlso{unw\_regname(3)},
 \SeeAlso{unw\_resume(3)},
 \SeeAlso{unw\_set\_caching\_policy(3)},
+\SeeAlso{unw\_set\_cache\_size(3)},
 \SeeAlso{unw\_set\_fpreg(3)},
 \SeeAlso{unw\_set\_reg(3)},
 \SeeAlso{unw\_step(3)},
diff --git a/doc/unw_apply_reg_state.man b/doc/unw_apply_reg_state.man
new file mode 100644
index 0000000..457f0c4
--- /dev/null
+++ b/doc/unw_apply_reg_state.man
@@ -0,0 +1,90 @@
+'\" t
+.\" Manual page created with latex2man on Wed Aug 16 11:09:44 PDT 2017
+.\" NOTE: This file is generated, DO NOT EDIT.
+.de Vb
+.ft CW
+.nf
+..
+.de Ve
+.ft R
+
+.fi
+..
+.TH "UNW\\_APPLY\\_REG\\_STATE" "3" "16 August 2017" "Programming Library " "Programming Library "
+.SH NAME
+unw_apply_reg_state
+\-\- apply a register state update to a cursor 
+.PP
+.SH SYNOPSIS
+
+.PP
+#include <libunwind.h>
+.br
+.PP
+int
+unw_apply_reg_state(unw_cursor_t *cp,
+void *reg_states_data);
+.br
+.PP
+.SH DESCRIPTION
+
+.PP
+The unw_apply_reg_state()
+routine updates the register values 
+of a cursor according to the instructions in reg_states_data,
+which have been obtained by calling unw_reg_states_iterate\&.
+.PP
+.SH RETURN VALUE
+
+.PP
+On successful completion, unw_apply_reg_state()
+returns 0. 
+Otherwise the negative value of one of the error\-codes below is 
+returned. 
+.PP
+.SH THREAD AND SIGNAL SAFETY
+
+.PP
+unw_apply_reg_state()
+is thread\-safe. If cursor cp
+is 
+in the local address\-space, this routine is also safe to use from a 
+signal handler. 
+.PP
+.SH ERRORS
+
+.PP
+.TP
+UNW_EUNSPEC
+ An unspecified error occurred. 
+.TP
+UNW_ENOINFO
+ Libunwind
+was unable to locate 
+unwind\-info for the procedure. 
+.TP
+UNW_EBADVERSION
+ The unwind\-info for the procedure has 
+version or format that is not understood by libunwind\&.
+.PP
+In addition, unw_apply_reg_state()
+may return any error 
+returned by the access_mem()
+call\-back (see 
+unw_create_addr_space(3)).
+.PP
+.SH SEE ALSO
+
+.PP
+libunwind(3),
+unw_reg_states_iterate(3)
+.PP
+.SH AUTHOR
+
+.PP
+David Mosberger\-Tang
+.br
+Email: \fBdmosberger@gmail.com\fP
+.br
+WWW: \fBhttp://www.nongnu.org/libunwind/\fP\&.
+.\" NOTE: This file is generated, DO NOT EDIT.
diff --git a/doc/unw_apply_reg_state.tex b/doc/unw_apply_reg_state.tex
new file mode 100644
index 0000000..c67cc3e
--- /dev/null
+++ b/doc/unw_apply_reg_state.tex
@@ -0,0 +1,63 @@
+\documentclass{article}
+\usepackage[fancyhdr,pdf]{latex2man}
+
+\input{common.tex}
+
+\begin{document}
+
+\begin{Name}{3}{unw\_apply\_reg\_state}{David Mosberger-Tang}{Programming Library}{unw\_apply\_reg\_state}unw\_apply\_reg\_state -- apply a register state update to a cursor
+\end{Name}
+
+\section{Synopsis}
+
+\File{\#include $<$libunwind.h$>$}\\
+
+\Type{int}
+\Func{unw\_apply\_reg\_state}(\Type{unw\_cursor\_t~*}\Var{cp},
+\Type{void~*}\Var{reg\_states\_data});\\
+
+\section{Description}
+
+The \Func{unw\_apply\_reg\_state}() routine updates the register values
+of a cursor according to the instructions in \Var{reg\_states\_data},
+which have been obtained by calling \Var{unw\_reg\_states\_iterate}.
+
+\section{Return Value}
+
+On successful completion, \Func{unw\_apply\_reg\_state}() returns 0.
+Otherwise the negative value of one of the error-codes below is
+returned.
+
+\section{Thread and Signal Safety}
+
+\Func{unw\_apply\_reg\_state}() is thread-safe.  If cursor \Var{cp} is
+in the local address-space, this routine is also safe to use from a
+signal handler.
+
+\section{Errors}
+
+\begin{Description}
+\item[\Const{UNW\_EUNSPEC}] An unspecified error occurred.
+\item[\Const{UNW\_ENOINFO}] \Prog{Libunwind} was unable to locate
+  unwind-info for the procedure.
+\item[\Const{UNW\_EBADVERSION}] The unwind-info for the procedure has
+  version or format that is not understood by \Prog{libunwind}.
+\end{Description}
+In addition, \Func{unw\_apply\_reg\_state}() may return any error
+returned by the \Func{access\_mem}() call-back (see
+\Func{unw\_create\_addr\_space}(3)).
+
+\section{See Also}
+
+\SeeAlso{libunwind(3)},
+\SeeAlso{unw\_reg\_states\_iterate(3)}
+
+\section{Author}
+
+\noindent
+David Mosberger-Tang\\
+Email: \Email{dmosberger@gmail.com}\\
+WWW: \URL{http://www.nongnu.org/libunwind/}.
+\LatexManEnd
+
+\end{document}
diff --git a/doc/unw_flush_cache.man b/doc/unw_flush_cache.man
index 2c05bc2..627449e 100644
--- a/doc/unw_flush_cache.man
+++ b/doc/unw_flush_cache.man
@@ -1,5 +1,5 @@
 '\" t
-.\" Manual page created with latex2man on Thu Aug 16 09:44:44 MDT 2007
+.\" Manual page created with latex2man on Fri Dec  2 16:09:33 PST 2016
 .\" NOTE: This file is generated, DO NOT EDIT.
 .de Vb
 .ft CW
@@ -10,7 +10,7 @@
 
 .fi
 ..
-.TH "UNW\\_FLUSH\\_CACHE" "3" "16 August 2007" "Programming Library " "Programming Library "
+.TH "UNW\\_FLUSH\\_CACHE" "3" "02 December 2016" "Programming Library " "Programming Library "
 .SH NAME
 unw_flush_cache
 \-\- flush cached info 
@@ -80,6 +80,7 @@ use from a signal handler.
 .PP
 libunwind(3),
 unw_set_caching_policy(3)
+unw_set_cache_size(3)
 .PP
 .SH AUTHOR
 
diff --git a/doc/unw_flush_cache.tex b/doc/unw_flush_cache.tex
index 9b61dfc..32319db 100644
--- a/doc/unw_flush_cache.tex
+++ b/doc/unw_flush_cache.tex
@@ -45,6 +45,7 @@ use from a signal handler.
 
 \SeeAlso{libunwind(3)},
 \SeeAlso{unw\_set\_caching\_policy(3)}
+\SeeAlso{unw\_set\_cache\_size(3)}
 
 \section{Author}
 
diff --git a/doc/unw_init_local.man b/doc/unw_init_local.man
index 73b7988..301dd6f 100644
--- a/doc/unw_init_local.man
+++ b/doc/unw_init_local.man
@@ -1,5 +1,5 @@
 '\" t
-.\" Manual page created with latex2man on Thu Aug 16 09:44:45 MDT 2007
+.\" Manual page created with latex2man on Wed Aug 16 12:11:05 PDT 2017
 .\" NOTE: This file is generated, DO NOT EDIT.
 .de Vb
 .ft CW
@@ -10,7 +10,7 @@
 
 .fi
 ..
-.TH "UNW\\_INIT\\_LOCAL" "3" "16 August 2007" "Programming Library " "Programming Library "
+.TH "UNW\\_INIT\\_LOCAL" "3" "16 August 2017" "Programming Library " "Programming Library "
 .SH NAME
 unw_init_local
 \-\- initialize cursor for local unwinding 
@@ -25,6 +25,12 @@ int
 unw_init_local(unw_cursor_t *c,
 unw_context_t *ctxt);
 .br
+int
+unw_init_local2(unw_cursor_t *c,
+unw_context_t *ctxt,
+int
+flag);
+.br
 .PP
 .SH DESCRIPTION
 
@@ -37,7 +43,11 @@ pointed to by ctxt\&.
 As such, the machine\-state pointed to by 
 ctxt
 identifies the initial stack frame at which unwinding 
-starts. The machine\-state must remain valid for the duration for 
+starts. The machine\-state is expected to be one provided by a call to 
+unw_getcontext; as such, the instruction pointer may point to the 
+instruction after the last instruction of a function, and libunwind 
+will back\-up the instruction pointer before beginning a walk up the 
+call stack. The machine\-state must remain valid for the duration for 
 which the cursor c
 is in use. 
 .PP
@@ -46,17 +56,6 @@ routine can be used only for unwinding in
 the address space of the current process (i.e., for local unwinding). 
 For all other cases, unw_init_remote()
 must be used instead. 
-From a behavioral point of view, the call: 
-.PP
-.Vb
-    ret = unw_init_local(&cursor, &ucontext);
-.Ve
-is equivalent to: 
-.PP
-.Vb
-    ret = unw_init_remote(&cursor, unw_local_addr_space,
-                          &ucontext);
-.Ve
 However, unwind performance may be better when using 
 unw_init_local().
 Also, unw_init_local()
@@ -67,6 +66,12 @@ including <libunwind.h>,
 whereas unw_init_remote()
 is not. 
 .PP
+If the unw_context_t is known to be a signal frame (i.e., from the 
+third argument in a sigaction handler on linux), 
+unw_init_local2()
+should be used for correct initialization 
+on some platforms, passing the UNW_INIT_SIGNAL_FRAME flag. 
+.PP
 .SH RETURN VALUE
 
 .PP
diff --git a/doc/unw_init_local.tex b/doc/unw_init_local.tex
index 5cea673..ff0d03b 100644
--- a/doc/unw_init_local.tex
+++ b/doc/unw_init_local.tex
@@ -13,6 +13,7 @@
 \File{\#include $<$libunwind.h$>$}\\
 
 \Type{int} \Func{unw\_init\_local}(\Type{unw\_cursor\_t~*}\Var{c}, \Type{unw\_context\_t~*}\Var{ctxt});\\
+\Type{int} \Func{unw\_init\_local2}(\Type{unw\_cursor\_t~*}\Var{c}, \Type{unw\_context\_t~*}\Var{ctxt}, \Type{int} \Var{flag});\\
 
 \section{Description}
 
@@ -20,29 +21,27 @@ The \Func{unw\_init\_local}() routine initializes the unwind cursor
 pointed to by \Var{c} with the machine-state in the context structure
 pointed to by \Var{ctxt}.  As such, the machine-state pointed to by
 \Var{ctxt} identifies the initial stack frame at which unwinding
-starts.  The machine-state must remain valid for the duration for
+starts.  The machine-state is expected to be one provided by a call to
+unw_getcontext; as such, the instruction pointer may point to the
+instruction after the last instruction of a function, and libunwind
+will back-up the instruction pointer before beginning a walk up the
+call stack.  The machine-state must remain valid for the duration for
 which the cursor \Var{c} is in use.
 
 The \Func{unw\_init\_local}() routine can be used only for unwinding in
 the address space of the current process (i.e., for local unwinding).
 For all other cases, \Func{unw\_init\_remote}() must be used instead.
-From a behavioral point of view, the call:
-
-\begin{verbatim}
-    ret = unw_init_local(&cursor, &ucontext);
-\end{verbatim}
-is equivalent to:
-
-\begin{verbatim}
-    ret = unw_init_remote(&cursor, unw_local_addr_space,
-                          &ucontext);
-\end{verbatim}
 However, unwind performance may be better when using
 \Func{unw\_init\_local}().  Also, \Func{unw\_init\_local}() is
 available even when \Const{UNW\_LOCAL\_ONLY} has been defined before
 including \File{$<$libunwind.h$>$}, whereas \Func{unw\_init\_remote}()
 is not.
 
+If the unw_context_t is known to be a signal frame (i.e., from the
+third argument in a sigaction handler on linux),
+\Func{unw\_init\_local2}() should be used for correct initialization
+on some platforms, passing the UNW_INIT_SIGNAL_FRAME flag.
+
 \section{Return Value}
 
 On successful completion, \Func{unw\_init\_local}() returns 0.
diff --git a/doc/unw_init_local2.man b/doc/unw_init_local2.man
new file mode 100644
index 0000000..6cbbf00
--- /dev/null
+++ b/doc/unw_init_local2.man
@@ -0,0 +1 @@
+.so man3/unw_init_local.3
diff --git a/doc/unw_reg_states_iterate.man b/doc/unw_reg_states_iterate.man
new file mode 100644
index 0000000..e328ad2
--- /dev/null
+++ b/doc/unw_reg_states_iterate.man
@@ -0,0 +1,137 @@
+'\" t
+.\" Manual page created with latex2man on Wed Aug 16 11:09:44 PDT 2017
+.\" NOTE: This file is generated, DO NOT EDIT.
+.de Vb
+.ft CW
+.nf
+..
+.de Ve
+.ft R
+
+.fi
+..
+.TH "UNW\\_REG\\_STATES\\_ITERATE" "3" "16 August 2017" "Programming Library " "Programming Library "
+.SH NAME
+unw_reg_states_iterate
+\-\- get register state info on current procedure 
+.PP
+.SH SYNOPSIS
+
+.PP
+#include <libunwind.h>
+.br
+.PP
+int
+unw_reg_states_iterate(unw_cursor_t *cp,
+unw_reg_states_callbackcb,
+void *token);
+.br
+.PP
+.SH DESCRIPTION
+
+.PP
+The unw_reg_states_iterate()
+routine provides 
+information about the procedure that created the stack frame 
+identified by argument cp\&.
+The cb
+argument is a pointer 
+to a function of type unw_reg_states_callback
+which is used to 
+return the information. The function unw_reg_states_callback
+has the 
+following definition: 
+.PP
+int
+( *unw_reg_states_callback)(void *token,
+void *reg_states_data,
+size_t
+reg_states_data_size,
+unw_word_t
+start_ip,
+unw_word_t
+end_ip);
+.PP
+The callback function may be invoked several times for each call of unw_reg_states_iterate\&.
+Each call is associcated with a instruction address range and a set of instructions on how to update register values when returning from the procedure in that address range. For each invocation, the arguments to the callback function are: 
+.TP
+void * token
+ The token value passed to unw_reg_states_callback\&.
+.br
+.TP
+void * reg_states_data
+ A pointer to data about 
+updating register values. This data, or a copy of it, can be passed 
+to unw_apply_reg_state\&.
+.br
+.TP
+int reg_states_data_size
+ The size of the register update data. 
+.br
+.TP
+unw_word_t start_ip
+ The address of the first 
+instruction of the address range. 
+.br
+.TP
+unw_word_t end_ip
+ The address of the first 
+instruction \fIbeyond\fP
+the end of the address range. 
+.br
+.PP
+.SH RETURN VALUE
+
+.PP
+On successful completion, unw_reg_states_iterate()
+returns 
+0. If the callback function returns a nonzero value, that indicates 
+failure and the function returns immediately. Otherwise the negative 
+value of one of the error\-codes below is returned. 
+.PP
+.SH THREAD AND SIGNAL SAFETY
+
+.PP
+unw_reg_states_iterate()
+is thread\-safe. If cursor cp
+is 
+in the local address\-space, this routine is also safe to use from a 
+signal handler. 
+.PP
+.SH ERRORS
+
+.PP
+.TP
+UNW_EUNSPEC
+ An unspecified error occurred. 
+.TP
+UNW_ENOINFO
+ Libunwind
+was unable to locate 
+unwind\-info for the procedure. 
+.TP
+UNW_EBADVERSION
+ The unwind\-info for the procedure has 
+version or format that is not understood by libunwind\&.
+.PP
+In addition, unw_reg_states_iterate()
+may return any error 
+returned by the access_mem()
+call\-back (see 
+unw_create_addr_space(3)).
+.PP
+.SH SEE ALSO
+
+.PP
+libunwind(3),
+unw_apply_reg_state(3)
+.PP
+.SH AUTHOR
+
+.PP
+David Mosberger\-Tang
+.br
+Email: \fBdmosberger@gmail.com\fP
+.br
+WWW: \fBhttp://www.nongnu.org/libunwind/\fP\&.
+.\" NOTE: This file is generated, DO NOT EDIT.
diff --git a/doc/unw_reg_states_iterate.tex b/doc/unw_reg_states_iterate.tex
new file mode 100644
index 0000000..36c9b54
--- /dev/null
+++ b/doc/unw_reg_states_iterate.tex
@@ -0,0 +1,83 @@
+\documentclass{article}
+\usepackage[fancyhdr,pdf]{latex2man}
+
+\input{common.tex}
+
+\begin{document}
+
+\begin{Name}{3}{unw\_reg\_states\_iterate}{David Mosberger-Tang}{Programming Library}{unw\_reg\_states\_iterate}unw\_reg\_states\_iterate -- get register state info on current procedure
+\end{Name}
+
+\section{Synopsis}
+
+\File{\#include $<$libunwind.h$>$}\\
+
+\Type{int} \Func{unw\_reg\_states\_iterate}(\Type{unw\_cursor\_t~*}\Var{cp}, \Type{unw\_reg\_states\_callback}\Var{cb}, \Type{void~*}\Var{token});\\
+
+\section{Description}
+
+The \Func{unw\_reg\_states\_iterate}() routine provides
+information about the procedure that created the stack frame
+identified by argument \Var{cp}.  The \Var{cb} argument is a pointer
+to a function of type \Type{unw\_reg\_states\_callback} which is used to
+return the information.  The function \Type{unw\_reg\_states\_callback} has the
+following definition:
+
+\Type{int} (~*\Var{unw\_reg\_states\_callback})(\Type{void~*}\Var{token},
+			\Type{void~*}\Var{reg\_states\_data},
+			\Type{size\_t} \Var{reg\_states\_data\_size},
+			\Type{unw\_word\_t} \Var{start\_ip}, \Type{unw\_word\_t} \Var{end\_ip});
+
+The callback function may be invoked several times for each call of \Func{unw\_reg\_states\_iterate}. Each call is associcated with a instruction address range and a set of instructions on how to update register values when returning from the procedure in that address range.  For each invocation, the arguments to the callback function are:
+\begin{description}
+\item[\Type{void~*} \Var{token}] The token value passed to \Var{unw\_reg\_states\_callback}. \\
+\item[\Type{void~*} \Var{reg\_states\_data}] A pointer to data about
+  updating register values. This data, or a copy of it, can be passed
+  to \Var{unw\_apply\_reg\_state}.\\
+\item[\Type{int} \Var{reg\_states\_data\_size}] The size of the register update data. \\
+\item[\Type{unw\_word\_t} \Var{start\_ip}] The address of the first
+  instruction of the address range.  \\
+\item[\Type{unw\_word\_t} \Var{end\_ip}] The address of the first
+  instruction \emph{beyond} the end of the address range.  \\
+\end{description}
+
+\section{Return Value}
+
+On successful completion, \Func{unw\_reg\_states\_iterate}() returns
+0.  If the callback function returns a nonzero value, that indicates
+failure and the function returns immediately.  Otherwise the negative
+value of one of the error-codes below is returned.
+
+\section{Thread and Signal Safety}
+
+\Func{unw\_reg\_states\_iterate}() is thread-safe.  If cursor \Var{cp} is
+in the local address-space, this routine is also safe to use from a
+signal handler.
+
+\section{Errors}
+
+\begin{Description}
+\item[\Const{UNW\_EUNSPEC}] An unspecified error occurred.
+\item[\Const{UNW\_ENOINFO}] \Prog{Libunwind} was unable to locate
+  unwind-info for the procedure.
+\item[\Const{UNW\_EBADVERSION}] The unwind-info for the procedure has
+  version or format that is not understood by \Prog{libunwind}.
+\end{Description}
+In addition, \Func{unw\_reg\_states\_iterate}() may return any error
+returned by the \Func{access\_mem}() call-back (see
+\Func{unw\_create\_addr\_space}(3)).
+
+\section{See Also}
+
+\SeeAlso{libunwind(3)},
+\SeeAlso{unw\_apply\_reg\_state(3)}
+
+\section{Author}
+
+\noindent
+David Mosberger-Tang\\
+Email: \Email{dmosberger@gmail.com}\\
+WWW: \URL{http://www.nongnu.org/libunwind/}.
+\LatexManEnd
+
+\end{document}
diff --git a/doc/unw_set_cache_size.man b/doc/unw_set_cache_size.man
new file mode 100644
index 0000000..34bbc53
--- /dev/null
+++ b/doc/unw_set_cache_size.man
@@ -0,0 +1,88 @@
+'\" t
+.\" Manual page created with latex2man on Fri Jan 13 08:33:21 PST 2017
+.\" NOTE: This file is generated, DO NOT EDIT.
+.de Vb
+.ft CW
+.nf
+..
+.de Ve
+.ft R
+
+.fi
+..
+.TH "UNW\\_SET\\_CACHE\\_SIZE" "3" "13 January 2017" "Programming Library " "Programming Library "
+.SH NAME
+unw_set_cache_size
+\-\- set unwind cache size 
+.PP
+.SH SYNOPSIS
+
+.PP
+#include <libunwind.h>
+.br
+.PP
+int
+unw_set_cache_size(unw_addr_space_t
+as,
+size_t
+size,
+int
+flag);
+.br
+.PP
+.SH DESCRIPTION
+
+.PP
+The unw_set_cache_size()
+routine sets the cache size of 
+address space as
+to hold at least as many items as given by 
+argument size\&.
+It may hold more items as determined by the 
+implementation. To disable caching, call 
+unw_set_caching_policy)
+with a policy of 
+UNW_CACHE_NONE\&.
+Flag is currently unused and must be 0. 
+.PP
+.SH RETURN VALUE
+
+.PP
+On successful completion, unw_set_cache_size()
+returns 0. 
+Otherwise the negative value of one of the error\-codes below is 
+returned. 
+.PP
+.SH THREAD AND SIGNAL SAFETY
+
+.PP
+unw_set_cache_size()
+is thread\-safe but \fInot\fP
+safe 
+to use from a signal handler. 
+.PP
+.SH ERRORS
+
+.PP
+.TP
+UNW_ENOMEM
+ The desired cache size could not be 
+established because the application is out of memory. 
+.PP
+.SH SEE ALSO
+
+.PP
+libunwind(3),
+unw_create_addr_space(3),
+unw_set_caching_policy(3),
+unw_flush_cache(3)
+.PP
+.SH AUTHOR
+
+.PP
+Dave Watson
+.br
+Email: \fBdade.watson@gmail.com\fP
+.br
+WWW: \fBhttp://www.nongnu.org/libunwind/\fP\&.
+.\" NOTE: This file is generated, DO NOT EDIT.
diff --git a/doc/unw_set_cache_size.tex b/doc/unw_set_cache_size.tex
new file mode 100644
index 0000000..1bd7e00
--- /dev/null
+++ b/doc/unw_set_cache_size.tex
@@ -0,0 +1,59 @@
+\documentclass{article}
+\usepackage[fancyhdr,pdf]{latex2man}
+
+\input{common.tex}
+
+\begin{document}
+
+\begin{Name}{3}{unw\_set\_cache\_size}{Dave Watson}{Programming Library}{unw\_set\_cache\_size}unw\_set\_cache\_size -- set unwind cache size
+\end{Name}
+
+\section{Synopsis}
+
+\File{\#include $<$libunwind.h$>$}\\
+
+\Type{int} \Func{unw\_set\_cache\_size}(\Type{unw\_addr\_space\_t} \Var{as}, \Type{size\_t} \Var{size}, \Type{int} \Var{flag});\\
+
+\section{Description}
+
+The \Func{unw\_set\_cache\_size}() routine sets the cache size of
+address space \Var{as} to hold at least as many items as given by
+argument \Var{size}.  It may hold more items as determined by the
+implementation.  To disable caching, call
+\Func{unw\_set\_caching\_policy}) with a policy of
+\Const{UNW\_CACHE\_NONE}.  Flag is currently unused and must be 0.
+
+\section{Return Value}
+
+On successful completion, \Func{unw\_set\_cache\_size}() returns 0.
+Otherwise the negative value of one of the error-codes below is
+returned.
+
+\section{Thread and Signal Safety}
+
+\Func{unw\_set\_cache\_size}() is thread-safe but \emph{not} safe
+to use from a signal handler.
+
+\section{Errors}
+
+\begin{Description}
+\item[\Const{UNW\_ENOMEM}] The desired cache size could not be
+  established because the application is out of memory.
+\end{Description}
+
+\section{See Also}
+
+\SeeAlso{libunwind(3)},
+\SeeAlso{unw\_create\_addr\_space(3)},
+\SeeAlso{unw\_set\_caching\_policy(3)},
+\SeeAlso{unw\_flush\_cache(3)}
+
+\section{Author}
+
+\noindent
+Dave Watson\\
+Email: \Email{dade.watson@gmail.com}\\
+WWW: \URL{http://www.nongnu.org/libunwind/}.
+\LatexManEnd
+
+\end{document}
diff --git a/doc/unw_set_caching_policy.man b/doc/unw_set_caching_policy.man
index a21d84a..4862ea5 100644
--- a/doc/unw_set_caching_policy.man
+++ b/doc/unw_set_caching_policy.man
@@ -1,5 +1,5 @@
 '\" t
-.\" Manual page created with latex2man on Thu Aug 16 09:44:45 MDT 2007
+.\" Manual page created with latex2man on Fri Dec  2 16:09:33 PST 2016
 .\" NOTE: This file is generated, DO NOT EDIT.
 .de Vb
 .ft CW
@@ -10,7 +10,7 @@
 
 .fi
 ..
-.TH "UNW\\_SET\\_CACHING\\_POLICY" "3" "16 August 2007" "Programming Library " "Programming Library "
+.TH "UNW\\_SET\\_CACHING\\_POLICY" "3" "02 December 2016" "Programming Library " "Programming Library "
 .SH NAME
 unw_set_caching_policy
 \-\- set unwind caching policy 
@@ -105,6 +105,7 @@ established because the application is out of memory.
 .PP
 libunwind(3),
 unw_create_addr_space(3),
+unw_set_cache_size(3),
 unw_flush_cache(3)
 .PP
 .SH AUTHOR
diff --git a/doc/unw_set_caching_policy.tex b/doc/unw_set_caching_policy.tex
index a84e020..3a4b07e 100644
--- a/doc/unw_set_caching_policy.tex
+++ b/doc/unw_set_caching_policy.tex
@@ -67,6 +67,7 @@ to use from a signal handler.
 
 \SeeAlso{libunwind(3)},
 \SeeAlso{unw\_create\_addr\_space(3)},
+\SeeAlso{unw\_set\_cache\_size(3)},
 \SeeAlso{unw\_flush\_cache(3)}
 
 \section{Author}
diff --git a/include/compiler.h b/include/compiler.h
index 312ac15..2fa59ef 100644
--- a/include/compiler.h
+++ b/include/compiler.h
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -31,28 +31,27 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #define COMPILER_H
 
 #ifdef __GNUC__
-# define ALIGNED(x)	__attribute__((aligned(x)))
-# define CONST_ATTR	__attribute__((__const__))
-# define UNUSED		__attribute__((unused))
-# define NOINLINE	__attribute__((noinline))
-# define NORETURN	__attribute__((noreturn))
-# define ALIAS(name)	__attribute__((alias (#name)))
+# define ALIGNED(x)     __attribute__((aligned(x)))
+# define CONST_ATTR     __attribute__((__const__))
+# define UNUSED         __attribute__((unused))
+# define NOINLINE       __attribute__((noinline))
+# define NORETURN       __attribute__((noreturn))
+# define ALIAS2(name)   #name
+# define ALIAS(name)    __attribute__((alias (ALIAS2(name))))
 # if (__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ > 2)
-#  define ALWAYS_INLINE	inline __attribute__((always_inline))
-#  define HIDDEN	__attribute__((visibility ("hidden")))
-#  define PROTECTED	__attribute__((visibility ("protected")))
+#  define ALWAYS_INLINE inline __attribute__((always_inline))
+#  define HIDDEN        __attribute__((visibility ("hidden")))
 # else
 #  define ALWAYS_INLINE
 #  define HIDDEN
-#  define PROTECTED
 # endif
-# define WEAK		__attribute__((weak))
+# define WEAK           __attribute__((weak))
 # if (__GNUC__ >= 3)
-#  define likely(x)	__builtin_expect ((x), 1)
-#  define unlikely(x)	__builtin_expect ((x), 0)
+#  define likely(x)     __builtin_expect ((x), 1)
+#  define unlikely(x)   __builtin_expect ((x), 0)
 # else
-#  define likely(x)	(x)
-#  define unlikely(x)	(x)
+#  define likely(x)     (x)
+#  define unlikely(x)   (x)
 # endif
 #else
 # define ALIGNED(x)
@@ -63,12 +62,11 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 # define NORETURN
 # define ALIAS(name)
 # define HIDDEN
-# define PROTECTED
 # define WEAK
-# define likely(x)	(x)
-# define unlikely(x)	(x)
+# define likely(x)      (x)
+# define unlikely(x)    (x)
 #endif
 
-#define ARRAY_SIZE(a)	(sizeof (a) / sizeof ((a)[0]))
+#define ARRAY_SIZE(a)   (sizeof (a) / sizeof ((a)[0]))
 
 #endif /* COMPILER_H */
diff --git a/include/config.h.in b/include/config.h.in
index d504deb..7b37ca2 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -33,6 +33,10 @@
    you don't. */
 #undef HAVE_DECL_PTRACE_POKEUSER
 
+/* Define to 1 if you have the declaration of `PTRACE_SETREGSET', and to 0 if
+   you don't. */
+#undef HAVE_DECL_PTRACE_SETREGSET
+
 /* Define to 1 if you have the declaration of `PTRACE_SINGLESTEP', and to 0 if
    you don't. */
 #undef HAVE_DECL_PTRACE_SINGLESTEP
@@ -85,6 +89,9 @@
 /* Define to 1 if you have the `dl_phdr_removals_counter' function. */
 #undef HAVE_DL_PHDR_REMOVALS_COUNTER
 
+/* Define to 1 if you have the <elf.h> header file. */
+#undef HAVE_ELF_H
+
 /* Define to 1 if you have the <endian.h> header file. */
 #undef HAVE_ENDIAN_H
 
@@ -103,6 +110,9 @@
 /* Define to 1 if you have the `uca' library (-luca). */
 #undef HAVE_LIBUCA
 
+/* Define to 1 if you have the <link.h> header file. */
+#undef HAVE_LINK_H
+
 /* Define if you have liblzma */
 #undef HAVE_LZMA
 
@@ -139,9 +149,15 @@
 /* Defined if __sync atomics are available */
 #undef HAVE_SYNC_ATOMICS
 
+/* Define to 1 if you have the <sys/elf.h> header file. */
+#undef HAVE_SYS_ELF_H
+
 /* Define to 1 if you have the <sys/endian.h> header file. */
 #undef HAVE_SYS_ENDIAN_H
 
+/* Define to 1 if you have the <sys/link.h> header file. */
+#undef HAVE_SYS_LINK_H
+
 /* Define to 1 if you have the <sys/procfs.h> header file. */
 #undef HAVE_SYS_PROCFS_H
 
@@ -163,6 +179,9 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
+/* Defined if __builtin_unreachable() is available */
+#undef HAVE__BUILTIN_UNREACHABLE
+
 /* Defined if __builtin___clear_cache() is available */
 #undef HAVE__BUILTIN___CLEAR_CACHE
 
diff --git a/include/dwarf-eh.h b/include/dwarf-eh.h
index 405e394..e037507 100644
--- a/include/dwarf-eh.h
+++ b/include/dwarf-eh.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -58,9 +58,9 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
     string:
 
      'z': The operand for this character is a uleb128 value that gives the
-	  length of the CIE augmentation body, not counting the length
-	  of the uleb128 operand itself.  If present, this code must
-	  appear as the first character in the augmentation body.
+          length of the CIE augmentation body, not counting the length
+          of the uleb128 operand itself.  If present, this code must
+          appear as the first character in the augmentation body.
 
      'L': Indicates that the FDE's augmentation body contains an LSDA
           pointer.  The operand for this character is a single byte
@@ -73,13 +73,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
           operand for this character is a single byte that specifies
           the pointer-encoding (PE) that is used for the
           code-pointers.  Note: the "address_range" member is always
-	  encoded as an absolute value.  Apart from that, the specified
-	  FDE pointer-encoding applies.
+          encoded as an absolute value.  Apart from that, the specified
+          FDE pointer-encoding applies.
 
      'P': Indicates the presence of a personality routine (handler).
           The first operand for this character specifies the
-	  pointer-encoding (PE) that is used for the second operand,
-	  which specifies the address of the personality routine.
+          pointer-encoding (PE) that is used for the second operand,
+          which specifies the address of the personality routine.
 
     If the augmentation string contains any other characters, the
     remainder of the augmentation string should be ignored.
@@ -104,25 +104,25 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 */
 
-#define DW_EH_VERSION		1	/* The version we're implementing */
+#define DW_EH_VERSION           1       /* The version we're implementing */
 
-struct dwarf_eh_frame_hdr
+struct __attribute__((packed)) dwarf_eh_frame_hdr
   {
     unsigned char version;
     unsigned char eh_frame_ptr_enc;
     unsigned char fde_count_enc;
     unsigned char table_enc;
+    Elf_W (Addr) eh_frame;
     /* The rest of the header is variable-length and consists of the
        following members:
 
-	encoded_t eh_frame_ptr;
-	encoded_t fde_count;
-	struct
-	  {
-	    encoded_t start_ip;	// first address covered by this FDE
-	    encoded_t fde_addr;	// address of the FDE
-	  }
-	binary_search_table[fde_count];  */
+        encoded_t fde_count;
+        struct
+          {
+            encoded_t start_ip; // first address covered by this FDE
+            encoded_t fde_addr; // address of the FDE
+          }
+        binary_search_table[fde_count];  */
   };
 
 #endif /* dwarf_eh_h */
diff --git a/include/dwarf.h b/include/dwarf.h
index 1885b9b..764f6f2 100644
--- a/include/dwarf.h
+++ b/include/dwarf.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -28,62 +28,74 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include <libunwind.h>
 
-struct dwarf_cursor;	/* forward-declaration */
+struct dwarf_cursor;    /* forward-declaration */
 struct elf_dyn_info;
 
 #include "dwarf-config.h"
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
 #ifndef UNW_REMOTE_ONLY
-#include <link.h>
+  #if defined(HAVE_LINK_H)
+    #include <link.h>
+  #elif defined(HAVE_SYS_LINK_H)
+    #include <sys/link.h>
+  #else
+    #error Could not find <link.h>
+  #endif
 #endif
+
 #include <pthread.h>
 
 /* DWARF expression opcodes.  */
 
 typedef enum
   {
-    DW_OP_addr			= 0x03,
-    DW_OP_deref			= 0x06,
-    DW_OP_const1u		= 0x08,
-    DW_OP_const1s		= 0x09,
-    DW_OP_const2u		= 0x0a,
-    DW_OP_const2s		= 0x0b,
-    DW_OP_const4u		= 0x0c,
-    DW_OP_const4s		= 0x0d,
-    DW_OP_const8u		= 0x0e,
-    DW_OP_const8s		= 0x0f,
-    DW_OP_constu		= 0x10,
-    DW_OP_consts		= 0x11,
-    DW_OP_dup			= 0x12,
-    DW_OP_drop			= 0x13,
-    DW_OP_over			= 0x14,
-    DW_OP_pick			= 0x15,
-    DW_OP_swap			= 0x16,
-    DW_OP_rot			= 0x17,
-    DW_OP_xderef		= 0x18,
-    DW_OP_abs			= 0x19,
-    DW_OP_and			= 0x1a,
-    DW_OP_div			= 0x1b,
-    DW_OP_minus			= 0x1c,
-    DW_OP_mod			= 0x1d,
-    DW_OP_mul			= 0x1e,
-    DW_OP_neg			= 0x1f,
-    DW_OP_not			= 0x20,
-    DW_OP_or			= 0x21,
-    DW_OP_plus			= 0x22,
-    DW_OP_plus_uconst		= 0x23,
-    DW_OP_shl			= 0x24,
-    DW_OP_shr			= 0x25,
-    DW_OP_shra			= 0x26,
-    DW_OP_xor			= 0x27,
-    DW_OP_skip			= 0x2f,
-    DW_OP_bra			= 0x28,
-    DW_OP_eq			= 0x29,
-    DW_OP_ge			= 0x2a,
-    DW_OP_gt			= 0x2b,
-    DW_OP_le			= 0x2c,
-    DW_OP_lt			= 0x2d,
-    DW_OP_ne			= 0x2e,
-    DW_OP_lit0			= 0x30,
+    DW_OP_addr                  = 0x03,
+    DW_OP_deref                 = 0x06,
+    DW_OP_const1u               = 0x08,
+    DW_OP_const1s               = 0x09,
+    DW_OP_const2u               = 0x0a,
+    DW_OP_const2s               = 0x0b,
+    DW_OP_const4u               = 0x0c,
+    DW_OP_const4s               = 0x0d,
+    DW_OP_const8u               = 0x0e,
+    DW_OP_const8s               = 0x0f,
+    DW_OP_constu                = 0x10,
+    DW_OP_consts                = 0x11,
+    DW_OP_dup                   = 0x12,
+    DW_OP_drop                  = 0x13,
+    DW_OP_over                  = 0x14,
+    DW_OP_pick                  = 0x15,
+    DW_OP_swap                  = 0x16,
+    DW_OP_rot                   = 0x17,
+    DW_OP_xderef                = 0x18,
+    DW_OP_abs                   = 0x19,
+    DW_OP_and                   = 0x1a,
+    DW_OP_div                   = 0x1b,
+    DW_OP_minus                 = 0x1c,
+    DW_OP_mod                   = 0x1d,
+    DW_OP_mul                   = 0x1e,
+    DW_OP_neg                   = 0x1f,
+    DW_OP_not                   = 0x20,
+    DW_OP_or                    = 0x21,
+    DW_OP_plus                  = 0x22,
+    DW_OP_plus_uconst           = 0x23,
+    DW_OP_shl                   = 0x24,
+    DW_OP_shr                   = 0x25,
+    DW_OP_shra                  = 0x26,
+    DW_OP_xor                   = 0x27,
+    DW_OP_skip                  = 0x2f,
+    DW_OP_bra                   = 0x28,
+    DW_OP_eq                    = 0x29,
+    DW_OP_ge                    = 0x2a,
+    DW_OP_gt                    = 0x2b,
+    DW_OP_le                    = 0x2c,
+    DW_OP_lt                    = 0x2d,
+    DW_OP_ne                    = 0x2e,
+    DW_OP_lit0                  = 0x30,
     DW_OP_lit1,  DW_OP_lit2,  DW_OP_lit3,  DW_OP_lit4,  DW_OP_lit5,
     DW_OP_lit6,  DW_OP_lit7,  DW_OP_lit8,  DW_OP_lit9,  DW_OP_lit10,
     DW_OP_lit11, DW_OP_lit12, DW_OP_lit13, DW_OP_lit14, DW_OP_lit15,
@@ -91,7 +103,7 @@ typedef enum
     DW_OP_lit21, DW_OP_lit22, DW_OP_lit23, DW_OP_lit24, DW_OP_lit25,
     DW_OP_lit26, DW_OP_lit27, DW_OP_lit28, DW_OP_lit29, DW_OP_lit30,
     DW_OP_lit31,
-    DW_OP_reg0			= 0x50,
+    DW_OP_reg0                  = 0x50,
     DW_OP_reg1,  DW_OP_reg2,  DW_OP_reg3,  DW_OP_reg4,  DW_OP_reg5,
     DW_OP_reg6,  DW_OP_reg7,  DW_OP_reg8,  DW_OP_reg9,  DW_OP_reg10,
     DW_OP_reg11, DW_OP_reg12, DW_OP_reg13, DW_OP_reg14, DW_OP_reg15,
@@ -99,7 +111,7 @@ typedef enum
     DW_OP_reg21, DW_OP_reg22, DW_OP_reg23, DW_OP_reg24, DW_OP_reg25,
     DW_OP_reg26, DW_OP_reg27, DW_OP_reg28, DW_OP_reg29, DW_OP_reg30,
     DW_OP_reg31,
-    DW_OP_breg0			= 0x70,
+    DW_OP_breg0                 = 0x70,
     DW_OP_breg1,  DW_OP_breg2,  DW_OP_breg3,  DW_OP_breg4,  DW_OP_breg5,
     DW_OP_breg6,  DW_OP_breg7,  DW_OP_breg8,  DW_OP_breg9,  DW_OP_breg10,
     DW_OP_breg11, DW_OP_breg12, DW_OP_breg13, DW_OP_breg14, DW_OP_breg15,
@@ -107,58 +119,60 @@ typedef enum
     DW_OP_breg21, DW_OP_breg22, DW_OP_breg23, DW_OP_breg24, DW_OP_breg25,
     DW_OP_breg26, DW_OP_breg27, DW_OP_breg28, DW_OP_breg29, DW_OP_breg30,
     DW_OP_breg31,
-    DW_OP_regx			= 0x90,
-    DW_OP_fbreg			= 0x91,
-    DW_OP_bregx			= 0x92,
-    DW_OP_piece			= 0x93,
-    DW_OP_deref_size		= 0x94,
-    DW_OP_xderef_size		= 0x95,
-    DW_OP_nop			= 0x96,
-    DW_OP_push_object_address	= 0x97,
-    DW_OP_call2			= 0x98,
-    DW_OP_call4			= 0x99,
-    DW_OP_call_ref		= 0x9a,
-    DW_OP_lo_user		= 0xe0,
-    DW_OP_hi_user		= 0xff
+    DW_OP_regx                  = 0x90,
+    DW_OP_fbreg                 = 0x91,
+    DW_OP_bregx                 = 0x92,
+    DW_OP_piece                 = 0x93,
+    DW_OP_deref_size            = 0x94,
+    DW_OP_xderef_size           = 0x95,
+    DW_OP_nop                   = 0x96,
+    DW_OP_push_object_address   = 0x97,
+    DW_OP_call2                 = 0x98,
+    DW_OP_call4                 = 0x99,
+    DW_OP_call_ref              = 0x9a,
+    DW_OP_lo_user               = 0xe0,
+    DW_OP_hi_user               = 0xff
   }
 dwarf_expr_op_t;
 
-#define DWARF_CIE_VERSION	3	/* GCC emits version 1??? */
+#define DWARF_CIE_VERSION       3
+#define DWARF_CIE_VERSION_MAX   4
 
-#define DWARF_CFA_OPCODE_MASK	0xc0
-#define DWARF_CFA_OPERAND_MASK	0x3f
+#define DWARF_CFA_OPCODE_MASK   0xc0
+#define DWARF_CFA_OPERAND_MASK  0x3f
 
 typedef enum
   {
-    DW_CFA_advance_loc		= 0x40,
-    DW_CFA_offset		= 0x80,
-    DW_CFA_restore		= 0xc0,
-    DW_CFA_nop			= 0x00,
-    DW_CFA_set_loc		= 0x01,
-    DW_CFA_advance_loc1		= 0x02,
-    DW_CFA_advance_loc2		= 0x03,
-    DW_CFA_advance_loc4		= 0x04,
-    DW_CFA_offset_extended	= 0x05,
-    DW_CFA_restore_extended	= 0x06,
-    DW_CFA_undefined		= 0x07,
-    DW_CFA_same_value		= 0x08,
-    DW_CFA_register		= 0x09,
-    DW_CFA_remember_state	= 0x0a,
-    DW_CFA_restore_state	= 0x0b,
-    DW_CFA_def_cfa		= 0x0c,
-    DW_CFA_def_cfa_register	= 0x0d,
-    DW_CFA_def_cfa_offset	= 0x0e,
-    DW_CFA_def_cfa_expression	= 0x0f,
-    DW_CFA_expression		= 0x10,
-    DW_CFA_offset_extended_sf	= 0x11,
-    DW_CFA_def_cfa_sf		= 0x12,
-    DW_CFA_def_cfa_offset_sf	= 0x13,
-    DW_CFA_lo_user		= 0x1c,
-    DW_CFA_MIPS_advance_loc8	= 0x1d,
-    DW_CFA_GNU_window_save	= 0x2d,
-    DW_CFA_GNU_args_size	= 0x2e,
-    DW_CFA_GNU_negative_offset_extended	= 0x2f,
-    DW_CFA_hi_user		= 0x3c
+    DW_CFA_advance_loc          = 0x40,
+    DW_CFA_offset               = 0x80,
+    DW_CFA_restore              = 0xc0,
+    DW_CFA_nop                  = 0x00,
+    DW_CFA_set_loc              = 0x01,
+    DW_CFA_advance_loc1         = 0x02,
+    DW_CFA_advance_loc2         = 0x03,
+    DW_CFA_advance_loc4         = 0x04,
+    DW_CFA_offset_extended      = 0x05,
+    DW_CFA_restore_extended     = 0x06,
+    DW_CFA_undefined            = 0x07,
+    DW_CFA_same_value           = 0x08,
+    DW_CFA_register             = 0x09,
+    DW_CFA_remember_state       = 0x0a,
+    DW_CFA_restore_state        = 0x0b,
+    DW_CFA_def_cfa              = 0x0c,
+    DW_CFA_def_cfa_register     = 0x0d,
+    DW_CFA_def_cfa_offset       = 0x0e,
+    DW_CFA_def_cfa_expression   = 0x0f,
+    DW_CFA_expression           = 0x10,
+    DW_CFA_offset_extended_sf   = 0x11,
+    DW_CFA_def_cfa_sf           = 0x12,
+    DW_CFA_def_cfa_offset_sf    = 0x13,
+    DW_CFA_val_expression       = 0x16,
+    DW_CFA_lo_user              = 0x1c,
+    DW_CFA_MIPS_advance_loc8    = 0x1d,
+    DW_CFA_GNU_window_save      = 0x2d,
+    DW_CFA_GNU_args_size        = 0x2e,
+    DW_CFA_GNU_negative_offset_extended = 0x2f,
+    DW_CFA_hi_user              = 0x3c
   }
 dwarf_cfa_t;
 
@@ -173,55 +187,49 @@ dwarf_cfa_t;
    engineered from GCC.
 
 */
-#define DW_EH_PE_FORMAT_MASK	0x0f	/* format of the encoded value */
-#define DW_EH_PE_APPL_MASK	0x70	/* how the value is to be applied */
+#define DW_EH_PE_FORMAT_MASK    0x0f    /* format of the encoded value */
+#define DW_EH_PE_APPL_MASK      0x70    /* how the value is to be applied */
 /* Flag bit.  If set, the resulting pointer is the address of the word
    that contains the final address.  */
-#define DW_EH_PE_indirect	0x80
+#define DW_EH_PE_indirect       0x80
 
 /* Pointer-encoding formats: */
-#define DW_EH_PE_omit		0xff
-#define DW_EH_PE_ptr		0x00	/* pointer-sized unsigned value */
-#define DW_EH_PE_uleb128	0x01	/* unsigned LE base-128 value */
-#define DW_EH_PE_udata2		0x02	/* unsigned 16-bit value */
-#define DW_EH_PE_udata4		0x03	/* unsigned 32-bit value */
-#define DW_EH_PE_udata8		0x04	/* unsigned 64-bit value */
-#define DW_EH_PE_sleb128	0x09	/* signed LE base-128 value */
-#define DW_EH_PE_sdata2		0x0a	/* signed 16-bit value */
-#define DW_EH_PE_sdata4		0x0b	/* signed 32-bit value */
-#define DW_EH_PE_sdata8		0x0c	/* signed 64-bit value */
+#define DW_EH_PE_omit           0xff
+#define DW_EH_PE_ptr            0x00    /* pointer-sized unsigned value */
+#define DW_EH_PE_uleb128        0x01    /* unsigned LE base-128 value */
+#define DW_EH_PE_udata2         0x02    /* unsigned 16-bit value */
+#define DW_EH_PE_udata4         0x03    /* unsigned 32-bit value */
+#define DW_EH_PE_udata8         0x04    /* unsigned 64-bit value */
+#define DW_EH_PE_sleb128        0x09    /* signed LE base-128 value */
+#define DW_EH_PE_sdata2         0x0a    /* signed 16-bit value */
+#define DW_EH_PE_sdata4         0x0b    /* signed 32-bit value */
+#define DW_EH_PE_sdata8         0x0c    /* signed 64-bit value */
 
 /* Pointer-encoding application: */
-#define DW_EH_PE_absptr		0x00	/* absolute value */
-#define DW_EH_PE_pcrel		0x10	/* rel. to addr. of encoded value */
-#define DW_EH_PE_textrel	0x20	/* text-relative (GCC-specific???) */
-#define DW_EH_PE_datarel	0x30	/* data-relative */
+#define DW_EH_PE_absptr         0x00    /* absolute value */
+#define DW_EH_PE_pcrel          0x10    /* rel. to addr. of encoded value */
+#define DW_EH_PE_textrel        0x20    /* text-relative (GCC-specific???) */
+#define DW_EH_PE_datarel        0x30    /* data-relative */
 /* The following are not documented by LSB v1.3, yet they are used by
    GCC, presumably they aren't documented by LSB since they aren't
    used on Linux:  */
-#define DW_EH_PE_funcrel	0x40	/* start-of-procedure-relative */
-#define DW_EH_PE_aligned	0x50	/* aligned pointer */
+#define DW_EH_PE_funcrel        0x40    /* start-of-procedure-relative */
+#define DW_EH_PE_aligned        0x50    /* aligned pointer */
 
 extern struct mempool dwarf_reg_state_pool;
 extern struct mempool dwarf_cie_info_pool;
 
 typedef enum
   {
-    DWARF_WHERE_UNDEF,		/* register isn't saved at all */
-    DWARF_WHERE_SAME,		/* register has same value as in prev. frame */
-    DWARF_WHERE_CFAREL,		/* register saved at CFA-relative address */
-    DWARF_WHERE_REG,		/* register saved in another register */
-    DWARF_WHERE_EXPR,		/* register saved */
+    DWARF_WHERE_UNDEF,          /* register isn't saved at all */
+    DWARF_WHERE_SAME,           /* register has same value as in prev. frame */
+    DWARF_WHERE_CFAREL,         /* register saved at CFA-relative address */
+    DWARF_WHERE_REG,            /* register saved in another register */
+    DWARF_WHERE_EXPR,           /* register saved */
+    DWARF_WHERE_VAL_EXPR,       /* register has computed value */
   }
 dwarf_where_t;
 
-typedef struct
-  {
-    dwarf_where_t where;	/* how is the register saved? */
-    unw_word_t val;		/* where it's saved */
-  }
-dwarf_save_loc_t;
-
 /* For uniformity, we'd like to treat the CFA save-location like any
    other register save-location, but this doesn't quite work, because
    the CFA can be expressed as a (REGISTER,OFFSET) pair.  To handle
@@ -232,33 +240,50 @@ dwarf_save_loc_t;
    case of DWARF_WHERE_REG, member "val" gives the number of the
    base-register and the "val" member of DWARF_CFA_OFF_COLUMN gives
    the offset value.  */
-#define DWARF_CFA_REG_COLUMN	DWARF_NUM_PRESERVED_REGS
-#define DWARF_CFA_OFF_COLUMN	(DWARF_NUM_PRESERVED_REGS + 1)
+#define DWARF_CFA_REG_COLUMN    DWARF_NUM_PRESERVED_REGS
+#define DWARF_CFA_OFF_COLUMN    (DWARF_NUM_PRESERVED_REGS + 1)
+
+typedef struct dwarf_reg_only_state
+  {
+    char where[DWARF_NUM_PRESERVED_REGS + 2];        /* how is the register saved? */
+    unw_word_t val[DWARF_NUM_PRESERVED_REGS + 2];             /* where it's saved */
+  }
+dwarf_reg_only_state_t;
 
 typedef struct dwarf_reg_state
   {
-    struct dwarf_reg_state *next;	/* for rs_stack */
-    dwarf_save_loc_t reg[DWARF_NUM_PRESERVED_REGS + 2];
-    unw_word_t ip;		          /* ip this rs is for */
-    unw_word_t ret_addr_column;           /* indicates which column in the rule table represents return address */
-    unsigned short lru_chain;	  /* used for least-recently-used chain */
-    unsigned short coll_chain;	/* used for hash collisions */
-    unsigned short hint;	      /* hint for next rs to try (or -1) */
+    unw_word_t ret_addr_column;	/* which column in rule table represents return address */
+    dwarf_reg_only_state_t reg;
+  }
+dwarf_reg_state_t;
+
+typedef struct dwarf_stackable_reg_state
+  {
+    struct dwarf_stackable_reg_state *next;       /* for rs_stack */
+    dwarf_reg_state_t state;
+  }
+dwarf_stackable_reg_state_t;
+
+typedef struct dwarf_reg_cache_entry
+  {
+    unw_word_t ip;                        /* ip this rs is for */
+    unsigned short coll_chain;  /* used for hash collisions */
+    unsigned short hint;              /* hint for next rs to try (or -1) */
     unsigned short valid : 1;         /* optional machine-dependent signal info */
     unsigned short signal_frame : 1;  /* optional machine-dependent signal info */
   }
-dwarf_reg_state_t;
+dwarf_reg_cache_entry_t;
 
 typedef struct dwarf_cie_info
   {
-    unw_word_t cie_instr_start;	/* start addr. of CIE "initial_instructions" */
-    unw_word_t cie_instr_end;	/* end addr. of CIE "initial_instructions" */
-    unw_word_t fde_instr_start;	/* start addr. of FDE "instructions" */
-    unw_word_t fde_instr_end;	/* end addr. of FDE "instructions" */
-    unw_word_t code_align;	/* code-alignment factor */
-    unw_word_t data_align;	/* data-alignment factor */
-    unw_word_t ret_addr_column;	/* column of return-address register */
-    unw_word_t handler;		/* address of personality-routine */
+    unw_word_t cie_instr_start; /* start addr. of CIE "initial_instructions" */
+    unw_word_t cie_instr_end;   /* end addr. of CIE "initial_instructions" */
+    unw_word_t fde_instr_start; /* start addr. of FDE "instructions" */
+    unw_word_t fde_instr_end;   /* end addr. of FDE "instructions" */
+    unw_word_t code_align;      /* code-alignment factor */
+    unw_word_t data_align;      /* data-alignment factor */
+    unw_word_t ret_addr_column; /* column of return-address register */
+    unw_word_t handler;         /* address of personality-routine */
     uint16_t abi;
     uint16_t tag;
     uint8_t fde_encoding;
@@ -274,20 +299,19 @@ typedef struct dwarf_state_record
     unsigned char fde_encoding;
     unw_word_t args_size;
 
-    dwarf_reg_state_t rs_initial;	/* reg-state after CIE instructions */
-    dwarf_reg_state_t rs_current;	/* current reg-state */
+    dwarf_reg_state_t rs_initial;       /* reg-state after CIE instructions */
+    dwarf_reg_state_t rs_current;       /* current reg-state */
   }
 dwarf_state_record_t;
 
 typedef struct dwarf_cursor
   {
-    void *as_arg;		/* argument to address-space callbacks */
-    unw_addr_space_t as;	/* reference to per-address-space info */
+    void *as_arg;               /* argument to address-space callbacks */
+    unw_addr_space_t as;        /* reference to per-address-space info */
 
-    unw_word_t cfa;	/* canonical frame address; aka frame-/stack-pointer */
-    unw_word_t ip;		/* instruction pointer */
-    unw_word_t args_size;	/* size of arguments */
-    unw_word_t ret_addr_column;	/* column for return-address */
+    unw_word_t cfa;     /* canonical frame address; aka frame-/stack-pointer */
+    unw_word_t ip;              /* instruction pointer */
+    unw_word_t args_size;       /* size of arguments */
     unw_word_t eh_args[UNW_TDEP_NUM_EH_REGS];
     unsigned int eh_valid_mask;
 
@@ -295,36 +319,44 @@ typedef struct dwarf_cursor
 
     unsigned int stash_frames :1; /* stash frames for fast lookup */
     unsigned int use_prev_instr :1; /* use previous (= call) or current (= signal) instruction? */
-    unsigned int pi_valid :1;	/* is proc_info valid? */
+    unsigned int pi_valid :1;   /* is proc_info valid? */
     unsigned int pi_is_dynamic :1; /* proc_info found via dynamic proc info? */
-    unw_proc_info_t pi;		/* info about current procedure */
+    unw_proc_info_t pi;         /* info about current procedure */
 
     short hint; /* faster lookup of the rs cache */
     short prev_rs;
   }
 dwarf_cursor_t;
 
-#define DWARF_LOG_UNW_CACHE_SIZE	7
-#define DWARF_UNW_CACHE_SIZE	(1 << DWARF_LOG_UNW_CACHE_SIZE)
+#define DWARF_DEFAULT_LOG_UNW_CACHE_SIZE        7
+#define DWARF_DEFAULT_UNW_CACHE_SIZE    (1 << DWARF_DEFAULT_LOG_UNW_CACHE_SIZE)
 
-#define DWARF_LOG_UNW_HASH_SIZE	(DWARF_LOG_UNW_CACHE_SIZE + 1)
-#define DWARF_UNW_HASH_SIZE	(1 << DWARF_LOG_UNW_HASH_SIZE)
+#define DWARF_DEFAULT_LOG_UNW_HASH_SIZE (DWARF_DEFAULT_LOG_UNW_CACHE_SIZE + 1)
+#define DWARF_DEFAULT_UNW_HASH_SIZE     (1 << DWARF_DEFAULT_LOG_UNW_HASH_SIZE)
 
 typedef unsigned char unw_hash_index_t;
 
 struct dwarf_rs_cache
   {
     pthread_mutex_t lock;
-    unsigned short lru_head;	/* index of lead-recently used rs */
-    unsigned short lru_tail;	/* index of most-recently used rs */
+    unsigned short rr_head;    /* index of least-recently allocated rs */
+
+    unsigned short log_size;
+    unsigned short prev_log_size;
 
     /* hash table that maps instruction pointer to rs index: */
-    unsigned short hash[DWARF_UNW_HASH_SIZE];
+    unsigned short *hash;
 
-    uint32_t generation;	/* generation number */
+    uint32_t generation;        /* generation number */
 
     /* rs cache: */
-    dwarf_reg_state_t buckets[DWARF_UNW_CACHE_SIZE];
+    dwarf_reg_state_t *buckets;
+    dwarf_reg_cache_entry_t *links;
+
+    /* default memory, loaded in BSS segment */
+    unsigned short default_hash[DWARF_DEFAULT_UNW_HASH_SIZE];
+    dwarf_reg_state_t default_buckets[DWARF_DEFAULT_UNW_CACHE_SIZE];
+    dwarf_reg_cache_entry_t default_links[DWARF_DEFAULT_UNW_CACHE_SIZE];
   };
 
 /* A list of descriptors for loaded .debug_frame sections.  */
@@ -344,77 +376,75 @@ struct unw_debug_frame_list
     struct unw_debug_frame_list *next;
   };
 
-struct dwarf_callback_data
-  {
-    /* in: */
-    unw_word_t ip;		/* instruction-pointer we're looking for */
-    unw_proc_info_t *pi;	/* proc-info pointer */
-    int need_unwind_info;
-    /* out: */
-    int single_fde;		/* did we find a single FDE? (vs. a table) */
-    unw_dyn_info_t di;		/* table info (if single_fde is false) */
-    unw_dyn_info_t di_debug;	/* additional table info for .debug_frame */
-  };
-
 /* Convenience macros: */
-#define dwarf_init			UNW_ARCH_OBJ (dwarf_init)
-#define dwarf_callback			UNW_OBJ (dwarf_callback)
-#define dwarf_find_proc_info		UNW_OBJ (dwarf_find_proc_info)
-#define dwarf_find_debug_frame		UNW_OBJ (dwarf_find_debug_frame)
-#define dwarf_search_unwind_table	UNW_OBJ (dwarf_search_unwind_table)
-#define dwarf_find_unwind_table		UNW_OBJ (dwarf_find_unwind_table)
-#define dwarf_put_unwind_info		UNW_OBJ (dwarf_put_unwind_info)
-#define dwarf_put_unwind_info		UNW_OBJ (dwarf_put_unwind_info)
-#define dwarf_eval_expr			UNW_OBJ (dwarf_eval_expr)
+#define dwarf_init                      UNW_ARCH_OBJ (dwarf_init)
+#define dwarf_callback                  UNW_OBJ (dwarf_callback)
+#define dwarf_find_proc_info            UNW_OBJ (dwarf_find_proc_info)
+#define dwarf_find_debug_frame          UNW_OBJ (dwarf_find_debug_frame)
+#define dwarf_search_unwind_table       UNW_OBJ (dwarf_search_unwind_table)
+#define dwarf_find_unwind_table         UNW_OBJ (dwarf_find_unwind_table)
+#define dwarf_put_unwind_info           UNW_OBJ (dwarf_put_unwind_info)
+#define dwarf_put_unwind_info           UNW_OBJ (dwarf_put_unwind_info)
+#define dwarf_eval_expr                 UNW_OBJ (dwarf_eval_expr)
+#define dwarf_stack_aligned             UNW_OBJ (dwarf_stack_aligned)
 #define dwarf_extract_proc_info_from_fde \
-		UNW_OBJ (dwarf_extract_proc_info_from_fde)
-#define dwarf_find_save_locs		UNW_OBJ (dwarf_find_save_locs)
-#define dwarf_create_state_record	UNW_OBJ (dwarf_create_state_record)
-#define dwarf_make_proc_info		UNW_OBJ (dwarf_make_proc_info)
-#define dwarf_read_encoded_pointer	UNW_OBJ (dwarf_read_encoded_pointer)
-#define dwarf_step			UNW_OBJ (dwarf_step)
+                UNW_OBJ (dwarf_extract_proc_info_from_fde)
+#define dwarf_find_save_locs            UNW_OBJ (dwarf_find_save_locs)
+#define dwarf_make_proc_info            UNW_OBJ (dwarf_make_proc_info)
+#define dwarf_apply_reg_state           UNW_OBJ (dwarf_apply_reg_state)
+#define dwarf_reg_states_iterate        UNW_OBJ (dwarf_reg_states_iterate)
+#define dwarf_read_encoded_pointer      UNW_OBJ (dwarf_read_encoded_pointer)
+#define dwarf_step                      UNW_OBJ (dwarf_step)
+#define dwarf_flush_rs_cache            UNW_OBJ (dwarf_flush_rs_cache)
 
 extern int dwarf_init (void);
 #ifndef UNW_REMOTE_ONLY
 extern int dwarf_callback (struct dl_phdr_info *info, size_t size, void *ptr);
 extern int dwarf_find_proc_info (unw_addr_space_t as, unw_word_t ip,
-				 unw_proc_info_t *pi,
-				 int need_unwind_info, void *arg);
+                                 unw_proc_info_t *pi,
+                                 int need_unwind_info, void *arg);
 #endif /* !UNW_REMOTE_ONLY */
 extern int dwarf_find_debug_frame (int found, unw_dyn_info_t *di_debug,
-				   unw_word_t ip, unw_word_t segbase,
-				   const char* obj_name, unw_word_t start,
-				   unw_word_t end);
+                                   unw_word_t ip, unw_word_t segbase,
+                                   const char* obj_name, unw_word_t start,
+                                   unw_word_t end);
 extern int dwarf_search_unwind_table (unw_addr_space_t as,
-				      unw_word_t ip,
-				      unw_dyn_info_t *di,
-				      unw_proc_info_t *pi,
-				      int need_unwind_info, void *arg);
+                                      unw_word_t ip,
+                                      unw_dyn_info_t *di,
+                                      unw_proc_info_t *pi,
+                                      int need_unwind_info, void *arg);
+
 extern int dwarf_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
-				    char *path, unw_word_t segbase, unw_word_t mapoff,
-				    unw_word_t ip);
+                                    char *path, unw_word_t segbase, unw_word_t mapoff,
+                                    unw_word_t ip);
 extern void dwarf_put_unwind_info (unw_addr_space_t as,
-				   unw_proc_info_t *pi, void *arg);
-extern int dwarf_eval_expr (struct dwarf_cursor *c, unw_word_t *addr,
-			    unw_word_t len, unw_word_t *valp,
-			    int *is_register);
+                                   unw_proc_info_t *pi, void *arg);
+extern int dwarf_eval_expr (struct dwarf_cursor *c, unw_word_t stack_val, unw_word_t *addr,
+                            unw_word_t len, unw_word_t *valp,
+                            int *is_register);
+extern int
+dwarf_stack_aligned(struct dwarf_cursor *c, unw_word_t cfa_addr,
+                    unw_word_t rbp_addr, unw_word_t *offset);
+
 extern int dwarf_extract_proc_info_from_fde (unw_addr_space_t as,
-					     unw_accessors_t *a,
-					     unw_word_t *fde_addr,
-					     unw_proc_info_t *pi,
-					     int need_unwind_info,
-					     unw_word_t base,
-					     void *arg);
+                                             unw_accessors_t *a,
+                                             unw_word_t *fde_addr,
+                                             unw_proc_info_t *pi,
+                                             unw_word_t base,
+                                             int need_unwind_info,
+                                             int is_debug_frame,
+                                             void *arg);
 extern int dwarf_find_save_locs (struct dwarf_cursor *c);
-extern int dwarf_create_state_record (struct dwarf_cursor *c,
-				      dwarf_state_record_t *sr);
 extern int dwarf_make_proc_info (struct dwarf_cursor *c);
+extern int dwarf_apply_reg_state (struct dwarf_cursor *c, struct dwarf_reg_state *rs);
+extern int dwarf_reg_states_iterate (struct dwarf_cursor *c, unw_reg_states_callback cb, void *token);
 extern int dwarf_read_encoded_pointer (unw_addr_space_t as,
-				       unw_accessors_t *a,
-				       unw_word_t *addr,
-				       unsigned char encoding,
-				       const unw_proc_info_t *pi,
-				       unw_word_t *valp, void *arg);
+                                       unw_accessors_t *a,
+                                       unw_word_t *addr,
+                                       unsigned char encoding,
+                                       const unw_proc_info_t *pi,
+                                       unw_word_t *valp, void *arg);
 extern int dwarf_step (struct dwarf_cursor *c);
+extern int dwarf_flush_rs_cache (struct dwarf_rs_cache *cache);
 
 #endif /* dwarf_h */
diff --git a/include/dwarf_i.h b/include/dwarf_i.h
index 0e72845..983b9f5 100644
--- a/include/dwarf_i.h
+++ b/include/dwarf_i.h
@@ -16,11 +16,11 @@
 #endif
 
 #ifndef dwarf_to_unw_regnum
-# define dwarf_to_unw_regnum_map		UNW_OBJ (dwarf_to_unw_regnum_map)
+# define dwarf_to_unw_regnum_map                UNW_OBJ (dwarf_to_unw_regnum_map)
 extern const uint8_t dwarf_to_unw_regnum_map[DWARF_REGNUM_MAP_LENGTH];
 /* REG is evaluated multiple times; it better be side-effects free!  */
-# define dwarf_to_unw_regnum(reg)					  \
-  (((reg) <= DWARF_REGNUM_MAP_LENGTH) ? dwarf_to_unw_regnum_map[reg] : 0)
+# define dwarf_to_unw_regnum(reg)                                         \
+  (((reg) < DWARF_REGNUM_MAP_LENGTH) ? dwarf_to_unw_regnum_map[reg] : 0)
 #endif
 
 #ifdef UNW_LOCAL_ONLY
@@ -44,7 +44,7 @@ dwarf_misaligned_value_t;
 
 static inline int
 dwarf_reads8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	      int8_t *val, void *arg)
+              int8_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -55,7 +55,7 @@ dwarf_reads8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_reads16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       int16_t *val, void *arg)
+               int16_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -66,7 +66,7 @@ dwarf_reads16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_reads32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       int32_t *val, void *arg)
+               int32_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -77,7 +77,7 @@ dwarf_reads32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_reads64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       int64_t *val, void *arg)
+               int64_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -88,7 +88,7 @@ dwarf_reads64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	      uint8_t *val, void *arg)
+              uint8_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -99,7 +99,7 @@ dwarf_readu8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       uint16_t *val, void *arg)
+               uint16_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -110,7 +110,7 @@ dwarf_readu16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       uint32_t *val, void *arg)
+               uint32_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -121,7 +121,7 @@ dwarf_readu32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       uint64_t *val, void *arg)
+               uint64_t *val, void *arg)
 {
   dwarf_misaligned_value_t *mvp = (void *) (uintptr_t) *addr;
 
@@ -134,7 +134,7 @@ dwarf_readu64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	      uint8_t *valp, void *arg)
+              uint8_t *valp, void *arg)
 {
   unw_word_t val, aligned_addr = *addr & -sizeof (unw_word_t);
   unw_word_t off = *addr - aligned_addr;
@@ -153,7 +153,7 @@ dwarf_readu8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       uint16_t *val, void *arg)
+               uint16_t *val, void *arg)
 {
   uint8_t v0, v1;
   int ret;
@@ -171,7 +171,7 @@ dwarf_readu16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       uint32_t *val, void *arg)
+               uint32_t *val, void *arg)
 {
   uint16_t v0, v1;
   int ret;
@@ -189,7 +189,7 @@ dwarf_readu32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readu64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       uint64_t *val, void *arg)
+               uint64_t *val, void *arg)
 {
   uint32_t v0, v1;
   int ret;
@@ -207,7 +207,7 @@ dwarf_readu64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_reads8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	      int8_t *val, void *arg)
+              int8_t *val, void *arg)
 {
   uint8_t uval;
   int ret;
@@ -220,7 +220,7 @@ dwarf_reads8 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_reads16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       int16_t *val, void *arg)
+               int16_t *val, void *arg)
 {
   uint16_t uval;
   int ret;
@@ -233,7 +233,7 @@ dwarf_reads16 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_reads32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       int32_t *val, void *arg)
+               int32_t *val, void *arg)
 {
   uint32_t uval;
   int ret;
@@ -246,7 +246,7 @@ dwarf_reads32 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_reads64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	       int64_t *val, void *arg)
+               int64_t *val, void *arg)
 {
   uint64_t uval;
   int ret;
@@ -261,7 +261,7 @@ dwarf_reads64 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_readw (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	     unw_word_t *val, void *arg)
+             unw_word_t *val, void *arg)
 {
   uint32_t u32;
   uint64_t u64;
@@ -272,14 +272,14 @@ dwarf_readw (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
     case 4:
       ret = dwarf_readu32 (as, a, addr, &u32, arg);
       if (ret < 0)
-	return ret;
+        return ret;
       *val = u32;
       return ret;
 
     case 8:
       ret = dwarf_readu64 (as, a, addr, &u64, arg);
       if (ret < 0)
-	return ret;
+        return ret;
       *val = u64;
       return ret;
 
@@ -293,7 +293,7 @@ dwarf_readw (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_read_uleb128 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-		    unw_word_t *valp, void *arg)
+                    unw_word_t *valp, void *arg)
 {
   unw_word_t val = 0, shift = 0;
   unsigned char byte;
@@ -302,7 +302,7 @@ dwarf_read_uleb128 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
   do
     {
       if ((ret = dwarf_readu8 (as, a, addr, &byte, arg)) < 0)
-	return ret;
+        return ret;
 
       val |= ((unw_word_t) byte & 0x7f) << shift;
       shift += 7;
@@ -318,7 +318,7 @@ dwarf_read_uleb128 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline int
 dwarf_read_sleb128 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-		    unw_word_t *valp, void *arg)
+                    unw_word_t *valp, void *arg)
 {
   unw_word_t val = 0, shift = 0;
   unsigned char byte;
@@ -327,7 +327,7 @@ dwarf_read_sleb128 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
   do
     {
       if ((ret = dwarf_readu8 (as, a, addr, &byte, arg)) < 0)
-	return ret;
+        return ret;
 
       val |= ((unw_word_t) byte & 0x7f) << shift;
       shift += 7;
@@ -344,17 +344,17 @@ dwarf_read_sleb128 (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static ALWAYS_INLINE int
 dwarf_read_encoded_pointer_inlined (unw_addr_space_t as, unw_accessors_t *a,
-				    unw_word_t *addr, unsigned char encoding,
-				    const unw_proc_info_t *pi,
-				    unw_word_t *valp, void *arg)
+                                    unw_word_t *addr, unsigned char encoding,
+                                    const unw_proc_info_t *pi,
+                                    unw_word_t *valp, void *arg)
 {
   unw_word_t val, initial_addr = *addr;
   uint16_t uval16;
   uint32_t uval32;
   uint64_t uval64;
-  int16_t sval16;
-  int32_t sval32;
-  int64_t sval64;
+  int16_t sval16 = 0;
+  int32_t sval32 = 0;
+  int64_t sval64 = 0;
   int ret;
 
   /* DW_EH_PE_omit and DW_EH_PE_aligned don't follow the normal
@@ -375,58 +375,58 @@ dwarf_read_encoded_pointer_inlined (unw_addr_space_t as, unw_accessors_t *a,
     {
     case DW_EH_PE_ptr:
       if ((ret = dwarf_readw (as, a, addr, &val, arg)) < 0)
-	return ret;
+        return ret;
       break;
 
     case DW_EH_PE_uleb128:
       if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
-	return ret;
+        return ret;
       break;
 
     case DW_EH_PE_udata2:
       if ((ret = dwarf_readu16 (as, a, addr, &uval16, arg)) < 0)
-	return ret;
+        return ret;
       val = uval16;
       break;
 
     case DW_EH_PE_udata4:
       if ((ret = dwarf_readu32 (as, a, addr, &uval32, arg)) < 0)
-	return ret;
+        return ret;
       val = uval32;
       break;
 
     case DW_EH_PE_udata8:
       if ((ret = dwarf_readu64 (as, a, addr, &uval64, arg)) < 0)
-	return ret;
+        return ret;
       val = uval64;
       break;
 
     case DW_EH_PE_sleb128:
       if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
-	return ret;
+        return ret;
       break;
 
     case DW_EH_PE_sdata2:
       if ((ret = dwarf_reads16 (as, a, addr, &sval16, arg)) < 0)
-	return ret;
+        return ret;
       val = sval16;
       break;
 
     case DW_EH_PE_sdata4:
       if ((ret = dwarf_reads32 (as, a, addr, &sval32, arg)) < 0)
-	return ret;
+        return ret;
       val = sval32;
       break;
 
     case DW_EH_PE_sdata8:
       if ((ret = dwarf_reads64 (as, a, addr, &sval64, arg)) < 0)
-	return ret;
+        return ret;
       val = sval64;
       break;
 
     default:
       Debug (1, "unexpected encoding format 0x%x\n",
-	     encoding & DW_EH_PE_FORMAT_MASK);
+             encoding & DW_EH_PE_FORMAT_MASK);
       return -UNW_EINVAL;
     }
 
@@ -462,7 +462,7 @@ dwarf_read_encoded_pointer_inlined (unw_addr_space_t as, unw_accessors_t *a,
          "segbase" member to unw_proc_info_t.  */
     default:
       Debug (1, "unexpected application type 0x%x\n",
-	     encoding & DW_EH_PE_APPL_MASK);
+             encoding & DW_EH_PE_APPL_MASK);
       return -UNW_EINVAL;
     }
 
@@ -480,7 +480,7 @@ dwarf_read_encoded_pointer_inlined (unw_addr_space_t as, unw_accessors_t *a,
       unw_word_t indirect_addr = val;
 
       if ((ret = dwarf_readw (as, a, &indirect_addr, &val, arg)) < 0)
-	return ret;
+        return ret;
     }
 
   *valp = val;
diff --git a/include/libunwind-aarch64.h b/include/libunwind-aarch64.h
new file mode 100644
index 0000000..778b436
--- /dev/null
+++ b/include/libunwind-aarch64.h
@@ -0,0 +1,245 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2001-2004 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef LIBUNWIND_H
+#define LIBUNWIND_H
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+#include <inttypes.h>
+#include <stddef.h>
+#include <ucontext.h>
+
+#define UNW_TARGET      aarch64
+#define UNW_TARGET_AARCH64      1
+
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
+
+/* This needs to be big enough to accommodate "struct cursor", while
+   leaving some slack for future expansion.  Changing this value will
+   require recompiling all users of this library.  Stack allocation is
+   relatively cheap and unwind-state copying is relatively rare, so we
+   want to err on making it rather too big than too small.
+
+   Calculation is regs used (64 + 34) * 2 + 40 (bytes of rest of
+   cursor) + padding
+*/
+
+#define UNW_TDEP_CURSOR_LEN     250
+
+typedef uint64_t unw_word_t;
+typedef int64_t unw_sword_t;
+
+typedef long double unw_tdep_fpreg_t;
+
+typedef struct
+  {
+    /* no aarch64-specific auxiliary proc-info */
+  }
+unw_tdep_proc_info_t;
+
+typedef enum
+  {
+    /* 64-bit general registers.  */
+    UNW_AARCH64_X0,
+    UNW_AARCH64_X1,
+    UNW_AARCH64_X2,
+    UNW_AARCH64_X3,
+    UNW_AARCH64_X4,
+    UNW_AARCH64_X5,
+    UNW_AARCH64_X6,
+    UNW_AARCH64_X7,
+    UNW_AARCH64_X8,
+
+    /* Temporary registers.  */
+    UNW_AARCH64_X9,
+    UNW_AARCH64_X10,
+    UNW_AARCH64_X11,
+    UNW_AARCH64_X12,
+    UNW_AARCH64_X13,
+    UNW_AARCH64_X14,
+    UNW_AARCH64_X15,
+
+    /* Intra-procedure-call temporary registers.  */
+    UNW_AARCH64_X16,
+    UNW_AARCH64_X17,
+
+    /* Callee-saved registers.  */
+    UNW_AARCH64_X18,
+    UNW_AARCH64_X19,
+    UNW_AARCH64_X20,
+    UNW_AARCH64_X21,
+    UNW_AARCH64_X22,
+    UNW_AARCH64_X23,
+    UNW_AARCH64_X24,
+    UNW_AARCH64_X25,
+    UNW_AARCH64_X26,
+    UNW_AARCH64_X27,
+    UNW_AARCH64_X28,
+
+    /* 64-bit frame pointer.  */
+    UNW_AARCH64_X29,
+
+    /* 64-bit link register.  */
+    UNW_AARCH64_X30,
+
+    /* 64-bit stack pointer.  */
+    UNW_AARCH64_SP =  31,
+    UNW_AARCH64_PC,
+    UNW_AARCH64_PSTATE,
+
+    /* 128-bit FP/Advanced SIMD registers.  */
+    UNW_AARCH64_V0 = 64,
+    UNW_AARCH64_V1,
+    UNW_AARCH64_V2,
+    UNW_AARCH64_V3,
+    UNW_AARCH64_V4,
+    UNW_AARCH64_V5,
+    UNW_AARCH64_V6,
+    UNW_AARCH64_V7,
+    UNW_AARCH64_V8,
+    UNW_AARCH64_V9,
+    UNW_AARCH64_V10,
+    UNW_AARCH64_V11,
+    UNW_AARCH64_V12,
+    UNW_AARCH64_V13,
+    UNW_AARCH64_V14,
+    UNW_AARCH64_V15,
+    UNW_AARCH64_V16,
+    UNW_AARCH64_V17,
+    UNW_AARCH64_V18,
+    UNW_AARCH64_V19,
+    UNW_AARCH64_V20,
+    UNW_AARCH64_V21,
+    UNW_AARCH64_V22,
+    UNW_AARCH64_V23,
+    UNW_AARCH64_V24,
+    UNW_AARCH64_V25,
+    UNW_AARCH64_V26,
+    UNW_AARCH64_V27,
+    UNW_AARCH64_V28,
+    UNW_AARCH64_V29,
+    UNW_AARCH64_V30,
+    UNW_AARCH64_V31,
+
+    UNW_AARCH64_FPSR,
+    UNW_AARCH64_FPCR,
+
+    /* For AArch64, the CFA is the value of SP (x31) at the call site of the
+       previous frame.  */
+    UNW_AARCH64_CFA = UNW_AARCH64_SP,
+
+    UNW_TDEP_LAST_REG = UNW_AARCH64_FPCR,
+
+    UNW_TDEP_IP = UNW_AARCH64_X30,
+    UNW_TDEP_SP = UNW_AARCH64_SP,
+    UNW_TDEP_EH = UNW_AARCH64_X0,
+
+  }
+aarch64_regnum_t;
+
+/* Use R0 through R3 to pass exception handling information.  */
+#define UNW_TDEP_NUM_EH_REGS    4
+
+typedef struct unw_tdep_save_loc
+  {
+    /* Additional target-dependent info on a save location.  */
+  }
+unw_tdep_save_loc_t;
+
+
+/* On AArch64, we can directly use ucontext_t as the unwind context,
+ * however, the __reserved struct is quite large: tune it down to only
+ * the necessary used fields.  */
+
+struct unw_sigcontext
+  {
+	uint64_t fault_address;
+	uint64_t regs[31];
+	uint64_t sp;
+	uint64_t pc;
+	uint64_t pstate;
+	uint8_t __reserved[(34 * 8)] __attribute__((__aligned__(16)));
+};
+
+typedef struct
+  {
+	unsigned long uc_flags;
+	struct ucontext *uc_link;
+	stack_t uc_stack;
+	__sigset_t uc_sigmask;
+	struct unw_sigcontext uc_mcontext;
+  } unw_tdep_context_t;
+
+typedef struct
+  {
+	uint32_t _ctx_magic;
+	uint32_t _ctx_size;
+	uint32_t fpsr;
+	uint32_t fpcr;
+	uint64_t vregs[64];
+  } unw_fpsimd_context_t;
+
+
+
+#include "libunwind-common.h"
+#include "libunwind-dynamic.h"
+
+#define unw_tdep_getcontext(uc) (({					\
+  unw_tdep_context_t *unw_ctx = (uc);					\
+  register uint64_t *unw_base __asm__ ("x0") = (uint64_t*) unw_ctx->uc_mcontext.regs;		\
+  __asm__ __volatile__ (						\
+     "stp x0, x1, [%[base], #0]\n" \
+     "stp x2, x3, [%[base], #16]\n" \
+     "stp x4, x5, [%[base], #32]\n" \
+     "stp x6, x7, [%[base], #48]\n" \
+     "stp x8, x9, [%[base], #64]\n" \
+     "stp x10, x11, [%[base], #80]\n" \
+     "stp x12, x13, [%[base], #96]\n" \
+     "stp x14, x13, [%[base], #112]\n" \
+     "stp x16, x17, [%[base], #128]\n" \
+     "stp x18, x19, [%[base], #144]\n" \
+     "stp x20, x21, [%[base], #160]\n" \
+     "stp x22, x23, [%[base], #176]\n" \
+     "stp x24, x25, [%[base], #192]\n" \
+     "stp x26, x27, [%[base], #208]\n" \
+     "stp x28, x29, [%[base], #224]\n" \
+     "str x30, [%[base], #240]\n" \
+     "mov x1, sp\n" \
+     "stp x1, x30, [%[base], #248]\n" \
+     : [base] "+r" (unw_base) : : "x1", "memory"); \
+  }), 0)
+#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+
+extern int unw_tdep_is_fpreg (int);
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif /* LIBUNWIND_H */
diff --git a/include/libunwind-arm.h b/include/libunwind-arm.h
index cba380f..6709b7a 100644
--- a/include/libunwind-arm.h
+++ b/include/libunwind-arm.h
@@ -32,10 +32,10 @@ extern "C" {
 #include <inttypes.h>
 #include <stddef.h>
 
-#define UNW_TARGET	arm
-#define UNW_TARGET_ARM	1
+#define UNW_TARGET      arm
+#define UNW_TARGET_ARM  1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /* This needs to be big enough to accommodate "struct cursor", while
    leaving some slack for future expansion.  Changing this value will
@@ -44,7 +44,7 @@ extern "C" {
    want to err on making it rather too big than too small.  */
    
 /* FIXME for ARM. Too big?  What do other things use for similar tasks?  */
-#define UNW_TDEP_CURSOR_LEN	4096
+#define UNW_TDEP_CURSOR_LEN     4096
 
 typedef uint32_t unw_word_t;
 typedef int32_t unw_sword_t;
@@ -242,7 +242,7 @@ typedef enum
   }
 arm_regnum_t;
 
-#define UNW_TDEP_NUM_EH_REGS	2	/* FIXME for ARM.  */
+#define UNW_TDEP_NUM_EH_REGS    2       /* FIXME for ARM.  */
 
 typedef struct unw_tdep_save_loc
   {
@@ -263,22 +263,23 @@ unw_tdep_context_t;
    registers.  FIXME: Not ideal, may not be sufficient for all libunwind
    use cases.  Stores pc+8, which is only approximately correct, really.  */
 #ifndef __thumb__
-#define unw_tdep_getcontext(uc) (({					\
-  unw_tdep_context_t *unw_ctx = (uc);					\
-  register unsigned long *unw_base asm ("r0") = unw_ctx->regs;		\
-  __asm__ __volatile__ (						\
-    "stmia %[base], {r0-r15}"						\
-    : : [base] "r" (unw_base) : "memory");				\
+#define unw_tdep_getcontext(uc) (({                                     \
+  unw_tdep_context_t *unw_ctx = (uc);                                   \
+  register unsigned long *unw_base __asm__ ("r0") = unw_ctx->regs;      \
+  __asm__ __volatile__ (                                                \
+    "stmia %[base], {r0-r15}"                                           \
+    : : [base] "r" (unw_base) : "memory");                              \
   }), 0)
 #else /* __thumb__ */
-#define unw_tdep_getcontext(uc) (({					\
-  unw_tdep_context_t *unw_ctx = (uc);					\
-  register unsigned long *unw_base asm ("r0") = unw_ctx->regs;		\
-  __asm__ __volatile__ (						\
-    ".align 2\nbx pc\nnop\n.code 32\n"					\
-    "stmia %[base], {r0-r15}\n"						\
-    "orr %[base], pc, #1\nbx %[base]"					\
-    : [base] "+r" (unw_base) : : "memory", "cc");			\
+#define unw_tdep_getcontext(uc) (({                                     \
+  unw_tdep_context_t *unw_ctx = (uc);                                   \
+  register unsigned long *unw_base __asm__ ("r0") = unw_ctx->regs;      \
+  __asm__ __volatile__ (                                                \
+    ".align 2\nbx pc\nnop\n.code 32\n"                                  \
+    "stmia %[base], {r0-r15}\n"                                         \
+    "orr %[base], pc, #1\nbx %[base]\n"                                 \
+    ".code 16\n"							\
+    : [base] "+r" (unw_base) : : "memory", "cc");                       \
   }), 0)
 #endif
 
@@ -292,7 +293,7 @@ unw_tdep_proc_info_t;
 
 #include "libunwind-common.h"
 
-#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
 extern int unw_tdep_is_fpreg (int);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/include/libunwind-common.h.in b/include/libunwind-common.h.in
index fa753ba..c82a8b9 100644
--- a/include/libunwind-common.h.in
+++ b/include/libunwind-common.h.in
@@ -86,6 +86,12 @@ typedef enum
   }
 unw_caching_policy_t;
 
+typedef enum
+  {
+    UNW_INIT_SIGNAL_FRAME = 1,          /* We know this is a signal frame */
+  }
+unw_init_local2_flags_t;
+
 typedef int unw_regnum_t;
 
 /* The unwind cursor starts at the youngest (most deeply nested) frame
@@ -126,6 +132,9 @@ typedef struct unw_proc_info
   {
     unw_word_t start_ip;	/* first IP covered by this procedure */
     unw_word_t end_ip;		/* first IP NOT covered by this procedure */
+#if defined(NEED_LAST_IP)
+    unw_word_t last_ip;		/* first IP that could begin another procedure */
+#endif
     unw_word_t lsda;		/* address of lang.-spec. data area (if any) */
     unw_word_t handler;		/* optional personality routine */
     unw_word_t gp;		/* global-pointer value for this procedure */
@@ -138,6 +147,11 @@ typedef struct unw_proc_info
   }
 unw_proc_info_t;
 
+typedef int (*unw_reg_states_callback)(void *token,
+				       void *reg_states_data,
+				       size_t reg_states_data_size,
+				       unw_word_t start_ip, unw_word_t end_ip);
+
 /* These are backend callback routines that provide access to the
    state of a "remote" process.  This can be used, for example, to
    unwind another process through the ptrace() interface.  */
@@ -210,21 +224,25 @@ unw_save_loc_t;
 #define unw_create_addr_space	UNW_OBJ(create_addr_space)
 #define unw_destroy_addr_space	UNW_OBJ(destroy_addr_space)
 #define unw_get_accessors	UNW_ARCH_OBJ(get_accessors)
+#define unw_get_accessors_int	UNW_ARCH_OBJ(get_accessors_int)
 #define unw_init_local		UNW_OBJ(init_local)
+#define unw_init_local2	        UNW_OBJ(init_local2)
 #define unw_init_remote		UNW_OBJ(init_remote)
 #define unw_step		UNW_OBJ(step)
 #define unw_resume		UNW_OBJ(resume)
 #define unw_get_proc_info	UNW_OBJ(get_proc_info)
 #define unw_get_proc_info_by_ip	UNW_OBJ(get_proc_info_by_ip)
+#define unw_reg_states_iterate  UNW_OBJ(reg_states_iterate)
+#define unw_apply_reg_state     UNW_OBJ(apply_reg_state)
 #define unw_get_reg		UNW_OBJ(get_reg)
 #define unw_set_reg		UNW_OBJ(set_reg)
 #define unw_get_fpreg		UNW_OBJ(get_fpreg)
 #define unw_set_fpreg		UNW_OBJ(set_fpreg)
 #define unw_get_save_loc	UNW_OBJ(get_save_loc)
 #define unw_is_signal_frame	UNW_OBJ(is_signal_frame)
-#define unw_handle_signal_frame	UNW_OBJ(handle_signal_frame)
 #define unw_get_proc_name	UNW_OBJ(get_proc_name)
 #define unw_set_caching_policy	UNW_OBJ(set_caching_policy)
+#define unw_set_cache_size	UNW_OBJ(set_cache_size)
 #define unw_regname		UNW_ARCH_OBJ(regname)
 #define unw_flush_cache		UNW_ARCH_OBJ(flush_cache)
 #define unw_strerror		UNW_ARCH_OBJ(strerror)
@@ -232,24 +250,28 @@ unw_save_loc_t;
 extern unw_addr_space_t unw_create_addr_space (unw_accessors_t *, int);
 extern void unw_destroy_addr_space (unw_addr_space_t);
 extern unw_accessors_t *unw_get_accessors (unw_addr_space_t);
+extern unw_accessors_t *unw_get_accessors_int (unw_addr_space_t);
 extern void unw_flush_cache (unw_addr_space_t, unw_word_t, unw_word_t);
 extern int unw_set_caching_policy (unw_addr_space_t, unw_caching_policy_t);
+extern int unw_set_cache_size (unw_addr_space_t, size_t, int);
 extern const char *unw_regname (unw_regnum_t);
 
 extern int unw_init_local (unw_cursor_t *, unw_context_t *);
+extern int unw_init_local2 (unw_cursor_t *, unw_context_t *, int);
 extern int unw_init_remote (unw_cursor_t *, unw_addr_space_t, void *);
 extern int unw_step (unw_cursor_t *);
 extern int unw_resume (unw_cursor_t *);
 extern int unw_get_proc_info (unw_cursor_t *, unw_proc_info_t *);
 extern int unw_get_proc_info_by_ip (unw_addr_space_t, unw_word_t,
 				    unw_proc_info_t *, void *);
+extern int unw_reg_states_iterate (unw_cursor_t *, unw_reg_states_callback, void *);
+extern int unw_apply_reg_state (unw_cursor_t *, void *);
 extern int unw_get_reg (unw_cursor_t *, int, unw_word_t *);
 extern int unw_set_reg (unw_cursor_t *, int, unw_word_t);
 extern int unw_get_fpreg (unw_cursor_t *, int, unw_fpreg_t *);
 extern int unw_set_fpreg (unw_cursor_t *, int, unw_fpreg_t);
 extern int unw_get_save_loc (unw_cursor_t *, int, unw_save_loc_t *);
 extern int unw_is_signal_frame (unw_cursor_t *);
-extern int unw_handle_signal_frame (unw_cursor_t *);
 extern int unw_get_proc_name (unw_cursor_t *, char *, size_t, unw_word_t *);
 extern const char *unw_strerror (int);
 extern int unw_backtrace (void **, int);
diff --git a/include/libunwind-coredump.h b/include/libunwind-coredump.h
index d2b05e7..3c78141 100644
--- a/include/libunwind-coredump.h
+++ b/include/libunwind-coredump.h
@@ -46,22 +46,22 @@ extern pid_t _UCD_get_pid(struct UCD_info *);
 extern int _UCD_get_cursig(struct UCD_info *);
 extern int _UCD_add_backing_file_at_segment(struct UCD_info *, int phdr_no, const char *filename);
 extern int _UCD_add_backing_file_at_vaddr(struct UCD_info *,
-				          unsigned long vaddr,
-					  const char *filename);
+                                          unsigned long vaddr,
+                                          const char *filename);
 
 extern int _UCD_find_proc_info (unw_addr_space_t, unw_word_t,
-				unw_proc_info_t *, int, void *);
+                                unw_proc_info_t *, int, void *);
 extern void _UCD_put_unwind_info (unw_addr_space_t, unw_proc_info_t *, void *);
 extern int _UCD_get_dyn_info_list_addr (unw_addr_space_t, unw_word_t *,
-					void *);
+                                        void *);
 extern int _UCD_access_mem (unw_addr_space_t, unw_word_t, unw_word_t *, int,
-			    void *);
+                            void *);
 extern int _UCD_access_reg (unw_addr_space_t, unw_regnum_t, unw_word_t *,
-			    int, void *);
+                            int, void *);
 extern int _UCD_access_fpreg (unw_addr_space_t, unw_regnum_t, unw_fpreg_t *,
-			      int, void *);
+                              int, void *);
 extern int _UCD_get_proc_name (unw_addr_space_t, unw_word_t, char *, size_t,
-			       unw_word_t *, void *);
+                               unw_word_t *, void *);
 extern int _UCD_resume (unw_addr_space_t, unw_cursor_t *, void *);
 extern unw_accessors_t _UCD_accessors;
 
diff --git a/include/libunwind-dynamic.h b/include/libunwind-dynamic.h
index 584f392..edb0bbd 100644
--- a/include/libunwind-dynamic.h
+++ b/include/libunwind-dynamic.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -59,50 +59,54 @@ the following rules should be followed in declaring these structures:
 
 typedef enum
   {
-    UNW_DYN_STOP = 0,		/* end-of-unwind-info marker */
-    UNW_DYN_SAVE_REG,		/* save register to another register */
-    UNW_DYN_SPILL_FP_REL,	/* frame-pointer-relative register spill */
-    UNW_DYN_SPILL_SP_REL,	/* stack-pointer-relative register spill */
-    UNW_DYN_ADD,		/* add constant value to a register */
-    UNW_DYN_POP_FRAMES,		/* drop one or more stack frames */
-    UNW_DYN_LABEL_STATE,	/* name the current state */
-    UNW_DYN_COPY_STATE,		/* set the region's entry-state */
-    UNW_DYN_ALIAS		/* get unwind info from an alias */
+    UNW_DYN_STOP = 0,           /* end-of-unwind-info marker */
+    UNW_DYN_SAVE_REG,           /* save register to another register */
+    UNW_DYN_SPILL_FP_REL,       /* frame-pointer-relative register spill */
+    UNW_DYN_SPILL_SP_REL,       /* stack-pointer-relative register spill */
+    UNW_DYN_ADD,                /* add constant value to a register */
+    UNW_DYN_POP_FRAMES,         /* drop one or more stack frames */
+    UNW_DYN_LABEL_STATE,        /* name the current state */
+    UNW_DYN_COPY_STATE,         /* set the region's entry-state */
+    UNW_DYN_ALIAS               /* get unwind info from an alias */
   }
 unw_dyn_operation_t;
 
 typedef enum
   {
-    UNW_INFO_FORMAT_DYNAMIC,		/* unw_dyn_proc_info_t */
-    UNW_INFO_FORMAT_TABLE,		/* unw_dyn_table_t */
-    UNW_INFO_FORMAT_REMOTE_TABLE,	/* unw_dyn_remote_table_t */
-    UNW_INFO_FORMAT_ARM_EXIDX		/* ARM specific unwind info */
+    UNW_INFO_FORMAT_DYNAMIC,            /* unw_dyn_proc_info_t */
+    UNW_INFO_FORMAT_TABLE,              /* unw_dyn_table_t */
+    UNW_INFO_FORMAT_REMOTE_TABLE,       /* unw_dyn_remote_table_t */
+    UNW_INFO_FORMAT_ARM_EXIDX,          /* ARM specific unwind info */
+    UNW_INFO_FORMAT_IP_OFFSET,          /* Like UNW_INFO_FORMAT_REMOTE_TABLE, but
+                                           table entries are considered
+                                           relative to di->start_ip, rather
+                                           than di->segbase */
   }
 unw_dyn_info_format_t;
 
 typedef struct unw_dyn_op
   {
-    int8_t tag;				/* what operation? */
-    int8_t qp;				/* qualifying predicate register */
-    int16_t reg;			/* what register */
-    int32_t when;			/* when does it take effect? */
-    unw_word_t val;			/* auxiliary value */
+    int8_t tag;                         /* what operation? */
+    int8_t qp;                          /* qualifying predicate register */
+    int16_t reg;                        /* what register */
+    int32_t when;                       /* when does it take effect? */
+    unw_word_t val;                     /* auxiliary value */
   }
 unw_dyn_op_t;
 
 typedef struct unw_dyn_region_info
   {
-    struct unw_dyn_region_info *next;	/* linked list of regions */
-    int32_t insn_count;			/* region length (# of instructions) */
-    uint32_t op_count;			/* length of op-array */
-    unw_dyn_op_t op[1];			/* variable-length op-array */
+    struct unw_dyn_region_info *next;   /* linked list of regions */
+    int32_t insn_count;                 /* region length (# of instructions) */
+    uint32_t op_count;                  /* length of op-array */
+    unw_dyn_op_t op[1];                 /* variable-length op-array */
   }
 unw_dyn_region_info_t;
 
 typedef struct unw_dyn_proc_info
   {
-    unw_word_t name_ptr;	/* address of human-readable procedure name */
-    unw_word_t handler;		/* address of personality routine */
+    unw_word_t name_ptr;        /* address of human-readable procedure name */
+    unw_word_t handler;         /* address of personality routine */
     uint32_t flags;
     int32_t pad0;
     unw_dyn_region_info_t *regions;
@@ -111,18 +115,18 @@ unw_dyn_proc_info_t;
 
 typedef struct unw_dyn_table_info
   {
-    unw_word_t name_ptr;	/* addr. of table name (e.g., library name) */
-    unw_word_t segbase;		/* segment base */
-    unw_word_t table_len;	/* must be a multiple of sizeof(unw_word_t)! */
+    unw_word_t name_ptr;        /* addr. of table name (e.g., library name) */
+    unw_word_t segbase;         /* segment base */
+    unw_word_t table_len;       /* must be a multiple of sizeof(unw_word_t)! */
     unw_word_t *table_data;
   }
 unw_dyn_table_info_t;
 
 typedef struct unw_dyn_remote_table_info
   {
-    unw_word_t name_ptr;	/* addr. of table name (e.g., library name) */
-    unw_word_t segbase;		/* segment base */
-    unw_word_t table_len;	/* must be a multiple of sizeof(unw_word_t)! */
+    unw_word_t name_ptr;        /* addr. of table name (e.g., library name) */
+    unw_word_t segbase;         /* segment base */
+    unw_word_t table_len;       /* must be a multiple of sizeof(unw_word_t)! */
     unw_word_t table_data;
   }
 unw_dyn_remote_table_info_t;
@@ -132,16 +136,16 @@ typedef struct unw_dyn_info
     /* doubly-linked list of dyn-info structures: */
     struct unw_dyn_info *next;
     struct unw_dyn_info *prev;
-    unw_word_t start_ip;	/* first IP covered by this entry */
-    unw_word_t end_ip;		/* first IP NOT covered by this entry */
-    unw_word_t gp;		/* global-pointer in effect for this entry */
-    int32_t format;		/* real type: unw_dyn_info_format_t */
+    unw_word_t start_ip;        /* first IP covered by this entry */
+    unw_word_t end_ip;          /* first IP NOT covered by this entry */
+    unw_word_t gp;              /* global-pointer in effect for this entry */
+    int32_t format;             /* real type: unw_dyn_info_format_t */
     int32_t pad;
     union
       {
-	unw_dyn_proc_info_t pi;
-	unw_dyn_table_info_t ti;
-	unw_dyn_remote_table_info_t rti;
+        unw_dyn_proc_info_t pi;
+        unw_dyn_table_info_t ti;
+        unw_dyn_remote_table_info_t rti;
       }
     u;
   }
@@ -157,9 +161,9 @@ unw_dyn_info_list_t;
 
 /* Return the size (in bytes) of an unw_dyn_region_info_t structure that can
    hold OP_COUNT ops.  */
-#define _U_dyn_region_info_size(op_count)				\
-	((char *) (((unw_dyn_region_info_t *) NULL)->op + (op_count))	\
-	 - (char *) NULL)
+#define _U_dyn_region_info_size(op_count)                               \
+        ((char *) (((unw_dyn_region_info_t *) NULL)->op + (op_count))   \
+         - (char *) NULL)
 
 /* Register the unwind info for a single procedure.
    This routine is NOT signal-safe.  */
@@ -172,39 +176,39 @@ extern void _U_dyn_cancel (unw_dyn_info_t *);
 
 /* Convenience routines.  */
 
-#define _U_dyn_op(_tag, _qp, _when, _reg, _val)				\
-	((unw_dyn_op_t) { (_tag), (_qp), (_reg), (_when), (_val) })
+#define _U_dyn_op(_tag, _qp, _when, _reg, _val)                         \
+        ((unw_dyn_op_t) { (_tag), (_qp), (_reg), (_when), (_val) })
 
-#define _U_dyn_op_save_reg(op, qp, when, reg, dst)			\
-	(*(op) = _U_dyn_op (UNW_DYN_SAVE_REG, (qp), (when), (reg), (dst)))
+#define _U_dyn_op_save_reg(op, qp, when, reg, dst)                      \
+        (*(op) = _U_dyn_op (UNW_DYN_SAVE_REG, (qp), (when), (reg), (dst)))
 
-#define _U_dyn_op_spill_fp_rel(op, qp, when, reg, offset)		\
-	(*(op) = _U_dyn_op (UNW_DYN_SPILL_FP_REL, (qp), (when), (reg),	\
-			    (offset)))
+#define _U_dyn_op_spill_fp_rel(op, qp, when, reg, offset)               \
+        (*(op) = _U_dyn_op (UNW_DYN_SPILL_FP_REL, (qp), (when), (reg),  \
+                            (offset)))
 
-#define _U_dyn_op_spill_sp_rel(op, qp, when, reg, offset)		\
-	(*(op) = _U_dyn_op (UNW_DYN_SPILL_SP_REL, (qp), (when), (reg),	\
-			    (offset)))
+#define _U_dyn_op_spill_sp_rel(op, qp, when, reg, offset)               \
+        (*(op) = _U_dyn_op (UNW_DYN_SPILL_SP_REL, (qp), (when), (reg),  \
+                            (offset)))
 
-#define _U_dyn_op_add(op, qp, when, reg, value)				\
-	(*(op) = _U_dyn_op (UNW_DYN_ADD, (qp), (when), (reg), (value)))
+#define _U_dyn_op_add(op, qp, when, reg, value)                         \
+        (*(op) = _U_dyn_op (UNW_DYN_ADD, (qp), (when), (reg), (value)))
 
-#define _U_dyn_op_pop_frames(op, qp, when, num_frames)			\
-	(*(op) = _U_dyn_op (UNW_DYN_POP_FRAMES, (qp), (when), 0, (num_frames)))
+#define _U_dyn_op_pop_frames(op, qp, when, num_frames)                  \
+        (*(op) = _U_dyn_op (UNW_DYN_POP_FRAMES, (qp), (when), 0, (num_frames)))
 
-#define _U_dyn_op_label_state(op, label)				\
-	(*(op) = _U_dyn_op (UNW_DYN_LABEL_STATE, _U_QP_TRUE, -1, 0, (label)))
+#define _U_dyn_op_label_state(op, label)                                \
+        (*(op) = _U_dyn_op (UNW_DYN_LABEL_STATE, _U_QP_TRUE, -1, 0, (label)))
 
-#define _U_dyn_op_copy_state(op, label)					\
-	(*(op) = _U_dyn_op (UNW_DYN_COPY_STATE, _U_QP_TRUE, -1, 0, (label)))
+#define _U_dyn_op_copy_state(op, label)                                 \
+        (*(op) = _U_dyn_op (UNW_DYN_COPY_STATE, _U_QP_TRUE, -1, 0, (label)))
 
-#define _U_dyn_op_alias(op, qp, when, addr)				\
-	(*(op) = _U_dyn_op (UNW_DYN_ALIAS, (qp), (when), 0, (addr)))
+#define _U_dyn_op_alias(op, qp, when, addr)                             \
+        (*(op) = _U_dyn_op (UNW_DYN_ALIAS, (qp), (when), 0, (addr)))
 
-#define _U_dyn_op_stop(op)						\
-	(*(op) = _U_dyn_op (UNW_DYN_STOP, _U_QP_TRUE, -1, 0, 0))
+#define _U_dyn_op_stop(op)                                              \
+        (*(op) = _U_dyn_op (UNW_DYN_STOP, _U_QP_TRUE, -1, 0, 0))
 
 /* The target-dependent qualifying predicate which is always TRUE.  On
    IA-64, that's p0 (0), on non-predicated architectures, the value is
    ignored.  */
-#define _U_QP_TRUE	_U_TDEP_QP_TRUE
+#define _U_QP_TRUE      _U_TDEP_QP_TRUE
diff --git a/include/libunwind-hppa.h b/include/libunwind-hppa.h
index 74ea70d..7013aa7 100644
--- a/include/libunwind-hppa.h
+++ b/include/libunwind-hppa.h
@@ -32,17 +32,17 @@ extern "C" {
 #include <inttypes.h>
 #include <ucontext.h>
 
-#define UNW_TARGET	hppa
-#define UNW_TARGET_HPPA	1
+#define UNW_TARGET      hppa
+#define UNW_TARGET_HPPA 1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /* This needs to be big enough to accommodate "struct cursor", while
    leaving some slack for future expansion.  Changing this value will
    require recompiling all users of this library.  Stack allocation is
    relatively cheap and unwind-state copying is relatively rare, so we
    want to err on making it rather too big than too small.  */
-#define UNW_TDEP_CURSOR_LEN	511
+#define UNW_TDEP_CURSOR_LEN     511
 
 typedef uint32_t unw_word_t;
 typedef int32_t unw_sword_t;
@@ -61,13 +61,13 @@ typedef enum
        implementation of the C++ exception handling ABI.  See
        _Unwind_SetGR() and _Unwind_GetGR() for details.  */
     UNW_HPPA_GR = 0,
-     UNW_HPPA_RP = 2,			/* return pointer */
-     UNW_HPPA_FP = 3,			/* frame pointer */
+     UNW_HPPA_RP = 2,                   /* return pointer */
+     UNW_HPPA_FP = 3,                   /* frame pointer */
      UNW_HPPA_SP = UNW_HPPA_GR + 30,
 
     UNW_HPPA_FR = UNW_HPPA_GR + 32,
 
-    UNW_HPPA_IP = UNW_HPPA_FR + 32,	/* instruction pointer */
+    UNW_HPPA_IP = UNW_HPPA_FR + 32,     /* instruction pointer */
 
     /* other "preserved" registers (fpsr etc.)... */
 
@@ -76,10 +76,10 @@ typedef enum
        exception-handling registers which we then alias to the actual
        physical register.  */
 
-    UNW_HPPA_EH0 = UNW_HPPA_IP + 1,	/* alias for UNW_HPPA_GR + 20 */
-    UNW_HPPA_EH1 = UNW_HPPA_EH0 + 1,	/* alias for UNW_HPPA_GR + 21 */
-    UNW_HPPA_EH2 = UNW_HPPA_EH1 + 1,	/* alias for UNW_HPPA_GR + 22 */
-    UNW_HPPA_EH3 = UNW_HPPA_EH2 + 1,	/* alias for UNW_HPPA_GR + 31 */
+    UNW_HPPA_EH0 = UNW_HPPA_IP + 1,     /* alias for UNW_HPPA_GR + 20 */
+    UNW_HPPA_EH1 = UNW_HPPA_EH0 + 1,    /* alias for UNW_HPPA_GR + 21 */
+    UNW_HPPA_EH2 = UNW_HPPA_EH1 + 1,    /* alias for UNW_HPPA_GR + 22 */
+    UNW_HPPA_EH3 = UNW_HPPA_EH2 + 1,    /* alias for UNW_HPPA_GR + 31 */
 
     /* frame info (read-only) */
     UNW_HPPA_CFA,
@@ -92,7 +92,7 @@ typedef enum
   }
 hppa_regnum_t;
 
-#define UNW_TDEP_NUM_EH_REGS	4
+#define UNW_TDEP_NUM_EH_REGS    4
 
 typedef struct unw_tdep_save_loc
   {
@@ -103,7 +103,7 @@ unw_tdep_save_loc_t;
 /* On PA-RISC, we can directly use ucontext_t as the unwind context.  */
 typedef ucontext_t unw_tdep_context_t;
 
-#define unw_tdep_is_fpreg(r)		((unsigned) ((r) - UNW_HPPA_FR) < 32)
+#define unw_tdep_is_fpreg(r)            ((unsigned) ((r) - UNW_HPPA_FR) < 32)
 
 #include "libunwind-dynamic.h"
 
@@ -115,7 +115,7 @@ unw_tdep_proc_info_t;
 
 #include "libunwind-common.h"
 
-#define unw_tdep_getcontext		UNW_ARCH_OBJ (getcontext)
+#define unw_tdep_getcontext             UNW_ARCH_OBJ (getcontext)
 extern int unw_tdep_getcontext (unw_tdep_context_t *);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/include/libunwind-ia64.h b/include/libunwind-ia64.h
index fb2fbfe..0cc4f39 100644
--- a/include/libunwind-ia64.h
+++ b/include/libunwind-ia64.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -47,24 +47,24 @@ extern "C" {
 # define UNW_GENERIC_ONLY
 #endif
 
-#define UNW_TARGET	ia64
-#define UNW_TARGET_IA64	1
+#define UNW_TARGET      ia64
+#define UNW_TARGET_IA64 1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /* This needs to be big enough to accommodate "struct cursor", while
    leaving some slack for future expansion.  Changing this value will
    require recompiling all users of this library.  Stack allocation is
    relatively cheap and unwind-state copying is relatively rare, so we
    want to err on making it rather too big than too small.  */
-#define UNW_TDEP_CURSOR_LEN	511
+#define UNW_TDEP_CURSOR_LEN     511
 
 /* If this bit is it indicates that the procedure saved all of ar.bsp,
    ar.bspstore, and ar.rnat.  If, additionally, ar.bsp != saved ar.bsp,
    then this procedure has performed a register-backing-store switch.  */
-#define UNW_PI_FLAG_IA64_RBS_SWITCH_BIT	(UNW_PI_FLAG_FIRST_TDEP_BIT + 0)
+#define UNW_PI_FLAG_IA64_RBS_SWITCH_BIT (UNW_PI_FLAG_FIRST_TDEP_BIT + 0)
 
-#define UNW_PI_FLAG_IA64_RBS_SWITCH	(1 << UNW_PI_FLAG_IA64_RBS_SWITCH_BIT)
+#define UNW_PI_FLAG_IA64_RBS_SWITCH     (1 << UNW_PI_FLAG_IA64_RBS_SWITCH_BIT)
 
 typedef uint64_t unw_word_t;
 typedef int64_t unw_sword_t;
@@ -76,7 +76,7 @@ typedef int64_t unw_sword_t;
 typedef union
   {
     struct { unw_word_t bits[2]; } raw;
-    long double dummy;	/* dummy to force 16-byte alignment */
+    long double dummy;  /* dummy to force 16-byte alignment */
   }
 unw_tdep_fpreg_t;
 
@@ -92,15 +92,15 @@ typedef enum
        This convention facilitates architecture-independent
        implementation of the C++ exception handling ABI.  See
        _Unwind_SetGR() and _Unwind_GetGR() for details.  */
-    UNW_IA64_GR = 0,			/* general registers (r0..r127) */
+    UNW_IA64_GR = 0,                    /* general registers (r0..r127) */
      UNW_IA64_GP = UNW_IA64_GR + 1,
      UNW_IA64_TP = UNW_IA64_GR + 13,
 
-    UNW_IA64_NAT = UNW_IA64_GR + 128,	/* NaT registers (nat0..nat127) */
+    UNW_IA64_NAT = UNW_IA64_GR + 128,   /* NaT registers (nat0..nat127) */
 
-    UNW_IA64_FR = UNW_IA64_NAT + 128,	/* fp registers (f0..f127) */
+    UNW_IA64_FR = UNW_IA64_NAT + 128,   /* fp registers (f0..f127) */
 
-    UNW_IA64_AR = UNW_IA64_FR + 128,	/* application registers (ar0..r127) */
+    UNW_IA64_AR = UNW_IA64_FR + 128,    /* application registers (ar0..r127) */
      UNW_IA64_AR_RSC = UNW_IA64_AR + 16,
      UNW_IA64_AR_BSP = UNW_IA64_AR + 17,
      UNW_IA64_AR_BSPSTORE = UNW_IA64_AR + 18,
@@ -115,9 +115,9 @@ typedef enum
      UNW_IA64_AR_LC = UNW_IA64_AR + 65,
      UNW_IA64_AR_EC = UNW_IA64_AR + 66,
 
-    UNW_IA64_BR = UNW_IA64_AR + 128,	/* branch registers (b0..p7) */
-      UNW_IA64_RP = UNW_IA64_BR + 0,	/* return pointer (rp) */
-    UNW_IA64_PR = UNW_IA64_BR + 8,	/* predicate registers (p0..p63) */
+    UNW_IA64_BR = UNW_IA64_AR + 128,    /* branch registers (b0..p7) */
+      UNW_IA64_RP = UNW_IA64_BR + 0,    /* return pointer (rp) */
+    UNW_IA64_PR = UNW_IA64_BR + 8,      /* predicate registers (p0..p63) */
     UNW_IA64_CFM,
 
     /* frame info: */
@@ -133,7 +133,7 @@ typedef enum
   }
 ia64_regnum_t;
 
-#define UNW_TDEP_NUM_EH_REGS	4	/* r15-r18 are exception args */
+#define UNW_TDEP_NUM_EH_REGS    4       /* r15-r18 are exception args */
 
 typedef struct unw_tdep_save_loc
   {
@@ -150,7 +150,7 @@ unw_tdep_save_loc_t;
 /* On IA-64, we can directly use ucontext_t as the unwind context.  */
 typedef ucontext_t unw_tdep_context_t;
 
-#define unw_tdep_is_fpreg(r)		((unsigned) ((r) - UNW_IA64_FR) < 128)
+#define unw_tdep_is_fpreg(r)            ((unsigned) ((r) - UNW_IA64_FR) < 128)
 
 #include "libunwind-dynamic.h"
 #include "libunwind-common.h"
@@ -159,9 +159,9 @@ typedef ucontext_t unw_tdep_context_t;
   /* In theory, we could use _Uia64_getcontext() on HP-UX as well, but
      the benefit of doing so would be marginal given that it can't
      support UNW_LOCAL_ONLY.  */
-# define unw_tdep_getcontext		getcontext
+# define unw_tdep_getcontext            getcontext
 #else
-# define unw_tdep_getcontext		UNW_ARCH_OBJ (getcontext)
+# define unw_tdep_getcontext            UNW_ARCH_OBJ (getcontext)
   extern int unw_tdep_getcontext (unw_tdep_context_t *);
 #endif
 
@@ -171,17 +171,17 @@ typedef ucontext_t unw_tdep_context_t;
    with malloc(), and should be free()d during the put_unwind_info()
    callback.  This routine is signal-safe for the local-address-space
    case ONLY.  */
-#define unw_search_ia64_unwind_table	UNW_OBJ(search_unwind_table)
+#define unw_search_ia64_unwind_table    UNW_OBJ(search_unwind_table)
 extern int unw_search_ia64_unwind_table (unw_addr_space_t, unw_word_t,
-					 unw_dyn_info_t *, unw_proc_info_t *,
-					 int, void *);
+                                         unw_dyn_info_t *, unw_proc_info_t *,
+                                         int, void *);
 
 /* This is a helper routine which the get_dyn_info_list_addr()
    callback can use to locate the special dynamic-info list entry in
    an IA-64 unwind table.  If the entry exists in the table, the
    list-address is returned.  In all other cases, 0 is returned.  */
 extern unw_word_t _Uia64_find_dyn_list (unw_addr_space_t, unw_dyn_info_t *,
-					void *);
+                                        void *);
 
 /* This is a helper routine to obtain the kernel-unwind info.  It is
    signal-safe.  */
diff --git a/include/libunwind-mips.h b/include/libunwind-mips.h
index cf22fc9..ced34b2 100644
--- a/include/libunwind-mips.h
+++ b/include/libunwind-mips.h
@@ -30,16 +30,16 @@ extern "C" {
 #endif
 
 #include <inttypes.h>
-#include <ucontext.h>
+#include <sys/ucontext.h>
 
 #ifdef mips
 # undef mips
 #endif
 
-#define UNW_TARGET	mips
-#define UNW_TARGET_MIPS	1
+#define UNW_TARGET      mips
+#define UNW_TARGET_MIPS 1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /* This needs to be big enough to accommodate "struct cursor", while
    leaving some slack for future expansion.  Changing this value will
@@ -48,13 +48,16 @@ extern "C" {
    want to err on making it rather too big than too small.  */
    
 /* FIXME for MIPS. Too big?  What do other things use for similar tasks?  */
-#define UNW_TDEP_CURSOR_LEN	4096
+#define UNW_TDEP_CURSOR_LEN     4096
 
-/* The size of a "word" varies on MIPS.  This type is used for memory
-   addresses and register values.  To allow a single library to support
-   multiple ABIs, and to support N32 at all, we must use a 64-bit type
-   even when addresses are only 32 bits.  */
+/* The size of a "word" varies on MIPS. This type is used for memory
+   addresses and register values, which are 32-bit wide for O32 and N32 
+   ABIs, and 64-bit wide for N64 ABI. */
+#if _MIPS_SIM == _ABI64
 typedef uint64_t unw_word_t;
+#else
+typedef uint32_t unw_word_t;
+#endif
 typedef int32_t unw_sword_t;
 
 /* FIXME: MIPS ABIs.  */
@@ -95,7 +98,7 @@ typedef enum
     UNW_MIPS_R30,
     UNW_MIPS_R31,
 
-    UNW_MIPS_PC = 34,
+    UNW_MIPS_PC = 64,
 
     /* FIXME: Other registers!  */
 
@@ -103,7 +106,7 @@ typedef enum
        previous frame.  */
     UNW_MIPS_CFA,
 
-    UNW_TDEP_LAST_REG = UNW_MIPS_R31,
+    UNW_TDEP_LAST_REG = UNW_MIPS_PC,
 
     UNW_TDEP_IP = UNW_MIPS_R31,
     UNW_TDEP_SP = UNW_MIPS_R29,
@@ -119,7 +122,7 @@ typedef enum
   }
 mips_abi_t;
 
-#define UNW_TDEP_NUM_EH_REGS	2	/* FIXME for MIPS.  */
+#define UNW_TDEP_NUM_EH_REGS    2       /* FIXME for MIPS.  */
 
 typedef struct unw_tdep_save_loc
   {
@@ -147,7 +150,7 @@ unw_tdep_proc_info_t;
 #define unw_tdep_getcontext UNW_ARCH_OBJ(getcontext)
 extern int unw_tdep_getcontext (ucontext_t *uc);
 
-#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
 extern int unw_tdep_is_fpreg (int);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/include/libunwind-ppc32.h b/include/libunwind-ppc32.h
index b40a84e..47ebfde 100644
--- a/include/libunwind-ppc32.h
+++ b/include/libunwind-ppc32.h
@@ -39,10 +39,10 @@ extern "C" {
 #include <inttypes.h>
 #include <ucontext.h>
 
-#define UNW_TARGET		ppc32
-#define UNW_TARGET_PPC32	1
+#define UNW_TARGET              ppc32
+#define UNW_TARGET_PPC32        1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /*
  * This needs to be big enough to accommodate "struct cursor", while
@@ -62,7 +62,7 @@ extern "C" {
  * round that up to 280.
  */
 
-#define UNW_TDEP_CURSOR_LEN 200
+#define UNW_TDEP_CURSOR_LEN 280
 
 #if __WORDSIZE==32
 typedef uint32_t unw_word_t;
@@ -170,7 +170,7 @@ ppc32_regnum_t;
  * passing parameters to exception handlers.
  */
 
-#define UNW_TDEP_NUM_EH_REGS	4
+#define UNW_TDEP_NUM_EH_REGS    4
 
 typedef struct unw_tdep_save_loc
   {
@@ -185,7 +185,7 @@ typedef ucontext_t unw_tdep_context_t;
    using the "getcontext" name just because it's using libunwind.  We
    can't just use __getcontext() either, because that isn't exported
    by glibc...  */
-#define unw_tdep_getcontext(uc)		(getcontext (uc), 0)
+#define unw_tdep_getcontext(uc)         (getcontext (uc), 0)
 
 #include "libunwind-dynamic.h"
 
@@ -197,7 +197,7 @@ unw_tdep_proc_info_t;
 
 #include "libunwind-common.h"
 
-#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
 extern int unw_tdep_is_fpreg (int);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/include/libunwind-ppc64.h b/include/libunwind-ppc64.h
index 66420b3..9944628 100644
--- a/include/libunwind-ppc64.h
+++ b/include/libunwind-ppc64.h
@@ -39,10 +39,10 @@ extern "C" {
 #include <inttypes.h>
 #include <ucontext.h>
 
-#define UNW_TARGET		ppc64
-#define UNW_TARGET_PPC64	1
+#define UNW_TARGET              ppc64
+#define UNW_TARGET_PPC64        1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /*
  * This needs to be big enough to accommodate "struct cursor", while
@@ -222,12 +222,19 @@ typedef enum
   }
 ppc64_regnum_t;
 
+typedef enum
+  {
+    UNW_PPC64_ABI_ELFv1,
+    UNW_PPC64_ABI_ELFv2
+  }
+ppc64_abi_t;
+
 /*
  * According to David Edelsohn, GNU gcc uses R3, R4, R5, and maybe R6 for
  * passing parameters to exception handlers.
  */
 
-#define UNW_TDEP_NUM_EH_REGS	4
+#define UNW_TDEP_NUM_EH_REGS    4
 
 typedef struct unw_tdep_save_loc
   {
@@ -242,7 +249,7 @@ typedef ucontext_t unw_tdep_context_t;
    using the "getcontext" name just because it's using libunwind.  We
    can't just use __getcontext() either, because that isn't exported
    by glibc...  */
-#define unw_tdep_getcontext(uc)		(getcontext (uc), 0)
+#define unw_tdep_getcontext(uc)         (getcontext (uc), 0)
 
 #include "libunwind-dynamic.h"
 
@@ -254,7 +261,7 @@ unw_tdep_proc_info_t;
 
 #include "libunwind-common.h"
 
-#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
 extern int unw_tdep_is_fpreg (int);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/include/libunwind-ptrace.h b/include/libunwind-ptrace.h
index 7fca205..801325c 100644
--- a/include/libunwind-ptrace.h
+++ b/include/libunwind-ptrace.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -40,18 +40,18 @@ extern "C" {
 extern void *_UPT_create (pid_t);
 extern void _UPT_destroy (void *);
 extern int _UPT_find_proc_info (unw_addr_space_t, unw_word_t,
-				unw_proc_info_t *, int, void *);
+                                unw_proc_info_t *, int, void *);
 extern void _UPT_put_unwind_info (unw_addr_space_t, unw_proc_info_t *, void *);
 extern int _UPT_get_dyn_info_list_addr (unw_addr_space_t, unw_word_t *,
-					void *);
+                                        void *);
 extern int _UPT_access_mem (unw_addr_space_t, unw_word_t, unw_word_t *, int,
-			    void *);
+                            void *);
 extern int _UPT_access_reg (unw_addr_space_t, unw_regnum_t, unw_word_t *,
-			    int, void *);
+                            int, void *);
 extern int _UPT_access_fpreg (unw_addr_space_t, unw_regnum_t, unw_fpreg_t *,
-			      int, void *);
+                              int, void *);
 extern int _UPT_get_proc_name (unw_addr_space_t, unw_word_t, char *, size_t,
-			       unw_word_t *, void *);
+                               unw_word_t *, void *);
 extern int _UPT_resume (unw_addr_space_t, unw_cursor_t *, void *);
 extern unw_accessors_t _UPT_accessors;
 
diff --git a/include/libunwind-s390x.h b/include/libunwind-s390x.h
new file mode 100644
index 0000000..ebda40d
--- /dev/null
+++ b/include/libunwind-s390x.h
@@ -0,0 +1,144 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2002-2004 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef LIBUNWIND_H
+#define LIBUNWIND_H
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <inttypes.h>
+#include <ucontext.h>
+
+#define UNW_TARGET              s390x
+#define UNW_TARGET_S390X        1
+
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
+
+/* This needs to be big enough to accommodate "struct cursor", while
+   leaving some slack for future expansion.  Changing this value will
+   require recompiling all users of this library.  Stack allocation is
+   relatively cheap and unwind-state copying is relatively rare, so we
+   want to err on making it rather too big than too small.  */
+#define UNW_TDEP_CURSOR_LEN     384
+
+typedef uint64_t unw_word_t;
+typedef int64_t unw_sword_t;
+
+typedef double unw_tdep_fpreg_t;
+
+typedef enum
+  {
+    /* general purpose registers */
+    UNW_S390X_R0,
+    UNW_S390X_R1,
+    UNW_S390X_R2,
+    UNW_S390X_R3,
+    UNW_S390X_R4,
+    UNW_S390X_R5,
+    UNW_S390X_R6,
+    UNW_S390X_R7,
+    UNW_S390X_R8,
+    UNW_S390X_R9,
+    UNW_S390X_R10,
+    UNW_S390X_R11,
+    UNW_S390X_R12,
+    UNW_S390X_R13,
+    UNW_S390X_R14,
+    UNW_S390X_R15,
+
+    /* floating point registers */
+    UNW_S390X_F0,
+    UNW_S390X_F1,
+    UNW_S390X_F2,
+    UNW_S390X_F3,
+    UNW_S390X_F4,
+    UNW_S390X_F5,
+    UNW_S390X_F6,
+    UNW_S390X_F7,
+    UNW_S390X_F8,
+    UNW_S390X_F9,
+    UNW_S390X_F10,
+    UNW_S390X_F11,
+    UNW_S390X_F12,
+    UNW_S390X_F13,
+    UNW_S390X_F14,
+    UNW_S390X_F15,
+
+    /* PSW */
+    UNW_S390X_IP,
+
+    UNW_TDEP_LAST_REG = UNW_S390X_IP,
+
+    /* TODO: access, vector registers */
+
+    /* frame info (read-only) */
+    UNW_S390X_CFA,
+
+    UNW_TDEP_IP = UNW_S390X_IP,
+    UNW_TDEP_SP = UNW_S390X_R15,
+
+    /* TODO: placeholders */
+    UNW_TDEP_EH = UNW_S390X_R0,
+  }
+s390x_regnum_t;
+
+#define UNW_TDEP_NUM_EH_REGS    2       /* XXX Not sure what this means */
+
+typedef struct unw_tdep_save_loc
+  {
+    /* Additional target-dependent info on a save location.  */
+    char unused;
+  }
+unw_tdep_save_loc_t;
+
+/* On s390x, we can directly use ucontext_t as the unwind context.  */
+typedef ucontext_t unw_tdep_context_t;
+
+typedef struct
+  {
+    /* no s390x-specific auxiliary proc-info */
+    char unused;
+  }
+unw_tdep_proc_info_t;
+
+#include "libunwind-dynamic.h"
+#include "libunwind-common.h"
+
+#define unw_tdep_getcontext             UNW_ARCH_OBJ(getcontext)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
+
+extern int unw_tdep_getcontext (unw_tdep_context_t *);
+extern int unw_tdep_is_fpreg (int);
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif /* LIBUNWIND_H */
diff --git a/include/libunwind-sh.h b/include/libunwind-sh.h
index a3edc86..927f61f 100644
--- a/include/libunwind-sh.h
+++ b/include/libunwind-sh.h
@@ -34,10 +34,10 @@ extern "C" {
 #include <stddef.h>
 #include <ucontext.h>
 
-#define UNW_TARGET	sh
-#define UNW_TARGET_SH	1
+#define UNW_TARGET      sh
+#define UNW_TARGET_SH   1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /* This needs to be big enough to accommodate "struct cursor", while
    leaving some slack for future expansion.  Changing this value will
@@ -45,7 +45,7 @@ extern "C" {
    relatively cheap and unwind-state copying is relatively rare, so we
    want to err on making it rather too big than too small.  */
 
-#define UNW_TDEP_CURSOR_LEN	4096
+#define UNW_TDEP_CURSOR_LEN     4096
 
 typedef uint32_t unw_word_t;
 typedef int32_t unw_sword_t;
@@ -82,11 +82,11 @@ typedef enum
   }
 sh_regnum_t;
 
-#define UNW_TDEP_NUM_EH_REGS	2
+#define UNW_TDEP_NUM_EH_REGS    2
 
 typedef ucontext_t unw_tdep_context_t;
 
-#define unw_tdep_getcontext(uc)		(getcontext (uc), 0)
+#define unw_tdep_getcontext(uc)         (getcontext (uc), 0)
 
 typedef struct unw_tdep_save_loc
   {
@@ -104,7 +104,7 @@ unw_tdep_proc_info_t;
 
 #include "libunwind-common.h"
 
-#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
 extern int unw_tdep_is_fpreg (int);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/include/libunwind-tilegx.h b/include/libunwind-tilegx.h
new file mode 100644
index 0000000..0f84ea6
--- /dev/null
+++ b/include/libunwind-tilegx.h
@@ -0,0 +1,161 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef LIBUNWIND_H
+#define LIBUNWIND_H
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+#include <inttypes.h>
+#include <ucontext.h>
+
+#define UNW_TARGET           tilegx
+#define UNW_TARGET_TILEGX    1
+
+#define _U_TDEP_QP_TRUE        0    /* see libunwind-dynamic.h  */
+
+/* This needs to be big enough to accommodate "struct cursor", while
+   leaving some slack for future expansion.  Changing this value will
+   require recompiling all users of this library.  Stack allocation is
+   relatively cheap and unwind-state copying is relatively rare, so we
+   want to err on making it rather too big than too small.  */
+
+#define UNW_TDEP_CURSOR_LEN   4096
+
+/* The size of a "word" varies on TILEGX.  This type is used for memory
+   addresses and register values. */
+typedef uint64_t unw_word_t;
+typedef int64_t unw_sword_t;
+
+typedef long double unw_tdep_fpreg_t;
+
+typedef enum
+{
+  UNW_TILEGX_R0,
+  UNW_TILEGX_R1,
+  UNW_TILEGX_R2,
+  UNW_TILEGX_R3,
+  UNW_TILEGX_R4,
+  UNW_TILEGX_R5,
+  UNW_TILEGX_R6,
+  UNW_TILEGX_R7,
+  UNW_TILEGX_R8,
+  UNW_TILEGX_R9,
+  UNW_TILEGX_R10,
+  UNW_TILEGX_R11,
+  UNW_TILEGX_R12,
+  UNW_TILEGX_R13,
+  UNW_TILEGX_R14,
+  UNW_TILEGX_R15,
+  UNW_TILEGX_R16,
+  UNW_TILEGX_R17,
+  UNW_TILEGX_R18,
+  UNW_TILEGX_R19,
+  UNW_TILEGX_R20,
+  UNW_TILEGX_R21,
+  UNW_TILEGX_R22,
+  UNW_TILEGX_R23,
+  UNW_TILEGX_R24,
+  UNW_TILEGX_R25,
+  UNW_TILEGX_R26,
+  UNW_TILEGX_R27,
+  UNW_TILEGX_R28,
+  UNW_TILEGX_R29,
+  UNW_TILEGX_R30,
+  UNW_TILEGX_R31,
+  UNW_TILEGX_R32,
+  UNW_TILEGX_R33,
+  UNW_TILEGX_R34,
+  UNW_TILEGX_R35,
+  UNW_TILEGX_R36,
+  UNW_TILEGX_R37,
+  UNW_TILEGX_R38,
+  UNW_TILEGX_R39,
+  UNW_TILEGX_R40,
+  UNW_TILEGX_R41,
+  UNW_TILEGX_R42,
+  UNW_TILEGX_R43,
+  UNW_TILEGX_R44,
+  UNW_TILEGX_R45,
+  UNW_TILEGX_R46,
+  UNW_TILEGX_R47,
+  UNW_TILEGX_R48,
+  UNW_TILEGX_R49,
+  UNW_TILEGX_R50,
+  UNW_TILEGX_R51,
+  UNW_TILEGX_R52,
+  UNW_TILEGX_R53,
+  UNW_TILEGX_R54,
+  UNW_TILEGX_R55,
+
+  /* FIXME: Other registers!  */
+
+  UNW_TILEGX_PC,
+  /* For TILEGX, the CFA is the value of SP (r54) at the call site in the
+     previous frame.  */
+  UNW_TILEGX_CFA,
+
+  UNW_TDEP_LAST_REG = UNW_TILEGX_PC,
+
+  UNW_TDEP_IP = UNW_TILEGX_R55,  /* R55 is link register for Tilegx */
+  UNW_TDEP_SP = UNW_TILEGX_R54,
+  UNW_TDEP_EH = UNW_TILEGX_R0   /* FIXME.  */
+} tilegx_regnum_t;
+
+typedef enum
+{
+  UNW_TILEGX_ABI_N64 = 2
+} tilegx_abi_t;
+
+#define UNW_TDEP_NUM_EH_REGS    2   /* FIXME for TILEGX.  */
+
+typedef struct unw_tdep_save_loc
+{
+  /* Additional target-dependent info on a save location.  */
+} unw_tdep_save_loc_t;
+
+typedef ucontext_t unw_tdep_context_t;
+
+#include "libunwind-dynamic.h"
+
+typedef struct
+{
+    /* no tilegx-specific auxiliary proc-info */
+} unw_tdep_proc_info_t;
+
+#include "libunwind-common.h"
+
+#define unw_tdep_getcontext  getcontext
+
+#define unw_tdep_is_fpreg    UNW_ARCH_OBJ(is_fpreg)
+extern int unw_tdep_is_fpreg (int);
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif /* LIBUNWIND_H */
diff --git a/include/libunwind-x86.h b/include/libunwind-x86.h
index 32533df..40fe046 100644
--- a/include/libunwind-x86.h
+++ b/include/libunwind-x86.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -34,17 +34,17 @@ extern "C" {
 #include <inttypes.h>
 #include <ucontext.h>
 
-#define UNW_TARGET	x86
-#define UNW_TARGET_X86	1
+#define UNW_TARGET      x86
+#define UNW_TARGET_X86  1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /* This needs to be big enough to accommodate "struct cursor", while
    leaving some slack for future expansion.  Changing this value will
    require recompiling all users of this library.  Stack allocation is
    relatively cheap and unwind-state copying is relatively rare, so we
    want to err on making it rather too big than too small.  */
-#define UNW_TDEP_CURSOR_LEN	127
+#define UNW_TDEP_CURSOR_LEN     127
 
 typedef uint32_t unw_word_t;
 typedef int32_t unw_sword_t;
@@ -72,78 +72,78 @@ typedef enum
        DWARF, but that doesn't work because the libunwind requires
        that the exception argument registers be consecutive, which the
        wouldn't be with the DWARF numbering.  */
-    UNW_X86_EAX,	/* scratch (exception argument 1) */
-    UNW_X86_EDX,	/* scratch (exception argument 2) */
-    UNW_X86_ECX,	/* scratch */
-    UNW_X86_EBX,	/* preserved */
-    UNW_X86_ESI,	/* preserved */
-    UNW_X86_EDI,	/* preserved */
-    UNW_X86_EBP,	/* (optional) frame-register */
-    UNW_X86_ESP,	/* (optional) frame-register */
-    UNW_X86_EIP,	/* frame-register */
-    UNW_X86_EFLAGS,	/* scratch (except for "direction", which is fixed */
-    UNW_X86_TRAPNO,	/* scratch */
+    UNW_X86_EAX,        /* scratch (exception argument 1) */
+    UNW_X86_EDX,        /* scratch (exception argument 2) */
+    UNW_X86_ECX,        /* scratch */
+    UNW_X86_EBX,        /* preserved */
+    UNW_X86_ESI,        /* preserved */
+    UNW_X86_EDI,        /* preserved */
+    UNW_X86_EBP,        /* (optional) frame-register */
+    UNW_X86_ESP,        /* (optional) frame-register */
+    UNW_X86_EIP,        /* frame-register */
+    UNW_X86_EFLAGS,     /* scratch (except for "direction", which is fixed */
+    UNW_X86_TRAPNO,     /* scratch */
 
     /* MMX/stacked-fp registers */
-    UNW_X86_ST0,	/* fp return value */
-    UNW_X86_ST1,	/* scratch */
-    UNW_X86_ST2,	/* scratch */
-    UNW_X86_ST3,	/* scratch */
-    UNW_X86_ST4,	/* scratch */
-    UNW_X86_ST5,	/* scratch */
-    UNW_X86_ST6,	/* scratch */
-    UNW_X86_ST7,	/* scratch */
-
-    UNW_X86_FCW,	/* scratch */
-    UNW_X86_FSW,	/* scratch */
-    UNW_X86_FTW,	/* scratch */
-    UNW_X86_FOP,	/* scratch */
-    UNW_X86_FCS,	/* scratch */
-    UNW_X86_FIP,	/* scratch */
-    UNW_X86_FEA,	/* scratch */
-    UNW_X86_FDS,	/* scratch */
+    UNW_X86_ST0,        /* fp return value */
+    UNW_X86_ST1,        /* scratch */
+    UNW_X86_ST2,        /* scratch */
+    UNW_X86_ST3,        /* scratch */
+    UNW_X86_ST4,        /* scratch */
+    UNW_X86_ST5,        /* scratch */
+    UNW_X86_ST6,        /* scratch */
+    UNW_X86_ST7,        /* scratch */
+
+    UNW_X86_FCW,        /* scratch */
+    UNW_X86_FSW,        /* scratch */
+    UNW_X86_FTW,        /* scratch */
+    UNW_X86_FOP,        /* scratch */
+    UNW_X86_FCS,        /* scratch */
+    UNW_X86_FIP,        /* scratch */
+    UNW_X86_FEA,        /* scratch */
+    UNW_X86_FDS,        /* scratch */
 
     /* SSE registers */
-    UNW_X86_XMM0_lo,	/* scratch */
-    UNW_X86_XMM0_hi,	/* scratch */
-    UNW_X86_XMM1_lo,	/* scratch */
-    UNW_X86_XMM1_hi,	/* scratch */
-    UNW_X86_XMM2_lo,	/* scratch */
-    UNW_X86_XMM2_hi,	/* scratch */
-    UNW_X86_XMM3_lo,	/* scratch */
-    UNW_X86_XMM3_hi,	/* scratch */
-    UNW_X86_XMM4_lo,	/* scratch */
-    UNW_X86_XMM4_hi,	/* scratch */
-    UNW_X86_XMM5_lo,	/* scratch */
-    UNW_X86_XMM5_hi,	/* scratch */
-    UNW_X86_XMM6_lo,	/* scratch */
-    UNW_X86_XMM6_hi,	/* scratch */
-    UNW_X86_XMM7_lo,	/* scratch */
-    UNW_X86_XMM7_hi,	/* scratch */
-
-    UNW_X86_MXCSR,	/* scratch */
+    UNW_X86_XMM0_lo,    /* scratch */
+    UNW_X86_XMM0_hi,    /* scratch */
+    UNW_X86_XMM1_lo,    /* scratch */
+    UNW_X86_XMM1_hi,    /* scratch */
+    UNW_X86_XMM2_lo,    /* scratch */
+    UNW_X86_XMM2_hi,    /* scratch */
+    UNW_X86_XMM3_lo,    /* scratch */
+    UNW_X86_XMM3_hi,    /* scratch */
+    UNW_X86_XMM4_lo,    /* scratch */
+    UNW_X86_XMM4_hi,    /* scratch */
+    UNW_X86_XMM5_lo,    /* scratch */
+    UNW_X86_XMM5_hi,    /* scratch */
+    UNW_X86_XMM6_lo,    /* scratch */
+    UNW_X86_XMM6_hi,    /* scratch */
+    UNW_X86_XMM7_lo,    /* scratch */
+    UNW_X86_XMM7_hi,    /* scratch */
+
+    UNW_X86_MXCSR,      /* scratch */
 
     /* segment registers */
-    UNW_X86_GS,		/* special */
-    UNW_X86_FS,		/* special */
-    UNW_X86_ES,		/* special */
-    UNW_X86_DS,		/* special */
-    UNW_X86_SS,		/* special */
-    UNW_X86_CS,		/* special */
-    UNW_X86_TSS,	/* special */
-    UNW_X86_LDT,	/* special */
+    UNW_X86_GS,         /* special */
+    UNW_X86_FS,         /* special */
+    UNW_X86_ES,         /* special */
+    UNW_X86_DS,         /* special */
+    UNW_X86_SS,         /* special */
+    UNW_X86_CS,         /* special */
+    UNW_X86_TSS,        /* special */
+    UNW_X86_LDT,        /* special */
 
     /* frame info (read-only) */
     UNW_X86_CFA,
 
-    UNW_X86_XMM0,	/* scratch */
-    UNW_X86_XMM1,	/* scratch */
-    UNW_X86_XMM2,	/* scratch */
-    UNW_X86_XMM3,	/* scratch */
-    UNW_X86_XMM4,	/* scratch */
-    UNW_X86_XMM5,	/* scratch */
-    UNW_X86_XMM6,	/* scratch */
-    UNW_X86_XMM7,	/* scratch */
+    UNW_X86_XMM0,       /* scratch */
+    UNW_X86_XMM1,       /* scratch */
+    UNW_X86_XMM2,       /* scratch */
+    UNW_X86_XMM3,       /* scratch */
+    UNW_X86_XMM4,       /* scratch */
+    UNW_X86_XMM5,       /* scratch */
+    UNW_X86_XMM6,       /* scratch */
+    UNW_X86_XMM7,       /* scratch */
 
     UNW_TDEP_LAST_REG = UNW_X86_XMM7,
 
@@ -153,7 +153,7 @@ typedef enum
   }
 x86_regnum_t;
 
-#define UNW_TDEP_NUM_EH_REGS	2	/* eax and edx are exception args */
+#define UNW_TDEP_NUM_EH_REGS    2       /* eax and edx are exception args */
 
 typedef struct unw_tdep_save_loc
   {
@@ -174,10 +174,10 @@ unw_tdep_proc_info_t;
 
 #include "libunwind-common.h"
 
-#define unw_tdep_getcontext		UNW_ARCH_OBJ(getcontext)
+#define unw_tdep_getcontext             UNW_ARCH_OBJ(getcontext)
 extern int unw_tdep_getcontext (unw_tdep_context_t *);
 
-#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
 extern int unw_tdep_is_fpreg (int);
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/include/libunwind-x86_64.h b/include/libunwind-x86_64.h
index 526b1ea..78eb541 100644
--- a/include/libunwind-x86_64.h
+++ b/include/libunwind-x86_64.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -36,17 +36,17 @@ extern "C" {
 #include <inttypes.h>
 #include <ucontext.h>
 
-#define UNW_TARGET		x86_64
-#define UNW_TARGET_X86_64	1
+#define UNW_TARGET              x86_64
+#define UNW_TARGET_X86_64       1
 
-#define _U_TDEP_QP_TRUE	0	/* see libunwind-dynamic.h  */
+#define _U_TDEP_QP_TRUE 0       /* see libunwind-dynamic.h  */
 
 /* This needs to be big enough to accommodate "struct cursor", while
    leaving some slack for future expansion.  Changing this value will
    require recompiling all users of this library.  Stack allocation is
    relatively cheap and unwind-state copying is relatively rare, so we
    want to err on making it rather too big than too small.  */
-#define UNW_TDEP_CURSOR_LEN	127
+#define UNW_TDEP_CURSOR_LEN     127
 
 typedef uint64_t unw_word_t;
 typedef int64_t unw_sword_t;
@@ -106,11 +106,12 @@ typedef enum
   }
 x86_64_regnum_t;
 
-#define UNW_TDEP_NUM_EH_REGS	2	/* XXX Not sure what this means */
+#define UNW_TDEP_NUM_EH_REGS    2       /* XXX Not sure what this means */
 
 typedef struct unw_tdep_save_loc
   {
     /* Additional target-dependent info on a save location.  */
+    char unused;
   }
 unw_tdep_save_loc_t;
 
@@ -120,14 +121,15 @@ typedef ucontext_t unw_tdep_context_t;
 typedef struct
   {
     /* no x86-64-specific auxiliary proc-info */
+    char unused;
   }
 unw_tdep_proc_info_t;
 
 #include "libunwind-dynamic.h"
 #include "libunwind-common.h"
 
-#define unw_tdep_getcontext		UNW_ARCH_OBJ(getcontext)
-#define unw_tdep_is_fpreg		UNW_ARCH_OBJ(is_fpreg)
+#define unw_tdep_getcontext             UNW_ARCH_OBJ(getcontext)
+#define unw_tdep_is_fpreg               UNW_ARCH_OBJ(is_fpreg)
 
 extern int unw_tdep_getcontext (unw_tdep_context_t *);
 extern int unw_tdep_is_fpreg (int);
diff --git a/include/libunwind.h b/include/libunwind.h
new file mode 100644
index 0000000..91bb8ef
--- /dev/null
+++ b/include/libunwind.h
@@ -0,0 +1,38 @@
+/* Provide a real file - not a symlink - as it would cause multiarch conflicts
+   when multiple different arch releases are installed simultaneously.  */
+
+#ifndef UNW_REMOTE_ONLY
+
+#if defined __aarch64__
+#include "libunwind-aarch64.h"
+#elif defined __arm__
+# include "libunwind-arm.h"
+#elif defined __hppa__
+# include "libunwind-hppa.h"
+#elif defined __ia64__
+# include "libunwind-ia64.h"
+#elif defined __mips__
+# include "libunwind-mips.h"
+#elif defined __powerpc__ && !defined __powerpc64__
+# include "libunwind-ppc32.h"
+#elif defined __powerpc64__
+# include "libunwind-ppc64.h"
+#elif defined __sh__
+# include "libunwind-sh.h"
+#elif defined __i386__
+# include "libunwind-x86.h"
+#elif defined __x86_64__
+# include "libunwind-x86_64.h"
+#elif defined __tilegx__
+# include "libunwind-tilegx.h"
+#elif defined __s390x__
+# include "libunwind-s390x.h"
+#else
+# error "Unsupported arch"
+#endif
+
+#else /* UNW_REMOTE_ONLY */
+
+# include "libunwind-x86_64.h"
+
+#endif /* UNW_REMOTE_ONLY */
diff --git a/include/libunwind.h.in b/include/libunwind.h.in
index 25c4e3b..a13e776 100644
--- a/include/libunwind.h.in
+++ b/include/libunwind.h.in
@@ -3,7 +3,9 @@
 
 #ifndef UNW_REMOTE_ONLY
 
-#if defined __arm__
+#if defined __aarch64__
+#include "libunwind-aarch64.h"
+#elif defined __arm__
 # include "libunwind-arm.h"
 #elif defined __hppa__
 # include "libunwind-hppa.h"
@@ -21,6 +23,10 @@
 # include "libunwind-x86.h"
 #elif defined __x86_64__
 # include "libunwind-x86_64.h"
+#elif defined __tilegx__
+# include "libunwind-tilegx.h"
+#elif defined __s390x__
+# include "libunwind-s390x.h"
 #else
 # error "Unsupported arch"
 #endif
diff --git a/include/libunwind_i.h b/include/libunwind_i.h
index 23f615e..36cf7a1 100644
--- a/include/libunwind_i.h
+++ b/include/libunwind_i.h
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -37,16 +37,15 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "compiler.h"
 
-#ifdef HAVE___THREAD
-  /* For now, turn off per-thread caching.  It uses up too much TLS
-     memory per thread even when the thread never uses libunwind at
-     all.  */
-# undef HAVE___THREAD
+#if defined(HAVE___THREAD) && HAVE___THREAD
+#define UNWI_DEFAULT_CACHING_POLICY UNW_CACHE_PER_THREAD
+#else
+#define UNWI_DEFAULT_CACHING_POLICY UNW_CACHE_GLOBAL
 #endif
 
 /* Platform-independent libunwind-internal declarations.  */
 
-#include <sys/types.h>	/* HP-UX needs this before include of pthread.h */
+#include <sys/types.h>  /* HP-UX needs this before include of pthread.h */
 
 #include <assert.h>
 #include <libunwind.h>
@@ -56,26 +55,56 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <string.h>
 #include <unistd.h>
 #include <sys/mman.h>
-#include <elf.h>
+
+#if defined(HAVE_ELF_H)
+# include <elf.h>
+#elif defined(HAVE_SYS_ELF_H)
+# include <sys/elf.h>
+#else
+# error Could not locate <elf.h>
+#endif
 
 #if defined(HAVE_ENDIAN_H)
 # include <endian.h>
 #elif defined(HAVE_SYS_ENDIAN_H)
 # include <sys/endian.h>
+# if defined(_LITTLE_ENDIAN) && !defined(__LITTLE_ENDIAN)
+#   define __LITTLE_ENDIAN _LITTLE_ENDIAN
+# endif
+# if defined(_BIG_ENDIAN) && !defined(__BIG_ENDIAN)
+#   define __BIG_ENDIAN _BIG_ENDIAN
+# endif
+# if defined(_BYTE_ORDER) && !defined(__BYTE_ORDER)
+#   define __BYTE_ORDER _BYTE_ORDER
+# endif
 #else
-# define __LITTLE_ENDIAN	1234
-# define __BIG_ENDIAN		4321
+# define __LITTLE_ENDIAN        1234
+# define __BIG_ENDIAN           4321
 # if defined(__hpux)
 #   define __BYTE_ORDER __BIG_ENDIAN
+# elif defined(__QNX__)
+#   if defined(__BIGENDIAN__)
+#     define __BYTE_ORDER __BIG_ENDIAN
+#   elif defined(__LITTLEENDIAN__)
+#     define __BYTE_ORDER __LITTLE_ENDIAN
+#   else
+#     error Host has unknown byte-order.
+#   endif
 # else
 #   error Host has unknown byte-order.
 # endif
 #endif
 
+#if defined(HAVE__BUILTIN_UNREACHABLE)
+# define unreachable() __builtin_unreachable()
+#else
+# define unreachable() do { } while (1)
+#endif
+
 #ifdef DEBUG
-# define UNW_DEBUG	1
+# define UNW_DEBUG      1
 #else
-# define UNW_DEBUG	0
+# define UNW_DEBUG      0
 #endif
 
 /* Make it easy to write thread-safe code which may or may not be
@@ -87,12 +116,12 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #pragma weak pthread_mutex_lock
 #pragma weak pthread_mutex_unlock
 
-#define mutex_init(l)							\
-	(pthread_mutex_init != NULL ? pthread_mutex_init ((l), NULL) : 0)
-#define mutex_lock(l)							\
-	(pthread_mutex_lock != NULL ? pthread_mutex_lock (l) : 0)
-#define mutex_unlock(l)							\
-	(pthread_mutex_unlock != NULL ? pthread_mutex_unlock (l) : 0)
+#define mutex_init(l)                                                   \
+        (pthread_mutex_init != NULL ? pthread_mutex_init ((l), NULL) : 0)
+#define mutex_lock(l)                                                   \
+        (pthread_mutex_lock != NULL ? pthread_mutex_lock (l) : 0)
+#define mutex_unlock(l)                                                 \
+        (pthread_mutex_unlock != NULL ? pthread_mutex_unlock (l) : 0)
 
 #ifdef HAVE_ATOMIC_OPS_H
 # include <atomic_ops.h>
@@ -109,8 +138,8 @@ cmpxchg_ptr (void *addr, void *old, void *new)
   u.vp = addr;
   return AO_compare_and_swap(u.aop, (AO_t) old, (AO_t) new);
 }
-# define fetch_and_add1(_ptr)		AO_fetch_and_add1(_ptr)
-# define fetch_and_add(_ptr, value)	AO_fetch_and_add(_ptr, value)
+# define fetch_and_add1(_ptr)           AO_fetch_and_add1(_ptr)
+# define fetch_and_add(_ptr, value)     AO_fetch_and_add(_ptr, value)
    /* GCC 3.2.0 on HP-UX crashes on cmpxchg_ptr() */
 #  if !(defined(__hpux) && __GNUC__ == 3 && __GNUC_MINOR__ == 2)
 #   define HAVE_CMPXCHG
@@ -133,14 +162,14 @@ cmpxchg_ptr (void *addr, void *old, void *new)
   u.vp = addr;
   return __sync_bool_compare_and_swap(u.vlp, (long) old, (long) new);
 }
-# define fetch_and_add1(_ptr)		__sync_fetch_and_add(_ptr, 1)
-# define fetch_and_add(_ptr, value)	__sync_fetch_and_add(_ptr, value)
+# define fetch_and_add1(_ptr)           __sync_fetch_and_add(_ptr, 1)
+# define fetch_and_add(_ptr, value)     __sync_fetch_and_add(_ptr, value)
 # define HAVE_CMPXCHG
 # define HAVE_FETCH_AND_ADD
 #endif
-#define atomic_read(ptr)	(*(ptr))
+#define atomic_read(ptr)        (*(ptr))
 
-#define UNWI_OBJ(fn)	  UNW_PASTE(UNW_PREFIX,UNW_PASTE(I,fn))
+#define UNWI_OBJ(fn)      UNW_PASTE(UNW_PREFIX,UNW_PASTE(I,fn))
 #define UNWI_ARCH_OBJ(fn) UNW_PASTE(UNW_PASTE(UNW_PASTE(_UI,UNW_TARGET),_), fn)
 
 #define unwi_full_mask    UNWI_ARCH_OBJ(full_mask)
@@ -165,91 +194,94 @@ static inline void mark_as_used(void *v UNUSED) {
 # define SIGPROCMASK(how, new_mask, old_mask) mark_as_used(old_mask)
 #endif
 
+/* Prefer adaptive mutexes if available */
+#ifdef PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
+#define UNW_PTHREAD_MUTEX_INITIALIZER PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
+#else
+#define UNW_PTHREAD_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+#endif
+
 #define define_lock(name) \
-  pthread_mutex_t name = PTHREAD_MUTEX_INITIALIZER
-#define lock_init(l)		mutex_init (l)
-#define lock_acquire(l,m)				\
-do {							\
-  SIGPROCMASK (SIG_SETMASK, &unwi_full_mask, &(m));	\
-  mutex_lock (l);					\
+  pthread_mutex_t name = UNW_PTHREAD_MUTEX_INITIALIZER
+#define lock_init(l)            mutex_init (l)
+#define lock_acquire(l,m)                               \
+do {                                                    \
+  SIGPROCMASK (SIG_SETMASK, &unwi_full_mask, &(m));     \
+  mutex_lock (l);                                       \
 } while (0)
-#define lock_release(l,m)			\
-do {						\
-  mutex_unlock (l);				\
-  SIGPROCMASK (SIG_SETMASK, &(m), NULL);	\
+#define lock_release(l,m)                       \
+do {                                            \
+  mutex_unlock (l);                             \
+  SIGPROCMASK (SIG_SETMASK, &(m), NULL);        \
 } while (0)
 
-#define SOS_MEMORY_SIZE 16384	/* see src/mi/mempool.c */
+#define SOS_MEMORY_SIZE 16384   /* see src/mi/mempool.c */
 
 #ifndef MAP_ANONYMOUS
 # define MAP_ANONYMOUS MAP_ANON
 #endif
-#define GET_MEMORY(mem, size)				    		    \
-do {									    \
+#define GET_MEMORY(mem, size)                                               \
+do {                                                                        \
   /* Hopefully, mmap() goes straight through to a system call stub...  */   \
-  mem = mmap (NULL, size, PROT_READ | PROT_WRITE,			    \
-	      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);			    \
-  if (mem == MAP_FAILED)						    \
-    mem = NULL;								    \
+  mem = mmap (NULL, size, PROT_READ | PROT_WRITE,                           \
+              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);                          \
+  if (mem == MAP_FAILED)                                                    \
+    mem = NULL;                                                             \
 } while (0)
 
-#define unwi_find_dynamic_proc_info	UNWI_OBJ(find_dynamic_proc_info)
-#define unwi_extract_dynamic_proc_info	UNWI_OBJ(extract_dynamic_proc_info)
-#define unwi_put_dynamic_unwind_info	UNWI_OBJ(put_dynamic_unwind_info)
-#define unwi_dyn_remote_find_proc_info	UNWI_OBJ(dyn_remote_find_proc_info)
-#define unwi_dyn_remote_put_unwind_info	UNWI_OBJ(dyn_remote_put_unwind_info)
-#define unwi_dyn_validate_cache		UNWI_OBJ(dyn_validate_cache)
+#define unwi_find_dynamic_proc_info     UNWI_OBJ(find_dynamic_proc_info)
+#define unwi_extract_dynamic_proc_info  UNWI_OBJ(extract_dynamic_proc_info)
+#define unwi_put_dynamic_unwind_info    UNWI_OBJ(put_dynamic_unwind_info)
+#define unwi_dyn_remote_find_proc_info  UNWI_OBJ(dyn_remote_find_proc_info)
+#define unwi_dyn_remote_put_unwind_info UNWI_OBJ(dyn_remote_put_unwind_info)
+#define unwi_dyn_validate_cache         UNWI_OBJ(dyn_validate_cache)
 
 extern int unwi_find_dynamic_proc_info (unw_addr_space_t as,
-					unw_word_t ip,
-					unw_proc_info_t *pi,
-					int need_unwind_info, void *arg);
+                                        unw_word_t ip,
+                                        unw_proc_info_t *pi,
+                                        int need_unwind_info, void *arg);
 extern int unwi_extract_dynamic_proc_info (unw_addr_space_t as,
-					   unw_word_t ip,
-					   unw_proc_info_t *pi,
-					   unw_dyn_info_t *di,
-					   int need_unwind_info,
-					   void *arg);
+                                           unw_word_t ip,
+                                           unw_proc_info_t *pi,
+                                           unw_dyn_info_t *di,
+                                           int need_unwind_info,
+                                           void *arg);
 extern void unwi_put_dynamic_unwind_info (unw_addr_space_t as,
-					  unw_proc_info_t *pi, void *arg);
+                                          unw_proc_info_t *pi, void *arg);
 
 /* These handle the remote (cross-address-space) case of accessing
    dynamic unwind info. */
 
 extern int unwi_dyn_remote_find_proc_info (unw_addr_space_t as,
-					   unw_word_t ip,
-					   unw_proc_info_t *pi,
-					   int need_unwind_info,
-					   void *arg);
+                                           unw_word_t ip,
+                                           unw_proc_info_t *pi,
+                                           int need_unwind_info,
+                                           void *arg);
 extern void unwi_dyn_remote_put_unwind_info (unw_addr_space_t as,
-					     unw_proc_info_t *pi,
-					     void *arg);
+                                             unw_proc_info_t *pi,
+                                             void *arg);
 extern int unwi_dyn_validate_cache (unw_addr_space_t as, void *arg);
 
 extern unw_dyn_info_list_t _U_dyn_info_list;
 extern pthread_mutex_t _U_dyn_info_list_lock;
 
 #if UNW_DEBUG
-#define unwi_debug_level		UNWI_ARCH_OBJ(debug_level)
+#define unwi_debug_level                UNWI_ARCH_OBJ(debug_level)
 extern long unwi_debug_level;
 
 # include <stdio.h>
-# define Debug(level,format...)						\
-do {									\
-  if (unwi_debug_level >= level)					\
-    {									\
-      int _n = level;							\
-      if (_n > 16)							\
-	_n = 16;							\
-      fprintf (stderr, "%*c>%s: ", _n, ' ', __FUNCTION__);		\
-      fprintf (stderr, format);						\
-    }									\
+# define Debug(level,format...)                                         \
+do {                                                                    \
+  if (unwi_debug_level >= level)                                        \
+    {                                                                   \
+      int _n = level;                                                   \
+      if (_n > 16)                                                      \
+        _n = 16;                                                        \
+      fprintf (stderr, "%*c>%s: ", _n, ' ', __FUNCTION__);              \
+      fprintf (stderr, format);                                         \
+    }                                                                   \
 } while (0)
-# define Dprintf(format...) 	    fprintf (stderr, format)
-# ifdef __GNUC__
-#  undef inline
-#  define inline	UNUSED
-# endif
+# define Dprintf(format...)         fprintf (stderr, format)
 #else
 # define Debug(level,format...)
 # define Dprintf(format...)
@@ -261,17 +293,17 @@ print_error (const char *string)
   return write (2, string, strlen (string));
 }
 
-#define mi_init		UNWI_ARCH_OBJ(mi_init)
+#define mi_init         UNWI_ARCH_OBJ(mi_init)
 
-extern void mi_init (void);	/* machine-independent initializations */
+extern void mi_init (void);     /* machine-independent initializations */
 extern unw_word_t _U_dyn_info_list_addr (void);
 
 /* This is needed/used by ELF targets only.  */
 
 struct elf_image
   {
-    void *image;		/* pointer to mmap'd image */
-    size_t size;		/* (file-) size of the image */
+    void *image;                /* pointer to mmap'd image */
+    size_t size;                /* (file-) size of the image */
   };
 
 struct elf_dyn_info
@@ -311,16 +343,21 @@ static inline void invalidate_edi (struct elf_dyn_info *edi)
 /* Define GNU and processor specific values for the Phdr p_type field in case
    they aren't defined by <elf.h>.  */
 #ifndef PT_GNU_EH_FRAME
-# define PT_GNU_EH_FRAME	0x6474e550
+# define PT_GNU_EH_FRAME        0x6474e550
 #endif /* !PT_GNU_EH_FRAME */
 #ifndef PT_ARM_EXIDX
-# define PT_ARM_EXIDX		0x70000001	/* ARM unwind segment */
+# define PT_ARM_EXIDX           0x70000001      /* ARM unwind segment */
 #endif /* !PT_ARM_EXIDX */
 
 #include "tdep/libunwind_i.h"
 
 #ifndef tdep_get_func_addr
-# define tdep_get_func_addr(as,addr,v)		(*(v) = addr, 0)
+# define tdep_get_func_addr(as,addr,v)          (*(v) = addr, 0)
+#endif
+
+#ifndef DWARF_VAL_LOC
+# define DWARF_IS_VAL_LOC(l)    0
+# define DWARF_VAL_LOC(c,v)     DWARF_NULL_LOC
 #endif
 
 #define UNW_ALIGN(x,a) (((x)+(a)-1UL)&~((a)-1UL))
diff --git a/include/mempool.h b/include/mempool.h
index 4b55974..1f1c770 100644
--- a/include/mempool.h
+++ b/include/mempool.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -51,23 +51,23 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-#define sos_alloc(s)		UNWI_ARCH_OBJ(_sos_alloc)(s)
-#define mempool_init(p,s,r)	UNWI_ARCH_OBJ(_mempool_init)(p,s,r)
-#define mempool_alloc(p)	UNWI_ARCH_OBJ(_mempool_alloc)(p)
-#define mempool_free(p,o)	UNWI_ARCH_OBJ(_mempool_free)(p,o)
+#define sos_alloc(s)            UNWI_ARCH_OBJ(_sos_alloc)(s)
+#define mempool_init(p,s,r)     UNWI_ARCH_OBJ(_mempool_init)(p,s,r)
+#define mempool_alloc(p)        UNWI_ARCH_OBJ(_mempool_alloc)(p)
+#define mempool_free(p,o)       UNWI_ARCH_OBJ(_mempool_free)(p,o)
 
 /* The mempool structure should be treated as an opaque object.  It's
    declared here only to enable static allocation of mempools.  */
 struct mempool
   {
     pthread_mutex_t lock;
-    size_t obj_size;		/* object size (rounded up for alignment) */
-    size_t chunk_size;		/* allocation granularity */
-    unsigned int reserve;	/* minimum (desired) size of the free-list */
-    unsigned int num_free;	/* number of objects on the free-list */
+    size_t obj_size;            /* object size (rounded up for alignment) */
+    size_t chunk_size;          /* allocation granularity */
+    unsigned int reserve;       /* minimum (desired) size of the free-list */
+    unsigned int num_free;      /* number of objects on the free-list */
     struct object
       {
-	struct object *next;
+        struct object *next;
       }
     *free_list;
   };
@@ -82,7 +82,7 @@ extern void *sos_alloc (size_t size);
    tight memory situations.  If it is zero, mempool attempts to pick a
    reasonable default value.  */
 extern void mempool_init (struct mempool *pool,
-			  size_t obj_size, size_t reserve);
+                          size_t obj_size, size_t reserve);
 extern void *mempool_alloc (struct mempool *pool);
 extern void mempool_free (struct mempool *pool, void *object);
 
diff --git a/include/remote.h b/include/remote.h
index 9fb90c3..064d630 100644
--- a/include/remote.h
+++ b/include/remote.h
@@ -9,7 +9,7 @@
 
 static inline int
 fetch8 (unw_addr_space_t as, unw_accessors_t *a,
-	unw_word_t *addr, int8_t *valp, void *arg)
+        unw_word_t *addr, int8_t *valp, void *arg)
 {
   *valp = *(int8_t *) (uintptr_t) *addr;
   *addr += 1;
@@ -18,7 +18,7 @@ fetch8 (unw_addr_space_t as, unw_accessors_t *a,
 
 static inline int
 fetch16 (unw_addr_space_t as, unw_accessors_t *a,
-	 unw_word_t *addr, int16_t *valp, void *arg)
+         unw_word_t *addr, int16_t *valp, void *arg)
 {
   *valp = *(int16_t *) (uintptr_t) *addr;
   *addr += 2;
@@ -27,7 +27,7 @@ fetch16 (unw_addr_space_t as, unw_accessors_t *a,
 
 static inline int
 fetch32 (unw_addr_space_t as, unw_accessors_t *a,
-	 unw_word_t *addr, int32_t *valp, void *arg)
+         unw_word_t *addr, int32_t *valp, void *arg)
 {
   *valp = *(int32_t *) (uintptr_t) *addr;
   *addr += 4;
@@ -36,7 +36,7 @@ fetch32 (unw_addr_space_t as, unw_accessors_t *a,
 
 static inline int
 fetchw (unw_addr_space_t as, unw_accessors_t *a,
-	unw_word_t *addr, unw_word_t *valp, void *arg)
+        unw_word_t *addr, unw_word_t *valp, void *arg)
 {
   *valp = *(unw_word_t *) (uintptr_t) *addr;
   *addr += sizeof (unw_word_t);
@@ -45,11 +45,11 @@ fetchw (unw_addr_space_t as, unw_accessors_t *a,
 
 #else /* !UNW_LOCAL_ONLY */
 
-#define WSIZE	(sizeof (unw_word_t))
+#define WSIZE   (sizeof (unw_word_t))
 
 static inline int
 fetch8 (unw_addr_space_t as, unw_accessors_t *a,
-	unw_word_t *addr, int8_t *valp, void *arg)
+        unw_word_t *addr, int8_t *valp, void *arg)
 {
   unw_word_t val, aligned_addr = *addr & -WSIZE, off = *addr - aligned_addr;
   int ret;
@@ -69,12 +69,13 @@ fetch8 (unw_addr_space_t as, unw_accessors_t *a,
 
 static inline int
 fetch16 (unw_addr_space_t as, unw_accessors_t *a,
-	 unw_word_t *addr, int16_t *valp, void *arg)
+         unw_word_t *addr, int16_t *valp, void *arg)
 {
   unw_word_t val, aligned_addr = *addr & -WSIZE, off = *addr - aligned_addr;
   int ret;
 
-  assert ((off & 0x1) == 0);
+  if ((off & 0x1) != 0)
+    return -UNW_EINVAL;
 
   *addr += 2;
 
@@ -91,12 +92,13 @@ fetch16 (unw_addr_space_t as, unw_accessors_t *a,
 
 static inline int
 fetch32 (unw_addr_space_t as, unw_accessors_t *a,
-	 unw_word_t *addr, int32_t *valp, void *arg)
+         unw_word_t *addr, int32_t *valp, void *arg)
 {
   unw_word_t val, aligned_addr = *addr & -WSIZE, off = *addr - aligned_addr;
   int ret;
 
-  assert ((off & 0x3) == 0);
+  if ((off & 0x3) != 0)
+    return -UNW_EINVAL;
 
   *addr += 4;
 
@@ -113,7 +115,7 @@ fetch32 (unw_addr_space_t as, unw_accessors_t *a,
 
 static inline int
 fetchw (unw_addr_space_t as, unw_accessors_t *a,
-	unw_word_t *addr, unw_word_t *valp, void *arg)
+        unw_word_t *addr, unw_word_t *valp, void *arg)
 {
   int ret;
 
diff --git a/include/tdep-aarch64/dwarf-config.h b/include/tdep-aarch64/dwarf-config.h
new file mode 100644
index 0000000..f65db17
--- /dev/null
+++ b/include/tdep-aarch64/dwarf-config.h
@@ -0,0 +1,52 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef dwarf_config_h
+#define dwarf_config_h
+
+/* This matches the value udes by GCC (see
+   gcc/config/aarch64/aarch64.h:DWARF_FRAME_REGISTERS.  */
+#define DWARF_NUM_PRESERVED_REGS        97
+
+/* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
+#define dwarf_is_big_endian(addr_space) 0
+
+#define dwarf_to_unw_regnum(reg) (((reg) <= UNW_AARCH64_V31) ? (reg) : 0)
+
+/* Convert a pointer to a dwarf_cursor structure to a pointer to
+   unw_cursor_t.  */
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
+
+typedef struct dwarf_loc
+  {
+    unw_word_t val;
+#ifndef UNW_LOCAL_ONLY
+    unw_word_t type;            /* see DWARF_LOC_TYPE_* macros.  */
+#endif
+  }
+dwarf_loc_t;
+
+#endif /* dwarf_config_h */
diff --git a/include/tdep-aarch64/jmpbuf.h b/include/tdep-aarch64/jmpbuf.h
new file mode 100644
index 0000000..3f01a44
--- /dev/null
+++ b/include/tdep-aarch64/jmpbuf.h
@@ -0,0 +1,33 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+/* Use glibc's jump-buffer indices; NPTL peeks at SP: */
+
+/* FIXME for AArch64  */
+
+#define JB_SP           13
+#define JB_RP           14
+#define JB_MASK_SAVED   15
+#define JB_MASK         16
diff --git a/include/tdep-aarch64/libunwind_i.h b/include/tdep-aarch64/libunwind_i.h
new file mode 100644
index 0000000..b91273f
--- /dev/null
+++ b/include/tdep-aarch64/libunwind_i.h
@@ -0,0 +1,320 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2001-2005 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef AARCH64_LIBUNWIND_I_H
+#define AARCH64_LIBUNWIND_I_H
+
+/* Target-dependent definitions that are internal to libunwind but need
+   to be shared with target-independent code.  */
+
+#include <stdlib.h>
+#include <libunwind.h>
+
+#include "elf64.h"
+#include "mempool.h"
+#include "dwarf.h"
+
+typedef enum
+  {
+    UNW_AARCH64_FRAME_STANDARD = -2,     /* regular fp, sp +/- offset */
+    UNW_AARCH64_FRAME_SIGRETURN = -1,    /* special sigreturn frame */
+    UNW_AARCH64_FRAME_OTHER = 0,         /* not cacheable (special or unrecognised) */
+    UNW_AARCH64_FRAME_GUESSED = 1        /* guessed it was regular, but not known */
+  }
+unw_tdep_frame_type_t;
+
+typedef struct
+  {
+    uint64_t virtual_address;
+    int64_t frame_type     : 2;  /* unw_tdep_frame_type_t classification */
+    int64_t last_frame     : 1;  /* non-zero if last frame in chain */
+    int64_t cfa_reg_sp     : 1;  /* cfa dwarf base register is sp vs. fp */
+    int64_t cfa_reg_offset : 30; /* cfa is at this offset from base register value */
+    int64_t fp_cfa_offset  : 30; /* fp saved at this offset from cfa (-1 = not saved) */
+    int64_t lr_cfa_offset  : 30; /* lr saved at this offset from cfa (-1 = not saved) */
+    int64_t sp_cfa_offset  : 30; /* sp saved at this offset from cfa (-1 = not saved) */
+  }
+unw_tdep_frame_t;
+
+#ifdef UNW_LOCAL_ONLY
+
+typedef unw_word_t aarch64_loc_t;
+
+#else /* !UNW_LOCAL_ONLY */
+
+typedef struct aarch64_loc
+  {
+    unw_word_t w0, w1;
+  }
+aarch64_loc_t;
+
+#endif /* !UNW_LOCAL_ONLY */
+
+struct unw_addr_space
+  {
+    struct unw_accessors acc;
+    int big_endian;
+    unw_caching_policy_t caching_policy;
+#ifdef HAVE_ATOMIC_OPS_H
+    AO_t cache_generation;
+#else
+    uint32_t cache_generation;
+#endif
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
+    struct dwarf_rs_cache global_cache;
+    struct unw_debug_frame_list *debug_frames;
+   };
+
+struct cursor
+  {
+    struct dwarf_cursor dwarf;          /* must be first */
+
+    unw_tdep_frame_t frame_info;        /* quick tracing assist info */
+
+    enum
+      {
+        AARCH64_SCF_NONE,
+        AARCH64_SCF_LINUX_RT_SIGFRAME,
+      }
+    sigcontext_format;
+    unw_word_t sigcontext_addr;
+    unw_word_t sigcontext_sp;
+    unw_word_t sigcontext_pc;
+    int validate;
+  };
+
+#define DWARF_GET_LOC(l)        ((l).val)
+
+#ifdef UNW_LOCAL_ONLY
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+
+static inline int
+dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *val = *(unw_fpreg_t *) DWARF_GET_LOC (loc);
+  return 0;
+}
+
+static inline int
+dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *(unw_fpreg_t *) DWARF_GET_LOC (loc) = val;
+  return 0;
+}
+
+static inline int
+dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *val = *(unw_word_t *) DWARF_GET_LOC (loc);
+  return 0;
+}
+
+static inline int
+dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *(unw_word_t *) DWARF_GET_LOC (loc) = val;
+  return 0;
+}
+
+#else /* !UNW_LOCAL_ONLY */
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
+
+static inline int
+dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
+{
+  char *valp = (char *) &val;
+  unw_word_t addr;
+  int ret;
+
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
+                                       val, 0, c->as_arg);
+
+  addr = DWARF_GET_LOC (loc);
+  if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
+                                       0, c->as_arg)) < 0)
+    return ret;
+
+  return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1, 0,
+                                   c->as_arg);
+}
+
+static inline int
+dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
+{
+  char *valp = (char *) &val;
+  unw_word_t addr;
+  int ret;
+
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
+                                       &val, 1, c->as_arg);
+
+  addr = DWARF_GET_LOC (loc);
+  if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
+                                       1, c->as_arg)) < 0)
+    return ret;
+
+  return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1,
+                                   1, c->as_arg);
+}
+
+static inline int
+dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
+{
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  /* If a code-generator were to save a value of type unw_word_t in a
+     floating-point register, we would have to support this case.  I
+     suppose it could happen with MMX registers, but does it really
+     happen?  */
+  assert (!DWARF_IS_FP_LOC (loc));
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
+                                     0, c->as_arg);
+  else
+    return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
+                                     0, c->as_arg);
+}
+
+static inline int
+dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
+{
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  /* If a code-generator were to save a value of type unw_word_t in a
+     floating-point register, we would have to support this case.  I
+     suppose it could happen with MMX registers, but does it really
+     happen?  */
+  assert (!DWARF_IS_FP_LOC (loc));
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
+                                     1, c->as_arg);
+  else
+    return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
+                                     1, c->as_arg);
+}
+
+#endif /* !UNW_LOCAL_ONLY */
+
+
+
+#define tdep_getcontext_trace           UNW_ARCH_OBJ(getcontext_trace)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
+/* Platforms that support UNW_INFO_FORMAT_TABLE need to define
+   tdep_search_unwind_table.  */
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame                UNW_OBJ(tdep_stash_frame)
+#define tdep_trace                      UNW_OBJ(tdep_trace)
+
+#ifdef UNW_LOCAL_ONLY
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
+#else
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
+#endif
+
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             ((as)->big_endian)
+
+extern int tdep_init_done;
+
+extern void tdep_init (void);
+extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
+extern void *tdep_uc_addr (unw_tdep_context_t *uc, int reg);
+extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
+extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
+                            unw_word_t *valp, int write);
+extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
+                              unw_fpreg_t *valp, int write);
+extern int tdep_trace (unw_cursor_t *cursor, void **addresses, int *n);
+extern void tdep_stash_frame (struct dwarf_cursor *c,
+                              struct dwarf_reg_state *rs);
+extern int tdep_getcontext_trace (unw_tdep_context_t *);
+
+#endif /* AARCH64_LIBUNWIND_I_H */
diff --git a/include/tdep-arm/dwarf-config.h b/include/tdep-arm/dwarf-config.h
index c997f3a..f502289 100644
--- a/include/tdep-arm/dwarf-config.h
+++ b/include/tdep-arm/dwarf-config.h
@@ -28,22 +28,22 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* This is FIRST_PSEUDO_REGISTER in GCC, since DWARF_FRAME_REGISTERS is not
    explicitly defined.  */
-#define DWARF_NUM_PRESERVED_REGS	128
+#define DWARF_NUM_PRESERVED_REGS        128
 
 #define dwarf_to_unw_regnum(reg) (((reg) < 16) ? (reg) : 0)
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
-#define dwarf_is_big_endian(addr_space)	0
+#define dwarf_is_big_endian(addr_space) 0
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
 #ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see DWARF_LOC_TYPE_* macros.  */
+    unw_word_t type;            /* see DWARF_LOC_TYPE_* macros.  */
 #endif
   }
 dwarf_loc_t;
diff --git a/include/tdep-arm/ex_tables.h b/include/tdep-arm/ex_tables.h
index 8906f13..9df5e0a 100644
--- a/include/tdep-arm/ex_tables.h
+++ b/include/tdep-arm/ex_tables.h
@@ -44,9 +44,9 @@ struct arm_exbuf_data
   uint32_t data;
 };
 
-#define arm_exidx_extract	UNW_OBJ(arm_exidx_extract)
-#define arm_exidx_decode	UNW_OBJ(arm_exidx_decode)
-#define arm_exidx_apply_cmd	UNW_OBJ(arm_exidx_apply_cmd)
+#define arm_exidx_extract       UNW_OBJ(arm_exidx_extract)
+#define arm_exidx_decode        UNW_OBJ(arm_exidx_decode)
+#define arm_exidx_apply_cmd     UNW_OBJ(arm_exidx_apply_cmd)
 
 int arm_exidx_extract (struct dwarf_cursor *c, uint8_t *buf);
 int arm_exidx_decode (const uint8_t *buf, uint8_t len, struct dwarf_cursor *c);
diff --git a/include/tdep-arm/jmpbuf.h b/include/tdep-arm/jmpbuf.h
index 499e7de..008e77f 100644
--- a/include/tdep-arm/jmpbuf.h
+++ b/include/tdep-arm/jmpbuf.h
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* FIXME for ARM!  */
 
-#define JB_SP		4
-#define JB_RP		5
-#define JB_MASK_SAVED	6
-#define JB_MASK		7
+#define JB_SP           4
+#define JB_RP           5
+#define JB_MASK_SAVED   6
+#define JB_MASK         7
diff --git a/include/tdep-arm/libunwind_i.h b/include/tdep-arm/libunwind_i.h
index 291b101..2602f41 100644
--- a/include/tdep-arm/libunwind_i.h
+++ b/include/tdep-arm/libunwind_i.h
@@ -36,9 +36,26 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "dwarf.h"
 #include "ex_tables.h"
 
+typedef enum
+  {
+    UNW_ARM_FRAME_SYSCALL = -3,      /* r7 saved in r12, sp offset zero */
+    UNW_ARM_FRAME_STANDARD = -2,     /* regular r7, sp +/- offset */
+    UNW_ARM_FRAME_SIGRETURN = -1,    /* special sigreturn frame */
+    UNW_ARM_FRAME_OTHER = 0,         /* not cacheable (special or unrecognised) */
+    UNW_ARM_FRAME_GUESSED = 1        /* guessed it was regular, but not known */
+  }
+unw_tdep_frame_type_t;
+
 typedef struct
   {
-    /* no arm-specific fast trace */
+    uint32_t virtual_address;
+    int32_t frame_type     : 3;  /* unw_tdep_frame_type_t classification */
+    int32_t last_frame     : 1;  /* non-zero if last frame in chain */
+    int32_t cfa_reg_sp     : 1;  /* cfa dwarf base register is sp vs. r7 */
+    int32_t cfa_reg_offset : 30; /* cfa is at this offset from base register value */
+    int32_t r7_cfa_offset  : 30; /* r7 saved at this offset from cfa (-1 = not saved) */
+    int32_t lr_cfa_offset  : 30; /* lr saved at this offset from cfa (-1 = not saved) */
+    int32_t sp_cfa_offset  : 30; /* sp saved at this offset from cfa (-1 = not saved) */
   }
 unw_tdep_frame_t;
 
@@ -52,41 +69,47 @@ struct unw_addr_space
 #else
     uint32_t cache_generation;
 #endif
-    unw_word_t dyn_generation;		/* see dyn-common.h */
-    unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
     struct dwarf_rs_cache global_cache;
     struct unw_debug_frame_list *debug_frames;
   };
 
 struct cursor
   {
-    struct dwarf_cursor dwarf;		/* must be first */
+    struct dwarf_cursor dwarf;          /* must be first */
+
+    unw_tdep_frame_t frame_info;        /* quick tracing assist info */
+
     enum
       {
         ARM_SCF_NONE,                   /* no signal frame */
         ARM_SCF_LINUX_SIGFRAME,         /* non-RT signal frame, kernel >=2.6.18 */
         ARM_SCF_LINUX_RT_SIGFRAME,      /* RT signal frame, kernel >=2.6.18 */
         ARM_SCF_LINUX_OLD_SIGFRAME,     /* non-RT signal frame, kernel < 2.6.18 */
-        ARM_SCF_LINUX_OLD_RT_SIGFRAME   /* RT signal frame, kernel < 2.6.18 */
+        ARM_SCF_LINUX_OLD_RT_SIGFRAME,  /* RT signal frame, kernel < 2.6.18 */
+        ARM_SCF_FREEBSD_SIGFRAME,	/* FreeBSD sigframe */
+	ARM_SCF_FREEBSD_SYSCALL,	/* FreeBSD syscall stub */
       }
     sigcontext_format;
     unw_word_t sigcontext_addr;
     unw_word_t sigcontext_sp;
     unw_word_t sigcontext_pc;
+    int validate;
   };
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -125,18 +148,18 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 }
 
 #else /* !UNW_LOCAL_ONLY */
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -150,15 +173,15 @@ dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       0, c->as_arg)) < 0)
+                                       0, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1, 0,
-				   c->as_arg);
+                                   c->as_arg);
 }
 
 static inline int
@@ -173,15 +196,15 @@ dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       &val, 1, c->as_arg);
+                                       &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       1, c->as_arg)) < 0)
+                                       1, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1,
-				   1, c->as_arg);
+                                   1, c->as_arg);
 }
 
 static inline int
@@ -198,10 +221,10 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
 }
 
 static inline int
@@ -218,71 +241,76 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
 #endif /* !UNW_LOCAL_ONLY */
 
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init			UNW_OBJ(init)
-#define arm_find_proc_info		UNW_OBJ(find_proc_info)
-#define arm_put_unwind_info		UNW_OBJ(put_unwind_info)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
+#define arm_find_proc_info              UNW_OBJ(find_proc_info)
+#define arm_put_unwind_info             UNW_OBJ(put_unwind_info)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	UNW_OBJ(search_unwind_table)
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_uc_addr			UNW_ARCH_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
+#define tdep_search_unwind_table        UNW_OBJ(search_unwind_table)
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame                UNW_OBJ(tdep_stash_frame)
+#define tdep_trace                      UNW_OBJ(tdep_trace)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	arm_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	arm_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        arm_find_proc_info((c)->as, (ip), &(c)->pi, (n),        \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        arm_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
-#define tdep_big_endian(as)		((as)->big_endian)
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             ((as)->big_endian)
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern int arm_find_proc_info (unw_addr_space_t as, unw_word_t ip,
-			       unw_proc_info_t *pi, int need_unwind_info,
-			       void *arg);
+                               unw_proc_info_t *pi, int need_unwind_info,
+                               void *arg);
 extern void arm_put_unwind_info (unw_addr_space_t as,
-				  unw_proc_info_t *pi, void *arg);
+                                  unw_proc_info_t *pi, void *arg);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t *di, unw_proc_info_t *pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
 extern void *tdep_uc_addr (unw_tdep_context_t *uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t *valp, int write);
+                            unw_word_t *valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t *valp, int write);
+                              unw_fpreg_t *valp, int write);
+extern int tdep_trace (unw_cursor_t *cursor, void **addresses, int *n);
+extern void tdep_stash_frame (struct dwarf_cursor *c,
+                              struct dwarf_reg_state *rs);
 
 /* unwinding method selection support */
 #define UNW_ARM_METHOD_ALL          0xFF
diff --git a/include/tdep-hppa/dwarf-config.h b/include/tdep-hppa/dwarf-config.h
index 29f9eee..fb963c7 100644
--- a/include/tdep-hppa/dwarf-config.h
+++ b/include/tdep-hppa/dwarf-config.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,26 +27,26 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #define dwarf_config_h
 
 /* See DWARF_FRAME_REGNUM() macro in gcc/config/pa/pa32-regs.h: */
-#define dwarf_to_unw_regnum(reg)			\
+#define dwarf_to_unw_regnum(reg)                        \
   (((reg) < DWARF_NUM_PRESERVED_REGS) ? (reg) : 0)
 
 /* This matches the value used by GCC (see
    gcc/config/pa/pa32-regs.h:FIRST_PSEUDO_REGISTER), which leaves
    plenty of room for expansion.  */
-#define DWARF_NUM_PRESERVED_REGS	89
+#define DWARF_NUM_PRESERVED_REGS        89
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
-#define dwarf_is_big_endian(addr_space)	1
+#define dwarf_is_big_endian(addr_space) 1
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
 #ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see X86_LOC_TYPE_* macros.  */
+    unw_word_t type;            /* see X86_LOC_TYPE_* macros.  */
 #endif
   }
 dwarf_loc_t;
diff --git a/include/tdep-hppa/jmpbuf.h b/include/tdep-hppa/jmpbuf.h
index 6735b21..91f062f 100644
--- a/include/tdep-hppa/jmpbuf.h
+++ b/include/tdep-hppa/jmpbuf.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -26,8 +26,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 /* Use glibc's jump-buffer indices; NPTL peeks at SP: */
 
 #ifndef JB_SP
-# define JB_SP		19
+# define JB_SP          19
 #endif
-#define JB_RP		20
-#define JB_MASK_SAVED	21
-#define JB_MASK		22
+#define JB_RP           20
+#define JB_MASK_SAVED   21
+#define JB_MASK         22
diff --git a/include/tdep-hppa/libunwind_i.h b/include/tdep-hppa/libunwind_i.h
index b5bbcec..72649aa 100644
--- a/include/tdep-hppa/libunwind_i.h
+++ b/include/tdep-hppa/libunwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -51,39 +51,39 @@ struct unw_addr_space
 #else
     uint32_t cache_generation;
 #endif
-    unw_word_t dyn_generation;		/* see dyn-common.h */
-    unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
     struct dwarf_rs_cache global_cache;
     struct unw_debug_frame_list *debug_frames;
    };
 
 struct cursor
   {
-    struct dwarf_cursor dwarf;		/* must be first */
+    struct dwarf_cursor dwarf;          /* must be first */
 
     /* Format of sigcontext structure and address at which it is
        stored: */
     enum
       {
-	HPPA_SCF_NONE,			/* no signal frame encountered */
-	HPPA_SCF_LINUX_RT_SIGFRAME	/* POSIX ucontext_t */
+        HPPA_SCF_NONE,                  /* no signal frame encountered */
+        HPPA_SCF_LINUX_RT_SIGFRAME      /* POSIX ucontext_t */
       }
     sigcontext_format;
     unw_word_t sigcontext_addr;
   };
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -122,18 +122,18 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 }
 
 #else /* !UNW_LOCAL_ONLY */
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -147,15 +147,15 @@ dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       0, c->as_arg)) < 0)
+                                       0, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1, 0,
-				   c->as_arg);
+                                   c->as_arg);
 }
 
 static inline int
@@ -170,15 +170,15 @@ dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       &val, 1, c->as_arg);
+                                       &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       1, c->as_arg)) < 0)
+                                       1, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1,
-				   1, c->as_arg);
+                                   1, c->as_arg);
 }
 
 static inline int
@@ -195,10 +195,10 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
 }
 
 static inline int
@@ -215,63 +215,65 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
 #endif /* !UNW_LOCAL_ONLY */
 
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init			UNW_OBJ(init)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	dwarf_search_unwind_table
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_uc_addr			UNW_ARCH_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	dwarf_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
-#define tdep_big_endian(as)		1
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             1
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t *di, unw_proc_info_t *pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
 extern void *tdep_uc_addr (ucontext_t *uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t *valp, int write);
+                            unw_word_t *valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t *valp, int write);
+                              unw_fpreg_t *valp, int write);
 
 #endif /* HPPA_LIBUNWIND_I_H */
diff --git a/include/tdep-ia64/jmpbuf.h b/include/tdep-ia64/jmpbuf.h
index faa1f34..d642af2 100644
--- a/include/tdep-ia64/jmpbuf.h
+++ b/include/tdep-ia64/jmpbuf.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,8 +25,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* Use glibc's jump-buffer indices; NPTL peeks at SP and BSP: */
 
-#define JB_SP		 0
-#define JB_RP		 8
-#define JB_BSP		17
-#define JB_MASK_SAVED	70
-#define JB_MASK		71
+#define JB_SP            0
+#define JB_RP            8
+#define JB_BSP          17
+#define JB_MASK_SAVED   70
+#define JB_MASK         71
diff --git a/include/tdep-ia64/libunwind_i.h b/include/tdep-ia64/libunwind_i.h
index 2bea830..1d9770b 100644
--- a/include/tdep-ia64/libunwind_i.h
+++ b/include/tdep-ia64/libunwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -45,11 +45,11 @@ enum ia64_pregnum
     IA64_REG_PRI_UNAT_MEM,
 
     /* memory stack (order matters: see build_script() */
-    IA64_REG_PSP,			/* previous memory stack pointer */
+    IA64_REG_PSP,                       /* previous memory stack pointer */
     /* register stack */
-    IA64_REG_BSP,			/* register stack pointer */
+    IA64_REG_BSP,                       /* register stack pointer */
     IA64_REG_BSPSTORE,
-    IA64_REG_PFS,			/* previous function state */
+    IA64_REG_PFS,                       /* previous function state */
     IA64_REG_RNAT,
     /* instruction pointer: */
     IA64_REG_IP,
@@ -83,19 +83,19 @@ ia64_loc_t;
 
 #include "script.h"
 
-#define ABI_UNKNOWN			0
-#define ABI_LINUX			1
-#define ABI_HPUX			2
-#define ABI_FREEBSD			3
-#define ABI_OPENVMS			4
-#define ABI_NSK				5	/* Tandem/HP Non-Stop Kernel */
-#define ABI_WINDOWS			6
+#define ABI_UNKNOWN                     0
+#define ABI_LINUX                       1
+#define ABI_HPUX                        2
+#define ABI_FREEBSD                     3
+#define ABI_OPENVMS                     4
+#define ABI_NSK                         5       /* Tandem/HP Non-Stop Kernel */
+#define ABI_WINDOWS                     6
 
 struct unw_addr_space
   {
     struct unw_accessors acc;
     int big_endian;
-    int abi;	/* abi < 0 => unknown, 0 => SysV, 1 => HP-UX, 2 => Windows */
+    int abi;    /* abi < 0 => unknown, 0 => SysV, 1 => HP-UX, 2 => Windows */
     unw_caching_policy_t caching_policy;
 #ifdef HAVE_ATOMIC_OPS_H
     AO_t cache_generation;
@@ -103,7 +103,7 @@ struct unw_addr_space
     uint32_t cache_generation;
 #endif
     unw_word_t dyn_generation;
-    unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
 #ifndef UNW_REMOTE_ONLY
     unsigned long long shared_object_removals;
 #endif
@@ -113,47 +113,47 @@ struct unw_addr_space
 
 /* Note: The ABI numbers in the ABI-markers (.unwabi directive) are
    not the same as the above ABI numbers.  */
-#define ABI_MARKER_OLD_LINUX_SIGTRAMP	((0 << 8) | 's')
-#define ABI_MARKER_OLD_LINUX_INTERRUPT	((0 << 8) | 'i')
-#define ABI_MARKER_HP_UX_SIGTRAMP	((1 << 8) | 1)
-#define ABI_MARKER_LINUX_SIGTRAMP	((3 << 8) | 's')
-#define ABI_MARKER_LINUX_INTERRUPT	((3 << 8) | 'i')
+#define ABI_MARKER_OLD_LINUX_SIGTRAMP   ((0 << 8) | 's')
+#define ABI_MARKER_OLD_LINUX_INTERRUPT  ((0 << 8) | 'i')
+#define ABI_MARKER_HP_UX_SIGTRAMP       ((1 << 8) | 1)
+#define ABI_MARKER_LINUX_SIGTRAMP       ((3 << 8) | 's')
+#define ABI_MARKER_LINUX_INTERRUPT      ((3 << 8) | 'i')
 
 struct cursor
   {
-    void *as_arg;		/* argument to address-space callbacks */
-    unw_addr_space_t as;	/* reference to per-address-space info */
+    void *as_arg;               /* argument to address-space callbacks */
+    unw_addr_space_t as;        /* reference to per-address-space info */
 
     /* IP, CFM, and predicate cache (these are always equal to the
        values stored in ip_loc, cfm_loc, and pr_loc,
        respectively).  */
-    unw_word_t ip;		/* instruction pointer value */
-    unw_word_t cfm;		/* current frame mask */
-    unw_word_t pr;		/* current predicate values */
+    unw_word_t ip;              /* instruction pointer value */
+    unw_word_t cfm;             /* current frame mask */
+    unw_word_t pr;              /* current predicate values */
 
     /* current frame info: */
-    unw_word_t bsp;		/* backing store pointer value */
-    unw_word_t sp;		/* stack pointer value */
-    unw_word_t psp;		/* previous sp value */
-    ia64_loc_t cfm_loc;		/* cfm save location (or NULL) */
-    ia64_loc_t ec_loc;		/* ar.ec save location (usually cfm_loc) */
+    unw_word_t bsp;             /* backing store pointer value */
+    unw_word_t sp;              /* stack pointer value */
+    unw_word_t psp;             /* previous sp value */
+    ia64_loc_t cfm_loc;         /* cfm save location (or NULL) */
+    ia64_loc_t ec_loc;          /* ar.ec save location (usually cfm_loc) */
     ia64_loc_t loc[IA64_NUM_PREGS];
 
-    unw_word_t eh_args[4];	/* exception handler arguments */
-    unw_word_t sigcontext_addr;	/* address of sigcontext or 0 */
-    unw_word_t sigcontext_off;	/* sigcontext-offset relative to signal sp */
+    unw_word_t eh_args[4];      /* exception handler arguments */
+    unw_word_t sigcontext_addr; /* address of sigcontext or 0 */
+    unw_word_t sigcontext_off;  /* sigcontext-offset relative to signal sp */
 
     short hint;
     short prev_script;
 
-    uint8_t nat_bitnr[4];	/* NaT bit numbers for r4-r7 */
-    uint16_t abi_marker;	/* abi_marker for current frame (if any) */
-    uint16_t last_abi_marker;	/* last abi_marker encountered so far */
+    uint8_t nat_bitnr[4];       /* NaT bit numbers for r4-r7 */
+    uint16_t abi_marker;        /* abi_marker for current frame (if any) */
+    uint16_t last_abi_marker;   /* last abi_marker encountered so far */
     uint8_t eh_valid_mask;
 
-    unsigned int pi_valid :1;		/* is proc_info valid? */
+    unsigned int pi_valid :1;           /* is proc_info valid? */
     unsigned int pi_is_dynamic :1; /* proc_info found via dynamic proc info? */
-    unw_proc_info_t pi;		/* info about current procedure */
+    unw_proc_info_t pi;         /* info about current procedure */
 
     /* In case of stack-discontiguities, such as those introduced by
        signal-delivery on an alternate signal-stack (see
@@ -171,20 +171,20 @@ struct cursor
        register may not have gotten spilled until much later, when a
        possibly different rbs-area might have been in effect
        already.  */
-    uint8_t rbs_curr;		/* index of curr. rbs-area (contains c->bsp) */
-    uint8_t rbs_left_edge;	/* index of inner-most valid rbs-area */
+    uint8_t rbs_curr;           /* index of curr. rbs-area (contains c->bsp) */
+    uint8_t rbs_left_edge;      /* index of inner-most valid rbs-area */
     struct rbs_area
       {
-	unw_word_t end;
-	unw_word_t size;
-	ia64_loc_t rnat_loc;
+        unw_word_t end;
+        unw_word_t size;
+        ia64_loc_t rnat_loc;
       }
-    rbs_area[96 + 2];	/* 96 stacked regs + 1 extra stack on each side... */
+    rbs_area[96 + 2];   /* 96 stacked regs + 1 extra stack on each side... */
 };
 
 struct ia64_global_unwind_state
   {
-    pthread_mutex_t lock;		/* global data lock */
+    pthread_mutex_t lock;               /* global data lock */
 
     volatile char init_done;
 
@@ -200,9 +200,9 @@ struct ia64_global_unwind_state
      */
     struct
       {
-	unw_word_t  r0;			/* r0 is byte-order neutral */
-	unw_fpreg_t f0;			/* f0 is byte-order neutral */
-	unw_fpreg_t f1_le, f1_be;	/* f1 is byte-order dependent */
+        unw_word_t  r0;                 /* r0 is byte-order neutral */
+        unw_fpreg_t f0;                 /* f0 is byte-order neutral */
+        unw_fpreg_t f1_le, f1_be;       /* f1 is byte-order dependent */
       }
     read_only;
     unw_fpreg_t nat_val_le, nat_val_be;
@@ -217,63 +217,65 @@ struct ia64_global_unwind_state
   };
 
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			unw.init_done
-#define tdep_init			UNW_OBJ(init)
+#define tdep_init_done                  unw.init_done
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	unw_search_ia64_unwind_table
-#define tdep_find_unwind_table	ia64_find_unwind_table
-#define tdep_find_proc_info		UNW_OBJ(find_proc_info)
-#define tdep_uc_addr			UNW_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
-#define tdep_get_as(c)			((c)->as)
-#define tdep_get_as_arg(c)		((c)->as_arg)
-#define tdep_get_ip(c)			((c)->ip)
-#define tdep_big_endian(as)		((c)->as->big_endian != 0)
+#define tdep_search_unwind_table        unw_search_ia64_unwind_table
+#define tdep_find_unwind_table  ia64_find_unwind_table
+#define tdep_find_proc_info             UNW_OBJ(find_proc_info)
+#define tdep_uc_addr                    UNW_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
+#define tdep_get_as(c)                  ((c)->as)
+#define tdep_get_as_arg(c)              ((c)->as_arg)
+#define tdep_get_ip(c)                  ((c)->ip)
+#define tdep_big_endian(as)             ((c)->as->big_endian != 0)
 
 #ifndef UNW_LOCAL_ONLY
-# define tdep_put_unwind_info		UNW_OBJ(put_unwind_info)
+# define tdep_put_unwind_info           UNW_OBJ(put_unwind_info)
 #endif
 
 /* This can't be an UNW_ARCH_OBJ() because we need separate
    unw.initialized flags for the local-only and generic versions of
    the library.  Also, if we wanted to have a single, shared global
-   data structure, we couldn't declare "unw" as HIDDEN/PROTECTED.  */
-#define unw				UNW_OBJ(data)
+   data structure, we couldn't declare "unw" as HIDDEN.  */
+#define unw                             UNW_OBJ(data)
 
 extern void tdep_init (void);
 extern int tdep_find_unwind_table (struct elf_dyn_info *edi,
-				   unw_addr_space_t as, char *path,
-				   unw_word_t segbase, unw_word_t mapoff,
-				   unw_word_t ip);
+                                   unw_addr_space_t as, char *path,
+                                   unw_word_t segbase, unw_word_t mapoff,
+                                   unw_word_t ip);
 extern int tdep_find_proc_info (unw_addr_space_t as, unw_word_t ip,
-				unw_proc_info_t *pi, int need_unwind_info,
-				void *arg);
+                                unw_proc_info_t *pi, int need_unwind_info,
+                                void *arg);
 extern void tdep_put_unwind_info (unw_addr_space_t as,
-				  unw_proc_info_t *pi, void *arg);
+                                  unw_proc_info_t *pi, void *arg);
 extern void *tdep_uc_addr (ucontext_t *uc, unw_regnum_t regnum,
-			   uint8_t *nat_bitnr);
+                           uint8_t *nat_bitnr);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t *valp, int write);
+                            unw_word_t *valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t *valp, int write);
+                              unw_fpreg_t *valp, int write);
 
 extern struct ia64_global_unwind_state unw;
 
 /* In user-level, we have no reasonable way of determining the base of
    an arbitrary backing-store.  We default to half the
    address-space.  */
-#define rbs_get_base(c,bspstore,rbs_basep)				\
-	(*(rbs_basep) = (bspstore) - (((unw_word_t) 1) << 63), 0)
+#define rbs_get_base(c,bspstore,rbs_basep)                              \
+        (*(rbs_basep) = (bspstore) - (((unw_word_t) 1) << 63), 0)
 
 #endif /* IA64_LIBUNWIND_I_H */
diff --git a/include/tdep-ia64/rse.h b/include/tdep-ia64/rse.h
index c5fe4b5..ee521a5 100644
--- a/include/tdep-ia64/rse.h
+++ b/include/tdep-ia64/rse.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 1998, 1999, 2002, 2003, 2005 Hewlett-Packard Co
- *	David Mosberger-Tang <davidm@hpl.hp.com>
+ *      David Mosberger-Tang <davidm@hpl.hp.com>
  *
  * Register stack engine related helper functions.  This file may be
  * used in applications, so be careful about the name-space and give
@@ -15,7 +15,7 @@
 static inline uint64_t
 rse_slot_num (uint64_t addr)
 {
-	return (addr >> 3) & 0x3f;
+        return (addr >> 3) & 0x3f;
 }
 
 /*
@@ -24,7 +24,7 @@ rse_slot_num (uint64_t addr)
 static inline uint64_t
 rse_is_rnat_slot (uint64_t addr)
 {
-	return rse_slot_num (addr) == 0x3f;
+        return rse_slot_num (addr) == 0x3f;
 }
 
 /*
@@ -34,7 +34,7 @@ rse_is_rnat_slot (uint64_t addr)
 static inline uint64_t
 rse_rnat_addr (uint64_t slot_addr)
 {
-	return slot_addr | (0x3f << 3);
+        return slot_addr | (0x3f << 3);
 }
 
 /*
@@ -45,9 +45,9 @@ rse_rnat_addr (uint64_t slot_addr)
 static inline uint64_t
 rse_num_regs (uint64_t bspstore, uint64_t bsp)
 {
-	uint64_t slots = (bsp - bspstore) >> 3;
+        uint64_t slots = (bsp - bspstore) >> 3;
 
-	return slots - (rse_slot_num(bspstore) + slots)/0x40;
+        return slots - (rse_slot_num(bspstore) + slots)/0x40;
 }
 
 /*
@@ -57,11 +57,11 @@ rse_num_regs (uint64_t bspstore, uint64_t bsp)
 static inline uint64_t
 rse_skip_regs (uint64_t addr, long num_regs)
 {
-	long delta = rse_slot_num(addr) + num_regs;
+        long delta = rse_slot_num(addr) + num_regs;
 
-	if (num_regs < 0)
-		delta -= 0x3e;
-	return addr + ((num_regs + delta/0x3f) << 3);
+        if (num_regs < 0)
+                delta -= 0x3e;
+        return addr + ((num_regs + delta/0x3f) << 3);
 }
 
 #endif /* RSE_H */
diff --git a/include/tdep-ia64/script.h b/include/tdep-ia64/script.h
index 48a9fe5..fe3360b 100644
--- a/include/tdep-ia64/script.h
+++ b/include/tdep-ia64/script.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -23,17 +23,17 @@ LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
-#define IA64_LOG_UNW_CACHE_SIZE	7
-#define IA64_UNW_CACHE_SIZE	(1 << IA64_LOG_UNW_CACHE_SIZE)
+#define IA64_LOG_UNW_CACHE_SIZE 7
+#define IA64_UNW_CACHE_SIZE     (1 << IA64_LOG_UNW_CACHE_SIZE)
 
-#define IA64_LOG_UNW_HASH_SIZE	(IA64_LOG_UNW_CACHE_SIZE + 1)
-#define IA64_UNW_HASH_SIZE	(1 << IA64_LOG_UNW_HASH_SIZE)
+#define IA64_LOG_UNW_HASH_SIZE  (IA64_LOG_UNW_CACHE_SIZE + 1)
+#define IA64_UNW_HASH_SIZE      (1 << IA64_LOG_UNW_HASH_SIZE)
 
 typedef unsigned char unw_hash_index_t;
 
 struct ia64_script_insn
   {
-    unsigned int opc;		/* see enum ia64_script_insn_opcode */
+    unsigned int opc;           /* see enum ia64_script_insn_opcode */
     unsigned int dst;
     unw_word_t val;
   };
@@ -41,18 +41,18 @@ struct ia64_script_insn
 /* Updating each preserved register may result in one script
    instruction each.  At the end of the script, psp gets popped,
    accounting for one more instruction.  */
-#define IA64_MAX_SCRIPT_LEN	(IA64_NUM_PREGS + 1)
+#define IA64_MAX_SCRIPT_LEN     (IA64_NUM_PREGS + 1)
 
 struct ia64_script
   {
-    unw_word_t ip;		/* ip this script is for */
-    unw_word_t pr_mask;		/* mask of predicates script depends on */
-    unw_word_t pr_val;		/* predicate values this script is for */
-    unw_proc_info_t pi;		/* info about underlying procedure */
-    unsigned short lru_chain;	/* used for least-recently-used chain */
-    unsigned short coll_chain;	/* used for hash collisions */
-    unsigned short hint;	/* hint for next script to try (or -1) */
-    unsigned short count;	/* number of instructions in script */
+    unw_word_t ip;              /* ip this script is for */
+    unw_word_t pr_mask;         /* mask of predicates script depends on */
+    unw_word_t pr_val;          /* predicate values this script is for */
+    unw_proc_info_t pi;         /* info about underlying procedure */
+    unsigned short lru_chain;   /* used for least-recently-used chain */
+    unsigned short coll_chain;  /* used for hash collisions */
+    unsigned short hint;        /* hint for next script to try (or -1) */
+    unsigned short count;       /* number of instructions in script */
     unsigned short abi_marker;
     struct ia64_script_insn insn[IA64_MAX_SCRIPT_LEN];
   };
@@ -60,26 +60,26 @@ struct ia64_script
 struct ia64_script_cache
   {
 #ifdef HAVE_ATOMIC_OPS_H
-    AO_TS_t busy;		/* is the script-cache busy? */
+    AO_TS_t busy;               /* is the script-cache busy? */
 #else
     pthread_mutex_t lock;
 #endif
-    unsigned short lru_head;	/* index of lead-recently used script */
-    unsigned short lru_tail;	/* index of most-recently used script */
+    unsigned short lru_head;    /* index of lead-recently used script */
+    unsigned short lru_tail;    /* index of most-recently used script */
 
     /* hash table that maps instruction pointer to script index: */
     unsigned short hash[IA64_UNW_HASH_SIZE];
 
-    uint32_t generation;	/* generation number */
+    uint32_t generation;        /* generation number */
 
     /* script cache: */
     struct ia64_script buckets[IA64_UNW_CACHE_SIZE];
   };
 
-#define ia64_cache_proc_info		UNW_OBJ(cache_proc_info)
-#define ia64_get_cached_proc_info	UNW_OBJ(get_cached_proc_info)
+#define ia64_cache_proc_info            UNW_OBJ(cache_proc_info)
+#define ia64_get_cached_proc_info       UNW_OBJ(get_cached_proc_info)
 
-struct cursor;			/* forward declaration */
+struct cursor;                  /* forward declaration */
 
 extern int ia64_cache_proc_info (struct cursor *c);
 extern int ia64_get_cached_proc_info (struct cursor *c);
diff --git a/include/tdep-mips/dwarf-config.h b/include/tdep-mips/dwarf-config.h
index 0dbdc5a..8006d0b 100644
--- a/include/tdep-mips/dwarf-config.h
+++ b/include/tdep-mips/dwarf-config.h
@@ -28,25 +28,25 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* This is FIRST_PSEUDO_REGISTER in GCC, since DWARF_FRAME_REGISTERS is not
    explicitly defined.  */
-#define DWARF_NUM_PRESERVED_REGS	188
+#define DWARF_NUM_PRESERVED_REGS        188
 
 #define dwarf_to_unw_regnum(reg) (((reg) < 32) ? (reg) : 0)
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
-#define dwarf_is_big_endian(addr_space)	((addr_space)->big_endian)
+#define dwarf_is_big_endian(addr_space) ((addr_space)->big_endian)
 
 /* Return the size of an address, for DWARF purposes.  */
 #define dwarf_addr_size(addr_space) ((addr_space)->addr_size)
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
 #ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see DWARF_LOC_TYPE_* macros.  */
+    unw_word_t type;            /* see DWARF_LOC_TYPE_* macros.  */
 #endif
   }
 dwarf_loc_t;
diff --git a/include/tdep-mips/jmpbuf.h b/include/tdep-mips/jmpbuf.h
index 1adb2bc..c099f92 100644
--- a/include/tdep-mips/jmpbuf.h
+++ b/include/tdep-mips/jmpbuf.h
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* FIXME for MIPS!  */
 
-#define JB_SP		4
-#define JB_RP		5
-#define JB_MASK_SAVED	6
-#define JB_MASK		7
+#define JB_SP           4
+#define JB_RP           5
+#define JB_MASK_SAVED   6
+#define JB_MASK         7
diff --git a/include/tdep-mips/libunwind_i.h b/include/tdep-mips/libunwind_i.h
index 3ef1cef..0c0fd3c 100644
--- a/include/tdep-mips/libunwind_i.h
+++ b/include/tdep-mips/libunwind_i.h
@@ -59,21 +59,21 @@ struct unw_addr_space
 #else
     uint32_t cache_generation;
 #endif
-    unw_word_t dyn_generation;		/* see dyn-common.h */
-    unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
     struct dwarf_rs_cache global_cache;
     struct unw_debug_frame_list *debug_frames;
 };
 
-#define tdep_big_endian(as)		((as)->big_endian)
+#define tdep_big_endian(as)             ((as)->big_endian)
 
 struct cursor
   {
-    struct dwarf_cursor dwarf;		/* must be first */
+    struct dwarf_cursor dwarf;          /* must be first */
     unw_word_t sigcontext_addr;
   };
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
 
 #ifndef UNW_REMOTE_ONLY
 # if _MIPS_SIM == _ABIN32
@@ -84,15 +84,15 @@ typedef long mips_reg_t;
 #endif
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t) (intptr_t)	     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t) (intptr_t)	     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t) (intptr_t)           \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t) (intptr_t)           \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
 
 /* FIXME: Implement these for the MIPS FPU.  */
 static inline int
@@ -132,18 +132,18 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 }
 
 #else /* !UNW_LOCAL_ONLY */
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
 
 static inline int
 read_s32 (struct dwarf_cursor *c, unw_word_t addr, unw_word_t *val)
@@ -196,15 +196,15 @@ dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       0, c->as_arg)) < 0)
+                                       0, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1, 0,
-				   c->as_arg);
+                                   c->as_arg);
 }
 
 static inline int
@@ -219,15 +219,15 @@ dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       &val, 1, c->as_arg);
+                                       &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       1, c->as_arg)) < 0)
+                                       1, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1,
-				   1, c->as_arg);
+                                   1, c->as_arg);
 }
 
 static inline int
@@ -244,12 +244,20 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
   else if (c->as->abi == UNW_MIPS_ABI_O32)
     return read_s32 (c, DWARF_GET_LOC (loc), val);
+  else if (c->as->abi == UNW_MIPS_ABI_N32) {
+    if (tdep_big_endian(c->as))
+      return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc) + 4, val,
+                                       0, c->as_arg);
+    else
+      return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
+                                       0, c->as_arg);
+  }
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
 }
 
 static inline int
@@ -266,64 +274,66 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else if (c->as->abi == UNW_MIPS_ABI_O32)
     return write_s32 (c, DWARF_GET_LOC (loc), &val);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
 #endif /* !UNW_LOCAL_ONLY */
 
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init			UNW_OBJ(init)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	dwarf_search_unwind_table
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_uc_addr			UNW_ARCH_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	dwarf_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t *di, unw_proc_info_t *pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
 extern void *tdep_uc_addr (ucontext_t *uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t *valp, int write);
+                            unw_word_t *valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t *valp, int write);
+                              unw_fpreg_t *valp, int write);
 
 #endif /* MIPS_LIBUNWIND_I_H */
diff --git a/include/tdep-ppc32/dwarf-config.h b/include/tdep-ppc32/dwarf-config.h
index e2676a8..bf6886b 100644
--- a/include/tdep-ppc32/dwarf-config.h
+++ b/include/tdep-ppc32/dwarf-config.h
@@ -33,22 +33,22 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #define dwarf_config_h
 
 /* For PPC64, 48 GPRs + 33 FPRs + 33 AltiVec + 1 SPE  */
-#define DWARF_NUM_PRESERVED_REGS	115
+#define DWARF_NUM_PRESERVED_REGS        115
 
-#define DWARF_REGNUM_MAP_LENGTH		115
+#define DWARF_REGNUM_MAP_LENGTH         115
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
 #define dwarf_is_big_endian(addr_space) 1
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
 #ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see X86_LOC_TYPE_* macros.  */
+    unw_word_t type;            /* see X86_LOC_TYPE_* macros.  */
 #endif
   }
 dwarf_loc_t;
diff --git a/include/tdep-ppc32/jmpbuf.h b/include/tdep-ppc32/jmpbuf.h
index 3780d5b..861e94d 100644
--- a/include/tdep-ppc32/jmpbuf.h
+++ b/include/tdep-ppc32/jmpbuf.h
@@ -31,7 +31,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* Use glibc's jump-buffer indices; NPTL peeks at SP: */
 
-#define JB_SP		6
-#define JB_RP		7
-#define JB_MASK_SAVED	8
-#define JB_MASK		9
+#define JB_SP           6
+#define JB_RP           7
+#define JB_MASK_SAVED   8
+#define JB_MASK         9
diff --git a/include/tdep-ppc32/libunwind_i.h b/include/tdep-ppc32/libunwind_i.h
index 06c0023..4cf6d13 100644
--- a/include/tdep-ppc32/libunwind_i.h
+++ b/include/tdep-ppc32/libunwind_i.h
@@ -57,8 +57,8 @@ struct unw_addr_space
 #else
   uint32_t cache_generation;
 #endif
-  unw_word_t dyn_generation;	/* see dyn-common.h */
-  unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+  unw_word_t dyn_generation;    /* see dyn-common.h */
+  unw_word_t dyn_info_list_addr;        /* (cached) dyn_info_list_addr */
   struct dwarf_rs_cache global_cache;
   struct unw_debug_frame_list *debug_frames;
   int validate;
@@ -66,53 +66,53 @@ struct unw_addr_space
 
 struct cursor
 {
-  struct dwarf_cursor dwarf;	/* must be first */
+  struct dwarf_cursor dwarf;    /* must be first */
 
   /* Format of sigcontext structure and address at which it is
      stored: */
   enum
   {
-    PPC_SCF_NONE,		/* no signal frame encountered */
-    PPC_SCF_LINUX_RT_SIGFRAME	/* POSIX ucontext_t */
+    PPC_SCF_NONE,               /* no signal frame encountered */
+    PPC_SCF_LINUX_RT_SIGFRAME   /* POSIX ucontext_t */
   }
   sigcontext_format;
   unw_word_t sigcontext_addr;
 };
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_IS_FP_LOC(l)	0
-# define DWARF_IS_V_LOC(l)	0
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_VREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_IS_FP_LOC(l)     0
+# define DWARF_IS_V_LOC(l)      0
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_VREG_LOC(c,r)    (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
 #else /* !UNW_LOCAL_ONLY */
 
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_LOC_TYPE_V	(1 << 2)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_IS_V_LOC(l)	(((l).type & DWARF_LOC_TYPE_V) != 0)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
-# define DWARF_VREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_V))
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_LOC_TYPE_V       (1 << 2)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_IS_V_LOC(l)      (((l).type & DWARF_LOC_TYPE_V) != 0)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
+# define DWARF_VREG_LOC(c,r)    DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_V))
 
 #endif /* !UNW_LOCAL_ONLY */
 
@@ -131,12 +131,12 @@ dwarf_getvr (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t * val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				      val, 0, c->as_arg);
+                                      val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
 
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, valp,
-				       0, c->as_arg)) < 0)
+                                       0, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 8, valp + 1, 0, c->as_arg);
@@ -157,11 +157,11 @@ dwarf_putvr (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				      &val, 1, c->as_arg);
+                                      &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, valp,
-				       1, c->as_arg)) < 0)
+                                       1, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 8, valp + 1, 1, c->as_arg);
@@ -181,7 +181,7 @@ dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t * val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   return (*c->as->acc.access_mem) (c->as, addr + 0, valp, 0, c->as_arg);
@@ -202,7 +202,7 @@ dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       &val, 1, c->as_arg);
+                                       &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
 
@@ -224,10 +224,10 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t * val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
 }
 
 static inline int
@@ -245,68 +245,70 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init			UNW_OBJ(init)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	dwarf_search_unwind_table
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_uc_addr			UNW_ARCH_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
-#define tdep_get_func_addr		UNW_OBJ(get_func_addr)
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
+#define tdep_get_func_addr              UNW_OBJ(get_func_addr)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	dwarf_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)			\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                        \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
 extern int tdep_fetch_proc_info_post (struct dwarf_cursor *c, unw_word_t ip,
-				      int need_unwind_info);
+                                      int need_unwind_info);
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
-#define tdep_big_endian(as)		1
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             1
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t * di,
-				     unw_proc_info_t * pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t * di,
+                                     unw_proc_info_t * pi,
+                                     int need_unwind_info, void *arg);
 extern void *tdep_uc_addr (ucontext_t * uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t * valp, int write);
+                            unw_word_t * valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t * valp, int write);
+                              unw_fpreg_t * valp, int write);
 extern int tdep_get_func_addr (unw_addr_space_t as, unw_word_t addr,
-			       unw_word_t *entry_point);
+                               unw_word_t *entry_point);
 
 #endif /* PPC64_LIBUNWIND_I_H */
diff --git a/include/tdep-ppc64/dwarf-config.h b/include/tdep-ppc64/dwarf-config.h
index e2676a8..6d8ef0a 100644
--- a/include/tdep-ppc64/dwarf-config.h
+++ b/include/tdep-ppc64/dwarf-config.h
@@ -33,22 +33,22 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #define dwarf_config_h
 
 /* For PPC64, 48 GPRs + 33 FPRs + 33 AltiVec + 1 SPE  */
-#define DWARF_NUM_PRESERVED_REGS	115
+#define DWARF_NUM_PRESERVED_REGS        115
 
-#define DWARF_REGNUM_MAP_LENGTH		115
+#define DWARF_REGNUM_MAP_LENGTH         115
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
-#define dwarf_is_big_endian(addr_space) 1
+#define dwarf_is_big_endian(addr_space) ((addr_space)->big_endian)
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
 #ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see X86_LOC_TYPE_* macros.  */
+    unw_word_t type;            /* see X86_LOC_TYPE_* macros.  */
 #endif
   }
 dwarf_loc_t;
diff --git a/include/tdep-ppc64/jmpbuf.h b/include/tdep-ppc64/jmpbuf.h
index 3780d5b..861e94d 100644
--- a/include/tdep-ppc64/jmpbuf.h
+++ b/include/tdep-ppc64/jmpbuf.h
@@ -31,7 +31,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* Use glibc's jump-buffer indices; NPTL peeks at SP: */
 
-#define JB_SP		6
-#define JB_RP		7
-#define JB_MASK_SAVED	8
-#define JB_MASK		9
+#define JB_SP           6
+#define JB_RP           7
+#define JB_MASK_SAVED   8
+#define JB_MASK         9
diff --git a/include/tdep-ppc64/libunwind_i.h b/include/tdep-ppc64/libunwind_i.h
index 6d72858..975f3bb 100644
--- a/include/tdep-ppc64/libunwind_i.h
+++ b/include/tdep-ppc64/libunwind_i.h
@@ -51,14 +51,16 @@ unw_tdep_frame_t;
 struct unw_addr_space
 {
   struct unw_accessors acc;
+  int big_endian;
+  ppc64_abi_t abi;
   unw_caching_policy_t caching_policy;
 #ifdef HAVE_ATOMIC_OPS_H
   AO_t cache_generation;
 #else
   uint32_t cache_generation;
 #endif
-  unw_word_t dyn_generation;	/* see dyn-common.h */
-  unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+  unw_word_t dyn_generation;    /* see dyn-common.h */
+  unw_word_t dyn_info_list_addr;        /* (cached) dyn_info_list_addr */
   struct dwarf_rs_cache global_cache;
   struct unw_debug_frame_list *debug_frames;
   int validate;
@@ -66,55 +68,106 @@ struct unw_addr_space
 
 struct cursor
 {
-  struct dwarf_cursor dwarf;	/* must be first */
+  struct dwarf_cursor dwarf;    /* must be first */
 
   /* Format of sigcontext structure and address at which it is
      stored: */
   enum
   {
-    PPC_SCF_NONE,		/* no signal frame encountered */
-    PPC_SCF_LINUX_RT_SIGFRAME	/* POSIX ucontext_t */
+    PPC_SCF_NONE,               /* no signal frame encountered */
+    PPC_SCF_LINUX_RT_SIGFRAME   /* POSIX ucontext_t */
   }
   sigcontext_format;
   unw_word_t sigcontext_addr;
 };
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_IS_FP_LOC(l)	0
-# define DWARF_IS_V_LOC(l)	0
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_VREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-#else /* !UNW_LOCAL_ONLY */
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_VREG_LOC(c,r)    (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
 
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_LOC_TYPE_V	(1 << 2)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_IS_V_LOC(l)	(((l).type & DWARF_LOC_TYPE_V) != 0)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
-# define DWARF_VREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_V))
+static inline int
+dwarf_getvr (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t * val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *val = *(unw_fpreg_t *) DWARF_GET_LOC (loc);
+  return 0;
+}
 
-#endif /* !UNW_LOCAL_ONLY */
+static inline int
+dwarf_putvr (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *(unw_fpreg_t *) DWARF_GET_LOC (loc) = val;
+  return 0;
+}
+
+static inline int
+dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *val = *(unw_fpreg_t *) DWARF_GET_LOC (loc);
+  return 0;
+}
+
+static inline int
+dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *(unw_fpreg_t *) DWARF_GET_LOC (loc) = val;
+  return 0;
+}
+
+static inline int
+dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *val = *(unw_word_t *) DWARF_GET_LOC (loc);
+  return 0;
+}
+
+static inline int
+dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+  *(unw_word_t *) DWARF_GET_LOC (loc) = val;
+  return 0;
+}
+
+#else /* !UNW_LOCAL_ONLY */
+
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_LOC_TYPE_V       (1 << 2)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_IS_V_LOC(l)      (((l).type & DWARF_LOC_TYPE_V) != 0)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
+# define DWARF_VREG_LOC(c,r)    DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_V))
 
 static inline int
 dwarf_getvr (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t * val)
@@ -131,12 +184,12 @@ dwarf_getvr (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t * val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				      val, 0, c->as_arg);
+                                      val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
 
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, valp,
-				       0, c->as_arg)) < 0)
+                                       0, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 8, valp + 1, 0, c->as_arg);
@@ -157,11 +210,11 @@ dwarf_putvr (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				      &val, 1, c->as_arg);
+                                      &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, valp,
-				       1, c->as_arg)) < 0)
+                                       1, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 8, valp + 1, 1, c->as_arg);
@@ -181,7 +234,7 @@ dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t * val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   return (*c->as->acc.access_mem) (c->as, addr + 0, valp, 0, c->as_arg);
@@ -202,7 +255,7 @@ dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       &val, 1, c->as_arg);
+                                       &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
 
@@ -224,10 +277,10 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t * val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
 }
 
 static inline int
@@ -245,68 +298,72 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
+#endif /* !UNW_LOCAL_ONLY */
+
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init			UNW_OBJ(init)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	dwarf_search_unwind_table
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_uc_addr			UNW_ARCH_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
-#define tdep_get_func_addr		UNW_OBJ(get_func_addr)
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
+#define tdep_get_func_addr              UNW_OBJ(get_func_addr)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	dwarf_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)			\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                        \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
 extern int tdep_fetch_proc_info_post (struct dwarf_cursor *c, unw_word_t ip,
-				      int need_unwind_info);
+                                      int need_unwind_info);
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
-#define tdep_big_endian(as)		1
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             ((as)->big_endian)
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t * di,
-				     unw_proc_info_t * pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t * di,
+                                     unw_proc_info_t * pi,
+                                     int need_unwind_info, void *arg);
 extern void *tdep_uc_addr (ucontext_t * uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t * valp, int write);
+                            unw_word_t * valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t * valp, int write);
+                              unw_fpreg_t * valp, int write);
 extern int tdep_get_func_addr (unw_addr_space_t as, unw_word_t addr,
-			       unw_word_t *entry_point);
+                               unw_word_t *entry_point);
 
 #endif /* PPC64_LIBUNWIND_I_H */
diff --git a/include/tdep-s390x/dwarf-config.h b/include/tdep-s390x/dwarf-config.h
new file mode 100644
index 0000000..ca419bd
--- /dev/null
+++ b/include/tdep-s390x/dwarf-config.h
@@ -0,0 +1,52 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+/* copy of include/tdep-x86/dwarf-config.h, modified slightly for x86-64
+   some consolidation is possible here */
+
+#ifndef dwarf_config_h
+#define dwarf_config_h
+
+/* derived from DWARF register mappings in Z ELF ABI */
+#define DWARF_NUM_PRESERVED_REGS        66
+#define DWARF_REGNUM_MAP_LENGTH         DWARF_NUM_PRESERVED_REGS
+
+/* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
+#define dwarf_is_big_endian(addr_space) 1
+
+/* Convert a pointer to a dwarf_cursor structure to a pointer to
+   unw_cursor_t.  */
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
+
+typedef struct dwarf_loc
+  {
+    unw_word_t val;
+    unw_word_t type;            /* see S390X_LOC_TYPE_* macros.  */
+  }
+dwarf_loc_t;
+
+#endif /* dwarf_config_h */
diff --git a/include/tdep-s390x/jmpbuf.h b/include/tdep-s390x/jmpbuf.h
new file mode 100644
index 0000000..5092375
--- /dev/null
+++ b/include/tdep-s390x/jmpbuf.h
@@ -0,0 +1,35 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2004 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#if defined __linux__
+
+/* Use glibc's jump-buffer indices; NPTL peeks at SP: */
+
+#define JB_SP           9  // __gregs[9]
+#define JB_RP           8  // __gregs[8]
+#define JB_MASK_SAVED   18 // __mask_was_saved
+#define JB_MASK         19 // __saved_mask
+
+#endif
diff --git a/include/tdep-s390x/libunwind_i.h b/include/tdep-s390x/libunwind_i.h
new file mode 100644
index 0000000..137a0b8
--- /dev/null
+++ b/include/tdep-s390x/libunwind_i.h
@@ -0,0 +1,262 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2002-2005 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef S390X_LIBUNWIND_I_H
+#define S390X_LIBUNWIND_I_H
+
+/* Target-dependent definitions that are internal to libunwind but need
+   to be shared with target-independent code.  */
+
+#include <stdlib.h>
+#include <libunwind.h>
+
+#include "elf64.h"
+#include "mempool.h"
+#include "dwarf.h"
+
+struct unw_addr_space
+  {
+    struct unw_accessors acc;
+    unw_caching_policy_t caching_policy;
+#ifdef HAVE_ATOMIC_OPS_H
+    AO_t cache_generation;
+#else
+    uint32_t cache_generation;
+#endif
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
+    struct dwarf_rs_cache global_cache;
+    struct unw_debug_frame_list *debug_frames;
+   };
+
+struct cursor
+  {
+    struct dwarf_cursor dwarf;          /* must be first */
+
+    /* Format of sigcontext structure and address at which it is
+       stored: */
+    enum
+      {
+        S390X_SCF_NONE              = 0, /* no signal frame encountered */
+        S390X_SCF_LINUX_SIGFRAME    = 1, /* Linux struct sigcontext */
+        S390X_SCF_LINUX_RT_SIGFRAME = 2, /* Linux ucontext_t */
+      }
+    sigcontext_format;
+    unw_word_t sigcontext_addr;
+    unw_word_t sigcontext_sp;
+    unw_word_t sigcontext_pc;
+    int validate;
+    ucontext_t *uc;
+  };
+
+static inline ucontext_t *
+dwarf_get_uc(const struct dwarf_cursor *cursor)
+{
+  const struct cursor *c = (struct cursor *) cursor->as_arg;
+  return c->uc;
+}
+
+#define DWARF_GET_LOC(l)        ((l).val)
+# define DWARF_LOC_TYPE_MEM     (0 << 0)
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_LOC_TYPE_VAL     (1 << 2)
+
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_IS_MEM_LOC(l)    ((l).type == DWARF_LOC_TYPE_MEM)
+# define DWARF_IS_VAL_LOC(l)    (((l).type & DWARF_LOC_TYPE_VAL) != 0)
+
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_VAL_LOC(c,v)     DWARF_LOC ((v), DWARF_LOC_TYPE_VAL)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), DWARF_LOC_TYPE_MEM)
+
+#ifdef UNW_LOCAL_ONLY
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr(dwarf_get_uc(c), (r)), 0))
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr(dwarf_get_uc(c), (r)), 0))
+
+#else /* !UNW_LOCAL_ONLY */
+
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
+
+#endif /* !UNW_LOCAL_ONLY */
+
+static inline int
+dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
+{
+  assert(sizeof(unw_fpreg_t) == sizeof(unw_word_t));
+
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  if (DWARF_IS_FP_LOC (loc))
+    return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc), val,
+                                       0, c->as_arg);
+  /* FPRs may be saved in GPRs */
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), (unw_word_t*)val,
+                                     0, c->as_arg);
+  if (DWARF_IS_MEM_LOC (loc))
+    return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), (unw_word_t*)val,
+                                     0, c->as_arg);
+  assert(DWARF_IS_VAL_LOC (loc));
+  *val = *(unw_fpreg_t*) DWARF_GET_LOC (loc);
+  return 0;
+}
+
+static inline int
+dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
+{
+  assert(sizeof(unw_fpreg_t) == sizeof(unw_word_t));
+  assert(!DWARF_IS_VAL_LOC (loc));
+
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  if (DWARF_IS_FP_LOC (loc))
+    return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc), &val,
+                                       1, c->as_arg);
+  /* FPRs may be saved in GPRs */
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), (unw_word_t*) &val,
+                                     1, c->as_arg);
+
+  assert(DWARF_IS_MEM_LOC (loc));
+  return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), (unw_word_t*) &val,
+                                   1, c->as_arg);
+}
+
+static inline int
+dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
+{
+  assert(sizeof(unw_fpreg_t) == sizeof(unw_word_t));
+
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
+                                     0, c->as_arg);
+  if (DWARF_IS_MEM_LOC (loc))
+    return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
+                                     0, c->as_arg);
+  /* GPRs may be saved in FPRs */
+  if (DWARF_IS_FP_LOC (loc))
+    return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc), (unw_fpreg_t*)val,
+                                       0, c->as_arg);
+  assert(DWARF_IS_VAL_LOC (loc));
+  *val = DWARF_GET_LOC (loc);
+  return 0;
+}
+
+static inline int
+dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
+{
+  assert(sizeof(unw_fpreg_t) == sizeof(unw_word_t));
+  assert(!DWARF_IS_VAL_LOC (loc));
+
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
+                                     1, c->as_arg);
+  /* GPRs may be saved in FPRs */
+  if (DWARF_IS_FP_LOC (loc))
+    return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc), (unw_fpreg_t*) &val,
+                                       1, c->as_arg);
+
+  assert(DWARF_IS_MEM_LOC (loc));
+  return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
+                                   1, c->as_arg);
+}
+
+#define tdep_getcontext_trace           unw_getcontext
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init_mem_validate          UNW_OBJ(init_mem_validate)
+#define tdep_init                       UNW_OBJ(init)
+/* Platforms that support UNW_INFO_FORMAT_TABLE need to define
+   tdep_search_unwind_table.  */
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,rs)          do {} while(0)
+#define tdep_stash_frame(cs,rs)         do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
+#define tdep_uc_addr                    UNW_OBJ(uc_addr)
+
+#ifdef UNW_LOCAL_ONLY
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
+#else
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                        \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
+#endif
+
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             1
+
+extern int tdep_init_done;
+
+extern void tdep_init (void);
+extern void tdep_init_mem_validate (void);
+extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
+extern void *tdep_uc_addr (unw_tdep_context_t *uc, int reg);
+extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
+extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
+                            unw_word_t *valp, int write);
+extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
+                              unw_fpreg_t *valp, int write);
+
+#endif /* S390X_LIBUNWIND_I_H */
diff --git a/include/tdep-sh/dwarf-config.h b/include/tdep-sh/dwarf-config.h
index 2a7116f..2f76f5b 100644
--- a/include/tdep-sh/dwarf-config.h
+++ b/include/tdep-sh/dwarf-config.h
@@ -26,22 +26,22 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifndef dwarf_config_h
 #define dwarf_config_h
 
-#define DWARF_NUM_PRESERVED_REGS	18
+#define DWARF_NUM_PRESERVED_REGS        18
 
 #define dwarf_to_unw_regnum(reg) (((reg) <= UNW_SH_PR) ? (reg) : 0)
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
-#define dwarf_is_big_endian(addr_space)	((addr_space)->big_endian)
+#define dwarf_is_big_endian(addr_space) ((addr_space)->big_endian)
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
 #ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see DWARF_LOC_TYPE_* macros.  */
+    unw_word_t type;            /* see DWARF_LOC_TYPE_* macros.  */
 #endif
   }
 dwarf_loc_t;
diff --git a/include/tdep-sh/jmpbuf.h b/include/tdep-sh/jmpbuf.h
index 684a405..8b44b5b 100644
--- a/include/tdep-sh/jmpbuf.h
+++ b/include/tdep-sh/jmpbuf.h
@@ -42,7 +42,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
  * 14. fr15
  */
 
-#define JB_SP		7
-#define JB_RP		8
-#define JB_MASK_SAVED	15
-#define JB_MASK		16
+#define JB_SP           7
+#define JB_RP           8
+#define JB_MASK_SAVED   15
+#define JB_MASK         16
diff --git a/include/tdep-sh/libunwind_i.h b/include/tdep-sh/libunwind_i.h
index 51234d1..8ced491 100644
--- a/include/tdep-sh/libunwind_i.h
+++ b/include/tdep-sh/libunwind_i.h
@@ -52,15 +52,15 @@ struct unw_addr_space
 #else
     uint32_t cache_generation;
 #endif
-    unw_word_t dyn_generation;		/* see dyn-common.h */
-    unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
     struct dwarf_rs_cache global_cache;
     struct unw_debug_frame_list *debug_frames;
   };
 
 struct cursor
   {
-    struct dwarf_cursor dwarf;		/* must be first */
+    struct dwarf_cursor dwarf;          /* must be first */
     enum
       {
         SH_SCF_NONE,                   /* no signal frame */
@@ -73,18 +73,18 @@ struct cursor
     unw_word_t sigcontext_pc;
   };
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr((c)->as_arg, (r)), 0))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -123,18 +123,18 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 }
 
 #else /* !UNW_LOCAL_ONLY */
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -148,15 +148,15 @@ dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       0, c->as_arg)) < 0)
+                                       0, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1, 0,
-				   c->as_arg);
+                                   c->as_arg);
 }
 
 static inline int
@@ -171,15 +171,15 @@ dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       &val, 1, c->as_arg);
+                                       &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       1, c->as_arg)) < 0)
+                                       1, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1,
-				   1, c->as_arg);
+                                   1, c->as_arg);
 }
 
 static inline int
@@ -196,10 +196,10 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
 }
 
 static inline int
@@ -216,63 +216,65 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
 #endif /* !UNW_LOCAL_ONLY */
 
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init			UNW_OBJ(init)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	dwarf_search_unwind_table
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_uc_addr			UNW_ARCH_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	dwarf_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
-#define tdep_big_endian(as)		((as)->big_endian)
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             ((as)->big_endian)
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t *di, unw_proc_info_t *pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
 extern void *tdep_uc_addr (unw_tdep_context_t *uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t *valp, int write);
+                            unw_word_t *valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t *valp, int write);
+                              unw_fpreg_t *valp, int write);
 
 #endif /* SH_LIBUNWIND_I_H */
diff --git a/include/tdep-tilegx/dwarf-config.h b/include/tdep-tilegx/dwarf-config.h
new file mode 100644
index 0000000..93bc6aa
--- /dev/null
+++ b/include/tdep-tilegx/dwarf-config.h
@@ -0,0 +1,50 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef dwarf_config_h
+#define dwarf_config_h
+
+/* This is FIRST_PSEUDO_REGISTER in GCC, since DWARF_FRAME_REGISTERS is not
+   explicitly defined.  */
+#define DWARF_NUM_PRESERVED_REGS        188
+
+#define DWARF_REGNUM_MAP_LENGTH         (56 + 2)
+
+/* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
+#define dwarf_is_big_endian(addr_space) ((addr_space)->big_endian)
+
+/* Convert a pointer to a dwarf_cursor structure to a pointer to
+   unw_cursor_t.  */
+#define dwarf_to_cursor(c)   ((unw_cursor_t *) (c))
+
+typedef struct dwarf_loc
+{
+  unw_word_t val;
+#ifndef UNW_LOCAL_ONLY
+  unw_word_t type;        /* see DWARF_LOC_TYPE_* macros.  */
+#endif
+} dwarf_loc_t;
+
+#endif /* dwarf_config_h */
diff --git a/include/tdep-tilegx/jmpbuf.h b/include/tdep-tilegx/jmpbuf.h
new file mode 100644
index 0000000..3afe9e4
--- /dev/null
+++ b/include/tdep-tilegx/jmpbuf.h
@@ -0,0 +1,33 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+/* Use glibc's jump-buffer indices; NPTL peeks at SP: */
+
+/* FIXME for Tilegx!  */
+
+#define JB_SP            4
+#define JB_RP            5
+#define JB_MASK_SAVED    6
+#define JB_MASK          7
diff --git a/include/tdep-tilegx/libunwind_i.h b/include/tdep-tilegx/libunwind_i.h
new file mode 100644
index 0000000..2cfed45
--- /dev/null
+++ b/include/tdep-tilegx/libunwind_i.h
@@ -0,0 +1,263 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef TILEGX_LIBUNWIND_I_H
+#define TILEGX_LIBUNWIND_I_H
+
+/* Target-dependent definitions that are internal to libunwind but need
+   to be shared with target-independent code.  */
+
+#include <stdlib.h>
+#include <libunwind.h>
+
+# include "elf64.h"
+#include "mempool.h"
+#include "dwarf.h"
+
+typedef struct
+{
+  /* no Tilegx-specific fast trace */
+} unw_tdep_frame_t;
+
+struct unw_addr_space
+{
+  struct unw_accessors acc;
+
+  int big_endian;
+  tilegx_abi_t abi;
+  unsigned int addr_size;
+
+  unw_caching_policy_t caching_policy;
+#ifdef HAVE_ATOMIC_OPS_H
+  AO_t cache_generation;
+#else
+  uint32_t cache_generation;
+#endif
+  unw_word_t dyn_generation;          /* see dyn-common.h */
+  unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
+  struct dwarf_rs_cache global_cache;
+  struct unw_debug_frame_list *debug_frames;
+};
+
+#define tdep_big_endian(as)            ((as)->big_endian)
+
+struct cursor
+{
+  struct dwarf_cursor dwarf;         /* must be first */
+  unw_word_t sigcontext_addr;
+  unw_word_t sigcontext_sp;
+  unw_word_t sigcontext_pc;
+};
+
+#define DWARF_GET_LOC(l)      ((l).val)
+
+#ifndef UNW_REMOTE_ONLY
+typedef long tilegx_reg_t;
+#endif
+
+#ifdef UNW_LOCAL_ONLY
+#define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+#define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+#define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+#define DWARF_IS_REG_LOC(l)    0
+#define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t) (intptr_t)       \
+                                          tdep_uc_addr((c)->as_arg, (r)), 0))
+#define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+#define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t) (intptr_t)       \
+                                          tdep_uc_addr((c)->as_arg, (r)), 0))
+
+/* Tilegx has no FP. */
+static inline int
+dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
+{
+  Debug (1, "Tielgx has no fp!\n");
+  abort();
+  return 0;
+}
+
+static inline int
+dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
+{
+  Debug (1, "Tielgx has no fp!\n");
+  abort();
+  return 0;
+}
+
+static inline int
+dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+
+  *val = *(tilegx_reg_t *) (intptr_t) DWARF_GET_LOC (loc);
+  return 0;
+}
+
+static inline int
+dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
+{
+  if (!DWARF_GET_LOC (loc))
+    return -1;
+
+  *(tilegx_reg_t *) (intptr_t) DWARF_GET_LOC (loc) = val;
+  return 0;
+}
+
+#else /* !UNW_LOCAL_ONLY */
+#define DWARF_LOC_TYPE_FP      (1 << 0)
+#define DWARF_LOC_TYPE_REG     (1 << 1)
+#define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+#define DWARF_IS_NULL_LOC(l)                                    \
+  ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+#define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+#define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+#define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+#define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+#define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+#define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG       \
+                                               | DWARF_LOC_TYPE_FP))
+
+/* TILEGX has no fp. */
+static inline int
+dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
+{
+  Debug (1, "Tielgx has no fp!\n");
+  abort();
+  return 0;
+}
+
+static inline int
+dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
+{
+  Debug (1, "Tielgx has no fp!\n");
+  abort();
+  return 0;
+}
+
+static inline int
+dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
+{
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  /* If a code-generator were to save a value of type unw_word_t in a
+     floating-point register, we would have to support this case.  I
+     suppose it could happen with MMX registers, but does it really
+     happen?  */
+  assert (!DWARF_IS_FP_LOC (loc));
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
+                                     0, c->as_arg);
+
+  return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
+                                   0, c->as_arg);
+}
+
+static inline int
+dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
+{
+  if (DWARF_IS_NULL_LOC (loc))
+    return -UNW_EBADREG;
+
+  /* If a code-generator were to save a value of type unw_word_t in a
+     floating-point register, we would have to support this case.  I
+     suppose it could happen with MMX registers, but does it really
+     happen?  */
+  assert (!DWARF_IS_FP_LOC (loc));
+
+  if (DWARF_IS_REG_LOC (loc))
+    return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
+                                     1, c->as_arg);
+
+  return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
+                                   1, c->as_arg);
+}
+
+#endif /* !UNW_LOCAL_ONLY */
+
+#define tdep_getcontext_trace           unw_getcontext
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_needs_initialization       UNW_OBJ(needs_initialization)
+#define tdep_init                       UNW_OBJ(init)
+/* Platforms that support UNW_INFO_FORMAT_TABLE need to define
+   tdep_search_unwind_table.  */
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
+
+#ifdef UNW_LOCAL_ONLY
+#define tdep_find_proc_info(c,ip,n)                            \
+  dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),           \
+                       (c)->as_arg)
+#define tdep_put_unwind_info(as,pi,arg)         \
+  dwarf_put_unwind_info((as), (pi), (arg))
+#else
+#define tdep_find_proc_info(c,ip,n)                                     \
+  (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),          \
+                                 (c)->as_arg)
+#define tdep_put_unwind_info(as,pi,arg)                 \
+  (*(as)->acc.put_unwind_info)((as), (pi), (arg))
+#endif
+
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+
+extern int tdep_init_done;
+
+extern void tdep_init (void);
+extern int tdep_search_unwind_table (unw_addr_space_t as,
+                                     unw_word_t ip,
+                                     unw_dyn_info_t *di,
+                                     unw_proc_info_t *pi,
+                                     int need_unwind_info,
+                                     void *arg);
+extern void *tdep_uc_addr (ucontext_t *uc, int reg);
+extern int tdep_get_elf_image (struct elf_image *ei,
+                               pid_t pid, unw_word_t ip,
+                               unsigned long *segbase,
+                               unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
+extern int tdep_access_reg (struct cursor *c,
+                            unw_regnum_t reg,
+                            unw_word_t *valp,
+                            int write);
+extern int tdep_access_fpreg (struct cursor *c,
+                              unw_regnum_t reg,
+                              unw_fpreg_t *valp,
+                              int write);
+
+#endif /* TILEGX_LIBUNWIND_I_H */
diff --git a/include/tdep-x86/dwarf-config.h b/include/tdep-x86/dwarf-config.h
index 898ab79..f76f9c1 100644
--- a/include/tdep-x86/dwarf-config.h
+++ b/include/tdep-x86/dwarf-config.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -29,22 +29,22 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 /* This matches the value used by GCC (see
    gcc/config/i386.h:DWARF_FRAME_REGISTERS), which leaves plenty of
    room for expansion.  */
-#define DWARF_NUM_PRESERVED_REGS	17
+#define DWARF_NUM_PRESERVED_REGS        17
 
-#define DWARF_REGNUM_MAP_LENGTH		19
+#define DWARF_REGNUM_MAP_LENGTH         19
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
-#define dwarf_is_big_endian(addr_space)	0
+#define dwarf_is_big_endian(addr_space) 0
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
 #ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see X86_LOC_TYPE_* macros.  */
+    unw_word_t type;            /* see X86_LOC_TYPE_* macros.  */
 #endif
   }
 dwarf_loc_t;
diff --git a/include/tdep-x86/jmpbuf.h b/include/tdep-x86/jmpbuf.h
index 5614950..521dfa6 100644
--- a/include/tdep-x86/jmpbuf.h
+++ b/include/tdep-x86/jmpbuf.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,16 +27,16 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #if defined __linux__
 
-#define JB_SP		4
-#define JB_RP		5
-#define JB_MASK_SAVED	6
-#define JB_MASK		7
+#define JB_SP           4
+#define JB_RP           5
+#define JB_MASK_SAVED   6
+#define JB_MASK         7
 
 #elif defined __FreeBSD__
 
-#define JB_SP		2
-#define JB_RP		0
-#define JB_MASK_SAVED	11
-#define JB_MASK		7
+#define JB_SP           2
+#define JB_RP           0
+#define JB_MASK_SAVED   11
+#define JB_MASK         7
 
 #endif
diff --git a/include/tdep-x86/libunwind_i.h b/include/tdep-x86/libunwind_i.h
index f59a3cf..5231189 100644
--- a/include/tdep-x86/libunwind_i.h
+++ b/include/tdep-x86/libunwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -51,27 +51,27 @@ struct unw_addr_space
 #else
     uint32_t cache_generation;
 #endif
-    unw_word_t dyn_generation;		/* see dyn-common.h */
-    unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
     struct dwarf_rs_cache global_cache;
     struct unw_debug_frame_list *debug_frames;
    };
 
 struct cursor
   {
-    struct dwarf_cursor dwarf;		/* must be first */
+    struct dwarf_cursor dwarf;          /* must be first */
 
     /* Format of sigcontext structure and address at which it is
        stored: */
     enum
       {
-	X86_SCF_NONE,			/* no signal frame encountered */
-	X86_SCF_LINUX_SIGFRAME,		/* Linux x86 sigcontext */
-	X86_SCF_LINUX_RT_SIGFRAME,	/* POSIX ucontext_t */
-	X86_SCF_FREEBSD_SIGFRAME,	/* FreeBSD x86 sigcontext */
-	X86_SCF_FREEBSD_SIGFRAME4,	/* FreeBSD 4.x x86 sigcontext */
-	X86_SCF_FREEBSD_OSIGFRAME,	/* FreeBSD pre-4.x x86 sigcontext */
-	X86_SCF_FREEBSD_SYSCALL,	/* FreeBSD x86 syscall */
+        X86_SCF_NONE,                   /* no signal frame encountered */
+        X86_SCF_LINUX_SIGFRAME,         /* Linux x86 sigcontext */
+        X86_SCF_LINUX_RT_SIGFRAME,      /* POSIX ucontext_t */
+        X86_SCF_FREEBSD_SIGFRAME,       /* FreeBSD x86 sigcontext */
+        X86_SCF_FREEBSD_SIGFRAME4,      /* FreeBSD 4.x x86 sigcontext */
+        X86_SCF_FREEBSD_OSIGFRAME,      /* FreeBSD pre-4.x x86 sigcontext */
+        X86_SCF_FREEBSD_SYSCALL,        /* FreeBSD x86 syscall */
       }
     sigcontext_format;
     unw_word_t sigcontext_addr;
@@ -86,18 +86,18 @@ dwarf_get_uc(const struct dwarf_cursor *cursor)
   return c->uc;
 }
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr(dwarf_get_uc(c), (r)), 0))
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 tdep_uc_addr(dwarf_get_uc(c), (r)), 0))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r) })
+# define DWARF_IS_REG_LOC(l)    0
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr(dwarf_get_uc(c), (r)), 0))
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 tdep_uc_addr(dwarf_get_uc(c), (r)), 0))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -123,7 +123,7 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
   if (!DWARF_GET_LOC (loc))
     return -1;
   return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				   0, c->as_arg);
+                                   0, c->as_arg);
 }
 
 static inline int
@@ -132,22 +132,22 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
   if (!DWARF_GET_LOC (loc))
     return -1;
   return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				   1, c->as_arg);
+                                   1, c->as_arg);
 }
 
 #else /* !UNW_LOCAL_ONLY */
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), 0)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
 
 static inline int
 dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
@@ -161,15 +161,15 @@ dwarf_getfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       0, c->as_arg)) < 0)
+                                       0, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1, 0,
-				   c->as_arg);
+                                   c->as_arg);
 }
 
 static inline int
@@ -184,15 +184,15 @@ dwarf_putfp (struct dwarf_cursor *c, dwarf_loc_t loc, unw_fpreg_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, DWARF_GET_LOC (loc),
-				       &val, 1, c->as_arg);
+                                       &val, 1, c->as_arg);
 
   addr = DWARF_GET_LOC (loc);
   if ((ret = (*c->as->acc.access_mem) (c->as, addr + 0, (unw_word_t *) valp,
-				       1, c->as_arg)) < 0)
+                                       1, c->as_arg)) < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 4, (unw_word_t *) valp + 1,
-				   1, c->as_arg);
+                                   1, c->as_arg);
 }
 
 static inline int
@@ -209,10 +209,10 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
 }
 
 static inline int
@@ -229,63 +229,65 @@ dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
 #endif /* !UNW_LOCAL_ONLY */
 
 #define tdep_getcontext_trace           unw_getcontext
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init			UNW_OBJ(init)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	dwarf_search_unwind_table
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_uc_addr			UNW_ARCH_OBJ(uc_addr)
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
-#define tdep_fetch_frame(c,ip,n)	do {} while(0)
-#define tdep_cache_frame(c,rs)		do {} while(0)
-#define tdep_reuse_frame(c,rs)		do {} while(0)
-#define tdep_stash_frame(c,rs)		do {} while(0)
-#define tdep_trace(cur,addr,n)		(-UNW_ENOINFO)
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_uc_addr                    UNW_ARCH_OBJ(uc_addr)
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
+#define tdep_fetch_frame(c,ip,n)        do {} while(0)
+#define tdep_cache_frame(c)             0
+#define tdep_reuse_frame(c,frame)       do {} while(0)
+#define tdep_stash_frame(c,rs)          do {} while(0)
+#define tdep_trace(cur,addr,n)          (-UNW_ENOINFO)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	dwarf_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
-#define tdep_big_endian(as)		0
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             0
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t *di, unw_proc_info_t *pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
 extern void *tdep_uc_addr (ucontext_t *uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t *valp, int write);
+                            unw_word_t *valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t *valp, int write);
+                              unw_fpreg_t *valp, int write);
 
 #endif /* X86_LIBUNWIND_I_H */
diff --git a/include/tdep-x86_64/dwarf-config.h b/include/tdep-x86_64/dwarf-config.h
index d3cbe7c..ff77808 100644
--- a/include/tdep-x86_64/dwarf-config.h
+++ b/include/tdep-x86_64/dwarf-config.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -33,26 +33,24 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* XXX need to verify if this value is correct */
 #ifdef CONFIG_MSABI_SUPPORT
-#define DWARF_NUM_PRESERVED_REGS	33
+#define DWARF_NUM_PRESERVED_REGS        33
 #else
-#define DWARF_NUM_PRESERVED_REGS	17
+#define DWARF_NUM_PRESERVED_REGS        17
 #endif 
 
-#define DWARF_REGNUM_MAP_LENGTH		DWARF_NUM_PRESERVED_REGS
+#define DWARF_REGNUM_MAP_LENGTH         DWARF_NUM_PRESERVED_REGS
 
 /* Return TRUE if the ADDR_SPACE uses big-endian byte-order.  */
-#define dwarf_is_big_endian(addr_space)	0
+#define dwarf_is_big_endian(addr_space) 0
 
 /* Convert a pointer to a dwarf_cursor structure to a pointer to
    unw_cursor_t.  */
-#define dwarf_to_cursor(c)	((unw_cursor_t *) (c))
+#define dwarf_to_cursor(c)      ((unw_cursor_t *) (c))
 
 typedef struct dwarf_loc
   {
     unw_word_t val;
-#ifndef UNW_LOCAL_ONLY
-    unw_word_t type;		/* see X86_LOC_TYPE_* macros.  */
-#endif
+    unw_word_t type;            /* see X86_LOC_TYPE_* macros.  */
   }
 dwarf_loc_t;
 
diff --git a/include/tdep-x86_64/jmpbuf.h b/include/tdep-x86_64/jmpbuf.h
index 44fcd69..d571966 100644
--- a/include/tdep-x86_64/jmpbuf.h
+++ b/include/tdep-x86_64/jmpbuf.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,17 +27,17 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* Use glibc's jump-buffer indices; NPTL peeks at SP: */
 
-#define JB_SP		6
-#define JB_RP		7
-#define JB_MASK_SAVED	8
-#define JB_MASK		9
+#define JB_SP           6
+#define JB_RP           7
+#define JB_MASK_SAVED   8
+#define JB_MASK         9
 
 #elif defined __FreeBSD__
 
-#define JB_SP		2
-#define JB_RP		0
+#define JB_SP           2
+#define JB_RP           0
 /* Pretend the ip cannot be 0 and mask is always saved */
-#define JB_MASK_SAVED	0
-#define JB_MASK		9
+#define JB_MASK_SAVED   0
+#define JB_MASK         9
 
 #endif
diff --git a/include/tdep-x86_64/libunwind_i.h b/include/tdep-x86_64/libunwind_i.h
index 8c9cd05..283525c 100644
--- a/include/tdep-x86_64/libunwind_i.h
+++ b/include/tdep-x86_64/libunwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -40,6 +40,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 typedef enum
   {
+    UNW_X86_64_FRAME_ALIGNED = -3,       /* frame stack pointer aligned */
     UNW_X86_64_FRAME_STANDARD = -2,     /* regular rbp, rsp +/- offset */
     UNW_X86_64_FRAME_SIGRETURN = -1,    /* special sigreturn frame */
     UNW_X86_64_FRAME_OTHER = 0,         /* not cacheable (special or unrecognised) */
@@ -50,10 +51,10 @@ unw_tdep_frame_type_t;
 typedef struct
   {
     uint64_t virtual_address;
-    int64_t frame_type     : 2;  /* unw_tdep_frame_type_t classification */
+    int64_t frame_type     : 3;  /* unw_tdep_frame_type_t classification */
     int64_t last_frame     : 1;  /* non-zero if last frame in chain */
     int64_t cfa_reg_rsp    : 1;  /* cfa dwarf base register is rsp vs. rbp */
-    int64_t cfa_reg_offset : 30; /* cfa is at this offset from base register value */
+    int64_t cfa_reg_offset : 29; /* cfa is at this offset from base register value */
     int64_t rbp_cfa_offset : 15; /* rbp saved at this offset from cfa (-1 = not saved) */
     int64_t rsp_cfa_offset : 15; /* rsp saved at this offset from cfa (-1 = not saved) */
   }
@@ -68,26 +69,26 @@ struct unw_addr_space
 #else
     uint32_t cache_generation;
 #endif
-    unw_word_t dyn_generation;		/* see dyn-common.h */
-    unw_word_t dyn_info_list_addr;	/* (cached) dyn_info_list_addr */
+    unw_word_t dyn_generation;          /* see dyn-common.h */
+    unw_word_t dyn_info_list_addr;      /* (cached) dyn_info_list_addr */
     struct dwarf_rs_cache global_cache;
     struct unw_debug_frame_list *debug_frames;
    };
 
 struct cursor
   {
-    struct dwarf_cursor dwarf;		/* must be first */
+    struct dwarf_cursor dwarf;          /* must be first */
 
-    unw_tdep_frame_t frame_info;	/* quick tracing assist info */
+    unw_tdep_frame_t frame_info;        /* quick tracing assist info */
 
     /* Format of sigcontext structure and address at which it is
        stored: */
     enum
       {
-	X86_64_SCF_NONE,		/* no signal frame encountered */
-	X86_64_SCF_LINUX_RT_SIGFRAME,	/* Linux ucontext_t */
-	X86_64_SCF_FREEBSD_SIGFRAME,	/* FreeBSD signal frame */
-	X86_64_SCF_FREEBSD_SYSCALL,	/* FreeBSD syscall */
+        X86_64_SCF_NONE,                /* no signal frame encountered */
+        X86_64_SCF_LINUX_RT_SIGFRAME,   /* Linux ucontext_t */
+        X86_64_SCF_FREEBSD_SIGFRAME,    /* FreeBSD signal frame */
+        X86_64_SCF_FREEBSD_SYSCALL,     /* FreeBSD syscall */
       }
     sigcontext_format;
     unw_word_t sigcontext_addr;
@@ -102,32 +103,37 @@ dwarf_get_uc(const struct dwarf_cursor *cursor)
   return c->uc;
 }
 
-#define DWARF_GET_LOC(l)	((l).val)
+#define DWARF_GET_LOC(l)        ((l).val)
+# define DWARF_LOC_TYPE_MEM     (0 << 0)
+# define DWARF_LOC_TYPE_FP      (1 << 0)
+# define DWARF_LOC_TYPE_REG     (1 << 1)
+# define DWARF_LOC_TYPE_VAL     (1 << 2)
+
+# define DWARF_IS_REG_LOC(l)    (((l).type & DWARF_LOC_TYPE_REG) != 0)
+# define DWARF_IS_FP_LOC(l)     (((l).type & DWARF_LOC_TYPE_FP) != 0)
+# define DWARF_IS_MEM_LOC(l)    ((l).type == DWARF_LOC_TYPE_MEM)
+# define DWARF_IS_VAL_LOC(l)    (((l).type & DWARF_LOC_TYPE_VAL) != 0)
+
+# define DWARF_LOC(r, t)        ((dwarf_loc_t) { .val = (r), .type = (t) })
+# define DWARF_VAL_LOC(c,v)     DWARF_LOC ((v), DWARF_LOC_TYPE_VAL)
+# define DWARF_MEM_LOC(c,m)     DWARF_LOC ((m), DWARF_LOC_TYPE_MEM)
 
 #ifdef UNW_LOCAL_ONLY
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)	(DWARF_GET_LOC (l) == 0)
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r) })
-# define DWARF_IS_REG_LOC(l)	0
-# define DWARF_REG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 x86_64_r_uc_addr(dwarf_get_uc(c), (r)), 0))
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	(DWARF_LOC((unw_word_t)			     \
-				 x86_64_r_uc_addr(dwarf_get_uc(c), (r)), 0))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)   (DWARF_GET_LOC (l) == 0)
+# define DWARF_REG_LOC(c,r)     (DWARF_LOC((unw_word_t)                      \
+                                 x86_64_r_uc_addr(dwarf_get_uc(c), (r)), 0))
+# define DWARF_FPREG_LOC(c,r)   (DWARF_LOC((unw_word_t)                      \
+                                 x86_64_r_uc_addr(dwarf_get_uc(c), (r)), 0))
+
 #else /* !UNW_LOCAL_ONLY */
 
-# define DWARF_LOC_TYPE_FP	(1 << 0)
-# define DWARF_LOC_TYPE_REG	(1 << 1)
-# define DWARF_NULL_LOC		DWARF_LOC (0, 0)
-# define DWARF_IS_NULL_LOC(l)						\
-		({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
-# define DWARF_LOC(r, t)	((dwarf_loc_t) { .val = (r), .type = (t) })
-# define DWARF_IS_REG_LOC(l)	(((l).type & DWARF_LOC_TYPE_REG) != 0)
-# define DWARF_IS_FP_LOC(l)	(((l).type & DWARF_LOC_TYPE_FP) != 0)
-# define DWARF_REG_LOC(c,r)	DWARF_LOC((r), DWARF_LOC_TYPE_REG)
-# define DWARF_MEM_LOC(c,m)	DWARF_LOC ((m), 0)
-# define DWARF_FPREG_LOC(c,r)	DWARF_LOC((r), (DWARF_LOC_TYPE_REG	\
-						| DWARF_LOC_TYPE_FP))
+# define DWARF_NULL_LOC         DWARF_LOC (0, 0)
+# define DWARF_IS_NULL_LOC(l)                                           \
+                ({ dwarf_loc_t _l = (l); _l.val == 0 && _l.type == 0; })
+# define DWARF_REG_LOC(c,r)     DWARF_LOC((r), DWARF_LOC_TYPE_REG)
+# define DWARF_FPREG_LOC(c,r)   DWARF_LOC((r), (DWARF_LOC_TYPE_REG      \
+                                                | DWARF_LOC_TYPE_FP))
 
 #endif /* !UNW_LOCAL_ONLY */
 
@@ -157,93 +163,99 @@ dwarf_get (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t *val)
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
-  else
+                                     0, c->as_arg);
+  if (DWARF_IS_MEM_LOC (loc))
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), val,
-				     0, c->as_arg);
+                                     0, c->as_arg);
+  assert(DWARF_IS_VAL_LOC (loc));
+  *val = DWARF_GET_LOC (loc);
+  return 0;
 }
 
 static inline int
 dwarf_put (struct dwarf_cursor *c, dwarf_loc_t loc, unw_word_t val)
 {
+  assert(!DWARF_IS_VAL_LOC (loc));
+
   if (DWARF_IS_NULL_LOC (loc))
     return -UNW_EBADREG;
 
   if (DWARF_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
   else
     return (*c->as->acc.access_mem) (c->as, DWARF_GET_LOC (loc), &val,
-				     1, c->as_arg);
+                                     1, c->as_arg);
 }
 
-#define tdep_getcontext_trace	        UNW_ARCH_OBJ(getcontext_trace)
-#define tdep_init_done			UNW_OBJ(init_done)
-#define tdep_init_mem_validate		UNW_OBJ(init_mem_validate)
-#define tdep_init			UNW_OBJ(init)
+#define tdep_getcontext_trace           UNW_ARCH_OBJ(getcontext_trace)
+#define tdep_init_done                  UNW_OBJ(init_done)
+#define tdep_init_mem_validate          UNW_OBJ(init_mem_validate)
+#define tdep_init                       UNW_OBJ(init)
 /* Platforms that support UNW_INFO_FORMAT_TABLE need to define
    tdep_search_unwind_table.  */
-#define tdep_search_unwind_table	dwarf_search_unwind_table
-#define tdep_find_unwind_table		dwarf_find_unwind_table
-#define tdep_get_elf_image		UNW_ARCH_OBJ(get_elf_image)
-#define tdep_access_reg			UNW_OBJ(access_reg)
-#define tdep_access_fpreg		UNW_OBJ(access_fpreg)
+#define tdep_search_unwind_table        dwarf_search_unwind_table
+#define tdep_find_unwind_table          dwarf_find_unwind_table
+#define tdep_get_elf_image              UNW_ARCH_OBJ(get_elf_image)
+#define tdep_get_exe_image_path         UNW_ARCH_OBJ(get_exe_image_path)
+#define tdep_access_reg                 UNW_OBJ(access_reg)
+#define tdep_access_fpreg               UNW_OBJ(access_fpreg)
 #if __linux__
-# define tdep_fetch_frame		UNW_OBJ(fetch_frame)
-# define tdep_cache_frame		UNW_OBJ(cache_frame)
-# define tdep_reuse_frame		UNW_OBJ(reuse_frame)
+# define tdep_fetch_frame               UNW_OBJ(fetch_frame)
+# define tdep_cache_frame               UNW_OBJ(cache_frame)
+# define tdep_reuse_frame               UNW_OBJ(reuse_frame)
 #else
-# define tdep_fetch_frame(c,ip,n)	do {} while(0)
-# define tdep_cache_frame(c,rs)		do {} while(0)
-# define tdep_reuse_frame(c,rs)		do {} while(0)
+# define tdep_fetch_frame(c,ip,n)       do {} while(0)
+# define tdep_cache_frame(c)            0
+# define tdep_reuse_frame(c,frame)      do {} while(0)
 #endif
-#define tdep_stash_frame		UNW_OBJ(stash_frame)
-#define tdep_trace			UNW_OBJ(tdep_trace)
+#define tdep_stash_frame                UNW_OBJ(stash_frame)
+#define tdep_trace                      UNW_OBJ(tdep_trace)
 #define x86_64_r_uc_addr                UNW_OBJ(r_uc_addr)
 
 #ifdef UNW_LOCAL_ONLY
-# define tdep_find_proc_info(c,ip,n)				\
-	dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)		\
-	dwarf_put_unwind_info((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                            \
+        dwarf_find_proc_info((c)->as, (ip), &(c)->pi, (n),      \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                \
+        dwarf_put_unwind_info((as), (pi), (arg))
 #else
-# define tdep_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define tdep_put_unwind_info(as,pi,arg)			\
-	(*(as)->acc.put_unwind_info)((as), (pi), (arg))
+# define tdep_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define tdep_put_unwind_info(as,pi,arg)                        \
+        (*(as)->acc.put_unwind_info)((as), (pi), (arg))
 #endif
 
-#define tdep_get_as(c)			((c)->dwarf.as)
-#define tdep_get_as_arg(c)		((c)->dwarf.as_arg)
-#define tdep_get_ip(c)			((c)->dwarf.ip)
-#define tdep_big_endian(as)		0
+#define tdep_get_as(c)                  ((c)->dwarf.as)
+#define tdep_get_as_arg(c)              ((c)->dwarf.as_arg)
+#define tdep_get_ip(c)                  ((c)->dwarf.ip)
+#define tdep_big_endian(as)             0
 
 extern int tdep_init_done;
 
 extern void tdep_init (void);
 extern void tdep_init_mem_validate (void);
 extern int tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-				     unw_dyn_info_t *di, unw_proc_info_t *pi,
-				     int need_unwind_info, void *arg);
+                                     unw_dyn_info_t *di, unw_proc_info_t *pi,
+                                     int need_unwind_info, void *arg);
 extern void *x86_64_r_uc_addr (ucontext_t *uc, int reg);
 extern int tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-			       unsigned long *segbase, unsigned long *mapoff,
-			       char *path, size_t pathlen);
+                               unsigned long *segbase, unsigned long *mapoff,
+                               char *path, size_t pathlen);
+extern void tdep_get_exe_image_path (char *path);
 extern int tdep_access_reg (struct cursor *c, unw_regnum_t reg,
-			    unw_word_t *valp, int write);
+                            unw_word_t *valp, int write);
 extern int tdep_access_fpreg (struct cursor *c, unw_regnum_t reg,
-			      unw_fpreg_t *valp, int write);
+                              unw_fpreg_t *valp, int write);
 #if __linux__
 extern void tdep_fetch_frame (struct dwarf_cursor *c, unw_word_t ip,
-			      int need_unwind_info);
-extern void tdep_cache_frame (struct dwarf_cursor *c,
-			      struct dwarf_reg_state *rs);
+                              int need_unwind_info);
+extern int tdep_cache_frame (struct dwarf_cursor *c);
 extern void tdep_reuse_frame (struct dwarf_cursor *c,
-			      struct dwarf_reg_state *rs);
+                              int frame);
 extern void tdep_stash_frame (struct dwarf_cursor *c,
-			      struct dwarf_reg_state *rs);
+                              struct dwarf_reg_state *rs);
 #endif
 
 extern int tdep_getcontext_trace (unw_tdep_context_t *);
diff --git a/include/tdep/dwarf-config.h b/include/tdep/dwarf-config.h
index 1da268b..c759a46 100644
--- a/include/tdep/dwarf-config.h
+++ b/include/tdep/dwarf-config.h
@@ -1,7 +1,9 @@
 /* Provide a real file - not a symlink - as it would cause multiarch conflicts
    when multiple different arch releases are installed simultaneously.  */
 
-#if defined __arm__
+#if defined __aarch64__
+# include "tdep-aarch64/dwarf-config.h"
+#elif defined __arm__
 # include "tdep-arm/dwarf-config.h"
 #elif defined __hppa__
 # include "tdep-hppa/dwarf-config.h"
@@ -19,6 +21,8 @@
 # include "tdep-x86/dwarf-config.h"
 #elif defined __x86_64__ || defined __amd64__
 # include "tdep-x86_64/dwarf-config.h"
+#elif defined __tilegx__
+# include "tdep-tilegx/dwarf-config.h"
 #else
 # error "Unsupported arch"
 #endif
diff --git a/include/tdep/jmpbuf.h b/include/tdep/jmpbuf.h
index 7d04a42..13093a0 100644
--- a/include/tdep/jmpbuf.h
+++ b/include/tdep/jmpbuf.h
@@ -3,7 +3,9 @@
 
 #ifndef UNW_REMOTE_ONLY
 
-#if defined __arm__
+#if defined __aarch64__
+# include "tdep-aarch64/jmpbuf.h"
+#elif defined __arm__
 # include "tdep-arm/jmpbuf.h"
 #elif defined __hppa__
 # include "tdep-hppa/jmpbuf.h"
@@ -19,6 +21,8 @@
 # include "tdep-x86/jmpbuf.h"
 #elif defined __x86_64__
 # include "tdep-x86_64/jmpbuf.h"
+#elif defined __tilegx__
+# include "tdep-tilegx/jmpbuf.h"
 #else
 # error "Unsupported arch"
 #endif
diff --git a/include/tdep/libunwind_i.h b/include/tdep/libunwind_i.h
new file mode 100644
index 0000000..19cdc15
--- /dev/null
+++ b/include/tdep/libunwind_i.h
@@ -0,0 +1,39 @@
+/* Provide a real file - not a symlink - as it would cause multiarch conflicts
+   when multiple different arch releases are installed simultaneously.  */
+
+#ifndef UNW_REMOTE_ONLY
+
+#if defined __aarch64__
+# include "tdep-aarch64/libunwind_i.h"
+#elif defined __arm__
+# include "tdep-arm/libunwind_i.h"
+#elif defined __hppa__
+# include "tdep-hppa/libunwind_i.h"
+#elif defined __ia64__
+# include "tdep-ia64/libunwind_i.h"
+#elif defined __mips__
+# include "tdep-mips/libunwind_i.h"
+#elif defined __powerpc__ && !defined __powerpc64__
+# include "tdep-ppc32/libunwind_i.h"
+#elif defined __powerpc64__
+# include "tdep-ppc64/libunwind_i.h"
+#elif defined __sh__
+# include "tdep-sh/libunwind_i.h"
+#elif defined __i386__
+# include "tdep-x86/libunwind_i.h"
+#elif defined __x86_64__
+# include "tdep-x86_64/libunwind_i.h"
+#elif defined __tilegx__
+# include "tdep-tilegx/libunwind_i.h"
+#elif defined __s390x__
+# include "tdep-s390x/libunwind_i.h"
+#else
+# error "Unsupported arch"
+#endif
+
+
+#else /* UNW_REMOTE_ONLY */
+
+# include "tdep-x86_64/libunwind_i.h"
+
+#endif /* UNW_REMOTE_ONLY */
diff --git a/include/tdep/libunwind_i.h.in b/include/tdep/libunwind_i.h.in
index 2ad6269..c472996 100644
--- a/include/tdep/libunwind_i.h.in
+++ b/include/tdep/libunwind_i.h.in
@@ -3,7 +3,9 @@
 
 #ifndef UNW_REMOTE_ONLY
 
-#if defined __arm__
+#if defined __aarch64__
+# include "tdep-aarch64/libunwind_i.h"
+#elif defined __arm__
 # include "tdep-arm/libunwind_i.h"
 #elif defined __hppa__
 # include "tdep-hppa/libunwind_i.h"
@@ -21,6 +23,10 @@
 # include "tdep-x86/libunwind_i.h"
 #elif defined __x86_64__
 # include "tdep-x86_64/libunwind_i.h"
+#elif defined __tilegx__
+# include "tdep-tilegx/libunwind_i.h"
+#elif defined __s390x__
+# include "tdep-s390x/libunwind_i.h"
 #else
 # error "Unsupported arch"
 #endif
diff --git a/include/unwind.h b/include/unwind.h
index f8d43d0..7cf128d 100644
--- a/include/unwind.h
+++ b/include/unwind.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -35,7 +35,7 @@ extern "C" {
 
 /* Minimal interface as per C++ ABI draft standard:
 
-	http://www.codesourcery.com/cxx-abi/abi-eh.html */
+        http://www.codesourcery.com/cxx-abi/abi-eh.html */
 
 typedef enum
   {
@@ -53,22 +53,22 @@ _Unwind_Reason_Code;
 
 typedef int _Unwind_Action;
 
-#define _UA_SEARCH_PHASE	1
-#define _UA_CLEANUP_PHASE	2
-#define _UA_HANDLER_FRAME	4
-#define _UA_FORCE_UNWIND	8
+#define _UA_SEARCH_PHASE        1
+#define _UA_CLEANUP_PHASE       2
+#define _UA_HANDLER_FRAME       4
+#define _UA_FORCE_UNWIND        8
 
-struct _Unwind_Context;		/* opaque data-structure */
-struct _Unwind_Exception;	/* forward-declaration */
+struct _Unwind_Context;         /* opaque data-structure */
+struct _Unwind_Exception;       /* forward-declaration */
 
 typedef void (*_Unwind_Exception_Cleanup_Fn) (_Unwind_Reason_Code,
-					      struct _Unwind_Exception *);
+                                              struct _Unwind_Exception *);
 
 typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn) (int, _Unwind_Action,
-						uint64_t,
-						struct _Unwind_Exception *,
-						struct _Unwind_Context *,
-						void *);
+                                                uint64_t,
+                                                struct _Unwind_Exception *,
+                                                struct _Unwind_Context *,
+                                                void *);
 
 /* The C++ ABI requires exception_class, private_1, and private_2 to
    be of type uint64 and the entire structure to be
@@ -84,7 +84,7 @@ struct _Unwind_Exception
 
 extern _Unwind_Reason_Code _Unwind_RaiseException (struct _Unwind_Exception *);
 extern _Unwind_Reason_Code _Unwind_ForcedUnwind (struct _Unwind_Exception *,
-						 _Unwind_Stop_Fn, void *);
+                                                 _Unwind_Stop_Fn, void *);
 extern void _Unwind_Resume (struct _Unwind_Exception *);
 extern void _Unwind_DeleteException (struct _Unwind_Exception *);
 extern unsigned long _Unwind_GetGR (struct _Unwind_Context *, int);
@@ -100,17 +100,17 @@ extern unsigned long _Unwind_GetRegionStart (struct _Unwind_Context *);
 /* Callback for _Unwind_Backtrace().  The backtrace stops immediately
    if the callback returns any value other than _URC_NO_REASON. */
 typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn) (struct _Unwind_Context *,
-						 void *);
+                                                 void *);
 
 /* See http://gcc.gnu.org/ml/gcc-patches/2001-09/msg00082.html for why
    _UA_END_OF_STACK exists.  */
-# define _UA_END_OF_STACK	16
+# define _UA_END_OF_STACK       16
 
 /* If the unwind was initiated due to a forced unwind, resume that
    operation, else re-raise the exception.  This is used by
    __cxa_rethrow().  */
 extern _Unwind_Reason_Code
-	  _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *);
+          _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *);
 
 /* See http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00154.html for why
    _Unwind_GetBSP() exists.  */
diff --git a/src/Makefile.am b/src/Makefile.am
index adfbef3..8d72ef0 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -4,12 +4,15 @@ COREDUMP_SO_VERSION=0:0:0
 #
 # Don't link with start-files since we don't use any constructors/destructors:
 #
-COMMON_SO_LDFLAGS =	-XCClinker -nostartfiles
+COMMON_SO_LDFLAGS = $(LDFLAGS_NOSTARTFILES)
 
 lib_LIBRARIES =
 lib_LTLIBRARIES =
 if !REMOTE_ONLY
-lib_LTLIBRARIES += libunwind.la libunwind-ptrace.la
+lib_LTLIBRARIES += libunwind.la
+if BUILD_PTRACE
+lib_LTLIBRARIES += libunwind-ptrace.la
+endif
 if BUILD_COREDUMP
 lib_LTLIBRARIES += libunwind-coredump.la
 endif
@@ -22,8 +25,15 @@ pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = libunwind-generic.pc
 
 if !REMOTE_ONLY
-pkgconfig_DATA += unwind/libunwind.pc ptrace/libunwind-ptrace.pc         \
-                  setjmp/libunwind-setjmp.pc
+pkgconfig_DATA += unwind/libunwind.pc
+endif
+
+if BUILD_PTRACE
+pkgconfig_DATA += ptrace/libunwind-ptrace.pc
+endif
+
+if BUILD_SETJMP
+pkgconfig_DATA += setjmp/libunwind-setjmp.pc
 endif
 
 if BUILD_COREDUMP
@@ -58,7 +68,8 @@ libunwind_coredump_la_SOURCES = \
 	coredump/_UPT_resume.c
 libunwind_coredump_la_LDFLAGS = $(COMMON_SO_LDFLAGS) \
 				-version-info $(COREDUMP_SO_VERSION)
-noinst_HEADERS += coredump/_UCD_internal.h
+libunwind_coredump_la_LIBADD = $(LIBLZMA)
+noinst_HEADERS += coredump/_UCD_internal.h coredump/_UCD_lib.h
 
 ### libunwind-setjmp:
 libunwind_setjmp_la_LDFLAGS		= $(COMMON_SO_LDFLAGS)		     \
@@ -98,7 +109,8 @@ libunwind_la_SOURCES_generic =						\
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c		\
 	mi/Gget_reg.c mi/Gset_reg.c					\
 	mi/Gget_fpreg.c mi/Gset_fpreg.c					\
-	mi/Gset_caching_policy.c
+	mi/Gset_caching_policy.c					\
+	mi/Gset_cache_size.c
 
 if SUPPORT_CXX_EXCEPTIONS
 libunwind_la_SOURCES_local_unwind =					\
@@ -126,7 +138,8 @@ libunwind_la_SOURCES_local_nounwind =					\
 	mi/Lput_dynamic_unwind_info.c mi/Ldestroy_addr_space.c		\
 	mi/Lget_reg.c   mi/Lset_reg.c					\
 	mi/Lget_fpreg.c mi/Lset_fpreg.c					\
-	mi/Lset_caching_policy.c
+	mi/Lset_caching_policy.c					\
+	mi/Lset_cache_size.c
 
 libunwind_la_SOURCES_local =						\
 	$(libunwind_la_SOURCES_local_nounwind)				\
@@ -139,16 +152,18 @@ libunwind_la_SOURCES_os_hpux = os-hpux.c
 
 libunwind_la_SOURCES_os_freebsd = os-freebsd.c
 
+libunwind_la_SOURCES_os_qnx = os-qnx.c
+
 libunwind_dwarf_common_la_SOURCES = dwarf/global.c
 
 libunwind_dwarf_local_la_SOURCES = \
-	dwarf/Lexpr.c dwarf/Lfde.c dwarf/Lparser.c dwarf/Lpe.c dwarf/Lstep.c \
+	dwarf/Lexpr.c dwarf/Lfde.c dwarf/Lparser.c dwarf/Lpe.c \
 	dwarf/Lfind_proc_info-lsb.c \
 	dwarf/Lfind_unwind_table.c
 libunwind_dwarf_local_la_LIBADD = libunwind-dwarf-common.la
 
 libunwind_dwarf_generic_la_SOURCES = \
-	dwarf/Gexpr.c dwarf/Gfde.c dwarf/Gparser.c dwarf/Gpe.c dwarf/Gstep.c \
+	dwarf/Gexpr.c dwarf/Gfde.c dwarf/Gparser.c dwarf/Gpe.c \
 	dwarf/Gfind_proc_info-lsb.c \
 	dwarf/Gfind_unwind_table.c
 libunwind_dwarf_generic_la_LIBADD = libunwind-dwarf-common.la
@@ -166,10 +181,38 @@ noinst_HEADERS += elf32.h elf64.h elfxx.h
 libunwind_elf32_la_SOURCES = elf32.c
 libunwind_elf64_la_SOURCES = elf64.c
 libunwind_elfxx_la_SOURCES = elfxx.c
+libunwind_elf32_la_LIBADD  = $(LIBLZMA)
+libunwind_elf64_la_LIBADD  = $(LIBLZMA)
+libunwind_elfxx_la_LIBADD  = $(LIBLZMA)
 
 noinst_LTLIBRARIES += $(LIBUNWIND_ELF)
 libunwind_la_LIBADD += $(LIBUNWIND_ELF)
 
+# The list of files that go into libunwind and libunwind-aarch64:
+noinst_HEADERS += aarch64/init.h aarch64/offsets.h aarch64/unwind_i.h
+libunwind_la_SOURCES_aarch64_common = $(libunwind_la_SOURCES_common)	    \
+	aarch64/is_fpreg.c aarch64/regname.c
+
+# The list of files that go into libunwind:
+libunwind_la_SOURCES_aarch64 = $(libunwind_la_SOURCES_aarch64_common)	    \
+	$(libunwind_la_SOURCES_local)					    \
+	aarch64/Lapply_reg_state.c aarch64/Lreg_states_iterate.c	    \
+	aarch64/Lcreate_addr_space.c aarch64/Lget_proc_info.c 		    \
+	aarch64/Lget_save_loc.c aarch64/Lglobal.c aarch64/Linit.c	    \
+	aarch64/Linit_local.c aarch64/Linit_remote.c 			    \
+	aarch64/Lis_signal_frame.c aarch64/Lregs.c aarch64/Lresume.c 	    \
+	aarch64/Lstash_frame.c aarch64/Lstep.c aarch64/Ltrace.c		    \
+	aarch64/getcontext.S
+
+libunwind_aarch64_la_SOURCES_aarch64 = $(libunwind_la_SOURCES_aarch64_common) \
+	$(libunwind_la_SOURCES_generic)					      \
+	aarch64/Gapply_reg_state.c aarch64/Greg_states_iterate.c	      \
+	aarch64/Gcreate_addr_space.c aarch64/Gget_proc_info.c 		      \
+	aarch64/Gget_save_loc.c aarch64/Gglobal.c aarch64/Ginit.c 	      \
+	aarch64/Ginit_local.c aarch64/Ginit_remote.c			      \
+	aarch64/Gis_signal_frame.c aarch64/Gregs.c aarch64/Gresume.c	      \
+	aarch64/Gstash_frame.c aarch64/Gstep.c aarch64/Gtrace.c
+
 # The list of files that go into libunwind and libunwind-arm:
 noinst_HEADERS += arm/init.h arm/offsets.h arm/unwind_i.h
 libunwind_la_SOURCES_arm_common = $(libunwind_la_SOURCES_common)	    \
@@ -177,19 +220,24 @@ libunwind_la_SOURCES_arm_common = $(libunwind_la_SOURCES_common)	    \
 
 # The list of files that go into libunwind:
 libunwind_la_SOURCES_arm = $(libunwind_la_SOURCES_arm_common)		    \
+	$(libunwind_la_SOURCES_arm_os_local)				    \
 	$(libunwind_la_SOURCES_local)					    \
 	arm/getcontext.S						    \
+	arm/Lapply_reg_state.c arm/Lreg_states_iterate.c		    \
 	arm/Lcreate_addr_space.c arm/Lget_proc_info.c arm/Lget_save_loc.c   \
 	arm/Lglobal.c arm/Linit.c arm/Linit_local.c arm/Linit_remote.c	    \
-	arm/Lis_signal_frame.c arm/Lregs.c arm/Lresume.c arm/Lstep.c	    \
-	arm/Lex_tables.c
+	arm/Lregs.c arm/Lresume.c arm/Lstep.c				    \
+	arm/Lex_tables.c arm/Lstash_frame.c arm/Ltrace.c
 
+# The list of files that go into libunwind-arm:
 libunwind_arm_la_SOURCES_arm = $(libunwind_la_SOURCES_arm_common)	    \
+	$(libunwind_la_SOURCES_arm_os)					    \
 	$(libunwind_la_SOURCES_generic)					    \
+	arm/Gapply_reg_state.c arm/Greg_states_iterate.c		    \
 	arm/Gcreate_addr_space.c arm/Gget_proc_info.c arm/Gget_save_loc.c   \
 	arm/Gglobal.c arm/Ginit.c arm/Ginit_local.c arm/Ginit_remote.c	    \
-	arm/Gis_signal_frame.c arm/Gregs.c arm/Gresume.c arm/Gstep.c	    \
-	arm/Gex_tables.c
+	arm/Gregs.c arm/Gresume.c arm/Gstep.c				    \
+	arm/Gex_tables.c arm/Gstash_frame.c arm/Gtrace.c
 
 # The list of files that go both into libunwind and libunwind-ia64:
 noinst_HEADERS += ia64/init.h ia64/offsets.h ia64/regs.h		    \
@@ -203,6 +251,7 @@ libunwind_la_SOURCES_ia64 = $(libunwind_la_SOURCES_ia64_common)		     \
 									     \
 	ia64/dyn_info_list.S ia64/getcontext.S				     \
 									     \
+	ia64/Lapply_reg_state.c ia64/Lreg_states_iterate.c		     \
 	ia64/Lcreate_addr_space.c ia64/Lget_proc_info.c ia64/Lget_save_loc.c \
 	ia64/Lglobal.c ia64/Linit.c ia64/Linit_local.c ia64/Linit_remote.c   \
 	ia64/Linstall_cursor.S ia64/Lis_signal_frame.c ia64/Lparser.c	     \
@@ -212,6 +261,7 @@ libunwind_la_SOURCES_ia64 = $(libunwind_la_SOURCES_ia64_common)		     \
 # The list of files that go into libunwind-ia64:
 libunwind_ia64_la_SOURCES_ia64 = $(libunwind_la_SOURCES_ia64_common)	     \
 	$(libunwind_la_SOURCES_generic)					     \
+	ia64/Gapply_reg_state.c ia64/Greg_states_iterate.c		     \
 	ia64/Gcreate_addr_space.c ia64/Gget_proc_info.c ia64/Gget_save_loc.c \
 	ia64/Gglobal.c ia64/Ginit.c ia64/Ginit_local.c ia64/Ginit_remote.c   \
 	ia64/Ginstall_cursor.S ia64/Gis_signal_frame.c ia64/Gparser.c	     \
@@ -227,6 +277,7 @@ libunwind_la_SOURCES_hppa_common = $(libunwind_la_SOURCES_common)	\
 libunwind_la_SOURCES_hppa = $(libunwind_la_SOURCES_hppa_common)		\
 	$(libunwind_la_SOURCES_local)					\
 	hppa/getcontext.S hppa/setcontext.S				\
+	hppa/Lapply_reg_state.c hppa/Lreg_states_iterate.c		\
 	hppa/Lcreate_addr_space.c hppa/Lget_save_loc.c hppa/Lglobal.c	\
 	hppa/Linit.c hppa/Linit_local.c hppa/Linit_remote.c		\
 	hppa/Lis_signal_frame.c hppa/Lget_proc_info.c hppa/Lregs.c	\
@@ -235,13 +286,14 @@ libunwind_la_SOURCES_hppa = $(libunwind_la_SOURCES_hppa_common)		\
 # The list of files that go into libunwind-hppa:
 libunwind_hppa_la_SOURCES_hppa = $(libunwind_la_SOURCES_hppa_common)	\
 	$(libunwind_la_SOURCES_generic)					\
+	hppa/Gapply_reg_state.c hppa/Greg_states_iterate.c		\
 	hppa/Gcreate_addr_space.c hppa/Gget_save_loc.c hppa/Gglobal.c	\
 	hppa/Ginit.c hppa/Ginit_local.c hppa/Ginit_remote.c		\
 	hppa/Gis_signal_frame.c hppa/Gget_proc_info.c hppa/Gregs.c	\
 	hppa/Gresume.c hppa/Gstep.c
 
 # The list of files that go info libunwind and libunwind-mips:
-noinst_HEADERS += mips/init.h mips/offsets.h
+noinst_HEADERS += mips/init.h mips/offsets.h mips/unwind_i.h
 libunwind_la_SOURCES_mips_common = $(libunwind_la_SOURCES_common)	    \
 	mips/is_fpreg.c mips/regname.c
 
@@ -249,16 +301,40 @@ libunwind_la_SOURCES_mips_common = $(libunwind_la_SOURCES_common)	    \
 libunwind_la_SOURCES_mips = $(libunwind_la_SOURCES_mips_common)		    \
 	$(libunwind_la_SOURCES_local)					    \
 	mips/getcontext.S						    \
+	mips/Lapply_reg_state.c mips/Lreg_states_iterate.c		    \
 	mips/Lcreate_addr_space.c mips/Lget_proc_info.c mips/Lget_save_loc.c   \
 	mips/Lglobal.c mips/Linit.c mips/Linit_local.c mips/Linit_remote.c  \
 	mips/Lis_signal_frame.c mips/Lregs.c mips/Lresume.c mips/Lstep.c
 
 libunwind_mips_la_SOURCES_mips = $(libunwind_la_SOURCES_mips_common)	    \
 	$(libunwind_la_SOURCES_generic)					    \
+	mips/Gapply_reg_state.c mips/Greg_states_iterate.c		    \
 	mips/Gcreate_addr_space.c mips/Gget_proc_info.c mips/Gget_save_loc.c   \
 	mips/Gglobal.c mips/Ginit.c mips/Ginit_local.c mips/Ginit_remote.c	    \
 	mips/Gis_signal_frame.c mips/Gregs.c mips/Gresume.c mips/Gstep.c
 
+# The list of files that go info libunwind and libunwind-tilegx:
+noinst_HEADERS += tilegx/init.h tilegx/offsets.h tilegx/unwind_i.h
+libunwind_la_SOURCES_tilegx_common = $(libunwind_la_SOURCES_common)	    \
+	tilegx/is_fpreg.c tilegx/regname.c
+
+# The list of files that go into libunwind:
+libunwind_la_SOURCES_tilegx = $(libunwind_la_SOURCES_tilegx_common)		    \
+	$(libunwind_la_SOURCES_local)					    \
+	tilegx/getcontext.S						\
+	tilegx/Lapply_reg_state.c tilegx/Lreg_states_iterate.c		    \
+	tilegx/Lcreate_addr_space.c tilegx/Lget_proc_info.c tilegx/Lget_save_loc.c   \
+	tilegx/Lglobal.c tilegx/Linit.c tilegx/Linit_local.c tilegx/Linit_remote.c  \
+	tilegx/Lis_signal_frame.c tilegx/Lregs.c tilegx/Lresume.c tilegx/Lstep.c
+
+libunwind_tilegx_la_SOURCES_tilegx = $(libunwind_la_SOURCES_tilegx_common)	    \
+	$(libunwind_la_SOURCES_generic)					    \
+	tilegx/Gapply_reg_state.c tilegx/Greg_states_iterate.c			     \
+	tilegx/Gcreate_addr_space.c tilegx/Gget_proc_info.c tilegx/Gget_save_loc.c   \
+	tilegx/Gglobal.c tilegx/Ginit.c tilegx/Ginit_local.c tilegx/Ginit_remote.c	    \
+	tilegx/Gis_signal_frame.c tilegx/Gregs.c tilegx/Gresume.c tilegx/Gstep.c
+
+
 # The list of files that go both into libunwind and libunwind-x86:
 noinst_HEADERS += x86/init.h x86/offsets.h x86/unwind_i.h
 libunwind_la_SOURCES_x86_common = $(libunwind_la_SOURCES_common)	\
@@ -268,6 +344,7 @@ libunwind_la_SOURCES_x86_common = $(libunwind_la_SOURCES_common)	\
 libunwind_la_SOURCES_x86 = $(libunwind_la_SOURCES_x86_common)		\
         $(libunwind_la_SOURCES_x86_os_local)				\
 	$(libunwind_la_SOURCES_local)					\
+	x86/Lapply_reg_state.c x86/Lreg_states_iterate.c		\
 	x86/Lcreate_addr_space.c x86/Lget_save_loc.c x86/Lglobal.c	\
 	x86/Linit.c x86/Linit_local.c x86/Linit_remote.c		\
 	x86/Lget_proc_info.c x86/Lregs.c				\
@@ -277,6 +354,7 @@ libunwind_la_SOURCES_x86 = $(libunwind_la_SOURCES_x86_common)		\
 libunwind_x86_la_SOURCES_x86 = $(libunwind_la_SOURCES_x86_common)	\
         $(libunwind_la_SOURCES_x86_os)					\
 	$(libunwind_la_SOURCES_generic)					\
+	x86/Gapply_reg_state.c x86/Greg_states_iterate.c		\
 	x86/Gcreate_addr_space.c x86/Gget_save_loc.c x86/Gglobal.c	\
 	x86/Ginit.c x86/Ginit_local.c x86/Ginit_remote.c		\
 	x86/Gget_proc_info.c x86/Gregs.c				\
@@ -293,6 +371,7 @@ libunwind_la_SOURCES_x86_64 = $(libunwind_la_SOURCES_x86_64_common)	    \
         $(libunwind_la_SOURCES_x86_64_os_local)			    	    \
 	$(libunwind_la_SOURCES_local)					    \
 	x86_64/setcontext.S						    \
+	x86_64/Lapply_reg_state.c x86_64/Lreg_states_iterate.c		    \
 	x86_64/Lcreate_addr_space.c x86_64/Lget_save_loc.c x86_64/Lglobal.c \
 	x86_64/Linit.c x86_64/Linit_local.c x86_64/Linit_remote.c	    \
 	x86_64/Lget_proc_info.c x86_64/Lregs.c x86_64/Lresume.c		    \
@@ -302,18 +381,19 @@ libunwind_la_SOURCES_x86_64 = $(libunwind_la_SOURCES_x86_64_common)	    \
 libunwind_x86_64_la_SOURCES_x86_64 = $(libunwind_la_SOURCES_x86_64_common)  \
         $(libunwind_la_SOURCES_x86_64_os)			    	    \
 	$(libunwind_la_SOURCES_generic)					    \
+	x86_64/Gapply_reg_state.c x86_64/Greg_states_iterate.c		    \
 	x86_64/Gcreate_addr_space.c x86_64/Gget_save_loc.c x86_64/Gglobal.c \
 	x86_64/Ginit.c x86_64/Ginit_local.c x86_64/Ginit_remote.c	    \
 	x86_64/Gget_proc_info.c x86_64/Gregs.c x86_64/Gresume.c		    \
 	x86_64/Gstash_frame.c x86_64/Gstep.c x86_64/Gtrace.c
 
 # The list of local files that go to Power 64 and 32:
-libunwind_la_SOURCES_ppc = ppc/Lcreate_addr_space.c 			\
+libunwind_la_SOURCES_ppc = \
 	ppc/Lget_proc_info.c ppc/Lget_save_loc.c ppc/Linit_local.c	\
 	ppc/Linit_remote.c ppc/Lis_signal_frame.c
 
 # The list of generic files that go to Power 64 and 32:
-libunwind_ppc_la_SOURCES_ppc_generic = ppc/Gcreate_addr_space.c		\
+libunwind_ppc_la_SOURCES_ppc_generic = \
 	ppc/Gget_proc_info.c ppc/Gget_save_loc.c ppc/Ginit_local.c	\
 	ppc/Ginit_remote.c ppc/Gis_signal_frame.c
 
@@ -326,6 +406,8 @@ libunwind_la_SOURCES_ppc32_common = $(libunwind_la_SOURCES_common)      \
 libunwind_la_SOURCES_ppc32 = $(libunwind_la_SOURCES_ppc32_common)       \
 	$(libunwind_la_SOURCES_local)                                   \
 	$(libunwind_la_SOURCES_ppc)					\
+	ppc32/Lapply_reg_state.c ppc32/Lreg_states_iterate.c		\
+	ppc32/Lcreate_addr_space.c					\
 	ppc32/Lglobal.c ppc32/Linit.c					\
 	ppc32/Lregs.c ppc32/Lresume.c ppc32/Lstep.c
 
@@ -333,6 +415,8 @@ libunwind_la_SOURCES_ppc32 = $(libunwind_la_SOURCES_ppc32_common)       \
 libunwind_ppc32_la_SOURCES_ppc32 = $(libunwind_la_SOURCES_ppc32_common) \
 	$(libunwind_la_SOURCES_generic)                                 \
 	$(libunwind_ppc_la_SOURCES_ppc_generic)				\
+	ppc32/Gapply_reg_state.c ppc32/Greg_states_iterate.c		\
+	ppc32/Gcreate_addr_space.c					\
 	ppc32/Gglobal.c ppc32/Ginit.c					\
 	ppc32/Gregs.c ppc32/Gresume.c ppc32/Gstep.c
 
@@ -345,6 +429,8 @@ libunwind_la_SOURCES_ppc64_common = $(libunwind_la_SOURCES_common)      \
 libunwind_la_SOURCES_ppc64 = $(libunwind_la_SOURCES_ppc64_common)       \
         $(libunwind_la_SOURCES_local)                                   \
 	$(libunwind_la_SOURCES_ppc)					\
+	ppc64/Lapply_reg_state.c ppc64/Lreg_states_iterate.c		\
+	ppc64/Lcreate_addr_space.c					\
 	ppc64/Lglobal.c ppc64/Linit.c					\
 	ppc64/Lregs.c ppc64/Lresume.c ppc64/Lstep.c
 
@@ -352,6 +438,8 @@ libunwind_la_SOURCES_ppc64 = $(libunwind_la_SOURCES_ppc64_common)       \
 libunwind_ppc64_la_SOURCES_ppc64 = $(libunwind_la_SOURCES_ppc64_common) \
         $(libunwind_la_SOURCES_generic)                                 \
 	$(libunwind_ppc_la_SOURCES_ppc_generic)				\
+	ppc64/Gapply_reg_state.c ppc64/Greg_states_iterate.c		\
+	ppc64/Gcreate_addr_space.c					\
 	ppc64/Gglobal.c ppc64/Ginit.c					\
 	ppc64/Gregs.c ppc64/Gresume.c ppc64/Gstep.c
 
@@ -363,16 +451,42 @@ libunwind_la_SOURCES_sh_common = $(libunwind_la_SOURCES_common)		\
 # The list of files that go into libunwind:
 libunwind_la_SOURCES_sh = $(libunwind_la_SOURCES_sh_common)		\
 	$(libunwind_la_SOURCES_local)					\
+	sh/Lapply_reg_state.c sh/Lreg_states_iterate.c			\
 	sh/Lcreate_addr_space.c sh/Lget_proc_info.c sh/Lget_save_loc.c	\
 	sh/Lglobal.c sh/Linit.c sh/Linit_local.c sh/Linit_remote.c	\
 	sh/Lis_signal_frame.c sh/Lregs.c sh/Lresume.c sh/Lstep.c
 
 libunwind_sh_la_SOURCES_sh = $(libunwind_la_SOURCES_sh_common)		\
 	$(libunwind_la_SOURCES_generic)					\
+	sh/Gapply_reg_state.c sh/Greg_states_iterate.c			\
 	sh/Gcreate_addr_space.c sh/Gget_proc_info.c sh/Gget_save_loc.c	\
 	sh/Gglobal.c sh/Ginit.c sh/Ginit_local.c sh/Ginit_remote.c	\
 	sh/Gis_signal_frame.c sh/Gregs.c sh/Gresume.c sh/Gstep.c
 
+# The list of files that go both into libunwind and libunwind-s390x:
+noinst_HEADERS += s390x/init.h s390x/unwind_i.h
+libunwind_la_SOURCES_s390x_common = $(libunwind_la_SOURCES_common)	\
+	s390x/is_fpreg.c s390x/regname.c
+
+# The list of files that go into libunwind:
+libunwind_la_SOURCES_s390x = $(libunwind_la_SOURCES_s390x_common)	    \
+	$(libunwind_la_SOURCES_local)					    \
+	s390x/Lapply_reg_state.c s390x/Lreg_states_iterate.c		    \
+	s390x/Lcreate_addr_space.c s390x/Lget_save_loc.c s390x/Lglobal.c    \
+	s390x/Linit.c s390x/Linit_local.c s390x/Linit_remote.c	            \
+	s390x/Lget_proc_info.c s390x/Lregs.c s390x/Lresume.c		    \
+	s390x/Lis_signal_frame.c s390x/Lstep.c				    \
+	s390x/getcontext.S s390x/setcontext.S
+
+# The list of files that go into libunwind-s390x:
+libunwind_s390x_la_SOURCES_s390x = $(libunwind_la_SOURCES_s390x_common)     \
+	$(libunwind_la_SOURCES_generic)					    \
+	s390x/Gapply_reg_state.c s390x/Greg_states_iterate.c	            \
+	s390x/Gcreate_addr_space.c s390x/Gget_save_loc.c s390x/Gglobal.c    \
+	s390x/Ginit.c s390x/Ginit_local.c s390x/Ginit_remote.c	            \
+	s390x/Gget_proc_info.c s390x/Gregs.c s390x/Gresume.c		    \
+	s390x/Gis_signal_frame.c s390x/Gstep.c
+
 if REMOTE_ONLY
 install-exec-hook:
 #	Nothing to do here....
@@ -384,10 +498,12 @@ else
 # to be there if the user configured with --disable-shared.
 #
 install-exec-hook:
-	$(LN_S) -f libunwind-$(arch).a  $(DESTDIR)$(libdir)/libunwind-generic.a
+	if test -f $(DESTDIR)$(libdir)/libunwind-$(arch).a; then \
+		cd $(DESTDIR)$(libdir) && $(LN_S) -f libunwind-$(arch).a libunwind-generic.a; \
+	fi
 	if test -f $(DESTDIR)$(libdir)/libunwind-$(arch).so; then \
-	    $(LN_S) -f libunwind-$(arch).so \
-		$(DESTDIR)$(libdir)/libunwind-generic.so; \
+		cd $(DESTDIR)$(libdir) && $(LN_S) -f libunwind-$(arch).so \
+		libunwind-generic.so; \
 	fi
 endif
 
@@ -399,6 +515,8 @@ if OS_LINUX
  libunwind_la_SOURCES_x86_os_local    = x86/Los-linux.c
  libunwind_la_SOURCES_x86_64_os       = x86_64/Gos-linux.c
  libunwind_la_SOURCES_x86_64_os_local = x86_64/Los-linux.c
+ libunwind_la_SOURCES_arm_os          = arm/Gos-linux.c
+ libunwind_la_SOURCES_arm_os_local    = arm/Los-linux.c
  libunwind_coredump_la_SOURCES += coredump/_UCD_access_reg_linux.c
 endif
 
@@ -415,9 +533,30 @@ if OS_FREEBSD
  libunwind_la_SOURCES_x86_os_local    = x86/Los-freebsd.c
  libunwind_la_SOURCES_x86_64_os       = x86_64/Gos-freebsd.c
  libunwind_la_SOURCES_x86_64_os_local = x86_64/Los-freebsd.c
+ libunwind_la_SOURCES_arm_os          = arm/Gos-freebsd.c
+ libunwind_la_SOURCES_arm_os_local    = arm/Los-freebsd.c
  libunwind_coredump_la_SOURCES += coredump/_UCD_access_reg_freebsd.c
 endif
 
+if OS_QNX
+ libunwind_la_SOURCES_os	= $(libunwind_la_SOURCES_os_qnx)
+ libunwind_la_SOURCES_os_local	= $(libunwind_la_SOURCES_os_qnx_local)
+ libunwind_la_SOURCES_arm_os          = arm/Gos-other.c
+ libunwind_la_SOURCES_arm_os_local    = arm/Los-other.c
+endif
+
+if ARCH_AARCH64
+ lib_LTLIBRARIES += libunwind-aarch64.la
+ libunwind_la_SOURCES = $(libunwind_la_SOURCES_aarch64)
+ libunwind_aarch64_la_SOURCES = $(libunwind_aarch64_la_SOURCES_aarch64)
+ libunwind_aarch64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+ libunwind_aarch64_la_LIBADD = libunwind-dwarf-generic.la
+ libunwind_aarch64_la_LIBADD += libunwind-elf64.la
+if !REMOTE_ONLY
+ libunwind_aarch64_la_LIBADD += libunwind.la -lc
+endif
+ libunwind_setjmp_la_SOURCES += aarch64/siglongjmp.S
+else
 if ARCH_ARM
  lib_LTLIBRARIES += libunwind-arm.la
  libunwind_la_SOURCES = $(libunwind_la_SOURCES_arm)
@@ -476,6 +615,18 @@ if !REMOTE_ONLY
 endif
  libunwind_setjmp_la_SOURCES += mips/siglongjmp.S
 else
+if ARCH_TILEGX
+ lib_LTLIBRARIES += libunwind-tilegx.la
+ libunwind_la_SOURCES = $(libunwind_la_SOURCES_tilegx)
+ libunwind_tilegx_la_SOURCES = $(libunwind_tilegx_la_SOURCES_tilegx)
+ libunwind_tilegx_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+ libunwind_tilegx_la_LIBADD = libunwind-dwarf-generic.la
+ libunwind_tilegx_la_LIBADD += libunwind-elfxx.la
+if !REMOTE_ONLY
+ libunwind_tilegx_la_LIBADD += libunwind.la -lc
+endif
+ libunwind_setjmp_la_SOURCES += tilegx/siglongjmp.S
+else
 if ARCH_X86
  lib_LTLIBRARIES += libunwind-x86.la
  libunwind_la_SOURCES = $(libunwind_la_SOURCES_x86) $(libunwind_x86_la_SOURCES_os)
@@ -535,20 +686,34 @@ if !REMOTE_ONLY
  libunwind_sh_la_LIBADD += libunwind.la -lc
 endif
  libunwind_setjmp_la_SOURCES += sh/siglongjmp.S
+else
+if ARCH_S390X
+ lib_LTLIBRARIES += libunwind-s390x.la
+ libunwind_la_SOURCES = $(libunwind_la_SOURCES_s390x)
+ libunwind_s390x_la_SOURCES = $(libunwind_s390x_la_SOURCES_s390x)
+ libunwind_s390x_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+ libunwind_s390x_la_LIBADD = libunwind-dwarf-generic.la
+ libunwind_s390x_la_LIBADD += libunwind-elf64.la
+if !REMOTE_ONLY
+ libunwind_s390x_la_LIBADD += libunwind.la -lc
+endif
 
+endif # ARCH_S390X
 endif # ARCH_SH
 endif # ARCH_PPC64
 endif # ARCH_PPC32
 endif # ARCH_X86_64
 endif # ARCH_X86
+endif # ARCH_TILEGX
 endif # ARCH_MIPS
 endif # ARCH_HPPA
 endif # ARCH_IA64
 endif # ARCH_ARM
+endif # ARCH_AARCH64
 
 # libunwind-setjmp depends on libunwind-$(arch). Therefore must be added
 # at the end.
-if !REMOTE_ONLY
+if BUILD_SETJMP
 lib_LTLIBRARIES += libunwind-setjmp.la
 endif
 
@@ -559,15 +724,14 @@ endif
 libunwind_la_LDFLAGS =	$(COMMON_SO_LDFLAGS) -XCClinker -nostdlib \
 			$(LDFLAGS_STATIC_LIBCXA) -version-info $(SOVERSION)
 libunwind_la_LIBADD  += -lc $(LIBCRTS)
-if HAVE_LZMA
- libunwind_la_LIBADD += -llzma
-endif
+libunwind_la_LIBADD += $(LIBLZMA)
 
 AM_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/tdep-$(arch) -I.
 AM_CCASFLAGS = $(AM_CPPFLAGS)
 noinst_HEADERS += unwind/unwind-internal.h
 
-EXTRA_DIST =	$(libunwind_la_SOURCES_arm)			\
+EXTRA_DIST =	$(libunwind_la_SOURCES_aarch64)			\
+		$(libunwind_la_SOURCES_arm)			\
 		$(libunwind_la_SOURCES_hppa)			\
 		$(libunwind_la_SOURCES_ia64)			\
 		$(libunwind_la_SOURCES_mips)			\
@@ -576,9 +740,11 @@ EXTRA_DIST =	$(libunwind_la_SOURCES_arm)			\
 		$(libunwind_la_SOURCES_os_freebsd)		\
 		$(libunwind_la_SOURCES_os_linux)		\
 		$(libunwind_la_SOURCES_os_hpux)			\
+		$(libunwind_la_SOURCES_os_qnx)			\
 		$(libunwind_la_SOURCES_common)			\
 		$(libunwind_la_SOURCES_local)			\
 		$(libunwind_la_SOURCES_generic)			\
+		$(libunwind_aarch64_la_SOURCES_aarch64)		\
 		$(libunwind_arm_la_SOURCES_arm)			\
 		$(libunwind_hppa_la_SOURCES_hppa)		\
 		$(libunwind_ia64_la_SOURCES_ia64)		\
diff --git a/src/Makefile.in b/src/Makefile.in
index aebc7ba..55a1828 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.13.4 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -19,6 +18,51 @@
 
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -38,54 +82,63 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-@REMOTE_ONLY_FALSE@am__append_1 = libunwind.la libunwind-ptrace.la
-@BUILD_COREDUMP_TRUE@@REMOTE_ONLY_FALSE@am__append_2 = libunwind-coredump.la
-@REMOTE_ONLY_FALSE@am__append_3 = unwind/libunwind.pc ptrace/libunwind-ptrace.pc         \
-@REMOTE_ONLY_FALSE@                  setjmp/libunwind-setjmp.pc
-
-@BUILD_COREDUMP_TRUE@am__append_4 = coredump/libunwind-coredump.pc
-@USE_DWARF_TRUE@am__append_5 = libunwind-dwarf-common.la libunwind-dwarf-generic.la
-@REMOTE_ONLY_FALSE@@USE_DWARF_TRUE@am__append_6 = libunwind-dwarf-local.la
-@USE_DWARF_TRUE@am__append_7 = libunwind-dwarf-local.la
-@OS_LINUX_TRUE@am__append_8 = coredump/_UCD_access_reg_linux.c
-@OS_FREEBSD_TRUE@am__append_9 = coredump/_UCD_access_reg_freebsd.c
-@ARCH_ARM_TRUE@am__append_10 = libunwind-arm.la
-@ARCH_ARM_TRUE@@REMOTE_ONLY_FALSE@am__append_11 = libunwind.la -lc
-@ARCH_ARM_TRUE@am__append_12 = arm/siglongjmp.S
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am__append_13 = libunwind-ia64.la
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__append_14 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am__append_15 = ia64/setjmp.S  ia64/sigsetjmp.S  \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@				ia64/longjmp.S ia64/siglongjmp.S
-
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am__append_16 = libunwind-hppa.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@@REMOTE_ONLY_FALSE@am__append_17 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am__append_18 = hppa/siglongjmp.S
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am__append_19 = libunwind-mips.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@@REMOTE_ONLY_FALSE@am__append_20 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am__append_21 = mips/siglongjmp.S
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@am__append_22 = libunwind-x86.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@@REMOTE_ONLY_FALSE@am__append_23 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@am__append_24 = x86/longjmp.S x86/siglongjmp.S
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am__append_25 = libunwind-x86_64.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_26 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am__append_27 = x86_64/longjmp.S x86_64/siglongjmp.S
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_28 = libunwind-ppc32.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_29 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_30 = ppc/longjmp.S ppc/siglongjmp.S
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_31 = libunwind-ppc64.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_32 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_33 = ppc/longjmp.S ppc/siglongjmp.S
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_34 = libunwind-sh.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_35 = libunwind.la -lc
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_36 = sh/siglongjmp.S
+@REMOTE_ONLY_FALSE@am__append_1 = libunwind.la
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@am__append_2 = libunwind-ptrace.la
+@BUILD_COREDUMP_TRUE@@REMOTE_ONLY_FALSE@am__append_3 = libunwind-coredump.la
+@REMOTE_ONLY_FALSE@am__append_4 = unwind/libunwind.pc
+@BUILD_PTRACE_TRUE@am__append_5 = ptrace/libunwind-ptrace.pc
+@BUILD_SETJMP_TRUE@am__append_6 = setjmp/libunwind-setjmp.pc
+@BUILD_COREDUMP_TRUE@am__append_7 = coredump/libunwind-coredump.pc
+@USE_DWARF_TRUE@am__append_8 = libunwind-dwarf-common.la libunwind-dwarf-generic.la
+@REMOTE_ONLY_FALSE@@USE_DWARF_TRUE@am__append_9 = libunwind-dwarf-local.la
+@USE_DWARF_TRUE@am__append_10 = libunwind-dwarf-local.la
+@OS_LINUX_TRUE@am__append_11 = coredump/_UCD_access_reg_linux.c
+@OS_FREEBSD_TRUE@am__append_12 = coredump/_UCD_access_reg_freebsd.c
+@ARCH_AARCH64_TRUE@am__append_13 = libunwind-aarch64.la
+@ARCH_AARCH64_TRUE@@REMOTE_ONLY_FALSE@am__append_14 = libunwind.la -lc
+@ARCH_AARCH64_TRUE@am__append_15 = aarch64/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@am__append_16 = libunwind-arm.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@@REMOTE_ONLY_FALSE@am__append_17 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@am__append_18 = arm/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am__append_19 = libunwind-ia64.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__append_20 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am__append_21 = ia64/setjmp.S  ia64/sigsetjmp.S  \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@				ia64/longjmp.S ia64/siglongjmp.S
+
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am__append_22 = libunwind-hppa.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@@REMOTE_ONLY_FALSE@am__append_23 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am__append_24 = hppa/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am__append_25 = libunwind-mips.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@@REMOTE_ONLY_FALSE@am__append_26 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am__append_27 = mips/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@am__append_28 = libunwind-tilegx.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@@REMOTE_ONLY_FALSE@am__append_29 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@am__append_30 = tilegx/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@am__append_31 = libunwind-x86.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@@REMOTE_ONLY_FALSE@am__append_32 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@am__append_33 = x86/longjmp.S x86/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am__append_34 = libunwind-x86_64.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_35 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am__append_36 = x86_64/longjmp.S x86_64/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_37 = libunwind-ppc32.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_38 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_39 = ppc/longjmp.S ppc/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_40 = libunwind-ppc64.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_41 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_42 = ppc/longjmp.S ppc/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_43 = libunwind-sh.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_44 = libunwind.la -lc
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_45 = sh/siglongjmp.S
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__append_46 = libunwind-s390x.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__append_47 = libunwind.la -lc
 
 # libunwind-setjmp depends on libunwind-$(arch). Therefore must be added
 # at the end.
-@REMOTE_ONLY_FALSE@am__append_37 = libunwind-setjmp.la
-@HAVE_LZMA_TRUE@am__append_38 = -llzma
+@BUILD_SETJMP_TRUE@am__append_48 = libunwind-setjmp.la
 subdir = src
-DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in $(srcdir)/libunwind-generic.pc.in
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(srcdir)/libunwind-generic.pc.in $(top_srcdir)/config/depcomp \
+	$(noinst_HEADERS)
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
 	$(top_srcdir)/configure.ac
@@ -126,50 +179,106 @@ am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(libdir)" \
 	"$(DESTDIR)$(pkgconfigdir)"
 LIBRARIES = $(lib_LIBRARIES)
 LTLIBRARIES = $(lib_LTLIBRARIES) $(noinst_LTLIBRARIES)
-@ARCH_ARM_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_1 = libunwind.la
-@ARCH_ARM_TRUE@libunwind_arm_la_DEPENDENCIES =  \
-@ARCH_ARM_TRUE@	libunwind-dwarf-generic.la libunwind-elf32.la \
-@ARCH_ARM_TRUE@	$(am__DEPENDENCIES_1)
-am__libunwind_arm_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
-	mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
-	arm/is_fpreg.c arm/regname.c mi/Gdyn-extract.c \
-	mi/Gdyn-remote.c mi/Gfind_dynamic_proc_info.c \
-	mi/Gget_accessors.c mi/Gget_proc_info_by_ip.c \
-	mi/Gget_proc_name.c mi/Gput_dynamic_unwind_info.c \
-	mi/Gdestroy_addr_space.c mi/Gget_reg.c mi/Gset_reg.c \
-	mi/Gget_fpreg.c mi/Gset_fpreg.c mi/Gset_caching_policy.c \
-	arm/Gcreate_addr_space.c arm/Gget_proc_info.c \
-	arm/Gget_save_loc.c arm/Gglobal.c arm/Ginit.c \
-	arm/Ginit_local.c arm/Ginit_remote.c arm/Gis_signal_frame.c \
-	arm/Gregs.c arm/Gresume.c arm/Gstep.c arm/Gex_tables.c
+@ARCH_AARCH64_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_1 =  \
+@ARCH_AARCH64_TRUE@@REMOTE_ONLY_FALSE@	libunwind.la
+@ARCH_AARCH64_TRUE@libunwind_aarch64_la_DEPENDENCIES =  \
+@ARCH_AARCH64_TRUE@	libunwind-dwarf-generic.la \
+@ARCH_AARCH64_TRUE@	libunwind-elf64.la $(am__DEPENDENCIES_1)
+am__libunwind_aarch64_la_SOURCES_DIST = os-freebsd.c os-hpux.c \
+	os-linux.c os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c \
+	mi/strerror.c aarch64/is_fpreg.c aarch64/regname.c \
+	mi/Gdyn-extract.c mi/Gdyn-remote.c \
+	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
+	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
+	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
+	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	aarch64/Gapply_reg_state.c aarch64/Greg_states_iterate.c \
+	aarch64/Gcreate_addr_space.c aarch64/Gget_proc_info.c \
+	aarch64/Gget_save_loc.c aarch64/Gglobal.c aarch64/Ginit.c \
+	aarch64/Ginit_local.c aarch64/Ginit_remote.c \
+	aarch64/Gis_signal_frame.c aarch64/Gregs.c aarch64/Gresume.c \
+	aarch64/Gstash_frame.c aarch64/Gstep.c aarch64/Gtrace.c
 am__objects_1 = os-freebsd.lo
 am__objects_2 = os-hpux.lo
 am__objects_3 = os-linux.lo
-@OS_FREEBSD_FALSE@@OS_HPUX_FALSE@@OS_LINUX_TRUE@am__objects_4 = $(am__objects_3)
-@OS_FREEBSD_FALSE@@OS_HPUX_TRUE@am__objects_4 = $(am__objects_2)
-@OS_FREEBSD_TRUE@am__objects_4 = $(am__objects_1)
+am__objects_4 = os-qnx.lo
+@OS_FREEBSD_FALSE@@OS_HPUX_FALSE@@OS_LINUX_FALSE@@OS_QNX_TRUE@am__objects_5 = $(am__objects_4)
+@OS_FREEBSD_FALSE@@OS_HPUX_FALSE@@OS_LINUX_TRUE@am__objects_5 = $(am__objects_3)
+@OS_FREEBSD_FALSE@@OS_HPUX_TRUE@am__objects_5 = $(am__objects_2)
+@OS_FREEBSD_TRUE@am__objects_5 = $(am__objects_1)
 am__dirstamp = $(am__leading_dot)dirstamp
-am__objects_5 = $(am__objects_4) mi/init.lo mi/flush_cache.lo \
+am__objects_6 = $(am__objects_5) mi/init.lo mi/flush_cache.lo \
 	mi/mempool.lo mi/strerror.lo
-am__objects_6 = $(am__objects_5) arm/is_fpreg.lo arm/regname.lo
-am__objects_7 = mi/Gdyn-extract.lo mi/Gdyn-remote.lo \
+am__objects_7 = $(am__objects_6) aarch64/is_fpreg.lo \
+	aarch64/regname.lo
+am__objects_8 = mi/Gdyn-extract.lo mi/Gdyn-remote.lo \
 	mi/Gfind_dynamic_proc_info.lo mi/Gget_accessors.lo \
 	mi/Gget_proc_info_by_ip.lo mi/Gget_proc_name.lo \
 	mi/Gput_dynamic_unwind_info.lo mi/Gdestroy_addr_space.lo \
 	mi/Gget_reg.lo mi/Gset_reg.lo mi/Gget_fpreg.lo \
-	mi/Gset_fpreg.lo mi/Gset_caching_policy.lo
-am__objects_8 = $(am__objects_6) $(am__objects_7) \
+	mi/Gset_fpreg.lo mi/Gset_caching_policy.lo \
+	mi/Gset_cache_size.lo
+am__objects_9 = $(am__objects_7) $(am__objects_8) \
+	aarch64/Gapply_reg_state.lo aarch64/Greg_states_iterate.lo \
+	aarch64/Gcreate_addr_space.lo aarch64/Gget_proc_info.lo \
+	aarch64/Gget_save_loc.lo aarch64/Gglobal.lo aarch64/Ginit.lo \
+	aarch64/Ginit_local.lo aarch64/Ginit_remote.lo \
+	aarch64/Gis_signal_frame.lo aarch64/Gregs.lo \
+	aarch64/Gresume.lo aarch64/Gstash_frame.lo aarch64/Gstep.lo \
+	aarch64/Gtrace.lo
+@ARCH_AARCH64_TRUE@am_libunwind_aarch64_la_OBJECTS = $(am__objects_9)
+libunwind_aarch64_la_OBJECTS = $(am_libunwind_aarch64_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+libunwind_aarch64_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_aarch64_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@ARCH_AARCH64_TRUE@am_libunwind_aarch64_la_rpath = -rpath $(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_2 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@libunwind_arm_la_DEPENDENCIES =  \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	$(am__DEPENDENCIES_2)
+am__libunwind_arm_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
+	os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
+	arm/is_fpreg.c arm/regname.c arm/Gos-freebsd.c arm/Gos-linux.c \
+	arm/Gos-other.c mi/Gdyn-extract.c mi/Gdyn-remote.c \
+	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
+	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
+	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
+	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	arm/Gapply_reg_state.c arm/Greg_states_iterate.c \
+	arm/Gcreate_addr_space.c arm/Gget_proc_info.c \
+	arm/Gget_save_loc.c arm/Gglobal.c arm/Ginit.c \
+	arm/Ginit_local.c arm/Ginit_remote.c arm/Gregs.c arm/Gresume.c \
+	arm/Gstep.c arm/Gex_tables.c arm/Gstash_frame.c arm/Gtrace.c
+am__objects_10 = $(am__objects_6) arm/is_fpreg.lo arm/regname.lo
+@OS_FREEBSD_FALSE@@OS_LINUX_FALSE@@OS_QNX_TRUE@am__objects_11 = arm/Gos-other.lo
+@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_11 = arm/Gos-linux.lo
+@OS_FREEBSD_TRUE@am__objects_11 = arm/Gos-freebsd.lo
+am__objects_12 = $(am__objects_10) $(am__objects_11) $(am__objects_8) \
+	arm/Gapply_reg_state.lo arm/Greg_states_iterate.lo \
 	arm/Gcreate_addr_space.lo arm/Gget_proc_info.lo \
 	arm/Gget_save_loc.lo arm/Gglobal.lo arm/Ginit.lo \
-	arm/Ginit_local.lo arm/Ginit_remote.lo arm/Gis_signal_frame.lo \
-	arm/Gregs.lo arm/Gresume.lo arm/Gstep.lo arm/Gex_tables.lo
-@ARCH_ARM_TRUE@am_libunwind_arm_la_OBJECTS = $(am__objects_8)
+	arm/Ginit_local.lo arm/Ginit_remote.lo arm/Gregs.lo \
+	arm/Gresume.lo arm/Gstep.lo arm/Gex_tables.lo \
+	arm/Gstash_frame.lo arm/Gtrace.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@am_libunwind_arm_la_OBJECTS =  \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	$(am__objects_12)
 libunwind_arm_la_OBJECTS = $(am_libunwind_arm_la_OBJECTS)
-libunwind_arm_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_arm_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_TRUE@am_libunwind_arm_la_rpath = -rpath $(libdir)
-libunwind_coredump_la_LIBADD =
+libunwind_arm_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_arm_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@am_libunwind_arm_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	$(libdir)
+am__DEPENDENCIES_3 =
+libunwind_coredump_la_DEPENDENCIES = $(am__DEPENDENCIES_3)
 am__libunwind_coredump_la_SOURCES_DIST = coredump/_UCD_accessors.c \
 	coredump/_UCD_create.c coredump/_UCD_destroy.c \
 	coredump/_UCD_access_mem.c coredump/_UCD_elf_map_image.c \
@@ -179,8 +288,8 @@ am__libunwind_coredump_la_SOURCES_DIST = coredump/_UCD_accessors.c \
 	coredump/_UPT_put_unwind_info.c coredump/_UPT_resume.c \
 	coredump/_UCD_access_reg_linux.c \
 	coredump/_UCD_access_reg_freebsd.c
-@OS_LINUX_TRUE@am__objects_9 = coredump/_UCD_access_reg_linux.lo
-@OS_FREEBSD_TRUE@am__objects_10 = coredump/_UCD_access_reg_freebsd.lo
+@OS_LINUX_TRUE@am__objects_13 = coredump/_UCD_access_reg_linux.lo
+@OS_FREEBSD_TRUE@am__objects_14 = coredump/_UCD_access_reg_freebsd.lo
 am_libunwind_coredump_la_OBJECTS = coredump/_UCD_accessors.lo \
 	coredump/_UCD_create.lo coredump/_UCD_destroy.lo \
 	coredump/_UCD_access_mem.lo coredump/_UCD_elf_map_image.lo \
@@ -188,11 +297,12 @@ am_libunwind_coredump_la_OBJECTS = coredump/_UCD_accessors.lo \
 	coredump/_UPT_elf.lo coredump/_UPT_access_fpreg.lo \
 	coredump/_UPT_get_dyn_info_list_addr.lo \
 	coredump/_UPT_put_unwind_info.lo coredump/_UPT_resume.lo \
-	$(am__objects_9) $(am__objects_10)
+	$(am__objects_13) $(am__objects_14)
 libunwind_coredump_la_OBJECTS = $(am_libunwind_coredump_la_OBJECTS)
-libunwind_coredump_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_coredump_la_LDFLAGS) $(LDFLAGS) -o $@
+libunwind_coredump_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_coredump_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
 @BUILD_COREDUMP_TRUE@@REMOTE_ONLY_FALSE@am_libunwind_coredump_la_rpath =  \
 @BUILD_COREDUMP_TRUE@@REMOTE_ONLY_FALSE@	-rpath $(libdir)
 libunwind_dwarf_common_la_LIBADD =
@@ -202,79 +312,84 @@ libunwind_dwarf_common_la_OBJECTS =  \
 @USE_DWARF_TRUE@am_libunwind_dwarf_common_la_rpath =
 libunwind_dwarf_generic_la_DEPENDENCIES = libunwind-dwarf-common.la
 am_libunwind_dwarf_generic_la_OBJECTS = dwarf/Gexpr.lo dwarf/Gfde.lo \
-	dwarf/Gparser.lo dwarf/Gpe.lo dwarf/Gstep.lo \
-	dwarf/Gfind_proc_info-lsb.lo dwarf/Gfind_unwind_table.lo
+	dwarf/Gparser.lo dwarf/Gpe.lo dwarf/Gfind_proc_info-lsb.lo \
+	dwarf/Gfind_unwind_table.lo
 libunwind_dwarf_generic_la_OBJECTS =  \
 	$(am_libunwind_dwarf_generic_la_OBJECTS)
 @USE_DWARF_TRUE@am_libunwind_dwarf_generic_la_rpath =
 libunwind_dwarf_local_la_DEPENDENCIES = libunwind-dwarf-common.la
 am_libunwind_dwarf_local_la_OBJECTS = dwarf/Lexpr.lo dwarf/Lfde.lo \
-	dwarf/Lparser.lo dwarf/Lpe.lo dwarf/Lstep.lo \
-	dwarf/Lfind_proc_info-lsb.lo dwarf/Lfind_unwind_table.lo
+	dwarf/Lparser.lo dwarf/Lpe.lo dwarf/Lfind_proc_info-lsb.lo \
+	dwarf/Lfind_unwind_table.lo
 libunwind_dwarf_local_la_OBJECTS =  \
 	$(am_libunwind_dwarf_local_la_OBJECTS)
 @REMOTE_ONLY_FALSE@@USE_DWARF_TRUE@am_libunwind_dwarf_local_la_rpath =
-libunwind_elf32_la_LIBADD =
+libunwind_elf32_la_DEPENDENCIES = $(am__DEPENDENCIES_3)
 am_libunwind_elf32_la_OBJECTS = elf32.lo
 libunwind_elf32_la_OBJECTS = $(am_libunwind_elf32_la_OBJECTS)
 @USE_ELF32_TRUE@am_libunwind_elf32_la_rpath =
-libunwind_elf64_la_LIBADD =
+libunwind_elf64_la_DEPENDENCIES = $(am__DEPENDENCIES_3)
 am_libunwind_elf64_la_OBJECTS = elf64.lo
 libunwind_elf64_la_OBJECTS = $(am_libunwind_elf64_la_OBJECTS)
 @USE_ELF64_TRUE@am_libunwind_elf64_la_rpath =
-libunwind_elfxx_la_LIBADD =
+libunwind_elfxx_la_DEPENDENCIES = $(am__DEPENDENCIES_3)
 am_libunwind_elfxx_la_OBJECTS = elfxx.lo
 libunwind_elfxx_la_OBJECTS = $(am_libunwind_elfxx_la_OBJECTS)
 @USE_ELFXX_TRUE@am_libunwind_elfxx_la_rpath =
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_2 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_DEPENDENCIES = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	$(am__DEPENDENCIES_2)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_4 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	$(am__DEPENDENCIES_4)
 am__libunwind_hppa_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
-	mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
+	os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
 	hppa/regname.c mi/Gdyn-extract.c mi/Gdyn-remote.c \
 	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
 	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
 	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
-	mi/Gset_caching_policy.c hppa/Gcreate_addr_space.c \
-	hppa/Gget_save_loc.c hppa/Gglobal.c hppa/Ginit.c \
-	hppa/Ginit_local.c hppa/Ginit_remote.c hppa/Gis_signal_frame.c \
-	hppa/Gget_proc_info.c hppa/Gregs.c hppa/Gresume.c hppa/Gstep.c
-am__objects_11 = $(am__objects_5) hppa/regname.lo
-am__objects_12 = $(am__objects_11) $(am__objects_7) \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	hppa/Gapply_reg_state.c hppa/Greg_states_iterate.c \
+	hppa/Gcreate_addr_space.c hppa/Gget_save_loc.c hppa/Gglobal.c \
+	hppa/Ginit.c hppa/Ginit_local.c hppa/Ginit_remote.c \
+	hppa/Gis_signal_frame.c hppa/Gget_proc_info.c hppa/Gregs.c \
+	hppa/Gresume.c hppa/Gstep.c
+am__objects_15 = $(am__objects_6) hppa/regname.lo
+am__objects_16 = $(am__objects_15) $(am__objects_8) \
+	hppa/Gapply_reg_state.lo hppa/Greg_states_iterate.lo \
 	hppa/Gcreate_addr_space.lo hppa/Gget_save_loc.lo \
 	hppa/Gglobal.lo hppa/Ginit.lo hppa/Ginit_local.lo \
 	hppa/Ginit_remote.lo hppa/Gis_signal_frame.lo \
 	hppa/Gget_proc_info.lo hppa/Gregs.lo hppa/Gresume.lo \
 	hppa/Gstep.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am_libunwind_hppa_la_OBJECTS = $(am__objects_12)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am_libunwind_hppa_la_OBJECTS = $(am__objects_16)
 libunwind_hppa_la_OBJECTS = $(am_libunwind_hppa_la_OBJECTS)
-libunwind_hppa_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_hppa_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am_libunwind_hppa_la_rpath =  \
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	-rpath \
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	$(libdir)
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_3 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_DEPENDENCIES =  \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	libunwind-elf64.la \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(am__DEPENDENCIES_3)
+libunwind_hppa_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_hppa_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am_libunwind_hppa_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	$(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_5 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_DEPENDENCIES = libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(am__DEPENDENCIES_5)
 am__libunwind_ia64_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
-	mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
+	os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
 	ia64/regname.c mi/Gdyn-extract.c mi/Gdyn-remote.c \
 	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
 	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
 	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
-	mi/Gset_caching_policy.c ia64/Gcreate_addr_space.c \
-	ia64/Gget_proc_info.c ia64/Gget_save_loc.c ia64/Gglobal.c \
-	ia64/Ginit.c ia64/Ginit_local.c ia64/Ginit_remote.c \
-	ia64/Ginstall_cursor.S ia64/Gis_signal_frame.c ia64/Gparser.c \
-	ia64/Grbs.c ia64/Gregs.c ia64/Gresume.c ia64/Gscript.c \
-	ia64/Gstep.c ia64/Gtables.c ia64/Gfind_unwind_table.c
-am__objects_13 = $(am__objects_5) ia64/regname.lo
-am__objects_14 = $(am__objects_13) $(am__objects_7) \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	ia64/Gapply_reg_state.c ia64/Greg_states_iterate.c \
+	ia64/Gcreate_addr_space.c ia64/Gget_proc_info.c \
+	ia64/Gget_save_loc.c ia64/Gglobal.c ia64/Ginit.c \
+	ia64/Ginit_local.c ia64/Ginit_remote.c ia64/Ginstall_cursor.S \
+	ia64/Gis_signal_frame.c ia64/Gparser.c ia64/Grbs.c \
+	ia64/Gregs.c ia64/Gresume.c ia64/Gscript.c ia64/Gstep.c \
+	ia64/Gtables.c ia64/Gfind_unwind_table.c
+am__objects_17 = $(am__objects_6) ia64/regname.lo
+am__objects_18 = $(am__objects_17) $(am__objects_8) \
+	ia64/Gapply_reg_state.lo ia64/Greg_states_iterate.lo \
 	ia64/Gcreate_addr_space.lo ia64/Gget_proc_info.lo \
 	ia64/Gget_save_loc.lo ia64/Gglobal.lo ia64/Ginit.lo \
 	ia64/Ginit_local.lo ia64/Ginit_remote.lo \
@@ -282,103 +397,115 @@ am__objects_14 = $(am__objects_13) $(am__objects_7) \
 	ia64/Gparser.lo ia64/Grbs.lo ia64/Gregs.lo ia64/Gresume.lo \
 	ia64/Gscript.lo ia64/Gstep.lo ia64/Gtables.lo \
 	ia64/Gfind_unwind_table.lo
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am_libunwind_ia64_la_OBJECTS =  \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(am__objects_14)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am_libunwind_ia64_la_OBJECTS = $(am__objects_18)
 libunwind_ia64_la_OBJECTS = $(am_libunwind_ia64_la_OBJECTS)
-libunwind_ia64_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_ia64_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am_libunwind_ia64_la_rpath = -rpath \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(libdir)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_4 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_DEPENDENCIES = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	libunwind-elfxx.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	$(am__DEPENDENCIES_4)
+libunwind_ia64_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_ia64_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am_libunwind_ia64_la_rpath =  \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	-rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_6 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	libunwind-elfxx.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	$(am__DEPENDENCIES_6)
 am__libunwind_mips_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
-	mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
+	os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
 	mips/is_fpreg.c mips/regname.c mi/Gdyn-extract.c \
 	mi/Gdyn-remote.c mi/Gfind_dynamic_proc_info.c \
 	mi/Gget_accessors.c mi/Gget_proc_info_by_ip.c \
 	mi/Gget_proc_name.c mi/Gput_dynamic_unwind_info.c \
 	mi/Gdestroy_addr_space.c mi/Gget_reg.c mi/Gset_reg.c \
 	mi/Gget_fpreg.c mi/Gset_fpreg.c mi/Gset_caching_policy.c \
-	mips/Gcreate_addr_space.c mips/Gget_proc_info.c \
-	mips/Gget_save_loc.c mips/Gglobal.c mips/Ginit.c \
-	mips/Ginit_local.c mips/Ginit_remote.c mips/Gis_signal_frame.c \
-	mips/Gregs.c mips/Gresume.c mips/Gstep.c
-am__objects_15 = $(am__objects_5) mips/is_fpreg.lo mips/regname.lo
-am__objects_16 = $(am__objects_15) $(am__objects_7) \
+	mi/Gset_cache_size.c mips/Gapply_reg_state.c \
+	mips/Greg_states_iterate.c mips/Gcreate_addr_space.c \
+	mips/Gget_proc_info.c mips/Gget_save_loc.c mips/Gglobal.c \
+	mips/Ginit.c mips/Ginit_local.c mips/Ginit_remote.c \
+	mips/Gis_signal_frame.c mips/Gregs.c mips/Gresume.c \
+	mips/Gstep.c
+am__objects_19 = $(am__objects_6) mips/is_fpreg.lo mips/regname.lo
+am__objects_20 = $(am__objects_19) $(am__objects_8) \
+	mips/Gapply_reg_state.lo mips/Greg_states_iterate.lo \
 	mips/Gcreate_addr_space.lo mips/Gget_proc_info.lo \
 	mips/Gget_save_loc.lo mips/Gglobal.lo mips/Ginit.lo \
 	mips/Ginit_local.lo mips/Ginit_remote.lo \
 	mips/Gis_signal_frame.lo mips/Gregs.lo mips/Gresume.lo \
 	mips/Gstep.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am_libunwind_mips_la_OBJECTS = $(am__objects_16)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am_libunwind_mips_la_OBJECTS = $(am__objects_20)
 libunwind_mips_la_OBJECTS = $(am_libunwind_mips_la_OBJECTS)
-libunwind_mips_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_mips_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am_libunwind_mips_la_rpath = -rpath \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	$(libdir)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_5 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_DEPENDENCIES = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_5)
+libunwind_mips_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_mips_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am_libunwind_mips_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	$(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_7 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_7)
 am__libunwind_ppc32_la_SOURCES_DIST = os-freebsd.c os-hpux.c \
-	os-linux.c mi/init.c mi/flush_cache.c mi/mempool.c \
+	os-linux.c os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c \
 	mi/strerror.c ppc32/is_fpreg.c ppc32/regname.c \
 	ppc32/get_func_addr.c mi/Gdyn-extract.c mi/Gdyn-remote.c \
 	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
 	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
 	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
-	mi/Gset_caching_policy.c ppc/Gcreate_addr_space.c \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
 	ppc/Gget_proc_info.c ppc/Gget_save_loc.c ppc/Ginit_local.c \
-	ppc/Ginit_remote.c ppc/Gis_signal_frame.c ppc32/Gglobal.c \
-	ppc32/Ginit.c ppc32/Gregs.c ppc32/Gresume.c ppc32/Gstep.c
-am__objects_17 = $(am__objects_5) ppc32/is_fpreg.lo ppc32/regname.lo \
+	ppc/Ginit_remote.c ppc/Gis_signal_frame.c \
+	ppc32/Gapply_reg_state.c ppc32/Greg_states_iterate.c \
+	ppc32/Gcreate_addr_space.c ppc32/Gglobal.c ppc32/Ginit.c \
+	ppc32/Gregs.c ppc32/Gresume.c ppc32/Gstep.c
+am__objects_21 = $(am__objects_6) ppc32/is_fpreg.lo ppc32/regname.lo \
 	ppc32/get_func_addr.lo
-am__objects_18 = ppc/Gcreate_addr_space.lo ppc/Gget_proc_info.lo \
-	ppc/Gget_save_loc.lo ppc/Ginit_local.lo ppc/Ginit_remote.lo \
-	ppc/Gis_signal_frame.lo
-am__objects_19 = $(am__objects_17) $(am__objects_7) $(am__objects_18) \
-	ppc32/Gglobal.lo ppc32/Ginit.lo ppc32/Gregs.lo \
-	ppc32/Gresume.lo ppc32/Gstep.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc32_la_OBJECTS = $(am__objects_19)
+am__objects_22 = ppc/Gget_proc_info.lo ppc/Gget_save_loc.lo \
+	ppc/Ginit_local.lo ppc/Ginit_remote.lo ppc/Gis_signal_frame.lo
+am__objects_23 = $(am__objects_21) $(am__objects_8) $(am__objects_22) \
+	ppc32/Gapply_reg_state.lo ppc32/Greg_states_iterate.lo \
+	ppc32/Gcreate_addr_space.lo ppc32/Gglobal.lo ppc32/Ginit.lo \
+	ppc32/Gregs.lo ppc32/Gresume.lo ppc32/Gstep.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc32_la_OBJECTS = $(am__objects_23)
 libunwind_ppc32_la_OBJECTS = $(am_libunwind_ppc32_la_OBJECTS)
-libunwind_ppc32_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_ppc32_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc32_la_rpath = -rpath \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(libdir)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_6 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_DEPENDENCIES = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf64.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_6)
+libunwind_ppc32_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_ppc32_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc32_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_8 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_8)
 am__libunwind_ppc64_la_SOURCES_DIST = os-freebsd.c os-hpux.c \
-	os-linux.c mi/init.c mi/flush_cache.c mi/mempool.c \
+	os-linux.c os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c \
 	mi/strerror.c ppc64/is_fpreg.c ppc64/regname.c \
 	ppc64/get_func_addr.c mi/Gdyn-extract.c mi/Gdyn-remote.c \
 	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
 	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
 	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
-	mi/Gset_caching_policy.c ppc/Gcreate_addr_space.c \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
 	ppc/Gget_proc_info.c ppc/Gget_save_loc.c ppc/Ginit_local.c \
-	ppc/Ginit_remote.c ppc/Gis_signal_frame.c ppc64/Gglobal.c \
-	ppc64/Ginit.c ppc64/Gregs.c ppc64/Gresume.c ppc64/Gstep.c
-am__objects_20 = $(am__objects_5) ppc64/is_fpreg.lo ppc64/regname.lo \
+	ppc/Ginit_remote.c ppc/Gis_signal_frame.c \
+	ppc64/Gapply_reg_state.c ppc64/Greg_states_iterate.c \
+	ppc64/Gcreate_addr_space.c ppc64/Gglobal.c ppc64/Ginit.c \
+	ppc64/Gregs.c ppc64/Gresume.c ppc64/Gstep.c
+am__objects_24 = $(am__objects_6) ppc64/is_fpreg.lo ppc64/regname.lo \
 	ppc64/get_func_addr.lo
-am__objects_21 = $(am__objects_20) $(am__objects_7) $(am__objects_18) \
-	ppc64/Gglobal.lo ppc64/Ginit.lo ppc64/Gregs.lo \
-	ppc64/Gresume.lo ppc64/Gstep.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc64_la_OBJECTS = $(am__objects_21)
+am__objects_25 = $(am__objects_24) $(am__objects_8) $(am__objects_22) \
+	ppc64/Gapply_reg_state.lo ppc64/Greg_states_iterate.lo \
+	ppc64/Gcreate_addr_space.lo ppc64/Gglobal.lo ppc64/Ginit.lo \
+	ppc64/Gregs.lo ppc64/Gresume.lo ppc64/Gstep.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc64_la_OBJECTS = $(am__objects_25)
 libunwind_ppc64_la_OBJECTS = $(am_libunwind_ppc64_la_OBJECTS)
-libunwind_ppc64_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_ppc64_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc64_la_rpath = -rpath \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(libdir)
+libunwind_ppc64_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_ppc64_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_ppc64_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(libdir)
 libunwind_ptrace_la_LIBADD =
 am_libunwind_ptrace_la_OBJECTS = ptrace/_UPT_elf.lo \
 	ptrace/_UPT_accessors.lo ptrace/_UPT_access_fpreg.lo \
@@ -389,105 +516,184 @@ am_libunwind_ptrace_la_OBJECTS = ptrace/_UPT_elf.lo \
 	ptrace/_UPT_put_unwind_info.lo ptrace/_UPT_get_proc_name.lo \
 	ptrace/_UPT_reg_offset.lo ptrace/_UPT_resume.lo
 libunwind_ptrace_la_OBJECTS = $(am_libunwind_ptrace_la_OBJECTS)
-@REMOTE_ONLY_FALSE@am_libunwind_ptrace_la_rpath = -rpath $(libdir)
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@am_libunwind_ptrace_la_rpath =  \
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@	-rpath $(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_9 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_s390x_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_9)
+am__libunwind_s390x_la_SOURCES_DIST = os-freebsd.c os-hpux.c \
+	os-linux.c os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c \
+	mi/strerror.c s390x/is_fpreg.c s390x/regname.c \
+	mi/Gdyn-extract.c mi/Gdyn-remote.c \
+	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
+	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
+	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
+	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	s390x/Gapply_reg_state.c s390x/Greg_states_iterate.c \
+	s390x/Gcreate_addr_space.c s390x/Gget_save_loc.c \
+	s390x/Gglobal.c s390x/Ginit.c s390x/Ginit_local.c \
+	s390x/Ginit_remote.c s390x/Gget_proc_info.c s390x/Gregs.c \
+	s390x/Gresume.c s390x/Gis_signal_frame.c s390x/Gstep.c
+am__objects_26 = $(am__objects_6) s390x/is_fpreg.lo s390x/regname.lo
+am__objects_27 = $(am__objects_26) $(am__objects_8) \
+	s390x/Gapply_reg_state.lo s390x/Greg_states_iterate.lo \
+	s390x/Gcreate_addr_space.lo s390x/Gget_save_loc.lo \
+	s390x/Gglobal.lo s390x/Ginit.lo s390x/Ginit_local.lo \
+	s390x/Ginit_remote.lo s390x/Gget_proc_info.lo s390x/Gregs.lo \
+	s390x/Gresume.lo s390x/Gis_signal_frame.lo s390x/Gstep.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_s390x_la_OBJECTS = $(am__objects_27)
+libunwind_s390x_la_OBJECTS = $(am_libunwind_s390x_la_OBJECTS)
+libunwind_s390x_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_s390x_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_s390x_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(libdir)
 libunwind_setjmp_la_DEPENDENCIES = $(LIBUNWIND_ELF) \
 	libunwind-$(arch).la libunwind.la
 am__libunwind_setjmp_la_SOURCES_DIST = setjmp/longjmp.c \
-	setjmp/siglongjmp.c arm/siglongjmp.S ia64/setjmp.S \
-	ia64/sigsetjmp.S ia64/longjmp.S ia64/siglongjmp.S \
-	hppa/siglongjmp.S mips/siglongjmp.S x86/longjmp.S \
-	x86/siglongjmp.S x86_64/longjmp.S x86_64/siglongjmp.S \
-	ppc/longjmp.S ppc/siglongjmp.S sh/siglongjmp.S
-@ARCH_ARM_TRUE@am__objects_22 = arm/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am__objects_23 = ia64/setjmp.lo \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	ia64/sigsetjmp.lo \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	ia64/longjmp.lo \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	ia64/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am__objects_24 = hppa/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am__objects_25 = mips/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@am__objects_26 = x86/longjmp.lo \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@	x86/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am__objects_27 = x86_64/longjmp.lo \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	x86_64/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__objects_28 = ppc/longjmp.lo \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	ppc/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__objects_29 = ppc/longjmp.lo \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	ppc/siglongjmp.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__objects_30 = sh/siglongjmp.lo
+	setjmp/siglongjmp.c aarch64/siglongjmp.S arm/siglongjmp.S \
+	ia64/setjmp.S ia64/sigsetjmp.S ia64/longjmp.S \
+	ia64/siglongjmp.S hppa/siglongjmp.S mips/siglongjmp.S \
+	tilegx/siglongjmp.S x86/longjmp.S x86/siglongjmp.S \
+	x86_64/longjmp.S x86_64/siglongjmp.S ppc/longjmp.S \
+	ppc/siglongjmp.S sh/siglongjmp.S
+@ARCH_AARCH64_TRUE@am__objects_28 = aarch64/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@am__objects_29 = arm/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am__objects_30 = ia64/setjmp.lo \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	ia64/sigsetjmp.lo \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	ia64/longjmp.lo \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	ia64/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am__objects_31 = hppa/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am__objects_32 = mips/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@am__objects_33 = tilegx/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@am__objects_34 = x86/longjmp.lo \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@	x86/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am__objects_35 = x86_64/longjmp.lo \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	x86_64/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__objects_36 = ppc/longjmp.lo \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	ppc/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__objects_37 = ppc/longjmp.lo \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	ppc/siglongjmp.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am__objects_38 = sh/siglongjmp.lo
 am_libunwind_setjmp_la_OBJECTS = setjmp/longjmp.lo \
-	setjmp/siglongjmp.lo $(am__objects_22) $(am__objects_23) \
-	$(am__objects_24) $(am__objects_25) $(am__objects_26) \
-	$(am__objects_27) $(am__objects_28) $(am__objects_29) \
-	$(am__objects_30)
+	setjmp/siglongjmp.lo $(am__objects_28) $(am__objects_29) \
+	$(am__objects_30) $(am__objects_31) $(am__objects_32) \
+	$(am__objects_33) $(am__objects_34) $(am__objects_35) \
+	$(am__objects_36) $(am__objects_37) $(am__objects_38)
 libunwind_setjmp_la_OBJECTS = $(am_libunwind_setjmp_la_OBJECTS)
-libunwind_setjmp_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_setjmp_la_LDFLAGS) $(LDFLAGS) -o $@
-@REMOTE_ONLY_FALSE@am_libunwind_setjmp_la_rpath = -rpath $(libdir)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_7 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_DEPENDENCIES = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_7)
+libunwind_setjmp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_setjmp_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@BUILD_SETJMP_TRUE@am_libunwind_setjmp_la_rpath = -rpath $(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_10 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_10)
 am__libunwind_sh_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
-	mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
+	os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
 	sh/is_fpreg.c sh/regname.c mi/Gdyn-extract.c mi/Gdyn-remote.c \
 	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
 	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
 	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
-	mi/Gset_caching_policy.c sh/Gcreate_addr_space.c \
-	sh/Gget_proc_info.c sh/Gget_save_loc.c sh/Gglobal.c sh/Ginit.c \
-	sh/Ginit_local.c sh/Ginit_remote.c sh/Gis_signal_frame.c \
-	sh/Gregs.c sh/Gresume.c sh/Gstep.c
-am__objects_31 = $(am__objects_5) sh/is_fpreg.lo sh/regname.lo
-am__objects_32 = $(am__objects_31) $(am__objects_7) \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	sh/Gapply_reg_state.c sh/Greg_states_iterate.c \
+	sh/Gcreate_addr_space.c sh/Gget_proc_info.c sh/Gget_save_loc.c \
+	sh/Gglobal.c sh/Ginit.c sh/Ginit_local.c sh/Ginit_remote.c \
+	sh/Gis_signal_frame.c sh/Gregs.c sh/Gresume.c sh/Gstep.c
+am__objects_39 = $(am__objects_6) sh/is_fpreg.lo sh/regname.lo
+am__objects_40 = $(am__objects_39) $(am__objects_8) \
+	sh/Gapply_reg_state.lo sh/Greg_states_iterate.lo \
 	sh/Gcreate_addr_space.lo sh/Gget_proc_info.lo \
 	sh/Gget_save_loc.lo sh/Gglobal.lo sh/Ginit.lo \
 	sh/Ginit_local.lo sh/Ginit_remote.lo sh/Gis_signal_frame.lo \
 	sh/Gregs.lo sh/Gresume.lo sh/Gstep.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_sh_la_OBJECTS = $(am__objects_32)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_sh_la_OBJECTS = $(am__objects_40)
 libunwind_sh_la_OBJECTS = $(am_libunwind_sh_la_OBJECTS)
-libunwind_sh_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_sh_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_sh_la_rpath = -rpath \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(libdir)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_8 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_DEPENDENCIES = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@	$(am__DEPENDENCIES_8)
+libunwind_sh_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_sh_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_sh_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_11 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@libunwind_tilegx_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@	libunwind-elfxx.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@	$(am__DEPENDENCIES_11)
+am__libunwind_tilegx_la_SOURCES_DIST = os-freebsd.c os-hpux.c \
+	os-linux.c os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c \
+	mi/strerror.c tilegx/is_fpreg.c tilegx/regname.c \
+	mi/Gdyn-extract.c mi/Gdyn-remote.c \
+	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
+	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
+	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
+	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	tilegx/Gapply_reg_state.c tilegx/Greg_states_iterate.c \
+	tilegx/Gcreate_addr_space.c tilegx/Gget_proc_info.c \
+	tilegx/Gget_save_loc.c tilegx/Gglobal.c tilegx/Ginit.c \
+	tilegx/Ginit_local.c tilegx/Ginit_remote.c \
+	tilegx/Gis_signal_frame.c tilegx/Gregs.c tilegx/Gresume.c \
+	tilegx/Gstep.c
+am__objects_41 = $(am__objects_6) tilegx/is_fpreg.lo tilegx/regname.lo
+am__objects_42 = $(am__objects_41) $(am__objects_8) \
+	tilegx/Gapply_reg_state.lo tilegx/Greg_states_iterate.lo \
+	tilegx/Gcreate_addr_space.lo tilegx/Gget_proc_info.lo \
+	tilegx/Gget_save_loc.lo tilegx/Gglobal.lo tilegx/Ginit.lo \
+	tilegx/Ginit_local.lo tilegx/Ginit_remote.lo \
+	tilegx/Gis_signal_frame.lo tilegx/Gregs.lo tilegx/Gresume.lo \
+	tilegx/Gstep.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@am_libunwind_tilegx_la_OBJECTS = $(am__objects_42)
+libunwind_tilegx_la_OBJECTS = $(am_libunwind_tilegx_la_OBJECTS)
+libunwind_tilegx_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_tilegx_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@am_libunwind_tilegx_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@	$(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_12 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@	$(am__DEPENDENCIES_12)
 am__libunwind_x86_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
-	mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
+	os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
 	x86/is_fpreg.c x86/regname.c x86/Gos-freebsd.c x86/Gos-linux.c \
 	mi/Gdyn-extract.c mi/Gdyn-remote.c \
 	mi/Gfind_dynamic_proc_info.c mi/Gget_accessors.c \
 	mi/Gget_proc_info_by_ip.c mi/Gget_proc_name.c \
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c \
 	mi/Gget_reg.c mi/Gset_reg.c mi/Gget_fpreg.c mi/Gset_fpreg.c \
-	mi/Gset_caching_policy.c x86/Gcreate_addr_space.c \
-	x86/Gget_save_loc.c x86/Gglobal.c x86/Ginit.c \
-	x86/Ginit_local.c x86/Ginit_remote.c x86/Gget_proc_info.c \
-	x86/Gregs.c x86/Gresume.c x86/Gstep.c
-am__objects_33 = $(am__objects_5) x86/is_fpreg.lo x86/regname.lo
-@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_34 = x86/Gos-linux.lo
-@OS_FREEBSD_TRUE@am__objects_34 = x86/Gos-freebsd.lo
-am__objects_35 = $(am__objects_33) $(am__objects_34) $(am__objects_7) \
+	mi/Gset_caching_policy.c mi/Gset_cache_size.c \
+	x86/Gapply_reg_state.c x86/Greg_states_iterate.c \
+	x86/Gcreate_addr_space.c x86/Gget_save_loc.c x86/Gglobal.c \
+	x86/Ginit.c x86/Ginit_local.c x86/Ginit_remote.c \
+	x86/Gget_proc_info.c x86/Gregs.c x86/Gresume.c x86/Gstep.c
+am__objects_43 = $(am__objects_6) x86/is_fpreg.lo x86/regname.lo
+@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_44 = x86/Gos-linux.lo
+@OS_FREEBSD_TRUE@am__objects_44 = x86/Gos-freebsd.lo
+am__objects_45 = $(am__objects_43) $(am__objects_44) $(am__objects_8) \
+	x86/Gapply_reg_state.lo x86/Greg_states_iterate.lo \
 	x86/Gcreate_addr_space.lo x86/Gget_save_loc.lo x86/Gglobal.lo \
 	x86/Ginit.lo x86/Ginit_local.lo x86/Ginit_remote.lo \
 	x86/Gget_proc_info.lo x86/Gregs.lo x86/Gresume.lo x86/Gstep.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@am_libunwind_x86_la_OBJECTS = $(am__objects_35)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@am_libunwind_x86_la_OBJECTS = $(am__objects_45)
 libunwind_x86_la_OBJECTS = $(am_libunwind_x86_la_OBJECTS)
-libunwind_x86_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_x86_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@am_libunwind_x86_la_rpath = -rpath \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@	$(libdir)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_9 = libunwind.la
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_DEPENDENCIES = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	libunwind-elf64.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_9)
+libunwind_x86_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_x86_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@am_libunwind_x86_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@	$(libdir)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@@REMOTE_ONLY_FALSE@am__DEPENDENCIES_13 = libunwind.la
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_DEPENDENCIES = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	$(am__DEPENDENCIES_13)
 am__libunwind_x86_64_la_SOURCES_DIST = os-freebsd.c os-hpux.c \
-	os-linux.c mi/init.c mi/flush_cache.c mi/mempool.c \
+	os-linux.c os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c \
 	mi/strerror.c x86_64/is_fpreg.c x86_64/regname.c \
 	x86_64/Gos-freebsd.c x86_64/Gos-linux.c mi/Gdyn-extract.c \
 	mi/Gdyn-remote.c mi/Gfind_dynamic_proc_info.c \
@@ -495,100 +701,135 @@ am__libunwind_x86_64_la_SOURCES_DIST = os-freebsd.c os-hpux.c \
 	mi/Gget_proc_name.c mi/Gput_dynamic_unwind_info.c \
 	mi/Gdestroy_addr_space.c mi/Gget_reg.c mi/Gset_reg.c \
 	mi/Gget_fpreg.c mi/Gset_fpreg.c mi/Gset_caching_policy.c \
-	x86_64/Gcreate_addr_space.c x86_64/Gget_save_loc.c \
-	x86_64/Gglobal.c x86_64/Ginit.c x86_64/Ginit_local.c \
-	x86_64/Ginit_remote.c x86_64/Gget_proc_info.c x86_64/Gregs.c \
-	x86_64/Gresume.c x86_64/Gstash_frame.c x86_64/Gstep.c \
-	x86_64/Gtrace.c
-am__objects_36 = $(am__objects_5) x86_64/is_fpreg.lo x86_64/regname.lo
-@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_37 = x86_64/Gos-linux.lo
-@OS_FREEBSD_TRUE@am__objects_37 = x86_64/Gos-freebsd.lo
-am__objects_38 = $(am__objects_36) $(am__objects_37) $(am__objects_7) \
+	mi/Gset_cache_size.c x86_64/Gapply_reg_state.c \
+	x86_64/Greg_states_iterate.c x86_64/Gcreate_addr_space.c \
+	x86_64/Gget_save_loc.c x86_64/Gglobal.c x86_64/Ginit.c \
+	x86_64/Ginit_local.c x86_64/Ginit_remote.c \
+	x86_64/Gget_proc_info.c x86_64/Gregs.c x86_64/Gresume.c \
+	x86_64/Gstash_frame.c x86_64/Gstep.c x86_64/Gtrace.c
+am__objects_46 = $(am__objects_6) x86_64/is_fpreg.lo x86_64/regname.lo
+@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_47 = x86_64/Gos-linux.lo
+@OS_FREEBSD_TRUE@am__objects_47 = x86_64/Gos-freebsd.lo
+am__objects_48 = $(am__objects_46) $(am__objects_47) $(am__objects_8) \
+	x86_64/Gapply_reg_state.lo x86_64/Greg_states_iterate.lo \
 	x86_64/Gcreate_addr_space.lo x86_64/Gget_save_loc.lo \
 	x86_64/Gglobal.lo x86_64/Ginit.lo x86_64/Ginit_local.lo \
 	x86_64/Ginit_remote.lo x86_64/Gget_proc_info.lo \
 	x86_64/Gregs.lo x86_64/Gresume.lo x86_64/Gstash_frame.lo \
 	x86_64/Gstep.lo x86_64/Gtrace.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am_libunwind_x86_64_la_OBJECTS = $(am__objects_38)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am_libunwind_x86_64_la_OBJECTS = $(am__objects_48)
 libunwind_x86_64_la_OBJECTS = $(am_libunwind_x86_64_la_OBJECTS)
-libunwind_x86_64_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(libunwind_x86_64_la_LDFLAGS) $(LDFLAGS) -o $@
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am_libunwind_x86_64_la_rpath = -rpath \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	$(libdir)
-am__DEPENDENCIES_10 =
-libunwind_la_DEPENDENCIES = $(am__append_7) $(LIBUNWIND_ELF) \
-	$(am__DEPENDENCIES_10) $(am__DEPENDENCIES_10)
+libunwind_x86_64_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libunwind_x86_64_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am_libunwind_x86_64_la_rpath = -rpath \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	$(libdir)
+libunwind_la_DEPENDENCIES = $(am__append_10) $(LIBUNWIND_ELF) \
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
 am__libunwind_la_SOURCES_DIST = os-freebsd.c os-hpux.c os-linux.c \
-	mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
-	sh/is_fpreg.c sh/regname.c mi/_ReadULEB.c mi/_ReadSLEB.c \
+	os-qnx.c mi/init.c mi/flush_cache.c mi/mempool.c mi/strerror.c \
+	s390x/is_fpreg.c s390x/regname.c mi/_ReadULEB.c mi/_ReadSLEB.c \
 	mi/backtrace.c mi/dyn-cancel.c mi/dyn-info-list.c \
 	mi/dyn-register.c mi/Ldyn-extract.c \
 	mi/Lfind_dynamic_proc_info.c mi/Lget_accessors.c \
 	mi/Lget_proc_info_by_ip.c mi/Lget_proc_name.c \
 	mi/Lput_dynamic_unwind_info.c mi/Ldestroy_addr_space.c \
 	mi/Lget_reg.c mi/Lset_reg.c mi/Lget_fpreg.c mi/Lset_fpreg.c \
-	mi/Lset_caching_policy.c unwind/Backtrace.c \
-	unwind/DeleteException.c unwind/FindEnclosingFunction.c \
-	unwind/ForcedUnwind.c unwind/GetBSP.c unwind/GetCFA.c \
-	unwind/GetDataRelBase.c unwind/GetGR.c unwind/GetIP.c \
-	unwind/GetLanguageSpecificData.c unwind/GetRegionStart.c \
-	unwind/GetTextRelBase.c unwind/RaiseException.c \
-	unwind/Resume.c unwind/Resume_or_Rethrow.c unwind/SetGR.c \
-	unwind/SetIP.c unwind/GetIPInfo.c sh/Lcreate_addr_space.c \
-	sh/Lget_proc_info.c sh/Lget_save_loc.c sh/Lglobal.c sh/Linit.c \
-	sh/Linit_local.c sh/Linit_remote.c sh/Lis_signal_frame.c \
-	sh/Lregs.c sh/Lresume.c sh/Lstep.c ppc64/is_fpreg.c \
-	ppc64/regname.c ppc64/get_func_addr.c ppc/Lcreate_addr_space.c \
+	mi/Lset_caching_policy.c mi/Lset_cache_size.c \
+	unwind/Backtrace.c unwind/DeleteException.c \
+	unwind/FindEnclosingFunction.c unwind/ForcedUnwind.c \
+	unwind/GetBSP.c unwind/GetCFA.c unwind/GetDataRelBase.c \
+	unwind/GetGR.c unwind/GetIP.c unwind/GetLanguageSpecificData.c \
+	unwind/GetRegionStart.c unwind/GetTextRelBase.c \
+	unwind/RaiseException.c unwind/Resume.c \
+	unwind/Resume_or_Rethrow.c unwind/SetGR.c unwind/SetIP.c \
+	unwind/GetIPInfo.c s390x/Lapply_reg_state.c \
+	s390x/Lreg_states_iterate.c s390x/Lcreate_addr_space.c \
+	s390x/Lget_save_loc.c s390x/Lglobal.c s390x/Linit.c \
+	s390x/Linit_local.c s390x/Linit_remote.c \
+	s390x/Lget_proc_info.c s390x/Lregs.c s390x/Lresume.c \
+	s390x/Lis_signal_frame.c s390x/Lstep.c s390x/getcontext.S \
+	s390x/setcontext.S sh/is_fpreg.c sh/regname.c \
+	sh/Lapply_reg_state.c sh/Lreg_states_iterate.c \
+	sh/Lcreate_addr_space.c sh/Lget_proc_info.c sh/Lget_save_loc.c \
+	sh/Lglobal.c sh/Linit.c sh/Linit_local.c sh/Linit_remote.c \
+	sh/Lis_signal_frame.c sh/Lregs.c sh/Lresume.c sh/Lstep.c \
+	ppc64/is_fpreg.c ppc64/regname.c ppc64/get_func_addr.c \
 	ppc/Lget_proc_info.c ppc/Lget_save_loc.c ppc/Linit_local.c \
-	ppc/Linit_remote.c ppc/Lis_signal_frame.c ppc64/Lglobal.c \
-	ppc64/Linit.c ppc64/Lregs.c ppc64/Lresume.c ppc64/Lstep.c \
-	ppc32/is_fpreg.c ppc32/regname.c ppc32/get_func_addr.c \
+	ppc/Linit_remote.c ppc/Lis_signal_frame.c \
+	ppc64/Lapply_reg_state.c ppc64/Lreg_states_iterate.c \
+	ppc64/Lcreate_addr_space.c ppc64/Lglobal.c ppc64/Linit.c \
+	ppc64/Lregs.c ppc64/Lresume.c ppc64/Lstep.c ppc32/is_fpreg.c \
+	ppc32/regname.c ppc32/get_func_addr.c ppc32/Lapply_reg_state.c \
+	ppc32/Lreg_states_iterate.c ppc32/Lcreate_addr_space.c \
 	ppc32/Lglobal.c ppc32/Linit.c ppc32/Lregs.c ppc32/Lresume.c \
 	ppc32/Lstep.c x86_64/is_fpreg.c x86_64/regname.c \
 	x86_64/Los-freebsd.c x86_64/Los-linux.c x86_64/setcontext.S \
+	x86_64/Lapply_reg_state.c x86_64/Lreg_states_iterate.c \
 	x86_64/Lcreate_addr_space.c x86_64/Lget_save_loc.c \
 	x86_64/Lglobal.c x86_64/Linit.c x86_64/Linit_local.c \
 	x86_64/Linit_remote.c x86_64/Lget_proc_info.c x86_64/Lregs.c \
 	x86_64/Lresume.c x86_64/Lstash_frame.c x86_64/Lstep.c \
 	x86_64/Ltrace.c x86_64/getcontext.S x86/is_fpreg.c \
 	x86/regname.c x86/Los-freebsd.c x86/Los-linux.c \
+	x86/Lapply_reg_state.c x86/Lreg_states_iterate.c \
 	x86/Lcreate_addr_space.c x86/Lget_save_loc.c x86/Lglobal.c \
 	x86/Linit.c x86/Linit_local.c x86/Linit_remote.c \
 	x86/Lget_proc_info.c x86/Lregs.c x86/Lresume.c x86/Lstep.c \
 	x86/getcontext-freebsd.S x86/getcontext-linux.S \
-	mips/is_fpreg.c mips/regname.c mips/getcontext.S \
-	mips/Lcreate_addr_space.c mips/Lget_proc_info.c \
-	mips/Lget_save_loc.c mips/Lglobal.c mips/Linit.c \
-	mips/Linit_local.c mips/Linit_remote.c mips/Lis_signal_frame.c \
-	mips/Lregs.c mips/Lresume.c mips/Lstep.c hppa/regname.c \
-	hppa/getcontext.S hppa/setcontext.S hppa/Lcreate_addr_space.c \
+	tilegx/is_fpreg.c tilegx/regname.c tilegx/getcontext.S \
+	tilegx/Lapply_reg_state.c tilegx/Lreg_states_iterate.c \
+	tilegx/Lcreate_addr_space.c tilegx/Lget_proc_info.c \
+	tilegx/Lget_save_loc.c tilegx/Lglobal.c tilegx/Linit.c \
+	tilegx/Linit_local.c tilegx/Linit_remote.c \
+	tilegx/Lis_signal_frame.c tilegx/Lregs.c tilegx/Lresume.c \
+	tilegx/Lstep.c mips/is_fpreg.c mips/regname.c \
+	mips/getcontext.S mips/Lapply_reg_state.c \
+	mips/Lreg_states_iterate.c mips/Lcreate_addr_space.c \
+	mips/Lget_proc_info.c mips/Lget_save_loc.c mips/Lglobal.c \
+	mips/Linit.c mips/Linit_local.c mips/Linit_remote.c \
+	mips/Lis_signal_frame.c mips/Lregs.c mips/Lresume.c \
+	mips/Lstep.c hppa/regname.c hppa/getcontext.S \
+	hppa/setcontext.S hppa/Lapply_reg_state.c \
+	hppa/Lreg_states_iterate.c hppa/Lcreate_addr_space.c \
 	hppa/Lget_save_loc.c hppa/Lglobal.c hppa/Linit.c \
 	hppa/Linit_local.c hppa/Linit_remote.c hppa/Lis_signal_frame.c \
 	hppa/Lget_proc_info.c hppa/Lregs.c hppa/Lresume.c hppa/Lstep.c \
 	ia64/regname.c ia64/dyn_info_list.S ia64/getcontext.S \
+	ia64/Lapply_reg_state.c ia64/Lreg_states_iterate.c \
 	ia64/Lcreate_addr_space.c ia64/Lget_proc_info.c \
 	ia64/Lget_save_loc.c ia64/Lglobal.c ia64/Linit.c \
 	ia64/Linit_local.c ia64/Linit_remote.c ia64/Linstall_cursor.S \
 	ia64/Lis_signal_frame.c ia64/Lparser.c ia64/Lrbs.c \
 	ia64/Lregs.c ia64/Lresume.c ia64/Lscript.c ia64/Lstep.c \
 	ia64/Ltables.c ia64/Lfind_unwind_table.c arm/is_fpreg.c \
-	arm/regname.c arm/getcontext.S arm/Lcreate_addr_space.c \
+	arm/regname.c arm/Los-freebsd.c arm/Los-linux.c \
+	arm/Los-other.c arm/getcontext.S arm/Lapply_reg_state.c \
+	arm/Lreg_states_iterate.c arm/Lcreate_addr_space.c \
 	arm/Lget_proc_info.c arm/Lget_save_loc.c arm/Lglobal.c \
-	arm/Linit.c arm/Linit_local.c arm/Linit_remote.c \
-	arm/Lis_signal_frame.c arm/Lregs.c arm/Lresume.c arm/Lstep.c \
-	arm/Lex_tables.c
-@SUPPORT_CXX_EXCEPTIONS_TRUE@am__objects_39 = mi/_ReadULEB.lo \
+	arm/Linit.c arm/Linit_local.c arm/Linit_remote.c arm/Lregs.c \
+	arm/Lresume.c arm/Lstep.c arm/Lex_tables.c arm/Lstash_frame.c \
+	arm/Ltrace.c aarch64/is_fpreg.c aarch64/regname.c \
+	aarch64/Lapply_reg_state.c aarch64/Lreg_states_iterate.c \
+	aarch64/Lcreate_addr_space.c aarch64/Lget_proc_info.c \
+	aarch64/Lget_save_loc.c aarch64/Lglobal.c aarch64/Linit.c \
+	aarch64/Linit_local.c aarch64/Linit_remote.c \
+	aarch64/Lis_signal_frame.c aarch64/Lregs.c aarch64/Lresume.c \
+	aarch64/Lstash_frame.c aarch64/Lstep.c aarch64/Ltrace.c \
+	aarch64/getcontext.S
+@SUPPORT_CXX_EXCEPTIONS_TRUE@am__objects_49 = mi/_ReadULEB.lo \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	mi/_ReadSLEB.lo
-@OS_LINUX_TRUE@am__objects_40 = $(am__objects_39)
-am__objects_41 = $(am__objects_40) mi/backtrace.lo mi/dyn-cancel.lo \
+@OS_LINUX_TRUE@am__objects_50 = $(am__objects_49)
+am__objects_51 = $(am__objects_50) mi/backtrace.lo mi/dyn-cancel.lo \
 	mi/dyn-info-list.lo mi/dyn-register.lo mi/Ldyn-extract.lo \
 	mi/Lfind_dynamic_proc_info.lo mi/Lget_accessors.lo \
 	mi/Lget_proc_info_by_ip.lo mi/Lget_proc_name.lo \
 	mi/Lput_dynamic_unwind_info.lo mi/Ldestroy_addr_space.lo \
 	mi/Lget_reg.lo mi/Lset_reg.lo mi/Lget_fpreg.lo \
-	mi/Lset_fpreg.lo mi/Lset_caching_policy.lo
-@SUPPORT_CXX_EXCEPTIONS_TRUE@am__objects_42 = unwind/Backtrace.lo \
+	mi/Lset_fpreg.lo mi/Lset_caching_policy.lo \
+	mi/Lset_cache_size.lo
+@SUPPORT_CXX_EXCEPTIONS_TRUE@am__objects_52 = unwind/Backtrace.lo \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	unwind/DeleteException.lo \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	unwind/FindEnclosingFunction.lo \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	unwind/ForcedUnwind.lo \
@@ -603,54 +844,74 @@ am__objects_41 = $(am__objects_40) mi/backtrace.lo mi/dyn-cancel.lo \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	unwind/Resume_or_Rethrow.lo \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	unwind/SetGR.lo unwind/SetIP.lo \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	unwind/GetIPInfo.lo
-am__objects_43 = $(am__objects_41) $(am__objects_42)
-am__objects_44 = $(am__objects_31) $(am__objects_43) \
+am__objects_53 = $(am__objects_51) $(am__objects_52)
+am__objects_54 = $(am__objects_26) $(am__objects_53) \
+	s390x/Lapply_reg_state.lo s390x/Lreg_states_iterate.lo \
+	s390x/Lcreate_addr_space.lo s390x/Lget_save_loc.lo \
+	s390x/Lglobal.lo s390x/Linit.lo s390x/Linit_local.lo \
+	s390x/Linit_remote.lo s390x/Lget_proc_info.lo s390x/Lregs.lo \
+	s390x/Lresume.lo s390x/Lis_signal_frame.lo s390x/Lstep.lo \
+	s390x/getcontext.lo s390x/setcontext.lo
+am__objects_55 = $(am__objects_39) $(am__objects_53) \
+	sh/Lapply_reg_state.lo sh/Lreg_states_iterate.lo \
 	sh/Lcreate_addr_space.lo sh/Lget_proc_info.lo \
 	sh/Lget_save_loc.lo sh/Lglobal.lo sh/Linit.lo \
 	sh/Linit_local.lo sh/Linit_remote.lo sh/Lis_signal_frame.lo \
 	sh/Lregs.lo sh/Lresume.lo sh/Lstep.lo
-am__objects_45 = ppc/Lcreate_addr_space.lo ppc/Lget_proc_info.lo \
-	ppc/Lget_save_loc.lo ppc/Linit_local.lo ppc/Linit_remote.lo \
-	ppc/Lis_signal_frame.lo
-am__objects_46 = $(am__objects_20) $(am__objects_43) $(am__objects_45) \
-	ppc64/Lglobal.lo ppc64/Linit.lo ppc64/Lregs.lo \
-	ppc64/Lresume.lo ppc64/Lstep.lo
-am__objects_47 = $(am__objects_17) $(am__objects_43) $(am__objects_45) \
-	ppc32/Lglobal.lo ppc32/Linit.lo ppc32/Lregs.lo \
-	ppc32/Lresume.lo ppc32/Lstep.lo
-@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_48 = x86_64/Los-linux.lo
-@OS_FREEBSD_TRUE@am__objects_48 = x86_64/Los-freebsd.lo
-am__objects_49 = $(am__objects_36) $(am__objects_48) $(am__objects_43) \
-	x86_64/setcontext.lo x86_64/Lcreate_addr_space.lo \
+am__objects_56 = ppc/Lget_proc_info.lo ppc/Lget_save_loc.lo \
+	ppc/Linit_local.lo ppc/Linit_remote.lo ppc/Lis_signal_frame.lo
+am__objects_57 = $(am__objects_24) $(am__objects_53) $(am__objects_56) \
+	ppc64/Lapply_reg_state.lo ppc64/Lreg_states_iterate.lo \
+	ppc64/Lcreate_addr_space.lo ppc64/Lglobal.lo ppc64/Linit.lo \
+	ppc64/Lregs.lo ppc64/Lresume.lo ppc64/Lstep.lo
+am__objects_58 = $(am__objects_21) $(am__objects_53) $(am__objects_56) \
+	ppc32/Lapply_reg_state.lo ppc32/Lreg_states_iterate.lo \
+	ppc32/Lcreate_addr_space.lo ppc32/Lglobal.lo ppc32/Linit.lo \
+	ppc32/Lregs.lo ppc32/Lresume.lo ppc32/Lstep.lo
+@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_59 = x86_64/Los-linux.lo
+@OS_FREEBSD_TRUE@am__objects_59 = x86_64/Los-freebsd.lo
+am__objects_60 = $(am__objects_46) $(am__objects_59) $(am__objects_53) \
+	x86_64/setcontext.lo x86_64/Lapply_reg_state.lo \
+	x86_64/Lreg_states_iterate.lo x86_64/Lcreate_addr_space.lo \
 	x86_64/Lget_save_loc.lo x86_64/Lglobal.lo x86_64/Linit.lo \
 	x86_64/Linit_local.lo x86_64/Linit_remote.lo \
 	x86_64/Lget_proc_info.lo x86_64/Lregs.lo x86_64/Lresume.lo \
 	x86_64/Lstash_frame.lo x86_64/Lstep.lo x86_64/Ltrace.lo \
 	x86_64/getcontext.lo
-@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_50 = x86/Los-linux.lo
-@OS_FREEBSD_TRUE@am__objects_50 = x86/Los-freebsd.lo
-am__objects_51 = $(am__objects_33) $(am__objects_50) $(am__objects_43) \
+@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_61 = x86/Los-linux.lo
+@OS_FREEBSD_TRUE@am__objects_61 = x86/Los-freebsd.lo
+am__objects_62 = $(am__objects_43) $(am__objects_61) $(am__objects_53) \
+	x86/Lapply_reg_state.lo x86/Lreg_states_iterate.lo \
 	x86/Lcreate_addr_space.lo x86/Lget_save_loc.lo x86/Lglobal.lo \
 	x86/Linit.lo x86/Linit_local.lo x86/Linit_remote.lo \
 	x86/Lget_proc_info.lo x86/Lregs.lo x86/Lresume.lo x86/Lstep.lo
-@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_52 =  \
+@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_63 =  \
 @OS_FREEBSD_FALSE@@OS_LINUX_TRUE@	x86/getcontext-linux.lo
-@OS_FREEBSD_TRUE@am__objects_52 = x86/getcontext-freebsd.lo
-am__objects_53 = $(am__objects_15) $(am__objects_43) \
-	mips/getcontext.lo mips/Lcreate_addr_space.lo \
+@OS_FREEBSD_TRUE@am__objects_63 = x86/getcontext-freebsd.lo
+am__objects_64 = $(am__objects_41) $(am__objects_53) \
+	tilegx/getcontext.lo tilegx/Lapply_reg_state.lo \
+	tilegx/Lreg_states_iterate.lo tilegx/Lcreate_addr_space.lo \
+	tilegx/Lget_proc_info.lo tilegx/Lget_save_loc.lo \
+	tilegx/Lglobal.lo tilegx/Linit.lo tilegx/Linit_local.lo \
+	tilegx/Linit_remote.lo tilegx/Lis_signal_frame.lo \
+	tilegx/Lregs.lo tilegx/Lresume.lo tilegx/Lstep.lo
+am__objects_65 = $(am__objects_19) $(am__objects_53) \
+	mips/getcontext.lo mips/Lapply_reg_state.lo \
+	mips/Lreg_states_iterate.lo mips/Lcreate_addr_space.lo \
 	mips/Lget_proc_info.lo mips/Lget_save_loc.lo mips/Lglobal.lo \
 	mips/Linit.lo mips/Linit_local.lo mips/Linit_remote.lo \
 	mips/Lis_signal_frame.lo mips/Lregs.lo mips/Lresume.lo \
 	mips/Lstep.lo
-am__objects_54 = $(am__objects_11) $(am__objects_43) \
-	hppa/getcontext.lo hppa/setcontext.lo \
-	hppa/Lcreate_addr_space.lo hppa/Lget_save_loc.lo \
-	hppa/Lglobal.lo hppa/Linit.lo hppa/Linit_local.lo \
-	hppa/Linit_remote.lo hppa/Lis_signal_frame.lo \
-	hppa/Lget_proc_info.lo hppa/Lregs.lo hppa/Lresume.lo \
-	hppa/Lstep.lo
-am__objects_55 = $(am__objects_13) $(am__objects_43) \
+am__objects_66 = $(am__objects_15) $(am__objects_53) \
+	hppa/getcontext.lo hppa/setcontext.lo hppa/Lapply_reg_state.lo \
+	hppa/Lreg_states_iterate.lo hppa/Lcreate_addr_space.lo \
+	hppa/Lget_save_loc.lo hppa/Lglobal.lo hppa/Linit.lo \
+	hppa/Linit_local.lo hppa/Linit_remote.lo \
+	hppa/Lis_signal_frame.lo hppa/Lget_proc_info.lo hppa/Lregs.lo \
+	hppa/Lresume.lo hppa/Lstep.lo
+am__objects_67 = $(am__objects_17) $(am__objects_53) \
 	ia64/dyn_info_list.lo ia64/getcontext.lo \
+	ia64/Lapply_reg_state.lo ia64/Lreg_states_iterate.lo \
 	ia64/Lcreate_addr_space.lo ia64/Lget_proc_info.lo \
 	ia64/Lget_save_loc.lo ia64/Lglobal.lo ia64/Linit.lo \
 	ia64/Linit_local.lo ia64/Linit_remote.lo \
@@ -658,46 +919,89 @@ am__objects_55 = $(am__objects_13) $(am__objects_43) \
 	ia64/Lparser.lo ia64/Lrbs.lo ia64/Lregs.lo ia64/Lresume.lo \
 	ia64/Lscript.lo ia64/Lstep.lo ia64/Ltables.lo \
 	ia64/Lfind_unwind_table.lo
-am__objects_56 = $(am__objects_6) $(am__objects_43) arm/getcontext.lo \
-	arm/Lcreate_addr_space.lo arm/Lget_proc_info.lo \
-	arm/Lget_save_loc.lo arm/Lglobal.lo arm/Linit.lo \
-	arm/Linit_local.lo arm/Linit_remote.lo arm/Lis_signal_frame.lo \
-	arm/Lregs.lo arm/Lresume.lo arm/Lstep.lo arm/Lex_tables.lo
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_44)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_46)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_47)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_49)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@am_libunwind_la_OBJECTS = $(am__objects_51) \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@	$(am__objects_52)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am_libunwind_la_OBJECTS = $(am__objects_53)
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am_libunwind_la_OBJECTS = $(am__objects_54)
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am_libunwind_la_OBJECTS =  \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(am__objects_55)
-@ARCH_ARM_TRUE@am_libunwind_la_OBJECTS = $(am__objects_56)
+@OS_FREEBSD_FALSE@@OS_LINUX_FALSE@@OS_QNX_TRUE@am__objects_68 = arm/Los-other.lo
+@OS_FREEBSD_FALSE@@OS_LINUX_TRUE@am__objects_68 = arm/Los-linux.lo
+@OS_FREEBSD_TRUE@am__objects_68 = arm/Los-freebsd.lo
+am__objects_69 = $(am__objects_10) $(am__objects_68) $(am__objects_53) \
+	arm/getcontext.lo arm/Lapply_reg_state.lo \
+	arm/Lreg_states_iterate.lo arm/Lcreate_addr_space.lo \
+	arm/Lget_proc_info.lo arm/Lget_save_loc.lo arm/Lglobal.lo \
+	arm/Linit.lo arm/Linit_local.lo arm/Linit_remote.lo \
+	arm/Lregs.lo arm/Lresume.lo arm/Lstep.lo arm/Lex_tables.lo \
+	arm/Lstash_frame.lo arm/Ltrace.lo
+am__objects_70 = $(am__objects_7) $(am__objects_53) \
+	aarch64/Lapply_reg_state.lo aarch64/Lreg_states_iterate.lo \
+	aarch64/Lcreate_addr_space.lo aarch64/Lget_proc_info.lo \
+	aarch64/Lget_save_loc.lo aarch64/Lglobal.lo aarch64/Linit.lo \
+	aarch64/Linit_local.lo aarch64/Linit_remote.lo \
+	aarch64/Lis_signal_frame.lo aarch64/Lregs.lo \
+	aarch64/Lresume.lo aarch64/Lstash_frame.lo aarch64/Lstep.lo \
+	aarch64/Ltrace.lo aarch64/getcontext.lo
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_54)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_55)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_57)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_58)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@am_libunwind_la_OBJECTS = $(am__objects_60)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@am_libunwind_la_OBJECTS = $(am__objects_62) \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@	$(am__objects_63)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@am_libunwind_la_OBJECTS = $(am__objects_64)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@am_libunwind_la_OBJECTS = $(am__objects_65)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@am_libunwind_la_OBJECTS = $(am__objects_66)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@am_libunwind_la_OBJECTS = $(am__objects_67)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@am_libunwind_la_OBJECTS =  \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	$(am__objects_69)
+@ARCH_AARCH64_TRUE@am_libunwind_la_OBJECTS = $(am__objects_70)
 libunwind_la_OBJECTS = $(am_libunwind_la_OBJECTS)
-libunwind_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+libunwind_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(libunwind_la_LDFLAGS) $(LDFLAGS) -o $@
 @REMOTE_ONLY_FALSE@am_libunwind_la_rpath = -rpath $(libdir)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/include
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
 CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)
-LTCPPASCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)
+LTCPPASCOMPILE = $(LIBTOOL) $(AM_V_lt) $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CCASFLAGS) $(CCASFLAGS)
+AM_V_CPPAS = $(am__v_CPPAS_@AM_V@)
+am__v_CPPAS_ = $(am__v_CPPAS_@AM_DEFAULT_V@)
+am__v_CPPAS_0 = @echo "  CPPAS   " $@;
+am__v_CPPAS_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
-	$(LDFLAGS) -o $@
-SOURCES = $(libunwind_arm_la_SOURCES) $(libunwind_coredump_la_SOURCES) \
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libunwind_aarch64_la_SOURCES) $(libunwind_arm_la_SOURCES) \
+	$(libunwind_coredump_la_SOURCES) \
 	$(libunwind_dwarf_common_la_SOURCES) \
 	$(libunwind_dwarf_generic_la_SOURCES) \
 	$(libunwind_dwarf_local_la_SOURCES) \
@@ -705,10 +1009,12 @@ SOURCES = $(libunwind_arm_la_SOURCES) $(libunwind_coredump_la_SOURCES) \
 	$(libunwind_elfxx_la_SOURCES) $(libunwind_hppa_la_SOURCES) \
 	$(libunwind_ia64_la_SOURCES) $(libunwind_mips_la_SOURCES) \
 	$(libunwind_ppc32_la_SOURCES) $(libunwind_ppc64_la_SOURCES) \
-	$(libunwind_ptrace_la_SOURCES) $(libunwind_setjmp_la_SOURCES) \
-	$(libunwind_sh_la_SOURCES) $(libunwind_x86_la_SOURCES) \
+	$(libunwind_ptrace_la_SOURCES) $(libunwind_s390x_la_SOURCES) \
+	$(libunwind_setjmp_la_SOURCES) $(libunwind_sh_la_SOURCES) \
+	$(libunwind_tilegx_la_SOURCES) $(libunwind_x86_la_SOURCES) \
 	$(libunwind_x86_64_la_SOURCES) $(libunwind_la_SOURCES)
-DIST_SOURCES = $(am__libunwind_arm_la_SOURCES_DIST) \
+DIST_SOURCES = $(am__libunwind_aarch64_la_SOURCES_DIST) \
+	$(am__libunwind_arm_la_SOURCES_DIST) \
 	$(am__libunwind_coredump_la_SOURCES_DIST) \
 	$(libunwind_dwarf_common_la_SOURCES) \
 	$(libunwind_dwarf_generic_la_SOURCES) \
@@ -721,24 +1027,50 @@ DIST_SOURCES = $(am__libunwind_arm_la_SOURCES_DIST) \
 	$(am__libunwind_ppc32_la_SOURCES_DIST) \
 	$(am__libunwind_ppc64_la_SOURCES_DIST) \
 	$(libunwind_ptrace_la_SOURCES) \
+	$(am__libunwind_s390x_la_SOURCES_DIST) \
 	$(am__libunwind_setjmp_la_SOURCES_DIST) \
 	$(am__libunwind_sh_la_SOURCES_DIST) \
+	$(am__libunwind_tilegx_la_SOURCES_DIST) \
 	$(am__libunwind_x86_la_SOURCES_DIST) \
 	$(am__libunwind_x86_64_la_SOURCES_DIST) \
 	$(am__libunwind_la_SOURCES_DIST)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 DATA = $(pkgconfig_DATA)
 HEADERS = $(noinst_HEADERS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AR = @AR@
 ARCH = @ARCH@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BACKTRACELIB = @BACKTRACELIB@
 CC = @CC@
 CCAS = @CCAS@
 CCASDEPMODE = @CCASDEPMODE@
@@ -770,8 +1102,10 @@ INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LATEX2MAN = @LATEX2MAN@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
+LDFLAGS_NOSTARTFILES = @LDFLAGS_NOSTARTFILES@
 LDFLAGS_STATIC_LIBCXA = @LDFLAGS_STATIC_LIBCXA@
 LIBCRTS = @LIBCRTS@
 LIBLZMA = @LIBLZMA@
@@ -876,12 +1210,16 @@ COREDUMP_SO_VERSION = 0:0:0
 #
 # Don't link with start-files since we don't use any constructors/destructors:
 #
-COMMON_SO_LDFLAGS = -XCClinker -nostartfiles
+COMMON_SO_LDFLAGS = $(LDFLAGS_NOSTARTFILES)
 lib_LIBRARIES = 
-lib_LTLIBRARIES = $(am__append_1) $(am__append_2) $(am__append_10) \
+lib_LTLIBRARIES = $(am__append_1) $(am__append_2) $(am__append_3) \
 	$(am__append_13) $(am__append_16) $(am__append_19) \
 	$(am__append_22) $(am__append_25) $(am__append_28) \
-	$(am__append_31) $(am__append_34) $(am__append_37)
+	$(am__append_31) $(am__append_34) $(am__append_37) \
+	$(am__append_40) $(am__append_43) $(am__append_46) \
+	$(am__append_48)
+
+# The list of files that go into libunwind and libunwind-aarch64:
 
 # The list of files that go into libunwind and libunwind-arm:
 
@@ -891,6 +1229,8 @@ lib_LTLIBRARIES = $(am__append_1) $(am__append_2) $(am__append_10) \
 
 # The list of files that go info libunwind and libunwind-mips:
 
+# The list of files that go info libunwind and libunwind-tilegx:
+
 # The list of files that go both into libunwind and libunwind-x86:
 
 # The list of files that go both into libunwind and libunwind-x86_64:
@@ -900,20 +1240,26 @@ lib_LTLIBRARIES = $(am__append_1) $(am__append_2) $(am__append_10) \
 # The list of files that go both into libunwind and libunwind-ppc64:
 
 # The list of files that go into libunwind and libunwind-sh:
+
+# The list of files that go both into libunwind and libunwind-s390x:
 noinst_HEADERS = ptrace/_UPT_internal.h coredump/_UCD_internal.h \
-	setjmp/setjmp_i.h os-linux.h elf32.h elf64.h elfxx.h \
-	arm/init.h arm/offsets.h arm/unwind_i.h ia64/init.h \
-	ia64/offsets.h ia64/regs.h ia64/ucontext_i.h \
+	coredump/_UCD_lib.h setjmp/setjmp_i.h os-linux.h elf32.h \
+	elf64.h elfxx.h aarch64/init.h aarch64/offsets.h \
+	aarch64/unwind_i.h arm/init.h arm/offsets.h arm/unwind_i.h \
+	ia64/init.h ia64/offsets.h ia64/regs.h ia64/ucontext_i.h \
 	ia64/unwind_decoder.h ia64/unwind_i.h hppa/init.h \
 	hppa/offsets.h hppa/unwind_i.h mips/init.h mips/offsets.h \
-	x86/init.h x86/offsets.h x86/unwind_i.h x86_64/offsets.h \
-	x86_64/init.h x86_64/unwind_i.h x86_64/ucontext_i.h \
-	ppc32/init.h ppc32/unwind_i.h ppc32/ucontext_i.h ppc64/init.h \
-	ppc64/unwind_i.h ppc64/ucontext_i.h sh/init.h sh/offsets.h \
-	sh/unwind_i.h unwind/unwind-internal.h
-noinst_LTLIBRARIES = $(am__append_5) $(am__append_6) $(LIBUNWIND_ELF)
+	mips/unwind_i.h tilegx/init.h tilegx/offsets.h \
+	tilegx/unwind_i.h x86/init.h x86/offsets.h x86/unwind_i.h \
+	x86_64/offsets.h x86_64/init.h x86_64/unwind_i.h \
+	x86_64/ucontext_i.h ppc32/init.h ppc32/unwind_i.h \
+	ppc32/ucontext_i.h ppc64/init.h ppc64/unwind_i.h \
+	ppc64/ucontext_i.h sh/init.h sh/offsets.h sh/unwind_i.h \
+	s390x/init.h s390x/unwind_i.h unwind/unwind-internal.h
+noinst_LTLIBRARIES = $(am__append_8) $(am__append_9) $(LIBUNWIND_ELF)
 pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = libunwind-generic.pc $(am__append_3) $(am__append_4)
+pkgconfig_DATA = libunwind-generic.pc $(am__append_4) $(am__append_5) \
+	$(am__append_6) $(am__append_7)
 
 ### libunwind-ptrace:
 libunwind_ptrace_la_SOURCES = \
@@ -934,10 +1280,11 @@ libunwind_coredump_la_SOURCES = coredump/_UCD_accessors.c \
 	coredump/_UPT_elf.c coredump/_UPT_access_fpreg.c \
 	coredump/_UPT_get_dyn_info_list_addr.c \
 	coredump/_UPT_put_unwind_info.c coredump/_UPT_resume.c \
-	$(am__append_8) $(am__append_9)
+	$(am__append_11) $(am__append_12)
 libunwind_coredump_la_LDFLAGS = $(COMMON_SO_LDFLAGS) \
 				-version-info $(COREDUMP_SO_VERSION)
 
+libunwind_coredump_la_LIBADD = $(LIBLZMA)
 
 ### libunwind-setjmp:
 libunwind_setjmp_la_LDFLAGS = $(COMMON_SO_LDFLAGS)		     \
@@ -951,13 +1298,14 @@ libunwind_setjmp_la_LIBADD = $(LIBUNWIND_ELF)	\
 					  libunwind.la -lc
 
 libunwind_setjmp_la_SOURCES = setjmp/longjmp.c setjmp/siglongjmp.c \
-	$(am__append_12) $(am__append_15) $(am__append_18) \
-	$(am__append_21) $(am__append_24) $(am__append_27) \
-	$(am__append_30) $(am__append_33) $(am__append_36)
+	$(am__append_15) $(am__append_18) $(am__append_21) \
+	$(am__append_24) $(am__append_27) $(am__append_30) \
+	$(am__append_33) $(am__append_36) $(am__append_39) \
+	$(am__append_42) $(am__append_45)
 
 ### libunwind:
-libunwind_la_LIBADD = $(am__append_7) $(LIBUNWIND_ELF) -lc $(LIBCRTS) \
-	$(am__append_38)
+libunwind_la_LIBADD = $(am__append_10) $(LIBUNWIND_ELF) -lc $(LIBCRTS) \
+	$(LIBLZMA)
 
 # List of arch-independent files needed by both local-only and generic
 # libraries:
@@ -974,7 +1322,8 @@ libunwind_la_SOURCES_generic = \
 	mi/Gput_dynamic_unwind_info.c mi/Gdestroy_addr_space.c		\
 	mi/Gget_reg.c mi/Gset_reg.c					\
 	mi/Gget_fpreg.c mi/Gset_fpreg.c					\
-	mi/Gset_caching_policy.c
+	mi/Gset_caching_policy.c					\
+	mi/Gset_cache_size.c
 
 @SUPPORT_CXX_EXCEPTIONS_TRUE@libunwind_la_SOURCES_local_unwind = \
 @SUPPORT_CXX_EXCEPTIONS_TRUE@	unwind/Backtrace.c unwind/DeleteException.c			\
@@ -1001,7 +1350,8 @@ libunwind_la_SOURCES_local_nounwind = \
 	mi/Lput_dynamic_unwind_info.c mi/Ldestroy_addr_space.c		\
 	mi/Lget_reg.c   mi/Lset_reg.c					\
 	mi/Lget_fpreg.c mi/Lset_fpreg.c					\
-	mi/Lset_caching_policy.c
+	mi/Lset_caching_policy.c					\
+	mi/Lset_cache_size.c
 
 libunwind_la_SOURCES_local = \
 	$(libunwind_la_SOURCES_local_nounwind)				\
@@ -1010,15 +1360,16 @@ libunwind_la_SOURCES_local = \
 libunwind_la_SOURCES_os_linux = os-linux.c
 libunwind_la_SOURCES_os_hpux = os-hpux.c
 libunwind_la_SOURCES_os_freebsd = os-freebsd.c
+libunwind_la_SOURCES_os_qnx = os-qnx.c
 libunwind_dwarf_common_la_SOURCES = dwarf/global.c
 libunwind_dwarf_local_la_SOURCES = \
-	dwarf/Lexpr.c dwarf/Lfde.c dwarf/Lparser.c dwarf/Lpe.c dwarf/Lstep.c \
+	dwarf/Lexpr.c dwarf/Lfde.c dwarf/Lparser.c dwarf/Lpe.c \
 	dwarf/Lfind_proc_info-lsb.c \
 	dwarf/Lfind_unwind_table.c
 
 libunwind_dwarf_local_la_LIBADD = libunwind-dwarf-common.la
 libunwind_dwarf_generic_la_SOURCES = \
-	dwarf/Gexpr.c dwarf/Gfde.c dwarf/Gparser.c dwarf/Gpe.c dwarf/Gstep.c \
+	dwarf/Gexpr.c dwarf/Gfde.c dwarf/Gparser.c dwarf/Gpe.c \
 	dwarf/Gfind_proc_info-lsb.c \
 	dwarf/Gfind_unwind_table.c
 
@@ -1026,25 +1377,58 @@ libunwind_dwarf_generic_la_LIBADD = libunwind-dwarf-common.la
 libunwind_elf32_la_SOURCES = elf32.c
 libunwind_elf64_la_SOURCES = elf64.c
 libunwind_elfxx_la_SOURCES = elfxx.c
+libunwind_elf32_la_LIBADD = $(LIBLZMA)
+libunwind_elf64_la_LIBADD = $(LIBLZMA)
+libunwind_elfxx_la_LIBADD = $(LIBLZMA)
+libunwind_la_SOURCES_aarch64_common = $(libunwind_la_SOURCES_common)	    \
+	aarch64/is_fpreg.c aarch64/regname.c
+
+
+# The list of files that go into libunwind:
+libunwind_la_SOURCES_aarch64 = $(libunwind_la_SOURCES_aarch64_common)	    \
+	$(libunwind_la_SOURCES_local)					    \
+	aarch64/Lapply_reg_state.c aarch64/Lreg_states_iterate.c	    \
+	aarch64/Lcreate_addr_space.c aarch64/Lget_proc_info.c 		    \
+	aarch64/Lget_save_loc.c aarch64/Lglobal.c aarch64/Linit.c	    \
+	aarch64/Linit_local.c aarch64/Linit_remote.c 			    \
+	aarch64/Lis_signal_frame.c aarch64/Lregs.c aarch64/Lresume.c 	    \
+	aarch64/Lstash_frame.c aarch64/Lstep.c aarch64/Ltrace.c		    \
+	aarch64/getcontext.S
+
+libunwind_aarch64_la_SOURCES_aarch64 = $(libunwind_la_SOURCES_aarch64_common) \
+	$(libunwind_la_SOURCES_generic)					      \
+	aarch64/Gapply_reg_state.c aarch64/Greg_states_iterate.c	      \
+	aarch64/Gcreate_addr_space.c aarch64/Gget_proc_info.c 		      \
+	aarch64/Gget_save_loc.c aarch64/Gglobal.c aarch64/Ginit.c 	      \
+	aarch64/Ginit_local.c aarch64/Ginit_remote.c			      \
+	aarch64/Gis_signal_frame.c aarch64/Gregs.c aarch64/Gresume.c	      \
+	aarch64/Gstash_frame.c aarch64/Gstep.c aarch64/Gtrace.c
+
 libunwind_la_SOURCES_arm_common = $(libunwind_la_SOURCES_common)	    \
 	arm/is_fpreg.c arm/regname.c
 
 
 # The list of files that go into libunwind:
 libunwind_la_SOURCES_arm = $(libunwind_la_SOURCES_arm_common)		    \
+	$(libunwind_la_SOURCES_arm_os_local)				    \
 	$(libunwind_la_SOURCES_local)					    \
 	arm/getcontext.S						    \
+	arm/Lapply_reg_state.c arm/Lreg_states_iterate.c		    \
 	arm/Lcreate_addr_space.c arm/Lget_proc_info.c arm/Lget_save_loc.c   \
 	arm/Lglobal.c arm/Linit.c arm/Linit_local.c arm/Linit_remote.c	    \
-	arm/Lis_signal_frame.c arm/Lregs.c arm/Lresume.c arm/Lstep.c	    \
-	arm/Lex_tables.c
+	arm/Lregs.c arm/Lresume.c arm/Lstep.c				    \
+	arm/Lex_tables.c arm/Lstash_frame.c arm/Ltrace.c
+
 
+# The list of files that go into libunwind-arm:
 libunwind_arm_la_SOURCES_arm = $(libunwind_la_SOURCES_arm_common)	    \
+	$(libunwind_la_SOURCES_arm_os)					    \
 	$(libunwind_la_SOURCES_generic)					    \
+	arm/Gapply_reg_state.c arm/Greg_states_iterate.c		    \
 	arm/Gcreate_addr_space.c arm/Gget_proc_info.c arm/Gget_save_loc.c   \
 	arm/Gglobal.c arm/Ginit.c arm/Ginit_local.c arm/Ginit_remote.c	    \
-	arm/Gis_signal_frame.c arm/Gregs.c arm/Gresume.c arm/Gstep.c	    \
-	arm/Gex_tables.c
+	arm/Gregs.c arm/Gresume.c arm/Gstep.c				    \
+	arm/Gex_tables.c arm/Gstash_frame.c arm/Gtrace.c
 
 libunwind_la_SOURCES_ia64_common = $(libunwind_la_SOURCES_common)	    \
 	ia64/regname.c
@@ -1056,6 +1440,7 @@ libunwind_la_SOURCES_ia64 = $(libunwind_la_SOURCES_ia64_common)		     \
 									     \
 	ia64/dyn_info_list.S ia64/getcontext.S				     \
 									     \
+	ia64/Lapply_reg_state.c ia64/Lreg_states_iterate.c		     \
 	ia64/Lcreate_addr_space.c ia64/Lget_proc_info.c ia64/Lget_save_loc.c \
 	ia64/Lglobal.c ia64/Linit.c ia64/Linit_local.c ia64/Linit_remote.c   \
 	ia64/Linstall_cursor.S ia64/Lis_signal_frame.c ia64/Lparser.c	     \
@@ -1066,6 +1451,7 @@ libunwind_la_SOURCES_ia64 = $(libunwind_la_SOURCES_ia64_common)		     \
 # The list of files that go into libunwind-ia64:
 libunwind_ia64_la_SOURCES_ia64 = $(libunwind_la_SOURCES_ia64_common)	     \
 	$(libunwind_la_SOURCES_generic)					     \
+	ia64/Gapply_reg_state.c ia64/Greg_states_iterate.c		     \
 	ia64/Gcreate_addr_space.c ia64/Gget_proc_info.c ia64/Gget_save_loc.c \
 	ia64/Gglobal.c ia64/Ginit.c ia64/Ginit_local.c ia64/Ginit_remote.c   \
 	ia64/Ginstall_cursor.S ia64/Gis_signal_frame.c ia64/Gparser.c	     \
@@ -1080,6 +1466,7 @@ libunwind_la_SOURCES_hppa_common = $(libunwind_la_SOURCES_common)	\
 libunwind_la_SOURCES_hppa = $(libunwind_la_SOURCES_hppa_common)		\
 	$(libunwind_la_SOURCES_local)					\
 	hppa/getcontext.S hppa/setcontext.S				\
+	hppa/Lapply_reg_state.c hppa/Lreg_states_iterate.c		\
 	hppa/Lcreate_addr_space.c hppa/Lget_save_loc.c hppa/Lglobal.c	\
 	hppa/Linit.c hppa/Linit_local.c hppa/Linit_remote.c		\
 	hppa/Lis_signal_frame.c hppa/Lget_proc_info.c hppa/Lregs.c	\
@@ -1089,6 +1476,7 @@ libunwind_la_SOURCES_hppa = $(libunwind_la_SOURCES_hppa_common)		\
 # The list of files that go into libunwind-hppa:
 libunwind_hppa_la_SOURCES_hppa = $(libunwind_la_SOURCES_hppa_common)	\
 	$(libunwind_la_SOURCES_generic)					\
+	hppa/Gapply_reg_state.c hppa/Greg_states_iterate.c		\
 	hppa/Gcreate_addr_space.c hppa/Gget_save_loc.c hppa/Gglobal.c	\
 	hppa/Ginit.c hppa/Ginit_local.c hppa/Ginit_remote.c		\
 	hppa/Gis_signal_frame.c hppa/Gget_proc_info.c hppa/Gregs.c	\
@@ -1102,16 +1490,38 @@ libunwind_la_SOURCES_mips_common = $(libunwind_la_SOURCES_common)	    \
 libunwind_la_SOURCES_mips = $(libunwind_la_SOURCES_mips_common)		    \
 	$(libunwind_la_SOURCES_local)					    \
 	mips/getcontext.S						    \
+	mips/Lapply_reg_state.c mips/Lreg_states_iterate.c		    \
 	mips/Lcreate_addr_space.c mips/Lget_proc_info.c mips/Lget_save_loc.c   \
 	mips/Lglobal.c mips/Linit.c mips/Linit_local.c mips/Linit_remote.c  \
 	mips/Lis_signal_frame.c mips/Lregs.c mips/Lresume.c mips/Lstep.c
 
 libunwind_mips_la_SOURCES_mips = $(libunwind_la_SOURCES_mips_common)	    \
 	$(libunwind_la_SOURCES_generic)					    \
+	mips/Gapply_reg_state.c mips/Greg_states_iterate.c		    \
 	mips/Gcreate_addr_space.c mips/Gget_proc_info.c mips/Gget_save_loc.c   \
 	mips/Gglobal.c mips/Ginit.c mips/Ginit_local.c mips/Ginit_remote.c	    \
 	mips/Gis_signal_frame.c mips/Gregs.c mips/Gresume.c mips/Gstep.c
 
+libunwind_la_SOURCES_tilegx_common = $(libunwind_la_SOURCES_common)	    \
+	tilegx/is_fpreg.c tilegx/regname.c
+
+
+# The list of files that go into libunwind:
+libunwind_la_SOURCES_tilegx = $(libunwind_la_SOURCES_tilegx_common)		    \
+	$(libunwind_la_SOURCES_local)					    \
+	tilegx/getcontext.S						\
+	tilegx/Lapply_reg_state.c tilegx/Lreg_states_iterate.c		    \
+	tilegx/Lcreate_addr_space.c tilegx/Lget_proc_info.c tilegx/Lget_save_loc.c   \
+	tilegx/Lglobal.c tilegx/Linit.c tilegx/Linit_local.c tilegx/Linit_remote.c  \
+	tilegx/Lis_signal_frame.c tilegx/Lregs.c tilegx/Lresume.c tilegx/Lstep.c
+
+libunwind_tilegx_la_SOURCES_tilegx = $(libunwind_la_SOURCES_tilegx_common)	    \
+	$(libunwind_la_SOURCES_generic)					    \
+	tilegx/Gapply_reg_state.c tilegx/Greg_states_iterate.c			     \
+	tilegx/Gcreate_addr_space.c tilegx/Gget_proc_info.c tilegx/Gget_save_loc.c   \
+	tilegx/Gglobal.c tilegx/Ginit.c tilegx/Ginit_local.c tilegx/Ginit_remote.c	    \
+	tilegx/Gis_signal_frame.c tilegx/Gregs.c tilegx/Gresume.c tilegx/Gstep.c
+
 libunwind_la_SOURCES_x86_common = $(libunwind_la_SOURCES_common)	\
 	x86/is_fpreg.c x86/regname.c
 
@@ -1120,6 +1530,7 @@ libunwind_la_SOURCES_x86_common = $(libunwind_la_SOURCES_common)	\
 libunwind_la_SOURCES_x86 = $(libunwind_la_SOURCES_x86_common)		\
         $(libunwind_la_SOURCES_x86_os_local)				\
 	$(libunwind_la_SOURCES_local)					\
+	x86/Lapply_reg_state.c x86/Lreg_states_iterate.c		\
 	x86/Lcreate_addr_space.c x86/Lget_save_loc.c x86/Lglobal.c	\
 	x86/Linit.c x86/Linit_local.c x86/Linit_remote.c		\
 	x86/Lget_proc_info.c x86/Lregs.c				\
@@ -1130,6 +1541,7 @@ libunwind_la_SOURCES_x86 = $(libunwind_la_SOURCES_x86_common)		\
 libunwind_x86_la_SOURCES_x86 = $(libunwind_la_SOURCES_x86_common)	\
         $(libunwind_la_SOURCES_x86_os)					\
 	$(libunwind_la_SOURCES_generic)					\
+	x86/Gapply_reg_state.c x86/Greg_states_iterate.c		\
 	x86/Gcreate_addr_space.c x86/Gget_save_loc.c x86/Gglobal.c	\
 	x86/Ginit.c x86/Ginit_local.c x86/Ginit_remote.c		\
 	x86/Gget_proc_info.c x86/Gregs.c				\
@@ -1144,6 +1556,7 @@ libunwind_la_SOURCES_x86_64 = $(libunwind_la_SOURCES_x86_64_common)	    \
         $(libunwind_la_SOURCES_x86_64_os_local)			    	    \
 	$(libunwind_la_SOURCES_local)					    \
 	x86_64/setcontext.S						    \
+	x86_64/Lapply_reg_state.c x86_64/Lreg_states_iterate.c		    \
 	x86_64/Lcreate_addr_space.c x86_64/Lget_save_loc.c x86_64/Lglobal.c \
 	x86_64/Linit.c x86_64/Linit_local.c x86_64/Linit_remote.c	    \
 	x86_64/Lget_proc_info.c x86_64/Lregs.c x86_64/Lresume.c		    \
@@ -1154,6 +1567,7 @@ libunwind_la_SOURCES_x86_64 = $(libunwind_la_SOURCES_x86_64_common)	    \
 libunwind_x86_64_la_SOURCES_x86_64 = $(libunwind_la_SOURCES_x86_64_common)  \
         $(libunwind_la_SOURCES_x86_64_os)			    	    \
 	$(libunwind_la_SOURCES_generic)					    \
+	x86_64/Gapply_reg_state.c x86_64/Greg_states_iterate.c		    \
 	x86_64/Gcreate_addr_space.c x86_64/Gget_save_loc.c x86_64/Gglobal.c \
 	x86_64/Ginit.c x86_64/Ginit_local.c x86_64/Ginit_remote.c	    \
 	x86_64/Gget_proc_info.c x86_64/Gregs.c x86_64/Gresume.c		    \
@@ -1161,13 +1575,13 @@ libunwind_x86_64_la_SOURCES_x86_64 = $(libunwind_la_SOURCES_x86_64_common)  \
 
 
 # The list of local files that go to Power 64 and 32:
-libunwind_la_SOURCES_ppc = ppc/Lcreate_addr_space.c 			\
+libunwind_la_SOURCES_ppc = \
 	ppc/Lget_proc_info.c ppc/Lget_save_loc.c ppc/Linit_local.c	\
 	ppc/Linit_remote.c ppc/Lis_signal_frame.c
 
 
 # The list of generic files that go to Power 64 and 32:
-libunwind_ppc_la_SOURCES_ppc_generic = ppc/Gcreate_addr_space.c		\
+libunwind_ppc_la_SOURCES_ppc_generic = \
 	ppc/Gget_proc_info.c ppc/Gget_save_loc.c ppc/Ginit_local.c	\
 	ppc/Ginit_remote.c ppc/Gis_signal_frame.c
 
@@ -1179,6 +1593,8 @@ libunwind_la_SOURCES_ppc32_common = $(libunwind_la_SOURCES_common)      \
 libunwind_la_SOURCES_ppc32 = $(libunwind_la_SOURCES_ppc32_common)       \
 	$(libunwind_la_SOURCES_local)                                   \
 	$(libunwind_la_SOURCES_ppc)					\
+	ppc32/Lapply_reg_state.c ppc32/Lreg_states_iterate.c		\
+	ppc32/Lcreate_addr_space.c					\
 	ppc32/Lglobal.c ppc32/Linit.c					\
 	ppc32/Lregs.c ppc32/Lresume.c ppc32/Lstep.c
 
@@ -1187,6 +1603,8 @@ libunwind_la_SOURCES_ppc32 = $(libunwind_la_SOURCES_ppc32_common)       \
 libunwind_ppc32_la_SOURCES_ppc32 = $(libunwind_la_SOURCES_ppc32_common) \
 	$(libunwind_la_SOURCES_generic)                                 \
 	$(libunwind_ppc_la_SOURCES_ppc_generic)				\
+	ppc32/Gapply_reg_state.c ppc32/Greg_states_iterate.c		\
+	ppc32/Gcreate_addr_space.c					\
 	ppc32/Gglobal.c ppc32/Ginit.c					\
 	ppc32/Gregs.c ppc32/Gresume.c ppc32/Gstep.c
 
@@ -1198,6 +1616,8 @@ libunwind_la_SOURCES_ppc64_common = $(libunwind_la_SOURCES_common)      \
 libunwind_la_SOURCES_ppc64 = $(libunwind_la_SOURCES_ppc64_common)       \
         $(libunwind_la_SOURCES_local)                                   \
 	$(libunwind_la_SOURCES_ppc)					\
+	ppc64/Lapply_reg_state.c ppc64/Lreg_states_iterate.c		\
+	ppc64/Lcreate_addr_space.c					\
 	ppc64/Lglobal.c ppc64/Linit.c					\
 	ppc64/Lregs.c ppc64/Lresume.c ppc64/Lstep.c
 
@@ -1206,6 +1626,8 @@ libunwind_la_SOURCES_ppc64 = $(libunwind_la_SOURCES_ppc64_common)       \
 libunwind_ppc64_la_SOURCES_ppc64 = $(libunwind_la_SOURCES_ppc64_common) \
         $(libunwind_la_SOURCES_generic)                                 \
 	$(libunwind_ppc_la_SOURCES_ppc_generic)				\
+	ppc64/Gapply_reg_state.c ppc64/Greg_states_iterate.c		\
+	ppc64/Gcreate_addr_space.c					\
 	ppc64/Gglobal.c ppc64/Ginit.c					\
 	ppc64/Gregs.c ppc64/Gresume.c ppc64/Gstep.c
 
@@ -1216,22 +1638,50 @@ libunwind_la_SOURCES_sh_common = $(libunwind_la_SOURCES_common)		\
 # The list of files that go into libunwind:
 libunwind_la_SOURCES_sh = $(libunwind_la_SOURCES_sh_common)		\
 	$(libunwind_la_SOURCES_local)					\
+	sh/Lapply_reg_state.c sh/Lreg_states_iterate.c			\
 	sh/Lcreate_addr_space.c sh/Lget_proc_info.c sh/Lget_save_loc.c	\
 	sh/Lglobal.c sh/Linit.c sh/Linit_local.c sh/Linit_remote.c	\
 	sh/Lis_signal_frame.c sh/Lregs.c sh/Lresume.c sh/Lstep.c
 
 libunwind_sh_la_SOURCES_sh = $(libunwind_la_SOURCES_sh_common)		\
 	$(libunwind_la_SOURCES_generic)					\
+	sh/Gapply_reg_state.c sh/Greg_states_iterate.c			\
 	sh/Gcreate_addr_space.c sh/Gget_proc_info.c sh/Gget_save_loc.c	\
 	sh/Gglobal.c sh/Ginit.c sh/Ginit_local.c sh/Ginit_remote.c	\
 	sh/Gis_signal_frame.c sh/Gregs.c sh/Gresume.c sh/Gstep.c
 
+libunwind_la_SOURCES_s390x_common = $(libunwind_la_SOURCES_common)	\
+	s390x/is_fpreg.c s390x/regname.c
+
+
+# The list of files that go into libunwind:
+libunwind_la_SOURCES_s390x = $(libunwind_la_SOURCES_s390x_common)	    \
+	$(libunwind_la_SOURCES_local)					    \
+	s390x/Lapply_reg_state.c s390x/Lreg_states_iterate.c		    \
+	s390x/Lcreate_addr_space.c s390x/Lget_save_loc.c s390x/Lglobal.c    \
+	s390x/Linit.c s390x/Linit_local.c s390x/Linit_remote.c	            \
+	s390x/Lget_proc_info.c s390x/Lregs.c s390x/Lresume.c		    \
+	s390x/Lis_signal_frame.c s390x/Lstep.c				    \
+	s390x/getcontext.S s390x/setcontext.S
+
+
+# The list of files that go into libunwind-s390x:
+libunwind_s390x_la_SOURCES_s390x = $(libunwind_la_SOURCES_s390x_common)     \
+	$(libunwind_la_SOURCES_generic)					    \
+	s390x/Gapply_reg_state.c s390x/Greg_states_iterate.c	            \
+	s390x/Gcreate_addr_space.c s390x/Gget_save_loc.c s390x/Gglobal.c    \
+	s390x/Ginit.c s390x/Ginit_local.c s390x/Ginit_remote.c	            \
+	s390x/Gget_proc_info.c s390x/Gregs.c s390x/Gresume.c		    \
+	s390x/Gis_signal_frame.c s390x/Gstep.c
+
 @OS_FREEBSD_TRUE@libunwind_la_SOURCES_os = $(libunwind_la_SOURCES_os_freebsd)
 @OS_HPUX_TRUE@libunwind_la_SOURCES_os = $(libunwind_la_SOURCES_os_hpux)
 @OS_LINUX_TRUE@libunwind_la_SOURCES_os = $(libunwind_la_SOURCES_os_linux)
+@OS_QNX_TRUE@libunwind_la_SOURCES_os = $(libunwind_la_SOURCES_os_qnx)
 @OS_FREEBSD_TRUE@libunwind_la_SOURCES_os_local = $(libunwind_la_SOURCES_os_freebsd_local)
 @OS_HPUX_TRUE@libunwind_la_SOURCES_os_local = $(libunwind_la_SOURCES_os_hpux_local)
 @OS_LINUX_TRUE@libunwind_la_SOURCES_os_local = $(libunwind_la_SOURCES_os_linux_local)
+@OS_QNX_TRUE@libunwind_la_SOURCES_os_local = $(libunwind_la_SOURCES_os_qnx_local)
 @OS_FREEBSD_TRUE@libunwind_la_SOURCES_x86_os = x86/Gos-freebsd.c
 @OS_LINUX_TRUE@libunwind_la_SOURCES_x86_os = x86/Gos-linux.c
 @OS_FREEBSD_TRUE@libunwind_x86_la_SOURCES_os = x86/getcontext-freebsd.S
@@ -1242,60 +1692,85 @@ libunwind_sh_la_SOURCES_sh = $(libunwind_la_SOURCES_sh_common)		\
 @OS_LINUX_TRUE@libunwind_la_SOURCES_x86_64_os = x86_64/Gos-linux.c
 @OS_FREEBSD_TRUE@libunwind_la_SOURCES_x86_64_os_local = x86_64/Los-freebsd.c
 @OS_LINUX_TRUE@libunwind_la_SOURCES_x86_64_os_local = x86_64/Los-linux.c
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_sh)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_ppc64)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_ppc32)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_x86_64)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_x86) $(libunwind_x86_la_SOURCES_os)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_mips)
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_hppa)
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_ia64)
-@ARCH_ARM_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_arm)
-@ARCH_ARM_TRUE@libunwind_arm_la_SOURCES = $(libunwind_arm_la_SOURCES_arm)
-@ARCH_ARM_TRUE@libunwind_arm_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_TRUE@libunwind_arm_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_TRUE@	libunwind-elf32.la $(am__append_11)
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@BUILT_SOURCES = Gcursor_i.h Lcursor_i.h
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_SOURCES = $(libunwind_ia64_la_SOURCES_ia64)
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_LIBADD =  \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	libunwind-elf64.la \
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(am__append_14)
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_SOURCES = $(libunwind_hppa_la_SOURCES_hppa)
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	$(am__append_17)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_SOURCES = $(libunwind_mips_la_SOURCES_mips)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	libunwind-elfxx.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	$(am__append_20)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_SOURCES = $(libunwind_x86_la_SOURCES_x86)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_TRUE@	$(am__append_23)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_SOURCES = $(libunwind_x86_64_la_SOURCES_x86_64)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	libunwind-elf64.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	$(am__append_26)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_SOURCES = $(libunwind_ppc32_la_SOURCES_ppc32)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__append_29)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_SOURCES = $(libunwind_ppc64_la_SOURCES_ppc64)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf64.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__append_32)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_SOURCES = $(libunwind_sh_la_SOURCES_sh)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_LIBADD = libunwind-dwarf-generic.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
-@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__append_35)
+@OS_FREEBSD_TRUE@libunwind_la_SOURCES_arm_os = arm/Gos-freebsd.c
+@OS_LINUX_TRUE@libunwind_la_SOURCES_arm_os = arm/Gos-linux.c
+@OS_QNX_TRUE@libunwind_la_SOURCES_arm_os = arm/Gos-other.c
+@OS_FREEBSD_TRUE@libunwind_la_SOURCES_arm_os_local = arm/Los-freebsd.c
+@OS_LINUX_TRUE@libunwind_la_SOURCES_arm_os_local = arm/Los-linux.c
+@OS_QNX_TRUE@libunwind_la_SOURCES_arm_os_local = arm/Los-other.c
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_s390x)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_sh)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_ppc64)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_ppc32)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_x86_64)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_x86) $(libunwind_x86_la_SOURCES_os)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_tilegx)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_mips)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_hppa)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_ia64)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_arm)
+@ARCH_AARCH64_TRUE@libunwind_la_SOURCES = $(libunwind_la_SOURCES_aarch64)
+@ARCH_AARCH64_TRUE@libunwind_aarch64_la_SOURCES = $(libunwind_aarch64_la_SOURCES_aarch64)
+@ARCH_AARCH64_TRUE@libunwind_aarch64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_TRUE@libunwind_aarch64_la_LIBADD =  \
+@ARCH_AARCH64_TRUE@	libunwind-dwarf-generic.la \
+@ARCH_AARCH64_TRUE@	libunwind-elf64.la $(am__append_14)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@libunwind_arm_la_SOURCES = $(libunwind_arm_la_SOURCES_arm)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@libunwind_arm_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@libunwind_arm_la_LIBADD =  \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_TRUE@	$(am__append_17)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@BUILT_SOURCES = Gcursor_i.h Lcursor_i.h
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_SOURCES = $(libunwind_ia64_la_SOURCES_ia64)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@libunwind_ia64_la_LIBADD = libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(am__append_20)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_SOURCES = $(libunwind_hppa_la_SOURCES_hppa)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@libunwind_hppa_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_TRUE@@ARCH_IA64_FALSE@	$(am__append_23)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_SOURCES = $(libunwind_mips_la_SOURCES_mips)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@libunwind_mips_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	libunwind-elfxx.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_TRUE@	$(am__append_26)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@libunwind_tilegx_la_SOURCES = $(libunwind_tilegx_la_SOURCES_tilegx)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@libunwind_tilegx_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@libunwind_tilegx_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@	libunwind-elfxx.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_TRUE@	$(am__append_29)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_SOURCES = $(libunwind_x86_la_SOURCES_x86)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@libunwind_x86_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_TRUE@	$(am__append_32)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_SOURCES = $(libunwind_x86_64_la_SOURCES_x86_64)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@libunwind_x86_64_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_TRUE@@ARCH_X86_FALSE@	$(am__append_35)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_SOURCES = $(libunwind_ppc32_la_SOURCES_ppc32)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc32_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__append_38)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_SOURCES = $(libunwind_ppc64_la_SOURCES_ppc64)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_ppc64_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__append_41)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_SOURCES = $(libunwind_sh_la_SOURCES_sh)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_sh_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf32.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_SH_TRUE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__append_44)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_s390x_la_SOURCES = $(libunwind_s390x_la_SOURCES_s390x)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_s390x_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -version-info $(SOVERSION)
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@libunwind_s390x_la_LIBADD = libunwind-dwarf-generic.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	libunwind-elf64.la \
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_HPPA_FALSE@@ARCH_IA64_FALSE@@ARCH_MIPS_FALSE@@ARCH_PPC32_FALSE@@ARCH_PPC64_FALSE@@ARCH_S390X_TRUE@@ARCH_SH_FALSE@@ARCH_TILEGX_FALSE@@ARCH_X86_64_FALSE@@ARCH_X86_FALSE@	$(am__append_47)
 
 #
 # Don't link with standard libraries, because those may mention
@@ -1306,7 +1781,8 @@ libunwind_la_LDFLAGS = $(COMMON_SO_LDFLAGS) -XCClinker -nostdlib \
 
 AM_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/tdep-$(arch) -I.
 AM_CCASFLAGS = $(AM_CPPFLAGS)
-EXTRA_DIST = $(libunwind_la_SOURCES_arm)			\
+EXTRA_DIST = $(libunwind_la_SOURCES_aarch64)			\
+		$(libunwind_la_SOURCES_arm)			\
 		$(libunwind_la_SOURCES_hppa)			\
 		$(libunwind_la_SOURCES_ia64)			\
 		$(libunwind_la_SOURCES_mips)			\
@@ -1315,9 +1791,11 @@ EXTRA_DIST = $(libunwind_la_SOURCES_arm)			\
 		$(libunwind_la_SOURCES_os_freebsd)		\
 		$(libunwind_la_SOURCES_os_linux)		\
 		$(libunwind_la_SOURCES_os_hpux)			\
+		$(libunwind_la_SOURCES_os_qnx)			\
 		$(libunwind_la_SOURCES_common)			\
 		$(libunwind_la_SOURCES_local)			\
 		$(libunwind_la_SOURCES_generic)			\
+		$(libunwind_aarch64_la_SOURCES_aarch64)		\
 		$(libunwind_arm_la_SOURCES_arm)			\
 		$(libunwind_hppa_la_SOURCES_hppa)		\
 		$(libunwind_ia64_la_SOURCES_ia64)		\
@@ -1366,7 +1844,6 @@ libunwind-generic.pc: $(top_builddir)/config.status $(srcdir)/libunwind-generic.
 	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
 install-libLIBRARIES: $(lib_LIBRARIES)
 	@$(NORMAL_INSTALL)
-	test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"
 	@list='$(lib_LIBRARIES)'; test -n "$(libdir)" || list=; \
 	list2=; for p in $$list; do \
 	  if test -f $$p; then \
@@ -1374,6 +1851,8 @@ install-libLIBRARIES: $(lib_LIBRARIES)
 	  else :; fi; \
 	done; \
 	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
 	  echo " $(INSTALL_DATA) $$list2 '$(DESTDIR)$(libdir)'"; \
 	  $(INSTALL_DATA) $$list2 "$(DESTDIR)$(libdir)" || exit $$?; }
 	@$(POST_INSTALL)
@@ -1394,9 +1873,9 @@ uninstall-libLIBRARIES:
 
 clean-libLIBRARIES:
 	-test -z "$(lib_LIBRARIES)" || rm -f $(lib_LIBRARIES)
+
 install-libLTLIBRARIES: $(lib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
-	test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"
 	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
 	list2=; for p in $$list; do \
 	  if test -f $$p; then \
@@ -1404,6 +1883,8 @@ install-libLTLIBRARIES: $(lib_LTLIBRARIES)
 	  else :; fi; \
 	done; \
 	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
 	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'"; \
 	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libdir)"; \
 	}
@@ -1419,21 +1900,25 @@ uninstall-libLTLIBRARIES:
 
 clean-libLTLIBRARIES:
 	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
-	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
+	@list='$(lib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
 
 clean-noinstLTLIBRARIES:
 	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
 mi/$(am__dirstamp):
 	@$(MKDIR_P) mi
 	@: > mi/$(am__dirstamp)
@@ -1444,14 +1929,16 @@ mi/init.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/flush_cache.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/mempool.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/strerror.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
-arm/$(am__dirstamp):
-	@$(MKDIR_P) arm
-	@: > arm/$(am__dirstamp)
-arm/$(DEPDIR)/$(am__dirstamp):
-	@$(MKDIR_P) arm/$(DEPDIR)
-	@: > arm/$(DEPDIR)/$(am__dirstamp)
-arm/is_fpreg.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
-arm/regname.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+aarch64/$(am__dirstamp):
+	@$(MKDIR_P) aarch64
+	@: > aarch64/$(am__dirstamp)
+aarch64/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) aarch64/$(DEPDIR)
+	@: > aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/is_fpreg.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/regname.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
 mi/Gdyn-extract.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/Gdyn-remote.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/Gfind_dynamic_proc_info.lo: mi/$(am__dirstamp) \
@@ -1470,6 +1957,55 @@ mi/Gget_fpreg.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/Gset_fpreg.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/Gset_caching_policy.lo: mi/$(am__dirstamp) \
 	mi/$(DEPDIR)/$(am__dirstamp)
+mi/Gset_cache_size.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gapply_reg_state.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Greg_states_iterate.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gcreate_addr_space.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gget_proc_info.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gget_save_loc.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gglobal.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Ginit.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Ginit_local.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Ginit_remote.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gis_signal_frame.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gregs.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gresume.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gstash_frame.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gstep.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Gtrace.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+
+libunwind-aarch64.la: $(libunwind_aarch64_la_OBJECTS) $(libunwind_aarch64_la_DEPENDENCIES) $(EXTRA_libunwind_aarch64_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libunwind_aarch64_la_LINK) $(am_libunwind_aarch64_la_rpath) $(libunwind_aarch64_la_OBJECTS) $(libunwind_aarch64_la_LIBADD) $(LIBS)
+arm/$(am__dirstamp):
+	@$(MKDIR_P) arm
+	@: > arm/$(am__dirstamp)
+arm/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) arm/$(DEPDIR)
+	@: > arm/$(DEPDIR)/$(am__dirstamp)
+arm/is_fpreg.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/regname.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Gos-freebsd.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Gos-linux.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Gos-other.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Gapply_reg_state.lo: arm/$(am__dirstamp) \
+	arm/$(DEPDIR)/$(am__dirstamp)
+arm/Greg_states_iterate.lo: arm/$(am__dirstamp) \
+	arm/$(DEPDIR)/$(am__dirstamp)
 arm/Gcreate_addr_space.lo: arm/$(am__dirstamp) \
 	arm/$(DEPDIR)/$(am__dirstamp)
 arm/Gget_proc_info.lo: arm/$(am__dirstamp) \
@@ -1480,14 +2016,15 @@ arm/Gglobal.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Ginit.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Ginit_local.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Ginit_remote.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
-arm/Gis_signal_frame.lo: arm/$(am__dirstamp) \
-	arm/$(DEPDIR)/$(am__dirstamp)
 arm/Gregs.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Gresume.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Gstep.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Gex_tables.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Gstash_frame.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Gtrace.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-arm.la: $(libunwind_arm_la_OBJECTS) $(libunwind_arm_la_DEPENDENCIES) $(EXTRA_libunwind_arm_la_DEPENDENCIES) 
-	$(libunwind_arm_la_LINK) $(am_libunwind_arm_la_rpath) $(libunwind_arm_la_OBJECTS) $(libunwind_arm_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_arm_la_LINK) $(am_libunwind_arm_la_rpath) $(libunwind_arm_la_OBJECTS) $(libunwind_arm_la_LIBADD) $(LIBS)
 coredump/$(am__dirstamp):
 	@$(MKDIR_P) coredump
 	@: > coredump/$(am__dirstamp)
@@ -1522,8 +2059,9 @@ coredump/_UCD_access_reg_linux.lo: coredump/$(am__dirstamp) \
 	coredump/$(DEPDIR)/$(am__dirstamp)
 coredump/_UCD_access_reg_freebsd.lo: coredump/$(am__dirstamp) \
 	coredump/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-coredump.la: $(libunwind_coredump_la_OBJECTS) $(libunwind_coredump_la_DEPENDENCIES) $(EXTRA_libunwind_coredump_la_DEPENDENCIES) 
-	$(libunwind_coredump_la_LINK) $(am_libunwind_coredump_la_rpath) $(libunwind_coredump_la_OBJECTS) $(libunwind_coredump_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_coredump_la_LINK) $(am_libunwind_coredump_la_rpath) $(libunwind_coredump_la_OBJECTS) $(libunwind_coredump_la_LIBADD) $(LIBS)
 dwarf/$(am__dirstamp):
 	@$(MKDIR_P) dwarf
 	@: > dwarf/$(am__dirstamp)
@@ -1531,38 +2069,42 @@ dwarf/$(DEPDIR)/$(am__dirstamp):
 	@$(MKDIR_P) dwarf/$(DEPDIR)
 	@: > dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/global.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-dwarf-common.la: $(libunwind_dwarf_common_la_OBJECTS) $(libunwind_dwarf_common_la_DEPENDENCIES) $(EXTRA_libunwind_dwarf_common_la_DEPENDENCIES) 
-	$(LINK) $(am_libunwind_dwarf_common_la_rpath) $(libunwind_dwarf_common_la_OBJECTS) $(libunwind_dwarf_common_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(am_libunwind_dwarf_common_la_rpath) $(libunwind_dwarf_common_la_OBJECTS) $(libunwind_dwarf_common_la_LIBADD) $(LIBS)
 dwarf/Gexpr.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Gfde.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Gparser.lo: dwarf/$(am__dirstamp) \
 	dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Gpe.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
-dwarf/Gstep.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Gfind_proc_info-lsb.lo: dwarf/$(am__dirstamp) \
 	dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Gfind_unwind_table.lo: dwarf/$(am__dirstamp) \
 	dwarf/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-dwarf-generic.la: $(libunwind_dwarf_generic_la_OBJECTS) $(libunwind_dwarf_generic_la_DEPENDENCIES) $(EXTRA_libunwind_dwarf_generic_la_DEPENDENCIES) 
-	$(LINK) $(am_libunwind_dwarf_generic_la_rpath) $(libunwind_dwarf_generic_la_OBJECTS) $(libunwind_dwarf_generic_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(am_libunwind_dwarf_generic_la_rpath) $(libunwind_dwarf_generic_la_OBJECTS) $(libunwind_dwarf_generic_la_LIBADD) $(LIBS)
 dwarf/Lexpr.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Lfde.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Lparser.lo: dwarf/$(am__dirstamp) \
 	dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Lpe.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
-dwarf/Lstep.lo: dwarf/$(am__dirstamp) dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Lfind_proc_info-lsb.lo: dwarf/$(am__dirstamp) \
 	dwarf/$(DEPDIR)/$(am__dirstamp)
 dwarf/Lfind_unwind_table.lo: dwarf/$(am__dirstamp) \
 	dwarf/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-dwarf-local.la: $(libunwind_dwarf_local_la_OBJECTS) $(libunwind_dwarf_local_la_DEPENDENCIES) $(EXTRA_libunwind_dwarf_local_la_DEPENDENCIES) 
-	$(LINK) $(am_libunwind_dwarf_local_la_rpath) $(libunwind_dwarf_local_la_OBJECTS) $(libunwind_dwarf_local_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(am_libunwind_dwarf_local_la_rpath) $(libunwind_dwarf_local_la_OBJECTS) $(libunwind_dwarf_local_la_LIBADD) $(LIBS)
+
 libunwind-elf32.la: $(libunwind_elf32_la_OBJECTS) $(libunwind_elf32_la_DEPENDENCIES) $(EXTRA_libunwind_elf32_la_DEPENDENCIES) 
-	$(LINK) $(am_libunwind_elf32_la_rpath) $(libunwind_elf32_la_OBJECTS) $(libunwind_elf32_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(am_libunwind_elf32_la_rpath) $(libunwind_elf32_la_OBJECTS) $(libunwind_elf32_la_LIBADD) $(LIBS)
+
 libunwind-elf64.la: $(libunwind_elf64_la_OBJECTS) $(libunwind_elf64_la_DEPENDENCIES) $(EXTRA_libunwind_elf64_la_DEPENDENCIES) 
-	$(LINK) $(am_libunwind_elf64_la_rpath) $(libunwind_elf64_la_OBJECTS) $(libunwind_elf64_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(am_libunwind_elf64_la_rpath) $(libunwind_elf64_la_OBJECTS) $(libunwind_elf64_la_LIBADD) $(LIBS)
+
 libunwind-elfxx.la: $(libunwind_elfxx_la_OBJECTS) $(libunwind_elfxx_la_DEPENDENCIES) $(EXTRA_libunwind_elfxx_la_DEPENDENCIES) 
-	$(LINK) $(am_libunwind_elfxx_la_rpath) $(libunwind_elfxx_la_OBJECTS) $(libunwind_elfxx_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(am_libunwind_elfxx_la_rpath) $(libunwind_elfxx_la_OBJECTS) $(libunwind_elfxx_la_LIBADD) $(LIBS)
 hppa/$(am__dirstamp):
 	@$(MKDIR_P) hppa
 	@: > hppa/$(am__dirstamp)
@@ -1570,6 +2112,10 @@ hppa/$(DEPDIR)/$(am__dirstamp):
 	@$(MKDIR_P) hppa/$(DEPDIR)
 	@: > hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/regname.lo: hppa/$(am__dirstamp) hppa/$(DEPDIR)/$(am__dirstamp)
+hppa/Gapply_reg_state.lo: hppa/$(am__dirstamp) \
+	hppa/$(DEPDIR)/$(am__dirstamp)
+hppa/Greg_states_iterate.lo: hppa/$(am__dirstamp) \
+	hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/Gcreate_addr_space.lo: hppa/$(am__dirstamp) \
 	hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/Gget_save_loc.lo: hppa/$(am__dirstamp) \
@@ -1587,8 +2133,9 @@ hppa/Gget_proc_info.lo: hppa/$(am__dirstamp) \
 hppa/Gregs.lo: hppa/$(am__dirstamp) hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/Gresume.lo: hppa/$(am__dirstamp) hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/Gstep.lo: hppa/$(am__dirstamp) hppa/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-hppa.la: $(libunwind_hppa_la_OBJECTS) $(libunwind_hppa_la_DEPENDENCIES) $(EXTRA_libunwind_hppa_la_DEPENDENCIES) 
-	$(libunwind_hppa_la_LINK) $(am_libunwind_hppa_la_rpath) $(libunwind_hppa_la_OBJECTS) $(libunwind_hppa_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_hppa_la_LINK) $(am_libunwind_hppa_la_rpath) $(libunwind_hppa_la_OBJECTS) $(libunwind_hppa_la_LIBADD) $(LIBS)
 ia64/$(am__dirstamp):
 	@$(MKDIR_P) ia64
 	@: > ia64/$(am__dirstamp)
@@ -1596,6 +2143,10 @@ ia64/$(DEPDIR)/$(am__dirstamp):
 	@$(MKDIR_P) ia64/$(DEPDIR)
 	@: > ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/regname.lo: ia64/$(am__dirstamp) ia64/$(DEPDIR)/$(am__dirstamp)
+ia64/Gapply_reg_state.lo: ia64/$(am__dirstamp) \
+	ia64/$(DEPDIR)/$(am__dirstamp)
+ia64/Greg_states_iterate.lo: ia64/$(am__dirstamp) \
+	ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Gcreate_addr_space.lo: ia64/$(am__dirstamp) \
 	ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Gget_proc_info.lo: ia64/$(am__dirstamp) \
@@ -1621,8 +2172,9 @@ ia64/Gstep.lo: ia64/$(am__dirstamp) ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Gtables.lo: ia64/$(am__dirstamp) ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Gfind_unwind_table.lo: ia64/$(am__dirstamp) \
 	ia64/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-ia64.la: $(libunwind_ia64_la_OBJECTS) $(libunwind_ia64_la_DEPENDENCIES) $(EXTRA_libunwind_ia64_la_DEPENDENCIES) 
-	$(libunwind_ia64_la_LINK) $(am_libunwind_ia64_la_rpath) $(libunwind_ia64_la_OBJECTS) $(libunwind_ia64_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_ia64_la_LINK) $(am_libunwind_ia64_la_rpath) $(libunwind_ia64_la_OBJECTS) $(libunwind_ia64_la_LIBADD) $(LIBS)
 mips/$(am__dirstamp):
 	@$(MKDIR_P) mips
 	@: > mips/$(am__dirstamp)
@@ -1631,6 +2183,10 @@ mips/$(DEPDIR)/$(am__dirstamp):
 	@: > mips/$(DEPDIR)/$(am__dirstamp)
 mips/is_fpreg.lo: mips/$(am__dirstamp) mips/$(DEPDIR)/$(am__dirstamp)
 mips/regname.lo: mips/$(am__dirstamp) mips/$(DEPDIR)/$(am__dirstamp)
+mips/Gapply_reg_state.lo: mips/$(am__dirstamp) \
+	mips/$(DEPDIR)/$(am__dirstamp)
+mips/Greg_states_iterate.lo: mips/$(am__dirstamp) \
+	mips/$(DEPDIR)/$(am__dirstamp)
 mips/Gcreate_addr_space.lo: mips/$(am__dirstamp) \
 	mips/$(DEPDIR)/$(am__dirstamp)
 mips/Gget_proc_info.lo: mips/$(am__dirstamp) \
@@ -1648,8 +2204,9 @@ mips/Gis_signal_frame.lo: mips/$(am__dirstamp) \
 mips/Gregs.lo: mips/$(am__dirstamp) mips/$(DEPDIR)/$(am__dirstamp)
 mips/Gresume.lo: mips/$(am__dirstamp) mips/$(DEPDIR)/$(am__dirstamp)
 mips/Gstep.lo: mips/$(am__dirstamp) mips/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-mips.la: $(libunwind_mips_la_OBJECTS) $(libunwind_mips_la_DEPENDENCIES) $(EXTRA_libunwind_mips_la_DEPENDENCIES) 
-	$(libunwind_mips_la_LINK) $(am_libunwind_mips_la_rpath) $(libunwind_mips_la_OBJECTS) $(libunwind_mips_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_mips_la_LINK) $(am_libunwind_mips_la_rpath) $(libunwind_mips_la_OBJECTS) $(libunwind_mips_la_LIBADD) $(LIBS)
 ppc32/$(am__dirstamp):
 	@$(MKDIR_P) ppc32
 	@: > ppc32/$(am__dirstamp)
@@ -1668,8 +2225,6 @@ ppc/$(am__dirstamp):
 ppc/$(DEPDIR)/$(am__dirstamp):
 	@$(MKDIR_P) ppc/$(DEPDIR)
 	@: > ppc/$(DEPDIR)/$(am__dirstamp)
-ppc/Gcreate_addr_space.lo: ppc/$(am__dirstamp) \
-	ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Gget_proc_info.lo: ppc/$(am__dirstamp) \
 	ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Gget_save_loc.lo: ppc/$(am__dirstamp) \
@@ -1678,6 +2233,12 @@ ppc/Ginit_local.lo: ppc/$(am__dirstamp) ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Ginit_remote.lo: ppc/$(am__dirstamp) ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Gis_signal_frame.lo: ppc/$(am__dirstamp) \
 	ppc/$(DEPDIR)/$(am__dirstamp)
+ppc32/Gapply_reg_state.lo: ppc32/$(am__dirstamp) \
+	ppc32/$(DEPDIR)/$(am__dirstamp)
+ppc32/Greg_states_iterate.lo: ppc32/$(am__dirstamp) \
+	ppc32/$(DEPDIR)/$(am__dirstamp)
+ppc32/Gcreate_addr_space.lo: ppc32/$(am__dirstamp) \
+	ppc32/$(DEPDIR)/$(am__dirstamp)
 ppc32/Gglobal.lo: ppc32/$(am__dirstamp) \
 	ppc32/$(DEPDIR)/$(am__dirstamp)
 ppc32/Ginit.lo: ppc32/$(am__dirstamp) ppc32/$(DEPDIR)/$(am__dirstamp)
@@ -1685,8 +2246,9 @@ ppc32/Gregs.lo: ppc32/$(am__dirstamp) ppc32/$(DEPDIR)/$(am__dirstamp)
 ppc32/Gresume.lo: ppc32/$(am__dirstamp) \
 	ppc32/$(DEPDIR)/$(am__dirstamp)
 ppc32/Gstep.lo: ppc32/$(am__dirstamp) ppc32/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-ppc32.la: $(libunwind_ppc32_la_OBJECTS) $(libunwind_ppc32_la_DEPENDENCIES) $(EXTRA_libunwind_ppc32_la_DEPENDENCIES) 
-	$(libunwind_ppc32_la_LINK) $(am_libunwind_ppc32_la_rpath) $(libunwind_ppc32_la_OBJECTS) $(libunwind_ppc32_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_ppc32_la_LINK) $(am_libunwind_ppc32_la_rpath) $(libunwind_ppc32_la_OBJECTS) $(libunwind_ppc32_la_LIBADD) $(LIBS)
 ppc64/$(am__dirstamp):
 	@$(MKDIR_P) ppc64
 	@: > ppc64/$(am__dirstamp)
@@ -1699,6 +2261,12 @@ ppc64/regname.lo: ppc64/$(am__dirstamp) \
 	ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/get_func_addr.lo: ppc64/$(am__dirstamp) \
 	ppc64/$(DEPDIR)/$(am__dirstamp)
+ppc64/Gapply_reg_state.lo: ppc64/$(am__dirstamp) \
+	ppc64/$(DEPDIR)/$(am__dirstamp)
+ppc64/Greg_states_iterate.lo: ppc64/$(am__dirstamp) \
+	ppc64/$(DEPDIR)/$(am__dirstamp)
+ppc64/Gcreate_addr_space.lo: ppc64/$(am__dirstamp) \
+	ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Gglobal.lo: ppc64/$(am__dirstamp) \
 	ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Ginit.lo: ppc64/$(am__dirstamp) ppc64/$(DEPDIR)/$(am__dirstamp)
@@ -1706,8 +2274,9 @@ ppc64/Gregs.lo: ppc64/$(am__dirstamp) ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Gresume.lo: ppc64/$(am__dirstamp) \
 	ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Gstep.lo: ppc64/$(am__dirstamp) ppc64/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-ppc64.la: $(libunwind_ppc64_la_OBJECTS) $(libunwind_ppc64_la_DEPENDENCIES) $(EXTRA_libunwind_ppc64_la_DEPENDENCIES) 
-	$(libunwind_ppc64_la_LINK) $(am_libunwind_ppc64_la_rpath) $(libunwind_ppc64_la_OBJECTS) $(libunwind_ppc64_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_ppc64_la_LINK) $(am_libunwind_ppc64_la_rpath) $(libunwind_ppc64_la_OBJECTS) $(libunwind_ppc64_la_LIBADD) $(LIBS)
 ptrace/$(am__dirstamp):
 	@$(MKDIR_P) ptrace
 	@: > ptrace/$(am__dirstamp)
@@ -1740,8 +2309,45 @@ ptrace/_UPT_reg_offset.lo: ptrace/$(am__dirstamp) \
 	ptrace/$(DEPDIR)/$(am__dirstamp)
 ptrace/_UPT_resume.lo: ptrace/$(am__dirstamp) \
 	ptrace/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-ptrace.la: $(libunwind_ptrace_la_OBJECTS) $(libunwind_ptrace_la_DEPENDENCIES) $(EXTRA_libunwind_ptrace_la_DEPENDENCIES) 
-	$(LINK) $(am_libunwind_ptrace_la_rpath) $(libunwind_ptrace_la_OBJECTS) $(libunwind_ptrace_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(am_libunwind_ptrace_la_rpath) $(libunwind_ptrace_la_OBJECTS) $(libunwind_ptrace_la_LIBADD) $(LIBS)
+s390x/$(am__dirstamp):
+	@$(MKDIR_P) s390x
+	@: > s390x/$(am__dirstamp)
+s390x/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) s390x/$(DEPDIR)
+	@: > s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/is_fpreg.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/regname.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gapply_reg_state.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Greg_states_iterate.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gcreate_addr_space.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gget_save_loc.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gglobal.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Ginit.lo: s390x/$(am__dirstamp) s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Ginit_local.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Ginit_remote.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gget_proc_info.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gregs.lo: s390x/$(am__dirstamp) s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gresume.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gis_signal_frame.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Gstep.lo: s390x/$(am__dirstamp) s390x/$(DEPDIR)/$(am__dirstamp)
+
+libunwind-s390x.la: $(libunwind_s390x_la_OBJECTS) $(libunwind_s390x_la_DEPENDENCIES) $(EXTRA_libunwind_s390x_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libunwind_s390x_la_LINK) $(am_libunwind_s390x_la_rpath) $(libunwind_s390x_la_OBJECTS) $(libunwind_s390x_la_LIBADD) $(LIBS)
 setjmp/$(am__dirstamp):
 	@$(MKDIR_P) setjmp
 	@: > setjmp/$(am__dirstamp)
@@ -1752,6 +2358,8 @@ setjmp/longjmp.lo: setjmp/$(am__dirstamp) \
 	setjmp/$(DEPDIR)/$(am__dirstamp)
 setjmp/siglongjmp.lo: setjmp/$(am__dirstamp) \
 	setjmp/$(DEPDIR)/$(am__dirstamp)
+aarch64/siglongjmp.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
 arm/siglongjmp.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 ia64/setjmp.lo: ia64/$(am__dirstamp) ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/sigsetjmp.lo: ia64/$(am__dirstamp) ia64/$(DEPDIR)/$(am__dirstamp)
@@ -1762,6 +2370,14 @@ hppa/siglongjmp.lo: hppa/$(am__dirstamp) \
 	hppa/$(DEPDIR)/$(am__dirstamp)
 mips/siglongjmp.lo: mips/$(am__dirstamp) \
 	mips/$(DEPDIR)/$(am__dirstamp)
+tilegx/$(am__dirstamp):
+	@$(MKDIR_P) tilegx
+	@: > tilegx/$(am__dirstamp)
+tilegx/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) tilegx/$(DEPDIR)
+	@: > tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/siglongjmp.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
 x86/$(am__dirstamp):
 	@$(MKDIR_P) x86
 	@: > x86/$(am__dirstamp)
@@ -1789,10 +2405,15 @@ sh/$(DEPDIR)/$(am__dirstamp):
 	@$(MKDIR_P) sh/$(DEPDIR)
 	@: > sh/$(DEPDIR)/$(am__dirstamp)
 sh/siglongjmp.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-setjmp.la: $(libunwind_setjmp_la_OBJECTS) $(libunwind_setjmp_la_DEPENDENCIES) $(EXTRA_libunwind_setjmp_la_DEPENDENCIES) 
-	$(libunwind_setjmp_la_LINK) $(am_libunwind_setjmp_la_rpath) $(libunwind_setjmp_la_OBJECTS) $(libunwind_setjmp_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_setjmp_la_LINK) $(am_libunwind_setjmp_la_rpath) $(libunwind_setjmp_la_OBJECTS) $(libunwind_setjmp_la_LIBADD) $(LIBS)
 sh/is_fpreg.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
 sh/regname.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
+sh/Gapply_reg_state.lo: sh/$(am__dirstamp) \
+	sh/$(DEPDIR)/$(am__dirstamp)
+sh/Greg_states_iterate.lo: sh/$(am__dirstamp) \
+	sh/$(DEPDIR)/$(am__dirstamp)
 sh/Gcreate_addr_space.lo: sh/$(am__dirstamp) \
 	sh/$(DEPDIR)/$(am__dirstamp)
 sh/Gget_proc_info.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
@@ -1806,12 +2427,50 @@ sh/Gis_signal_frame.lo: sh/$(am__dirstamp) \
 sh/Gregs.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
 sh/Gresume.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
 sh/Gstep.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-sh.la: $(libunwind_sh_la_OBJECTS) $(libunwind_sh_la_DEPENDENCIES) $(EXTRA_libunwind_sh_la_DEPENDENCIES) 
-	$(libunwind_sh_la_LINK) $(am_libunwind_sh_la_rpath) $(libunwind_sh_la_OBJECTS) $(libunwind_sh_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_sh_la_LINK) $(am_libunwind_sh_la_rpath) $(libunwind_sh_la_OBJECTS) $(libunwind_sh_la_LIBADD) $(LIBS)
+tilegx/is_fpreg.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/regname.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gapply_reg_state.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Greg_states_iterate.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gcreate_addr_space.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gget_proc_info.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gget_save_loc.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gglobal.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Ginit.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Ginit_local.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Ginit_remote.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gis_signal_frame.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gregs.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gresume.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Gstep.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+
+libunwind-tilegx.la: $(libunwind_tilegx_la_OBJECTS) $(libunwind_tilegx_la_DEPENDENCIES) $(EXTRA_libunwind_tilegx_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libunwind_tilegx_la_LINK) $(am_libunwind_tilegx_la_rpath) $(libunwind_tilegx_la_OBJECTS) $(libunwind_tilegx_la_LIBADD) $(LIBS)
 x86/is_fpreg.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
 x86/regname.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
 x86/Gos-freebsd.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
 x86/Gos-linux.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
+x86/Gapply_reg_state.lo: x86/$(am__dirstamp) \
+	x86/$(DEPDIR)/$(am__dirstamp)
+x86/Greg_states_iterate.lo: x86/$(am__dirstamp) \
+	x86/$(DEPDIR)/$(am__dirstamp)
 x86/Gcreate_addr_space.lo: x86/$(am__dirstamp) \
 	x86/$(DEPDIR)/$(am__dirstamp)
 x86/Gget_save_loc.lo: x86/$(am__dirstamp) \
@@ -1825,8 +2484,9 @@ x86/Gget_proc_info.lo: x86/$(am__dirstamp) \
 x86/Gregs.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
 x86/Gresume.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
 x86/Gstep.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-x86.la: $(libunwind_x86_la_OBJECTS) $(libunwind_x86_la_DEPENDENCIES) $(EXTRA_libunwind_x86_la_DEPENDENCIES) 
-	$(libunwind_x86_la_LINK) $(am_libunwind_x86_la_rpath) $(libunwind_x86_la_OBJECTS) $(libunwind_x86_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_x86_la_LINK) $(am_libunwind_x86_la_rpath) $(libunwind_x86_la_OBJECTS) $(libunwind_x86_la_LIBADD) $(LIBS)
 x86_64/is_fpreg.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/regname.lo: x86_64/$(am__dirstamp) \
@@ -1835,6 +2495,10 @@ x86_64/Gos-freebsd.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/Gos-linux.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
+x86_64/Gapply_reg_state.lo: x86_64/$(am__dirstamp) \
+	x86_64/$(DEPDIR)/$(am__dirstamp)
+x86_64/Greg_states_iterate.lo: x86_64/$(am__dirstamp) \
+	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/Gcreate_addr_space.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/Gget_save_loc.lo: x86_64/$(am__dirstamp) \
@@ -1859,8 +2523,9 @@ x86_64/Gstep.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/Gtrace.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
+
 libunwind-x86_64.la: $(libunwind_x86_64_la_OBJECTS) $(libunwind_x86_64_la_DEPENDENCIES) $(EXTRA_libunwind_x86_64_la_DEPENDENCIES) 
-	$(libunwind_x86_64_la_LINK) $(am_libunwind_x86_64_la_rpath) $(libunwind_x86_64_la_OBJECTS) $(libunwind_x86_64_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_x86_64_la_LINK) $(am_libunwind_x86_64_la_rpath) $(libunwind_x86_64_la_OBJECTS) $(libunwind_x86_64_la_LIBADD) $(LIBS)
 mi/_ReadULEB.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/_ReadSLEB.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/backtrace.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
@@ -1884,6 +2549,7 @@ mi/Lget_fpreg.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/Lset_fpreg.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 mi/Lset_caching_policy.lo: mi/$(am__dirstamp) \
 	mi/$(DEPDIR)/$(am__dirstamp)
+mi/Lset_cache_size.lo: mi/$(am__dirstamp) mi/$(DEPDIR)/$(am__dirstamp)
 unwind/$(am__dirstamp):
 	@$(MKDIR_P) unwind
 	@: > unwind/$(am__dirstamp)
@@ -1926,6 +2592,37 @@ unwind/SetIP.lo: unwind/$(am__dirstamp) \
 	unwind/$(DEPDIR)/$(am__dirstamp)
 unwind/GetIPInfo.lo: unwind/$(am__dirstamp) \
 	unwind/$(DEPDIR)/$(am__dirstamp)
+s390x/Lapply_reg_state.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lreg_states_iterate.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lcreate_addr_space.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lget_save_loc.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lglobal.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Linit.lo: s390x/$(am__dirstamp) s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Linit_local.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Linit_remote.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lget_proc_info.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lregs.lo: s390x/$(am__dirstamp) s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lresume.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lis_signal_frame.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/Lstep.lo: s390x/$(am__dirstamp) s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/getcontext.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+s390x/setcontext.lo: s390x/$(am__dirstamp) \
+	s390x/$(DEPDIR)/$(am__dirstamp)
+sh/Lapply_reg_state.lo: sh/$(am__dirstamp) \
+	sh/$(DEPDIR)/$(am__dirstamp)
+sh/Lreg_states_iterate.lo: sh/$(am__dirstamp) \
+	sh/$(DEPDIR)/$(am__dirstamp)
 sh/Lcreate_addr_space.lo: sh/$(am__dirstamp) \
 	sh/$(DEPDIR)/$(am__dirstamp)
 sh/Lget_proc_info.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
@@ -1939,8 +2636,6 @@ sh/Lis_signal_frame.lo: sh/$(am__dirstamp) \
 sh/Lregs.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
 sh/Lresume.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
 sh/Lstep.lo: sh/$(am__dirstamp) sh/$(DEPDIR)/$(am__dirstamp)
-ppc/Lcreate_addr_space.lo: ppc/$(am__dirstamp) \
-	ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Lget_proc_info.lo: ppc/$(am__dirstamp) \
 	ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Lget_save_loc.lo: ppc/$(am__dirstamp) \
@@ -1949,6 +2644,12 @@ ppc/Linit_local.lo: ppc/$(am__dirstamp) ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Linit_remote.lo: ppc/$(am__dirstamp) ppc/$(DEPDIR)/$(am__dirstamp)
 ppc/Lis_signal_frame.lo: ppc/$(am__dirstamp) \
 	ppc/$(DEPDIR)/$(am__dirstamp)
+ppc64/Lapply_reg_state.lo: ppc64/$(am__dirstamp) \
+	ppc64/$(DEPDIR)/$(am__dirstamp)
+ppc64/Lreg_states_iterate.lo: ppc64/$(am__dirstamp) \
+	ppc64/$(DEPDIR)/$(am__dirstamp)
+ppc64/Lcreate_addr_space.lo: ppc64/$(am__dirstamp) \
+	ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Lglobal.lo: ppc64/$(am__dirstamp) \
 	ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Linit.lo: ppc64/$(am__dirstamp) ppc64/$(DEPDIR)/$(am__dirstamp)
@@ -1956,6 +2657,12 @@ ppc64/Lregs.lo: ppc64/$(am__dirstamp) ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Lresume.lo: ppc64/$(am__dirstamp) \
 	ppc64/$(DEPDIR)/$(am__dirstamp)
 ppc64/Lstep.lo: ppc64/$(am__dirstamp) ppc64/$(DEPDIR)/$(am__dirstamp)
+ppc32/Lapply_reg_state.lo: ppc32/$(am__dirstamp) \
+	ppc32/$(DEPDIR)/$(am__dirstamp)
+ppc32/Lreg_states_iterate.lo: ppc32/$(am__dirstamp) \
+	ppc32/$(DEPDIR)/$(am__dirstamp)
+ppc32/Lcreate_addr_space.lo: ppc32/$(am__dirstamp) \
+	ppc32/$(DEPDIR)/$(am__dirstamp)
 ppc32/Lglobal.lo: ppc32/$(am__dirstamp) \
 	ppc32/$(DEPDIR)/$(am__dirstamp)
 ppc32/Linit.lo: ppc32/$(am__dirstamp) ppc32/$(DEPDIR)/$(am__dirstamp)
@@ -1969,6 +2676,10 @@ x86_64/Los-linux.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/setcontext.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
+x86_64/Lapply_reg_state.lo: x86_64/$(am__dirstamp) \
+	x86_64/$(DEPDIR)/$(am__dirstamp)
+x86_64/Lreg_states_iterate.lo: x86_64/$(am__dirstamp) \
+	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/Lcreate_addr_space.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86_64/Lget_save_loc.lo: x86_64/$(am__dirstamp) \
@@ -1997,6 +2708,10 @@ x86_64/getcontext.lo: x86_64/$(am__dirstamp) \
 	x86_64/$(DEPDIR)/$(am__dirstamp)
 x86/Los-freebsd.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
 x86/Los-linux.lo: x86/$(am__dirstamp) x86/$(DEPDIR)/$(am__dirstamp)
+x86/Lapply_reg_state.lo: x86/$(am__dirstamp) \
+	x86/$(DEPDIR)/$(am__dirstamp)
+x86/Lreg_states_iterate.lo: x86/$(am__dirstamp) \
+	x86/$(DEPDIR)/$(am__dirstamp)
 x86/Lcreate_addr_space.lo: x86/$(am__dirstamp) \
 	x86/$(DEPDIR)/$(am__dirstamp)
 x86/Lget_save_loc.lo: x86/$(am__dirstamp) \
@@ -2014,8 +2729,40 @@ x86/getcontext-freebsd.lo: x86/$(am__dirstamp) \
 	x86/$(DEPDIR)/$(am__dirstamp)
 x86/getcontext-linux.lo: x86/$(am__dirstamp) \
 	x86/$(DEPDIR)/$(am__dirstamp)
+tilegx/getcontext.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lapply_reg_state.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lreg_states_iterate.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lcreate_addr_space.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lget_proc_info.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lget_save_loc.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lglobal.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Linit.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Linit_local.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Linit_remote.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lis_signal_frame.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lregs.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lresume.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
+tilegx/Lstep.lo: tilegx/$(am__dirstamp) \
+	tilegx/$(DEPDIR)/$(am__dirstamp)
 mips/getcontext.lo: mips/$(am__dirstamp) \
 	mips/$(DEPDIR)/$(am__dirstamp)
+mips/Lapply_reg_state.lo: mips/$(am__dirstamp) \
+	mips/$(DEPDIR)/$(am__dirstamp)
+mips/Lreg_states_iterate.lo: mips/$(am__dirstamp) \
+	mips/$(DEPDIR)/$(am__dirstamp)
 mips/Lcreate_addr_space.lo: mips/$(am__dirstamp) \
 	mips/$(DEPDIR)/$(am__dirstamp)
 mips/Lget_proc_info.lo: mips/$(am__dirstamp) \
@@ -2037,6 +2784,10 @@ hppa/getcontext.lo: hppa/$(am__dirstamp) \
 	hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/setcontext.lo: hppa/$(am__dirstamp) \
 	hppa/$(DEPDIR)/$(am__dirstamp)
+hppa/Lapply_reg_state.lo: hppa/$(am__dirstamp) \
+	hppa/$(DEPDIR)/$(am__dirstamp)
+hppa/Lreg_states_iterate.lo: hppa/$(am__dirstamp) \
+	hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/Lcreate_addr_space.lo: hppa/$(am__dirstamp) \
 	hppa/$(DEPDIR)/$(am__dirstamp)
 hppa/Lget_save_loc.lo: hppa/$(am__dirstamp) \
@@ -2058,6 +2809,10 @@ ia64/dyn_info_list.lo: ia64/$(am__dirstamp) \
 	ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/getcontext.lo: ia64/$(am__dirstamp) \
 	ia64/$(DEPDIR)/$(am__dirstamp)
+ia64/Lapply_reg_state.lo: ia64/$(am__dirstamp) \
+	ia64/$(DEPDIR)/$(am__dirstamp)
+ia64/Lreg_states_iterate.lo: ia64/$(am__dirstamp) \
+	ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Lcreate_addr_space.lo: ia64/$(am__dirstamp) \
 	ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Lget_proc_info.lo: ia64/$(am__dirstamp) \
@@ -2083,7 +2838,14 @@ ia64/Lstep.lo: ia64/$(am__dirstamp) ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Ltables.lo: ia64/$(am__dirstamp) ia64/$(DEPDIR)/$(am__dirstamp)
 ia64/Lfind_unwind_table.lo: ia64/$(am__dirstamp) \
 	ia64/$(DEPDIR)/$(am__dirstamp)
+arm/Los-freebsd.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Los-linux.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Los-other.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/getcontext.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Lapply_reg_state.lo: arm/$(am__dirstamp) \
+	arm/$(DEPDIR)/$(am__dirstamp)
+arm/Lreg_states_iterate.lo: arm/$(am__dirstamp) \
+	arm/$(DEPDIR)/$(am__dirstamp)
 arm/Lcreate_addr_space.lo: arm/$(am__dirstamp) \
 	arm/$(DEPDIR)/$(am__dirstamp)
 arm/Lget_proc_info.lo: arm/$(am__dirstamp) \
@@ -2094,711 +2856,88 @@ arm/Lglobal.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Linit.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Linit_local.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Linit_remote.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
-arm/Lis_signal_frame.lo: arm/$(am__dirstamp) \
-	arm/$(DEPDIR)/$(am__dirstamp)
 arm/Lregs.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Lresume.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Lstep.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
 arm/Lex_tables.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Lstash_frame.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+arm/Ltrace.lo: arm/$(am__dirstamp) arm/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lapply_reg_state.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lreg_states_iterate.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lcreate_addr_space.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lget_proc_info.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lget_save_loc.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lglobal.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Linit.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Linit_local.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Linit_remote.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lis_signal_frame.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lregs.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lresume.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lstash_frame.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Lstep.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/Ltrace.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+aarch64/getcontext.lo: aarch64/$(am__dirstamp) \
+	aarch64/$(DEPDIR)/$(am__dirstamp)
+
 libunwind.la: $(libunwind_la_OBJECTS) $(libunwind_la_DEPENDENCIES) $(EXTRA_libunwind_la_DEPENDENCIES) 
-	$(libunwind_la_LINK) $(am_libunwind_la_rpath) $(libunwind_la_OBJECTS) $(libunwind_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libunwind_la_LINK) $(am_libunwind_la_rpath) $(libunwind_la_OBJECTS) $(libunwind_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
-	-rm -f arm/Gcreate_addr_space.$(OBJEXT)
-	-rm -f arm/Gcreate_addr_space.lo
-	-rm -f arm/Gex_tables.$(OBJEXT)
-	-rm -f arm/Gex_tables.lo
-	-rm -f arm/Gget_proc_info.$(OBJEXT)
-	-rm -f arm/Gget_proc_info.lo
-	-rm -f arm/Gget_save_loc.$(OBJEXT)
-	-rm -f arm/Gget_save_loc.lo
-	-rm -f arm/Gglobal.$(OBJEXT)
-	-rm -f arm/Gglobal.lo
-	-rm -f arm/Ginit.$(OBJEXT)
-	-rm -f arm/Ginit.lo
-	-rm -f arm/Ginit_local.$(OBJEXT)
-	-rm -f arm/Ginit_local.lo
-	-rm -f arm/Ginit_remote.$(OBJEXT)
-	-rm -f arm/Ginit_remote.lo
-	-rm -f arm/Gis_signal_frame.$(OBJEXT)
-	-rm -f arm/Gis_signal_frame.lo
-	-rm -f arm/Gregs.$(OBJEXT)
-	-rm -f arm/Gregs.lo
-	-rm -f arm/Gresume.$(OBJEXT)
-	-rm -f arm/Gresume.lo
-	-rm -f arm/Gstep.$(OBJEXT)
-	-rm -f arm/Gstep.lo
-	-rm -f arm/Lcreate_addr_space.$(OBJEXT)
-	-rm -f arm/Lcreate_addr_space.lo
-	-rm -f arm/Lex_tables.$(OBJEXT)
-	-rm -f arm/Lex_tables.lo
-	-rm -f arm/Lget_proc_info.$(OBJEXT)
-	-rm -f arm/Lget_proc_info.lo
-	-rm -f arm/Lget_save_loc.$(OBJEXT)
-	-rm -f arm/Lget_save_loc.lo
-	-rm -f arm/Lglobal.$(OBJEXT)
-	-rm -f arm/Lglobal.lo
-	-rm -f arm/Linit.$(OBJEXT)
-	-rm -f arm/Linit.lo
-	-rm -f arm/Linit_local.$(OBJEXT)
-	-rm -f arm/Linit_local.lo
-	-rm -f arm/Linit_remote.$(OBJEXT)
-	-rm -f arm/Linit_remote.lo
-	-rm -f arm/Lis_signal_frame.$(OBJEXT)
-	-rm -f arm/Lis_signal_frame.lo
-	-rm -f arm/Lregs.$(OBJEXT)
-	-rm -f arm/Lregs.lo
-	-rm -f arm/Lresume.$(OBJEXT)
-	-rm -f arm/Lresume.lo
-	-rm -f arm/Lstep.$(OBJEXT)
-	-rm -f arm/Lstep.lo
-	-rm -f arm/getcontext.$(OBJEXT)
-	-rm -f arm/getcontext.lo
-	-rm -f arm/is_fpreg.$(OBJEXT)
-	-rm -f arm/is_fpreg.lo
-	-rm -f arm/regname.$(OBJEXT)
-	-rm -f arm/regname.lo
-	-rm -f arm/siglongjmp.$(OBJEXT)
-	-rm -f arm/siglongjmp.lo
-	-rm -f coredump/_UCD_access_mem.$(OBJEXT)
-	-rm -f coredump/_UCD_access_mem.lo
-	-rm -f coredump/_UCD_access_reg_freebsd.$(OBJEXT)
-	-rm -f coredump/_UCD_access_reg_freebsd.lo
-	-rm -f coredump/_UCD_access_reg_linux.$(OBJEXT)
-	-rm -f coredump/_UCD_access_reg_linux.lo
-	-rm -f coredump/_UCD_accessors.$(OBJEXT)
-	-rm -f coredump/_UCD_accessors.lo
-	-rm -f coredump/_UCD_create.$(OBJEXT)
-	-rm -f coredump/_UCD_create.lo
-	-rm -f coredump/_UCD_destroy.$(OBJEXT)
-	-rm -f coredump/_UCD_destroy.lo
-	-rm -f coredump/_UCD_elf_map_image.$(OBJEXT)
-	-rm -f coredump/_UCD_elf_map_image.lo
-	-rm -f coredump/_UCD_find_proc_info.$(OBJEXT)
-	-rm -f coredump/_UCD_find_proc_info.lo
-	-rm -f coredump/_UCD_get_proc_name.$(OBJEXT)
-	-rm -f coredump/_UCD_get_proc_name.lo
-	-rm -f coredump/_UPT_access_fpreg.$(OBJEXT)
-	-rm -f coredump/_UPT_access_fpreg.lo
-	-rm -f coredump/_UPT_elf.$(OBJEXT)
-	-rm -f coredump/_UPT_elf.lo
-	-rm -f coredump/_UPT_get_dyn_info_list_addr.$(OBJEXT)
-	-rm -f coredump/_UPT_get_dyn_info_list_addr.lo
-	-rm -f coredump/_UPT_put_unwind_info.$(OBJEXT)
-	-rm -f coredump/_UPT_put_unwind_info.lo
-	-rm -f coredump/_UPT_resume.$(OBJEXT)
-	-rm -f coredump/_UPT_resume.lo
-	-rm -f dwarf/Gexpr.$(OBJEXT)
-	-rm -f dwarf/Gexpr.lo
-	-rm -f dwarf/Gfde.$(OBJEXT)
-	-rm -f dwarf/Gfde.lo
-	-rm -f dwarf/Gfind_proc_info-lsb.$(OBJEXT)
-	-rm -f dwarf/Gfind_proc_info-lsb.lo
-	-rm -f dwarf/Gfind_unwind_table.$(OBJEXT)
-	-rm -f dwarf/Gfind_unwind_table.lo
-	-rm -f dwarf/Gparser.$(OBJEXT)
-	-rm -f dwarf/Gparser.lo
-	-rm -f dwarf/Gpe.$(OBJEXT)
-	-rm -f dwarf/Gpe.lo
-	-rm -f dwarf/Gstep.$(OBJEXT)
-	-rm -f dwarf/Gstep.lo
-	-rm -f dwarf/Lexpr.$(OBJEXT)
-	-rm -f dwarf/Lexpr.lo
-	-rm -f dwarf/Lfde.$(OBJEXT)
-	-rm -f dwarf/Lfde.lo
-	-rm -f dwarf/Lfind_proc_info-lsb.$(OBJEXT)
-	-rm -f dwarf/Lfind_proc_info-lsb.lo
-	-rm -f dwarf/Lfind_unwind_table.$(OBJEXT)
-	-rm -f dwarf/Lfind_unwind_table.lo
-	-rm -f dwarf/Lparser.$(OBJEXT)
-	-rm -f dwarf/Lparser.lo
-	-rm -f dwarf/Lpe.$(OBJEXT)
-	-rm -f dwarf/Lpe.lo
-	-rm -f dwarf/Lstep.$(OBJEXT)
-	-rm -f dwarf/Lstep.lo
-	-rm -f dwarf/global.$(OBJEXT)
-	-rm -f dwarf/global.lo
-	-rm -f hppa/Gcreate_addr_space.$(OBJEXT)
-	-rm -f hppa/Gcreate_addr_space.lo
-	-rm -f hppa/Gget_proc_info.$(OBJEXT)
-	-rm -f hppa/Gget_proc_info.lo
-	-rm -f hppa/Gget_save_loc.$(OBJEXT)
-	-rm -f hppa/Gget_save_loc.lo
-	-rm -f hppa/Gglobal.$(OBJEXT)
-	-rm -f hppa/Gglobal.lo
-	-rm -f hppa/Ginit.$(OBJEXT)
-	-rm -f hppa/Ginit.lo
-	-rm -f hppa/Ginit_local.$(OBJEXT)
-	-rm -f hppa/Ginit_local.lo
-	-rm -f hppa/Ginit_remote.$(OBJEXT)
-	-rm -f hppa/Ginit_remote.lo
-	-rm -f hppa/Gis_signal_frame.$(OBJEXT)
-	-rm -f hppa/Gis_signal_frame.lo
-	-rm -f hppa/Gregs.$(OBJEXT)
-	-rm -f hppa/Gregs.lo
-	-rm -f hppa/Gresume.$(OBJEXT)
-	-rm -f hppa/Gresume.lo
-	-rm -f hppa/Gstep.$(OBJEXT)
-	-rm -f hppa/Gstep.lo
-	-rm -f hppa/Lcreate_addr_space.$(OBJEXT)
-	-rm -f hppa/Lcreate_addr_space.lo
-	-rm -f hppa/Lget_proc_info.$(OBJEXT)
-	-rm -f hppa/Lget_proc_info.lo
-	-rm -f hppa/Lget_save_loc.$(OBJEXT)
-	-rm -f hppa/Lget_save_loc.lo
-	-rm -f hppa/Lglobal.$(OBJEXT)
-	-rm -f hppa/Lglobal.lo
-	-rm -f hppa/Linit.$(OBJEXT)
-	-rm -f hppa/Linit.lo
-	-rm -f hppa/Linit_local.$(OBJEXT)
-	-rm -f hppa/Linit_local.lo
-	-rm -f hppa/Linit_remote.$(OBJEXT)
-	-rm -f hppa/Linit_remote.lo
-	-rm -f hppa/Lis_signal_frame.$(OBJEXT)
-	-rm -f hppa/Lis_signal_frame.lo
-	-rm -f hppa/Lregs.$(OBJEXT)
-	-rm -f hppa/Lregs.lo
-	-rm -f hppa/Lresume.$(OBJEXT)
-	-rm -f hppa/Lresume.lo
-	-rm -f hppa/Lstep.$(OBJEXT)
-	-rm -f hppa/Lstep.lo
-	-rm -f hppa/getcontext.$(OBJEXT)
-	-rm -f hppa/getcontext.lo
-	-rm -f hppa/regname.$(OBJEXT)
-	-rm -f hppa/regname.lo
-	-rm -f hppa/setcontext.$(OBJEXT)
-	-rm -f hppa/setcontext.lo
-	-rm -f hppa/siglongjmp.$(OBJEXT)
-	-rm -f hppa/siglongjmp.lo
-	-rm -f ia64/Gcreate_addr_space.$(OBJEXT)
-	-rm -f ia64/Gcreate_addr_space.lo
-	-rm -f ia64/Gfind_unwind_table.$(OBJEXT)
-	-rm -f ia64/Gfind_unwind_table.lo
-	-rm -f ia64/Gget_proc_info.$(OBJEXT)
-	-rm -f ia64/Gget_proc_info.lo
-	-rm -f ia64/Gget_save_loc.$(OBJEXT)
-	-rm -f ia64/Gget_save_loc.lo
-	-rm -f ia64/Gglobal.$(OBJEXT)
-	-rm -f ia64/Gglobal.lo
-	-rm -f ia64/Ginit.$(OBJEXT)
-	-rm -f ia64/Ginit.lo
-	-rm -f ia64/Ginit_local.$(OBJEXT)
-	-rm -f ia64/Ginit_local.lo
-	-rm -f ia64/Ginit_remote.$(OBJEXT)
-	-rm -f ia64/Ginit_remote.lo
-	-rm -f ia64/Ginstall_cursor.$(OBJEXT)
-	-rm -f ia64/Ginstall_cursor.lo
-	-rm -f ia64/Gis_signal_frame.$(OBJEXT)
-	-rm -f ia64/Gis_signal_frame.lo
-	-rm -f ia64/Gparser.$(OBJEXT)
-	-rm -f ia64/Gparser.lo
-	-rm -f ia64/Grbs.$(OBJEXT)
-	-rm -f ia64/Grbs.lo
-	-rm -f ia64/Gregs.$(OBJEXT)
-	-rm -f ia64/Gregs.lo
-	-rm -f ia64/Gresume.$(OBJEXT)
-	-rm -f ia64/Gresume.lo
-	-rm -f ia64/Gscript.$(OBJEXT)
-	-rm -f ia64/Gscript.lo
-	-rm -f ia64/Gstep.$(OBJEXT)
-	-rm -f ia64/Gstep.lo
-	-rm -f ia64/Gtables.$(OBJEXT)
-	-rm -f ia64/Gtables.lo
-	-rm -f ia64/Lcreate_addr_space.$(OBJEXT)
-	-rm -f ia64/Lcreate_addr_space.lo
-	-rm -f ia64/Lfind_unwind_table.$(OBJEXT)
-	-rm -f ia64/Lfind_unwind_table.lo
-	-rm -f ia64/Lget_proc_info.$(OBJEXT)
-	-rm -f ia64/Lget_proc_info.lo
-	-rm -f ia64/Lget_save_loc.$(OBJEXT)
-	-rm -f ia64/Lget_save_loc.lo
-	-rm -f ia64/Lglobal.$(OBJEXT)
-	-rm -f ia64/Lglobal.lo
-	-rm -f ia64/Linit.$(OBJEXT)
-	-rm -f ia64/Linit.lo
-	-rm -f ia64/Linit_local.$(OBJEXT)
-	-rm -f ia64/Linit_local.lo
-	-rm -f ia64/Linit_remote.$(OBJEXT)
-	-rm -f ia64/Linit_remote.lo
-	-rm -f ia64/Linstall_cursor.$(OBJEXT)
-	-rm -f ia64/Linstall_cursor.lo
-	-rm -f ia64/Lis_signal_frame.$(OBJEXT)
-	-rm -f ia64/Lis_signal_frame.lo
-	-rm -f ia64/Lparser.$(OBJEXT)
-	-rm -f ia64/Lparser.lo
-	-rm -f ia64/Lrbs.$(OBJEXT)
-	-rm -f ia64/Lrbs.lo
-	-rm -f ia64/Lregs.$(OBJEXT)
-	-rm -f ia64/Lregs.lo
-	-rm -f ia64/Lresume.$(OBJEXT)
-	-rm -f ia64/Lresume.lo
-	-rm -f ia64/Lscript.$(OBJEXT)
-	-rm -f ia64/Lscript.lo
-	-rm -f ia64/Lstep.$(OBJEXT)
-	-rm -f ia64/Lstep.lo
-	-rm -f ia64/Ltables.$(OBJEXT)
-	-rm -f ia64/Ltables.lo
-	-rm -f ia64/dyn_info_list.$(OBJEXT)
-	-rm -f ia64/dyn_info_list.lo
-	-rm -f ia64/getcontext.$(OBJEXT)
-	-rm -f ia64/getcontext.lo
-	-rm -f ia64/longjmp.$(OBJEXT)
-	-rm -f ia64/longjmp.lo
-	-rm -f ia64/regname.$(OBJEXT)
-	-rm -f ia64/regname.lo
-	-rm -f ia64/setjmp.$(OBJEXT)
-	-rm -f ia64/setjmp.lo
-	-rm -f ia64/siglongjmp.$(OBJEXT)
-	-rm -f ia64/siglongjmp.lo
-	-rm -f ia64/sigsetjmp.$(OBJEXT)
-	-rm -f ia64/sigsetjmp.lo
-	-rm -f mi/Gdestroy_addr_space.$(OBJEXT)
-	-rm -f mi/Gdestroy_addr_space.lo
-	-rm -f mi/Gdyn-extract.$(OBJEXT)
-	-rm -f mi/Gdyn-extract.lo
-	-rm -f mi/Gdyn-remote.$(OBJEXT)
-	-rm -f mi/Gdyn-remote.lo
-	-rm -f mi/Gfind_dynamic_proc_info.$(OBJEXT)
-	-rm -f mi/Gfind_dynamic_proc_info.lo
-	-rm -f mi/Gget_accessors.$(OBJEXT)
-	-rm -f mi/Gget_accessors.lo
-	-rm -f mi/Gget_fpreg.$(OBJEXT)
-	-rm -f mi/Gget_fpreg.lo
-	-rm -f mi/Gget_proc_info_by_ip.$(OBJEXT)
-	-rm -f mi/Gget_proc_info_by_ip.lo
-	-rm -f mi/Gget_proc_name.$(OBJEXT)
-	-rm -f mi/Gget_proc_name.lo
-	-rm -f mi/Gget_reg.$(OBJEXT)
-	-rm -f mi/Gget_reg.lo
-	-rm -f mi/Gput_dynamic_unwind_info.$(OBJEXT)
-	-rm -f mi/Gput_dynamic_unwind_info.lo
-	-rm -f mi/Gset_caching_policy.$(OBJEXT)
-	-rm -f mi/Gset_caching_policy.lo
-	-rm -f mi/Gset_fpreg.$(OBJEXT)
-	-rm -f mi/Gset_fpreg.lo
-	-rm -f mi/Gset_reg.$(OBJEXT)
-	-rm -f mi/Gset_reg.lo
-	-rm -f mi/Ldestroy_addr_space.$(OBJEXT)
-	-rm -f mi/Ldestroy_addr_space.lo
-	-rm -f mi/Ldyn-extract.$(OBJEXT)
-	-rm -f mi/Ldyn-extract.lo
-	-rm -f mi/Lfind_dynamic_proc_info.$(OBJEXT)
-	-rm -f mi/Lfind_dynamic_proc_info.lo
-	-rm -f mi/Lget_accessors.$(OBJEXT)
-	-rm -f mi/Lget_accessors.lo
-	-rm -f mi/Lget_fpreg.$(OBJEXT)
-	-rm -f mi/Lget_fpreg.lo
-	-rm -f mi/Lget_proc_info_by_ip.$(OBJEXT)
-	-rm -f mi/Lget_proc_info_by_ip.lo
-	-rm -f mi/Lget_proc_name.$(OBJEXT)
-	-rm -f mi/Lget_proc_name.lo
-	-rm -f mi/Lget_reg.$(OBJEXT)
-	-rm -f mi/Lget_reg.lo
-	-rm -f mi/Lput_dynamic_unwind_info.$(OBJEXT)
-	-rm -f mi/Lput_dynamic_unwind_info.lo
-	-rm -f mi/Lset_caching_policy.$(OBJEXT)
-	-rm -f mi/Lset_caching_policy.lo
-	-rm -f mi/Lset_fpreg.$(OBJEXT)
-	-rm -f mi/Lset_fpreg.lo
-	-rm -f mi/Lset_reg.$(OBJEXT)
-	-rm -f mi/Lset_reg.lo
-	-rm -f mi/_ReadSLEB.$(OBJEXT)
-	-rm -f mi/_ReadSLEB.lo
-	-rm -f mi/_ReadULEB.$(OBJEXT)
-	-rm -f mi/_ReadULEB.lo
-	-rm -f mi/backtrace.$(OBJEXT)
-	-rm -f mi/backtrace.lo
-	-rm -f mi/dyn-cancel.$(OBJEXT)
-	-rm -f mi/dyn-cancel.lo
-	-rm -f mi/dyn-info-list.$(OBJEXT)
-	-rm -f mi/dyn-info-list.lo
-	-rm -f mi/dyn-register.$(OBJEXT)
-	-rm -f mi/dyn-register.lo
-	-rm -f mi/flush_cache.$(OBJEXT)
-	-rm -f mi/flush_cache.lo
-	-rm -f mi/init.$(OBJEXT)
-	-rm -f mi/init.lo
-	-rm -f mi/mempool.$(OBJEXT)
-	-rm -f mi/mempool.lo
-	-rm -f mi/strerror.$(OBJEXT)
-	-rm -f mi/strerror.lo
-	-rm -f mips/Gcreate_addr_space.$(OBJEXT)
-	-rm -f mips/Gcreate_addr_space.lo
-	-rm -f mips/Gget_proc_info.$(OBJEXT)
-	-rm -f mips/Gget_proc_info.lo
-	-rm -f mips/Gget_save_loc.$(OBJEXT)
-	-rm -f mips/Gget_save_loc.lo
-	-rm -f mips/Gglobal.$(OBJEXT)
-	-rm -f mips/Gglobal.lo
-	-rm -f mips/Ginit.$(OBJEXT)
-	-rm -f mips/Ginit.lo
-	-rm -f mips/Ginit_local.$(OBJEXT)
-	-rm -f mips/Ginit_local.lo
-	-rm -f mips/Ginit_remote.$(OBJEXT)
-	-rm -f mips/Ginit_remote.lo
-	-rm -f mips/Gis_signal_frame.$(OBJEXT)
-	-rm -f mips/Gis_signal_frame.lo
-	-rm -f mips/Gregs.$(OBJEXT)
-	-rm -f mips/Gregs.lo
-	-rm -f mips/Gresume.$(OBJEXT)
-	-rm -f mips/Gresume.lo
-	-rm -f mips/Gstep.$(OBJEXT)
-	-rm -f mips/Gstep.lo
-	-rm -f mips/Lcreate_addr_space.$(OBJEXT)
-	-rm -f mips/Lcreate_addr_space.lo
-	-rm -f mips/Lget_proc_info.$(OBJEXT)
-	-rm -f mips/Lget_proc_info.lo
-	-rm -f mips/Lget_save_loc.$(OBJEXT)
-	-rm -f mips/Lget_save_loc.lo
-	-rm -f mips/Lglobal.$(OBJEXT)
-	-rm -f mips/Lglobal.lo
-	-rm -f mips/Linit.$(OBJEXT)
-	-rm -f mips/Linit.lo
-	-rm -f mips/Linit_local.$(OBJEXT)
-	-rm -f mips/Linit_local.lo
-	-rm -f mips/Linit_remote.$(OBJEXT)
-	-rm -f mips/Linit_remote.lo
-	-rm -f mips/Lis_signal_frame.$(OBJEXT)
-	-rm -f mips/Lis_signal_frame.lo
-	-rm -f mips/Lregs.$(OBJEXT)
-	-rm -f mips/Lregs.lo
-	-rm -f mips/Lresume.$(OBJEXT)
-	-rm -f mips/Lresume.lo
-	-rm -f mips/Lstep.$(OBJEXT)
-	-rm -f mips/Lstep.lo
-	-rm -f mips/getcontext.$(OBJEXT)
-	-rm -f mips/getcontext.lo
-	-rm -f mips/is_fpreg.$(OBJEXT)
-	-rm -f mips/is_fpreg.lo
-	-rm -f mips/regname.$(OBJEXT)
-	-rm -f mips/regname.lo
-	-rm -f mips/siglongjmp.$(OBJEXT)
-	-rm -f mips/siglongjmp.lo
-	-rm -f ppc/Gcreate_addr_space.$(OBJEXT)
-	-rm -f ppc/Gcreate_addr_space.lo
-	-rm -f ppc/Gget_proc_info.$(OBJEXT)
-	-rm -f ppc/Gget_proc_info.lo
-	-rm -f ppc/Gget_save_loc.$(OBJEXT)
-	-rm -f ppc/Gget_save_loc.lo
-	-rm -f ppc/Ginit_local.$(OBJEXT)
-	-rm -f ppc/Ginit_local.lo
-	-rm -f ppc/Ginit_remote.$(OBJEXT)
-	-rm -f ppc/Ginit_remote.lo
-	-rm -f ppc/Gis_signal_frame.$(OBJEXT)
-	-rm -f ppc/Gis_signal_frame.lo
-	-rm -f ppc/Lcreate_addr_space.$(OBJEXT)
-	-rm -f ppc/Lcreate_addr_space.lo
-	-rm -f ppc/Lget_proc_info.$(OBJEXT)
-	-rm -f ppc/Lget_proc_info.lo
-	-rm -f ppc/Lget_save_loc.$(OBJEXT)
-	-rm -f ppc/Lget_save_loc.lo
-	-rm -f ppc/Linit_local.$(OBJEXT)
-	-rm -f ppc/Linit_local.lo
-	-rm -f ppc/Linit_remote.$(OBJEXT)
-	-rm -f ppc/Linit_remote.lo
-	-rm -f ppc/Lis_signal_frame.$(OBJEXT)
-	-rm -f ppc/Lis_signal_frame.lo
-	-rm -f ppc/longjmp.$(OBJEXT)
-	-rm -f ppc/longjmp.lo
-	-rm -f ppc/siglongjmp.$(OBJEXT)
-	-rm -f ppc/siglongjmp.lo
-	-rm -f ppc32/Gglobal.$(OBJEXT)
-	-rm -f ppc32/Gglobal.lo
-	-rm -f ppc32/Ginit.$(OBJEXT)
-	-rm -f ppc32/Ginit.lo
-	-rm -f ppc32/Gregs.$(OBJEXT)
-	-rm -f ppc32/Gregs.lo
-	-rm -f ppc32/Gresume.$(OBJEXT)
-	-rm -f ppc32/Gresume.lo
-	-rm -f ppc32/Gstep.$(OBJEXT)
-	-rm -f ppc32/Gstep.lo
-	-rm -f ppc32/Lglobal.$(OBJEXT)
-	-rm -f ppc32/Lglobal.lo
-	-rm -f ppc32/Linit.$(OBJEXT)
-	-rm -f ppc32/Linit.lo
-	-rm -f ppc32/Lregs.$(OBJEXT)
-	-rm -f ppc32/Lregs.lo
-	-rm -f ppc32/Lresume.$(OBJEXT)
-	-rm -f ppc32/Lresume.lo
-	-rm -f ppc32/Lstep.$(OBJEXT)
-	-rm -f ppc32/Lstep.lo
-	-rm -f ppc32/get_func_addr.$(OBJEXT)
-	-rm -f ppc32/get_func_addr.lo
-	-rm -f ppc32/is_fpreg.$(OBJEXT)
-	-rm -f ppc32/is_fpreg.lo
-	-rm -f ppc32/regname.$(OBJEXT)
-	-rm -f ppc32/regname.lo
-	-rm -f ppc64/Gglobal.$(OBJEXT)
-	-rm -f ppc64/Gglobal.lo
-	-rm -f ppc64/Ginit.$(OBJEXT)
-	-rm -f ppc64/Ginit.lo
-	-rm -f ppc64/Gregs.$(OBJEXT)
-	-rm -f ppc64/Gregs.lo
-	-rm -f ppc64/Gresume.$(OBJEXT)
-	-rm -f ppc64/Gresume.lo
-	-rm -f ppc64/Gstep.$(OBJEXT)
-	-rm -f ppc64/Gstep.lo
-	-rm -f ppc64/Lglobal.$(OBJEXT)
-	-rm -f ppc64/Lglobal.lo
-	-rm -f ppc64/Linit.$(OBJEXT)
-	-rm -f ppc64/Linit.lo
-	-rm -f ppc64/Lregs.$(OBJEXT)
-	-rm -f ppc64/Lregs.lo
-	-rm -f ppc64/Lresume.$(OBJEXT)
-	-rm -f ppc64/Lresume.lo
-	-rm -f ppc64/Lstep.$(OBJEXT)
-	-rm -f ppc64/Lstep.lo
-	-rm -f ppc64/get_func_addr.$(OBJEXT)
-	-rm -f ppc64/get_func_addr.lo
-	-rm -f ppc64/is_fpreg.$(OBJEXT)
-	-rm -f ppc64/is_fpreg.lo
-	-rm -f ppc64/regname.$(OBJEXT)
-	-rm -f ppc64/regname.lo
-	-rm -f ptrace/_UPT_access_fpreg.$(OBJEXT)
-	-rm -f ptrace/_UPT_access_fpreg.lo
-	-rm -f ptrace/_UPT_access_mem.$(OBJEXT)
-	-rm -f ptrace/_UPT_access_mem.lo
-	-rm -f ptrace/_UPT_access_reg.$(OBJEXT)
-	-rm -f ptrace/_UPT_access_reg.lo
-	-rm -f ptrace/_UPT_accessors.$(OBJEXT)
-	-rm -f ptrace/_UPT_accessors.lo
-	-rm -f ptrace/_UPT_create.$(OBJEXT)
-	-rm -f ptrace/_UPT_create.lo
-	-rm -f ptrace/_UPT_destroy.$(OBJEXT)
-	-rm -f ptrace/_UPT_destroy.lo
-	-rm -f ptrace/_UPT_elf.$(OBJEXT)
-	-rm -f ptrace/_UPT_elf.lo
-	-rm -f ptrace/_UPT_find_proc_info.$(OBJEXT)
-	-rm -f ptrace/_UPT_find_proc_info.lo
-	-rm -f ptrace/_UPT_get_dyn_info_list_addr.$(OBJEXT)
-	-rm -f ptrace/_UPT_get_dyn_info_list_addr.lo
-	-rm -f ptrace/_UPT_get_proc_name.$(OBJEXT)
-	-rm -f ptrace/_UPT_get_proc_name.lo
-	-rm -f ptrace/_UPT_put_unwind_info.$(OBJEXT)
-	-rm -f ptrace/_UPT_put_unwind_info.lo
-	-rm -f ptrace/_UPT_reg_offset.$(OBJEXT)
-	-rm -f ptrace/_UPT_reg_offset.lo
-	-rm -f ptrace/_UPT_resume.$(OBJEXT)
-	-rm -f ptrace/_UPT_resume.lo
-	-rm -f setjmp/longjmp.$(OBJEXT)
-	-rm -f setjmp/longjmp.lo
-	-rm -f setjmp/siglongjmp.$(OBJEXT)
-	-rm -f setjmp/siglongjmp.lo
-	-rm -f sh/Gcreate_addr_space.$(OBJEXT)
-	-rm -f sh/Gcreate_addr_space.lo
-	-rm -f sh/Gget_proc_info.$(OBJEXT)
-	-rm -f sh/Gget_proc_info.lo
-	-rm -f sh/Gget_save_loc.$(OBJEXT)
-	-rm -f sh/Gget_save_loc.lo
-	-rm -f sh/Gglobal.$(OBJEXT)
-	-rm -f sh/Gglobal.lo
-	-rm -f sh/Ginit.$(OBJEXT)
-	-rm -f sh/Ginit.lo
-	-rm -f sh/Ginit_local.$(OBJEXT)
-	-rm -f sh/Ginit_local.lo
-	-rm -f sh/Ginit_remote.$(OBJEXT)
-	-rm -f sh/Ginit_remote.lo
-	-rm -f sh/Gis_signal_frame.$(OBJEXT)
-	-rm -f sh/Gis_signal_frame.lo
-	-rm -f sh/Gregs.$(OBJEXT)
-	-rm -f sh/Gregs.lo
-	-rm -f sh/Gresume.$(OBJEXT)
-	-rm -f sh/Gresume.lo
-	-rm -f sh/Gstep.$(OBJEXT)
-	-rm -f sh/Gstep.lo
-	-rm -f sh/Lcreate_addr_space.$(OBJEXT)
-	-rm -f sh/Lcreate_addr_space.lo
-	-rm -f sh/Lget_proc_info.$(OBJEXT)
-	-rm -f sh/Lget_proc_info.lo
-	-rm -f sh/Lget_save_loc.$(OBJEXT)
-	-rm -f sh/Lget_save_loc.lo
-	-rm -f sh/Lglobal.$(OBJEXT)
-	-rm -f sh/Lglobal.lo
-	-rm -f sh/Linit.$(OBJEXT)
-	-rm -f sh/Linit.lo
-	-rm -f sh/Linit_local.$(OBJEXT)
-	-rm -f sh/Linit_local.lo
-	-rm -f sh/Linit_remote.$(OBJEXT)
-	-rm -f sh/Linit_remote.lo
-	-rm -f sh/Lis_signal_frame.$(OBJEXT)
-	-rm -f sh/Lis_signal_frame.lo
-	-rm -f sh/Lregs.$(OBJEXT)
-	-rm -f sh/Lregs.lo
-	-rm -f sh/Lresume.$(OBJEXT)
-	-rm -f sh/Lresume.lo
-	-rm -f sh/Lstep.$(OBJEXT)
-	-rm -f sh/Lstep.lo
-	-rm -f sh/is_fpreg.$(OBJEXT)
-	-rm -f sh/is_fpreg.lo
-	-rm -f sh/regname.$(OBJEXT)
-	-rm -f sh/regname.lo
-	-rm -f sh/siglongjmp.$(OBJEXT)
-	-rm -f sh/siglongjmp.lo
-	-rm -f unwind/Backtrace.$(OBJEXT)
-	-rm -f unwind/Backtrace.lo
-	-rm -f unwind/DeleteException.$(OBJEXT)
-	-rm -f unwind/DeleteException.lo
-	-rm -f unwind/FindEnclosingFunction.$(OBJEXT)
-	-rm -f unwind/FindEnclosingFunction.lo
-	-rm -f unwind/ForcedUnwind.$(OBJEXT)
-	-rm -f unwind/ForcedUnwind.lo
-	-rm -f unwind/GetBSP.$(OBJEXT)
-	-rm -f unwind/GetBSP.lo
-	-rm -f unwind/GetCFA.$(OBJEXT)
-	-rm -f unwind/GetCFA.lo
-	-rm -f unwind/GetDataRelBase.$(OBJEXT)
-	-rm -f unwind/GetDataRelBase.lo
-	-rm -f unwind/GetGR.$(OBJEXT)
-	-rm -f unwind/GetGR.lo
-	-rm -f unwind/GetIP.$(OBJEXT)
-	-rm -f unwind/GetIP.lo
-	-rm -f unwind/GetIPInfo.$(OBJEXT)
-	-rm -f unwind/GetIPInfo.lo
-	-rm -f unwind/GetLanguageSpecificData.$(OBJEXT)
-	-rm -f unwind/GetLanguageSpecificData.lo
-	-rm -f unwind/GetRegionStart.$(OBJEXT)
-	-rm -f unwind/GetRegionStart.lo
-	-rm -f unwind/GetTextRelBase.$(OBJEXT)
-	-rm -f unwind/GetTextRelBase.lo
-	-rm -f unwind/RaiseException.$(OBJEXT)
-	-rm -f unwind/RaiseException.lo
-	-rm -f unwind/Resume.$(OBJEXT)
-	-rm -f unwind/Resume.lo
-	-rm -f unwind/Resume_or_Rethrow.$(OBJEXT)
-	-rm -f unwind/Resume_or_Rethrow.lo
-	-rm -f unwind/SetGR.$(OBJEXT)
-	-rm -f unwind/SetGR.lo
-	-rm -f unwind/SetIP.$(OBJEXT)
-	-rm -f unwind/SetIP.lo
-	-rm -f x86/Gcreate_addr_space.$(OBJEXT)
-	-rm -f x86/Gcreate_addr_space.lo
-	-rm -f x86/Gget_proc_info.$(OBJEXT)
-	-rm -f x86/Gget_proc_info.lo
-	-rm -f x86/Gget_save_loc.$(OBJEXT)
-	-rm -f x86/Gget_save_loc.lo
-	-rm -f x86/Gglobal.$(OBJEXT)
-	-rm -f x86/Gglobal.lo
-	-rm -f x86/Ginit.$(OBJEXT)
-	-rm -f x86/Ginit.lo
-	-rm -f x86/Ginit_local.$(OBJEXT)
-	-rm -f x86/Ginit_local.lo
-	-rm -f x86/Ginit_remote.$(OBJEXT)
-	-rm -f x86/Ginit_remote.lo
-	-rm -f x86/Gos-freebsd.$(OBJEXT)
-	-rm -f x86/Gos-freebsd.lo
-	-rm -f x86/Gos-linux.$(OBJEXT)
-	-rm -f x86/Gos-linux.lo
-	-rm -f x86/Gregs.$(OBJEXT)
-	-rm -f x86/Gregs.lo
-	-rm -f x86/Gresume.$(OBJEXT)
-	-rm -f x86/Gresume.lo
-	-rm -f x86/Gstep.$(OBJEXT)
-	-rm -f x86/Gstep.lo
-	-rm -f x86/Lcreate_addr_space.$(OBJEXT)
-	-rm -f x86/Lcreate_addr_space.lo
-	-rm -f x86/Lget_proc_info.$(OBJEXT)
-	-rm -f x86/Lget_proc_info.lo
-	-rm -f x86/Lget_save_loc.$(OBJEXT)
-	-rm -f x86/Lget_save_loc.lo
-	-rm -f x86/Lglobal.$(OBJEXT)
-	-rm -f x86/Lglobal.lo
-	-rm -f x86/Linit.$(OBJEXT)
-	-rm -f x86/Linit.lo
-	-rm -f x86/Linit_local.$(OBJEXT)
-	-rm -f x86/Linit_local.lo
-	-rm -f x86/Linit_remote.$(OBJEXT)
-	-rm -f x86/Linit_remote.lo
-	-rm -f x86/Los-freebsd.$(OBJEXT)
-	-rm -f x86/Los-freebsd.lo
-	-rm -f x86/Los-linux.$(OBJEXT)
-	-rm -f x86/Los-linux.lo
-	-rm -f x86/Lregs.$(OBJEXT)
-	-rm -f x86/Lregs.lo
-	-rm -f x86/Lresume.$(OBJEXT)
-	-rm -f x86/Lresume.lo
-	-rm -f x86/Lstep.$(OBJEXT)
-	-rm -f x86/Lstep.lo
-	-rm -f x86/getcontext-freebsd.$(OBJEXT)
-	-rm -f x86/getcontext-freebsd.lo
-	-rm -f x86/getcontext-linux.$(OBJEXT)
-	-rm -f x86/getcontext-linux.lo
-	-rm -f x86/is_fpreg.$(OBJEXT)
-	-rm -f x86/is_fpreg.lo
-	-rm -f x86/longjmp.$(OBJEXT)
-	-rm -f x86/longjmp.lo
-	-rm -f x86/regname.$(OBJEXT)
-	-rm -f x86/regname.lo
-	-rm -f x86/siglongjmp.$(OBJEXT)
-	-rm -f x86/siglongjmp.lo
-	-rm -f x86_64/Gcreate_addr_space.$(OBJEXT)
-	-rm -f x86_64/Gcreate_addr_space.lo
-	-rm -f x86_64/Gget_proc_info.$(OBJEXT)
-	-rm -f x86_64/Gget_proc_info.lo
-	-rm -f x86_64/Gget_save_loc.$(OBJEXT)
-	-rm -f x86_64/Gget_save_loc.lo
-	-rm -f x86_64/Gglobal.$(OBJEXT)
-	-rm -f x86_64/Gglobal.lo
-	-rm -f x86_64/Ginit.$(OBJEXT)
-	-rm -f x86_64/Ginit.lo
-	-rm -f x86_64/Ginit_local.$(OBJEXT)
-	-rm -f x86_64/Ginit_local.lo
-	-rm -f x86_64/Ginit_remote.$(OBJEXT)
-	-rm -f x86_64/Ginit_remote.lo
-	-rm -f x86_64/Gos-freebsd.$(OBJEXT)
-	-rm -f x86_64/Gos-freebsd.lo
-	-rm -f x86_64/Gos-linux.$(OBJEXT)
-	-rm -f x86_64/Gos-linux.lo
-	-rm -f x86_64/Gregs.$(OBJEXT)
-	-rm -f x86_64/Gregs.lo
-	-rm -f x86_64/Gresume.$(OBJEXT)
-	-rm -f x86_64/Gresume.lo
-	-rm -f x86_64/Gstash_frame.$(OBJEXT)
-	-rm -f x86_64/Gstash_frame.lo
-	-rm -f x86_64/Gstep.$(OBJEXT)
-	-rm -f x86_64/Gstep.lo
-	-rm -f x86_64/Gtrace.$(OBJEXT)
-	-rm -f x86_64/Gtrace.lo
-	-rm -f x86_64/Lcreate_addr_space.$(OBJEXT)
-	-rm -f x86_64/Lcreate_addr_space.lo
-	-rm -f x86_64/Lget_proc_info.$(OBJEXT)
-	-rm -f x86_64/Lget_proc_info.lo
-	-rm -f x86_64/Lget_save_loc.$(OBJEXT)
-	-rm -f x86_64/Lget_save_loc.lo
-	-rm -f x86_64/Lglobal.$(OBJEXT)
-	-rm -f x86_64/Lglobal.lo
-	-rm -f x86_64/Linit.$(OBJEXT)
-	-rm -f x86_64/Linit.lo
-	-rm -f x86_64/Linit_local.$(OBJEXT)
-	-rm -f x86_64/Linit_local.lo
-	-rm -f x86_64/Linit_remote.$(OBJEXT)
-	-rm -f x86_64/Linit_remote.lo
-	-rm -f x86_64/Los-freebsd.$(OBJEXT)
-	-rm -f x86_64/Los-freebsd.lo
-	-rm -f x86_64/Los-linux.$(OBJEXT)
-	-rm -f x86_64/Los-linux.lo
-	-rm -f x86_64/Lregs.$(OBJEXT)
-	-rm -f x86_64/Lregs.lo
-	-rm -f x86_64/Lresume.$(OBJEXT)
-	-rm -f x86_64/Lresume.lo
-	-rm -f x86_64/Lstash_frame.$(OBJEXT)
-	-rm -f x86_64/Lstash_frame.lo
-	-rm -f x86_64/Lstep.$(OBJEXT)
-	-rm -f x86_64/Lstep.lo
-	-rm -f x86_64/Ltrace.$(OBJEXT)
-	-rm -f x86_64/Ltrace.lo
-	-rm -f x86_64/getcontext.$(OBJEXT)
-	-rm -f x86_64/getcontext.lo
-	-rm -f x86_64/is_fpreg.$(OBJEXT)
-	-rm -f x86_64/is_fpreg.lo
-	-rm -f x86_64/longjmp.$(OBJEXT)
-	-rm -f x86_64/longjmp.lo
-	-rm -f x86_64/regname.$(OBJEXT)
-	-rm -f x86_64/regname.lo
-	-rm -f x86_64/setcontext.$(OBJEXT)
-	-rm -f x86_64/setcontext.lo
-	-rm -f x86_64/siglongjmp.$(OBJEXT)
-	-rm -f x86_64/siglongjmp.lo
+	-rm -f aarch64/*.$(OBJEXT)
+	-rm -f aarch64/*.lo
+	-rm -f arm/*.$(OBJEXT)
+	-rm -f arm/*.lo
+	-rm -f coredump/*.$(OBJEXT)
+	-rm -f coredump/*.lo
+	-rm -f dwarf/*.$(OBJEXT)
+	-rm -f dwarf/*.lo
+	-rm -f hppa/*.$(OBJEXT)
+	-rm -f hppa/*.lo
+	-rm -f ia64/*.$(OBJEXT)
+	-rm -f ia64/*.lo
+	-rm -f mi/*.$(OBJEXT)
+	-rm -f mi/*.lo
+	-rm -f mips/*.$(OBJEXT)
+	-rm -f mips/*.lo
+	-rm -f ppc/*.$(OBJEXT)
+	-rm -f ppc/*.lo
+	-rm -f ppc32/*.$(OBJEXT)
+	-rm -f ppc32/*.lo
+	-rm -f ppc64/*.$(OBJEXT)
+	-rm -f ppc64/*.lo
+	-rm -f ptrace/*.$(OBJEXT)
+	-rm -f ptrace/*.lo
+	-rm -f s390x/*.$(OBJEXT)
+	-rm -f s390x/*.lo
+	-rm -f setjmp/*.$(OBJEXT)
+	-rm -f setjmp/*.lo
+	-rm -f sh/*.$(OBJEXT)
+	-rm -f sh/*.lo
+	-rm -f tilegx/*.$(OBJEXT)
+	-rm -f tilegx/*.lo
+	-rm -f unwind/*.$(OBJEXT)
+	-rm -f unwind/*.lo
+	-rm -f x86/*.$(OBJEXT)
+	-rm -f x86/*.lo
+	-rm -f x86_64/*.$(OBJEXT)
+	-rm -f x86_64/*.lo
 
 distclean-compile:
 	-rm -f *.tab.c
@@ -2809,6 +2948,42 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os-freebsd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os-hpux.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/os-qnx.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gglobal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Ginit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Ginit_local.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Ginit_remote.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gregs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gstash_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Gtrace.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lglobal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Linit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Linit_local.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Linit_remote.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lregs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lstash_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Lstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/Ltrace.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/getcontext.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/is_fpreg.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/regname.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@aarch64/$(DEPDIR)/siglongjmp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gex_tables.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
@@ -2817,10 +2992,16 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Ginit.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Ginit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Ginit_remote.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gos-freebsd.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gos-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gos-other.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gstash_frame.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Gtrace.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lex_tables.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
@@ -2829,10 +3010,15 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Linit.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Linit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Linit_remote.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Los-freebsd.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Los-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Los-other.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lstash_frame.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Lstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/Ltrace.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/getcontext.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/is_fpreg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@arm/$(DEPDIR)/regname.Plo@am__quote@
@@ -2857,15 +3043,14 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Gfind_unwind_table.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Gparser.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Gpe.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Gstep.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Lexpr.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Lfde.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Lfind_proc_info-lsb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Lfind_unwind_table.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Lparser.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Lpe.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/Lstep.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@dwarf/$(DEPDIR)/global.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
@@ -2874,9 +3059,11 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Ginit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Ginit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
@@ -2885,6 +3072,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Linit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Linit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/Lstep.Plo@am__quote@
@@ -2892,6 +3080,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/regname.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/setcontext.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@hppa/$(DEPDIR)/siglongjmp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gfind_unwind_table.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
@@ -2904,11 +3093,13 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gparser.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Grbs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gscript.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gstep.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Gtables.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lfind_unwind_table.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
@@ -2921,6 +3112,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lparser.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lrbs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ia64/$(DEPDIR)/Lscript.Plo@am__quote@
@@ -2943,6 +3135,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Gget_proc_name.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Gget_reg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Gput_dynamic_unwind_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Gset_cache_size.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Gset_caching_policy.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Gset_fpreg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Gset_reg.Plo@am__quote@
@@ -2955,6 +3148,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Lget_proc_name.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Lget_reg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Lput_dynamic_unwind_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Lset_cache_size.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Lset_caching_policy.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Lset_fpreg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/Lset_reg.Plo@am__quote@
@@ -2968,6 +3162,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/init.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/mempool.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mi/$(DEPDIR)/strerror.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
@@ -2976,9 +3171,11 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Ginit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Ginit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
@@ -2987,6 +3184,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Linit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Linit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/Lstep.Plo@am__quote@
@@ -2994,13 +3192,11 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/is_fpreg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/regname.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@mips/$(DEPDIR)/siglongjmp.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Ginit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Ginit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Linit_local.Plo@am__quote@
@@ -3008,26 +3204,38 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/longjmp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc/$(DEPDIR)/siglongjmp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Gglobal.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Ginit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Lglobal.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Linit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/Lstep.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/get_func_addr.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/is_fpreg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc32/$(DEPDIR)/regname.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Gglobal.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Ginit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Lglobal.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Linit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ppc64/$(DEPDIR)/Lstep.Plo@am__quote@
@@ -3047,8 +3255,39 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@ptrace/$(DEPDIR)/_UPT_put_unwind_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ptrace/$(DEPDIR)/_UPT_reg_offset.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@ptrace/$(DEPDIR)/_UPT_resume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gglobal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Ginit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Ginit_local.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Ginit_remote.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gregs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lglobal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Linit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Linit_local.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Linit_remote.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lregs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/Lstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/getcontext.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/is_fpreg.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/regname.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@s390x/$(DEPDIR)/setcontext.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@setjmp/$(DEPDIR)/longjmp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@setjmp/$(DEPDIR)/siglongjmp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
@@ -3057,9 +3296,11 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Ginit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Ginit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
@@ -3068,12 +3309,43 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Linit_local.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Linit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/Lstep.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/is_fpreg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/regname.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@sh/$(DEPDIR)/siglongjmp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gglobal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Ginit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Ginit_local.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Ginit_remote.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gregs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lglobal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Linit.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Linit_local.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Linit_remote.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lis_signal_frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lregs.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lresume.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/Lstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/getcontext.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/is_fpreg.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/regname.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tilegx/$(DEPDIR)/siglongjmp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@unwind/$(DEPDIR)/Backtrace.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@unwind/$(DEPDIR)/DeleteException.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@unwind/$(DEPDIR)/FindEnclosingFunction.Plo@am__quote@
@@ -3092,6 +3364,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@unwind/$(DEPDIR)/Resume_or_Rethrow.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@unwind/$(DEPDIR)/SetGR.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@unwind/$(DEPDIR)/SetIP.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
@@ -3101,9 +3374,11 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Ginit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gos-freebsd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gos-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Gstep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
@@ -3113,6 +3388,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Linit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Los-freebsd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Los-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/Lstep.Plo@am__quote@
@@ -3122,6 +3398,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/longjmp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/regname.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86/$(DEPDIR)/siglongjmp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gget_save_loc.Plo@am__quote@
@@ -3131,11 +3408,13 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Ginit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gos-freebsd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gos-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Greg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gstash_frame.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gstep.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Gtrace.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lapply_reg_state.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lcreate_addr_space.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lget_proc_info.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lget_save_loc.Plo@am__quote@
@@ -3145,6 +3424,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Linit_remote.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Los-freebsd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Los-linux.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lreg_states_iterate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lregs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lresume.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/Lstash_frame.Plo@am__quote@
@@ -3158,58 +3438,59 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@x86_64/$(DEPDIR)/siglongjmp.Plo@am__quote@
 
 .S.o:
-@am__fastdepCCAS_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
 @am__fastdepCCAS_TRUE@	$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCCAS_FALSE@	$(CPPASCOMPILE) -c -o $@ $<
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ $<
 
 .S.obj:
-@am__fastdepCCAS_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
 @am__fastdepCCAS_TRUE@	$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
 @am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCCAS_FALSE@	$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 .S.lo:
-@am__fastdepCCAS_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
 @am__fastdepCCAS_TRUE@	$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCCAS_FALSE@	$(LTCPPASCOMPILE) -c -o $@ $<
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(LTCPPASCOMPILE) -c -o $@ $<
 
 .c.o:
-@am__fastdepCC_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c -o $@ $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
 @am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 .c.lo:
-@am__fastdepCC_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
 @am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
 
 mostlyclean-libtool:
 	-rm -f *.lo
 
 clean-libtool:
 	-rm -rf .libs _libs
+	-rm -rf aarch64/.libs aarch64/_libs
 	-rm -rf arm/.libs arm/_libs
 	-rm -rf coredump/.libs coredump/_libs
 	-rm -rf dwarf/.libs dwarf/_libs
@@ -3221,15 +3502,20 @@ clean-libtool:
 	-rm -rf ppc32/.libs ppc32/_libs
 	-rm -rf ppc64/.libs ppc64/_libs
 	-rm -rf ptrace/.libs ptrace/_libs
+	-rm -rf s390x/.libs s390x/_libs
 	-rm -rf setjmp/.libs setjmp/_libs
 	-rm -rf sh/.libs sh/_libs
+	-rm -rf tilegx/.libs tilegx/_libs
 	-rm -rf unwind/.libs unwind/_libs
 	-rm -rf x86/.libs x86/_libs
 	-rm -rf x86_64/.libs x86_64/_libs
 install-pkgconfigDATA: $(pkgconfig_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(pkgconfigdir)" || $(MKDIR_P) "$(DESTDIR)$(pkgconfigdir)"
 	@list='$(pkgconfig_DATA)'; test -n "$(pkgconfigdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(pkgconfigdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(pkgconfigdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3245,26 +3531,15 @@ uninstall-pkgconfigDATA:
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
 	dir='$(DESTDIR)$(pkgconfigdir)'; $(am__uninstall_files_from_dir)
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -3276,15 +3551,11 @@ TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -3293,6 +3564,21 @@ GTAGS:
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
@@ -3362,6 +3648,8 @@ clean-generic:
 distclean-generic:
 	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+	-rm -f aarch64/$(DEPDIR)/$(am__dirstamp)
+	-rm -f aarch64/$(am__dirstamp)
 	-rm -f arm/$(DEPDIR)/$(am__dirstamp)
 	-rm -f arm/$(am__dirstamp)
 	-rm -f coredump/$(DEPDIR)/$(am__dirstamp)
@@ -3384,10 +3672,14 @@ distclean-generic:
 	-rm -f ppc64/$(am__dirstamp)
 	-rm -f ptrace/$(DEPDIR)/$(am__dirstamp)
 	-rm -f ptrace/$(am__dirstamp)
+	-rm -f s390x/$(DEPDIR)/$(am__dirstamp)
+	-rm -f s390x/$(am__dirstamp)
 	-rm -f setjmp/$(DEPDIR)/$(am__dirstamp)
 	-rm -f setjmp/$(am__dirstamp)
 	-rm -f sh/$(DEPDIR)/$(am__dirstamp)
 	-rm -f sh/$(am__dirstamp)
+	-rm -f tilegx/$(DEPDIR)/$(am__dirstamp)
+	-rm -f tilegx/$(am__dirstamp)
 	-rm -f unwind/$(DEPDIR)/$(am__dirstamp)
 	-rm -f unwind/$(am__dirstamp)
 	-rm -f x86/$(DEPDIR)/$(am__dirstamp)
@@ -3406,7 +3698,7 @@ clean-am: clean-generic clean-libLIBRARIES clean-libLTLIBRARIES \
 	clean-libtool clean-noinstLTLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-	-rm -rf ./$(DEPDIR) arm/$(DEPDIR) coredump/$(DEPDIR) dwarf/$(DEPDIR) hppa/$(DEPDIR) ia64/$(DEPDIR) mi/$(DEPDIR) mips/$(DEPDIR) ppc/$(DEPDIR) ppc32/$(DEPDIR) ppc64/$(DEPDIR) ptrace/$(DEPDIR) setjmp/$(DEPDIR) sh/$(DEPDIR) unwind/$(DEPDIR) x86/$(DEPDIR) x86_64/$(DEPDIR)
+	-rm -rf ./$(DEPDIR) aarch64/$(DEPDIR) arm/$(DEPDIR) coredump/$(DEPDIR) dwarf/$(DEPDIR) hppa/$(DEPDIR) ia64/$(DEPDIR) mi/$(DEPDIR) mips/$(DEPDIR) ppc/$(DEPDIR) ppc32/$(DEPDIR) ppc64/$(DEPDIR) ptrace/$(DEPDIR) s390x/$(DEPDIR) setjmp/$(DEPDIR) sh/$(DEPDIR) tilegx/$(DEPDIR) unwind/$(DEPDIR) x86/$(DEPDIR) x86_64/$(DEPDIR)
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
@@ -3453,7 +3745,7 @@ install-ps-am:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR) arm/$(DEPDIR) coredump/$(DEPDIR) dwarf/$(DEPDIR) hppa/$(DEPDIR) ia64/$(DEPDIR) mi/$(DEPDIR) mips/$(DEPDIR) ppc/$(DEPDIR) ppc32/$(DEPDIR) ppc64/$(DEPDIR) ptrace/$(DEPDIR) setjmp/$(DEPDIR) sh/$(DEPDIR) unwind/$(DEPDIR) x86/$(DEPDIR) x86_64/$(DEPDIR)
+	-rm -rf ./$(DEPDIR) aarch64/$(DEPDIR) arm/$(DEPDIR) coredump/$(DEPDIR) dwarf/$(DEPDIR) hppa/$(DEPDIR) ia64/$(DEPDIR) mi/$(DEPDIR) mips/$(DEPDIR) ppc/$(DEPDIR) ppc32/$(DEPDIR) ppc64/$(DEPDIR) ptrace/$(DEPDIR) s390x/$(DEPDIR) setjmp/$(DEPDIR) sh/$(DEPDIR) tilegx/$(DEPDIR) unwind/$(DEPDIR) x86/$(DEPDIR) x86_64/$(DEPDIR)
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -3475,20 +3767,20 @@ uninstall-am: uninstall-libLIBRARIES uninstall-libLTLIBRARIES \
 
 .MAKE: all check install install-am install-exec-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
 	clean-libLIBRARIES clean-libLTLIBRARIES clean-libtool \
-	clean-noinstLTLIBRARIES ctags distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-exec-hook install-html \
-	install-html-am install-info install-info-am \
+	clean-noinstLTLIBRARIES cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-exec-hook \
+	install-html install-html-am install-info install-info-am \
 	install-libLIBRARIES install-libLTLIBRARIES install-man \
 	install-pdf install-pdf-am install-pkgconfigDATA install-ps \
 	install-ps-am install-strip installcheck installcheck-am \
 	installdirs maintainer-clean maintainer-clean-generic \
 	mostlyclean mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
 	uninstall-am uninstall-libLIBRARIES uninstall-libLTLIBRARIES \
 	uninstall-pkgconfigDATA
 
@@ -3502,19 +3794,21 @@ uninstall-am: uninstall-libLIBRARIES uninstall-libLTLIBRARIES \
 # to be there if the user configured with --disable-shared.
 #
 @REMOTE_ONLY_FALSE@install-exec-hook:
-@REMOTE_ONLY_FALSE@	$(LN_S) -f libunwind-$(arch).a  $(DESTDIR)$(libdir)/libunwind-generic.a
+@REMOTE_ONLY_FALSE@	if test -f $(DESTDIR)$(libdir)/libunwind-$(arch).a; then \
+@REMOTE_ONLY_FALSE@		cd $(DESTDIR)$(libdir) && $(LN_S) -f libunwind-$(arch).a libunwind-generic.a; \
+@REMOTE_ONLY_FALSE@	fi
 @REMOTE_ONLY_FALSE@	if test -f $(DESTDIR)$(libdir)/libunwind-$(arch).so; then \
-@REMOTE_ONLY_FALSE@	    $(LN_S) -f libunwind-$(arch).so \
-@REMOTE_ONLY_FALSE@		$(DESTDIR)$(libdir)/libunwind-generic.so; \
+@REMOTE_ONLY_FALSE@		cd $(DESTDIR)$(libdir) && $(LN_S) -f libunwind-$(arch).so \
+@REMOTE_ONLY_FALSE@		libunwind-generic.so; \
 @REMOTE_ONLY_FALSE@	fi
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@mk_Gcursor_i.s: $(srcdir)/ia64/mk_Gcursor_i.c
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(COMPILE) -S "$(srcdir)/ia64/mk_Gcursor_i.c" -o mk_Gcursor_i.s
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@mk_Lcursor_i.s: $(srcdir)/ia64/mk_Lcursor_i.c
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(COMPILE) -S "$(srcdir)/ia64/mk_Lcursor_i.c" -o mk_Lcursor_i.s
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@Gcursor_i.h: mk_Gcursor_i.s
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	"$(srcdir)/ia64/mk_cursor_i" mk_Gcursor_i.s > Gcursor_i.h
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@Lcursor_i.h: mk_Lcursor_i.s
-@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	"$(srcdir)/ia64/mk_cursor_i" mk_Lcursor_i.s > Lcursor_i.h
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@mk_Gcursor_i.s: $(srcdir)/ia64/mk_Gcursor_i.c
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(COMPILE) -S "$(srcdir)/ia64/mk_Gcursor_i.c" -o mk_Gcursor_i.s
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@mk_Lcursor_i.s: $(srcdir)/ia64/mk_Lcursor_i.c
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	$(COMPILE) -S "$(srcdir)/ia64/mk_Lcursor_i.c" -o mk_Lcursor_i.s
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@Gcursor_i.h: mk_Gcursor_i.s
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	"$(srcdir)/ia64/mk_cursor_i" mk_Gcursor_i.s > Gcursor_i.h
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@Lcursor_i.h: mk_Lcursor_i.s
+@ARCH_AARCH64_FALSE@@ARCH_ARM_FALSE@@ARCH_IA64_TRUE@	"$(srcdir)/ia64/mk_cursor_i" mk_Lcursor_i.s > Lcursor_i.h
 
 # The -version-info flag accepts an argument of the form
 # `current[:revision[:age]]'. So, passing `-version-info 3:12:1' sets
diff --git a/src/aarch64/Gapply_reg_state.c b/src/aarch64/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/aarch64/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/aarch64/Gcreate_addr_space.c b/src/aarch64/Gcreate_addr_space.c
new file mode 100644
index 0000000..f217adc
--- /dev/null
+++ b/src/aarch64/Gcreate_addr_space.c
@@ -0,0 +1,60 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "unwind_i.h"
+
+unw_addr_space_t
+unw_create_addr_space (unw_accessors_t *a, int byte_order)
+{
+#ifdef UNW_LOCAL_ONLY
+  return NULL;
+#else
+  unw_addr_space_t as;
+
+  /* AArch64 supports little-endian and big-endian. */
+  if (byte_order != 0 && byte_order != __LITTLE_ENDIAN
+      && byte_order != __BIG_ENDIAN)
+    return NULL;
+
+  as = malloc (sizeof (*as));
+  if (!as)
+    return NULL;
+
+  memset (as, 0, sizeof (*as));
+
+  as->acc = *a;
+
+  /* Default to little-endian for AArch64. */
+  if (byte_order == 0 || byte_order == __LITTLE_ENDIAN)
+    as->big_endian = 0;
+  else
+    as->big_endian = 1;
+
+  return as;
+#endif
+}
diff --git a/src/aarch64/Gget_proc_info.c b/src/aarch64/Gget_proc_info.c
new file mode 100644
index 0000000..c363d24
--- /dev/null
+++ b/src/aarch64/Gget_proc_info.c
@@ -0,0 +1,39 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+
+  ret = dwarf_make_proc_info (&c->dwarf);
+  if (ret < 0)
+    return ret;
+
+  *pi = c->dwarf.pi;
+  return 0;
+}
diff --git a/src/aarch64/Gget_save_loc.c b/src/aarch64/Gget_save_loc.c
new file mode 100644
index 0000000..86bbbd0
--- /dev/null
+++ b/src/aarch64/Gget_save_loc.c
@@ -0,0 +1,100 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  dwarf_loc_t loc;
+
+  switch (reg)
+    {
+    case UNW_AARCH64_X0:
+    case UNW_AARCH64_X1:
+    case UNW_AARCH64_X2:
+    case UNW_AARCH64_X3:
+    case UNW_AARCH64_X4:
+    case UNW_AARCH64_X5:
+    case UNW_AARCH64_X6:
+    case UNW_AARCH64_X7:
+    case UNW_AARCH64_X8:
+    case UNW_AARCH64_X9:
+    case UNW_AARCH64_X10:
+    case UNW_AARCH64_X11:
+    case UNW_AARCH64_X12:
+    case UNW_AARCH64_X13:
+    case UNW_AARCH64_X14:
+    case UNW_AARCH64_X15:
+    case UNW_AARCH64_X16:
+    case UNW_AARCH64_X17:
+    case UNW_AARCH64_X18:
+    case UNW_AARCH64_X19:
+    case UNW_AARCH64_X20:
+    case UNW_AARCH64_X21:
+    case UNW_AARCH64_X22:
+    case UNW_AARCH64_X23:
+    case UNW_AARCH64_X24:
+    case UNW_AARCH64_X25:
+    case UNW_AARCH64_X26:
+    case UNW_AARCH64_X27:
+    case UNW_AARCH64_X28:
+    case UNW_AARCH64_X29:
+    case UNW_AARCH64_X30:
+    case UNW_AARCH64_SP:
+    case UNW_AARCH64_PC:
+    case UNW_AARCH64_PSTATE:
+      loc = c->dwarf.loc[reg];
+      break;
+
+    default:
+      loc = DWARF_NULL_LOC;     /* default to "not saved" */
+      break;
+    }
+
+  memset (sloc, 0, sizeof (*sloc));
+
+  if (DWARF_IS_NULL_LOC (loc))
+    {
+      sloc->type = UNW_SLT_NONE;
+      return 0;
+    }
+
+#if !defined(UNW_LOCAL_ONLY)
+  if (DWARF_IS_REG_LOC (loc))
+    {
+      sloc->type = UNW_SLT_REG;
+      sloc->u.regnum = DWARF_GET_LOC (loc);
+    }
+  else
+#endif
+    {
+      sloc->type = UNW_SLT_MEMORY;
+      sloc->u.addr = DWARF_GET_LOC (loc);
+    }
+  return 0;
+}
diff --git a/src/aarch64/Gglobal.c b/src/aarch64/Gglobal.c
new file mode 100644
index 0000000..72e36b2
--- /dev/null
+++ b/src/aarch64/Gglobal.c
@@ -0,0 +1,57 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "dwarf_i.h"
+
+HIDDEN define_lock (aarch64_lock);
+HIDDEN int tdep_init_done;
+
+HIDDEN void
+tdep_init (void)
+{
+  intrmask_t saved_mask;
+
+  sigfillset (&unwi_full_mask);
+
+  lock_acquire (&aarch64_lock, saved_mask);
+  {
+    if (tdep_init_done)
+      /* another thread else beat us to it... */
+      goto out;
+
+    mi_init ();
+
+    dwarf_init ();
+
+#ifndef UNW_REMOTE_ONLY
+    aarch64_local_addr_space_init ();
+#endif
+    tdep_init_done = 1; /* signal that we're initialized... */
+  }
+ out:
+  lock_release (&aarch64_lock, saved_mask);
+}
diff --git a/src/aarch64/Ginit.c b/src/aarch64/Ginit.c
new file mode 100644
index 0000000..dec235c
--- /dev/null
+++ b/src/aarch64/Ginit.c
@@ -0,0 +1,190 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "unwind_i.h"
+
+#ifdef UNW_REMOTE_ONLY
+
+/* unw_local_addr_space is a NULL pointer in this case.  */
+unw_addr_space_t unw_local_addr_space;
+
+#else /* !UNW_REMOTE_ONLY */
+
+static struct unw_addr_space local_addr_space;
+
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
+
+static inline void *
+uc_addr (unw_tdep_context_t *uc, int reg)
+{
+  if (reg >= UNW_AARCH64_X0 && reg < UNW_AARCH64_V0)
+    return &uc->uc_mcontext.regs[reg];
+  else if (reg >= UNW_AARCH64_V0 && reg <= UNW_AARCH64_V31)
+    return &GET_FPCTX(uc)->vregs[reg - UNW_AARCH64_V0];
+  else
+    return NULL;
+}
+
+# ifdef UNW_LOCAL_ONLY
+
+HIDDEN void *
+tdep_uc_addr (unw_tdep_context_t *uc, int reg)
+{
+  return uc_addr (uc, reg);
+}
+
+# endif /* UNW_LOCAL_ONLY */
+
+HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
+
+/* XXX fix me: there is currently no way to locate the dyn-info list
+       by a remote unwinder.  On ia64, this is done via a special
+       unwind-table entry.  Perhaps something similar can be done with
+       DWARF2 unwind info.  */
+
+static void
+put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
+{
+  /* it's a no-op */
+}
+
+static int
+get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
+                        void *arg)
+{
+  *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
+  return 0;
+}
+
+static int
+access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
+            void *arg)
+{
+  if (write)
+    {
+      Debug (16, "mem[%lx] <- %lx\n", addr, *val);
+      *(unw_word_t *) addr = *val;
+    }
+  else
+    {
+      *val = *(unw_word_t *) addr;
+      Debug (16, "mem[%lx] -> %lx\n", addr, *val);
+    }
+  return 0;
+}
+
+static int
+access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
+            void *arg)
+{
+  unw_word_t *addr;
+  unw_tdep_context_t *uc = arg;
+
+  if (unw_is_fpreg (reg))
+    goto badreg;
+
+  if (!(addr = uc_addr (uc, reg)))
+    goto badreg;
+
+  if (write)
+    {
+      *(unw_word_t *) addr = *val;
+      Debug (12, "%s <- %lx\n", unw_regname (reg), *val);
+    }
+  else
+    {
+      *val = *(unw_word_t *) addr;
+      Debug (12, "%s -> %lx\n", unw_regname (reg), *val);
+    }
+  return 0;
+
+ badreg:
+  Debug (1, "bad register number %u\n", reg);
+  return -UNW_EBADREG;
+}
+
+static int
+access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
+              int write, void *arg)
+{
+  unw_tdep_context_t *uc = arg;
+  unw_fpreg_t *addr;
+
+  if (!unw_is_fpreg (reg))
+    goto badreg;
+
+  if (!(addr = uc_addr (uc, reg)))
+    goto badreg;
+
+  if (write)
+    {
+      Debug (12, "%s <- %08lx.%08lx.%08lx\n", unw_regname (reg),
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+      *(unw_fpreg_t *) addr = *val;
+    }
+  else
+    {
+      *val = *(unw_fpreg_t *) addr;
+      Debug (12, "%s -> %08lx.%08lx.%08lx\n", unw_regname (reg),
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+    }
+  return 0;
+
+ badreg:
+  Debug (1, "bad register number %u\n", reg);
+  /* attempt to access a non-preserved register */
+  return -UNW_EBADREG;
+}
+
+static int
+get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
+{
+  return _Uelf64_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
+}
+
+HIDDEN void
+aarch64_local_addr_space_init (void)
+{
+  memset (&local_addr_space, 0, sizeof (local_addr_space));
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
+  local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
+  local_addr_space.acc.put_unwind_info = put_unwind_info;
+  local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
+  local_addr_space.acc.access_mem = access_mem;
+  local_addr_space.acc.access_reg = access_reg;
+  local_addr_space.acc.access_fpreg = access_fpreg;
+  local_addr_space.acc.resume = aarch64_local_resume;
+  local_addr_space.acc.get_proc_name = get_static_proc_name;
+  local_addr_space.big_endian = (__BYTE_ORDER == __BIG_ENDIAN);
+  unw_flush_cache (&local_addr_space, 0, 0);
+}
+
+#endif /* !UNW_REMOTE_ONLY */
diff --git a/src/aarch64/Ginit_local.c b/src/aarch64/Ginit_local.c
new file mode 100644
index 0000000..69d4ed3
--- /dev/null
+++ b/src/aarch64/Ginit_local.c
@@ -0,0 +1,78 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2011-2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "init.h"
+
+#ifdef UNW_REMOTE_ONLY
+
+int
+unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
+{
+  return -UNW_EINVAL;
+}
+
+#else /* !UNW_REMOTE_ONLY */
+
+static int
+unw_init_local_common (unw_cursor_t *cursor, unw_context_t *uc, unsigned use_prev_instr)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  if (!tdep_init_done)
+    tdep_init ();
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  c->dwarf.as = unw_local_addr_space;
+  c->dwarf.as_arg = uc;
+
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, unw_tdep_context_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
+}
+
+#endif /* !UNW_REMOTE_ONLY */
diff --git a/src/aarch64/Ginit_remote.c b/src/aarch64/Ginit_remote.c
new file mode 100644
index 0000000..9b8ba5b
--- /dev/null
+++ b/src/aarch64/Ginit_remote.c
@@ -0,0 +1,45 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "init.h"
+#include "unwind_i.h"
+
+int
+unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
+{
+#ifdef UNW_LOCAL_ONLY
+  return -UNW_EINVAL;
+#else /* !UNW_LOCAL_ONLY */
+  struct cursor *c = (struct cursor *) cursor;
+
+  if (!tdep_init_done)
+    tdep_init ();
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  c->dwarf.as = as;
+  c->dwarf.as_arg = as_arg;
+  return common_init (c, 0);
+#endif /* !UNW_LOCAL_ONLY */
+}
diff --git a/src/aarch64/Gis_signal_frame.c b/src/aarch64/Gis_signal_frame.c
new file mode 100644
index 0000000..67159d8
--- /dev/null
+++ b/src/aarch64/Gis_signal_frame.c
@@ -0,0 +1,64 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+/* The restorer stub will always have the form:
+
+   d2801168        movz    x8, #0x8b
+   d4000001        svc     #0x0
+*/
+
+int
+unw_is_signal_frame (unw_cursor_t *cursor)
+{
+#ifdef __linux__
+  struct cursor *c = (struct cursor *) cursor;
+  unw_word_t w0, ip;
+  unw_addr_space_t as;
+  unw_accessors_t *a;
+  void *arg;
+  int ret;
+
+  as = c->dwarf.as;
+  a = unw_get_accessors_int (as);
+  arg = c->dwarf.as_arg;
+
+  ip = c->dwarf.ip;
+
+  ret = (*a->access_mem) (as, ip, &w0, 0, arg);
+  if (ret < 0)
+    return ret;
+
+  /* FIXME: distinguish 32bit insn vs 64bit registers.  */
+  if (w0 != 0xd4000001d2801168)
+    return 0;
+
+  return 1;
+
+#else
+  return -UNW_ENOINFO;
+#endif
+}
diff --git a/src/aarch64/Greg_states_iterate.c b/src/aarch64/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/aarch64/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/aarch64/Gregs.c b/src/aarch64/Gregs.c
new file mode 100644
index 0000000..a884373
--- /dev/null
+++ b/src/aarch64/Gregs.c
@@ -0,0 +1,118 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+HIDDEN int
+tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
+                 int write)
+{
+  dwarf_loc_t loc = DWARF_NULL_LOC;
+  unsigned int mask;
+
+  switch (reg)
+    {
+    case UNW_AARCH64_X0:
+    case UNW_AARCH64_X1:
+    case UNW_AARCH64_X2:
+    case UNW_AARCH64_X3:
+      mask = 1 << reg;
+      if (write)
+        {
+          c->dwarf.eh_args[reg] = *valp;
+          c->dwarf.eh_valid_mask |= mask;
+          return 0;
+        }
+      else if ((c->dwarf.eh_valid_mask & mask) != 0)
+        {
+          *valp = c->dwarf.eh_args[reg];
+          return 0;
+        }
+      else
+        loc = c->dwarf.loc[reg];
+      break;
+
+    case UNW_AARCH64_X30:
+      if (write)
+        c->dwarf.ip = *valp;            /* update the IP cache */
+    case UNW_AARCH64_X4:
+    case UNW_AARCH64_X5:
+    case UNW_AARCH64_X6:
+    case UNW_AARCH64_X7:
+    case UNW_AARCH64_X8:
+    case UNW_AARCH64_X9:
+    case UNW_AARCH64_X10:
+    case UNW_AARCH64_X11:
+    case UNW_AARCH64_X12:
+    case UNW_AARCH64_X13:
+    case UNW_AARCH64_X14:
+    case UNW_AARCH64_X15:
+    case UNW_AARCH64_X16:
+    case UNW_AARCH64_X17:
+    case UNW_AARCH64_X18:
+    case UNW_AARCH64_X19:
+    case UNW_AARCH64_X20:
+    case UNW_AARCH64_X21:
+    case UNW_AARCH64_X22:
+    case UNW_AARCH64_X23:
+    case UNW_AARCH64_X24:
+    case UNW_AARCH64_X25:
+    case UNW_AARCH64_X26:
+    case UNW_AARCH64_X27:
+    case UNW_AARCH64_X28:
+    case UNW_AARCH64_X29:
+    case UNW_AARCH64_PC:
+    case UNW_AARCH64_PSTATE:
+      loc = c->dwarf.loc[reg];
+      break;
+
+    case UNW_AARCH64_SP:
+      if (write)
+        return -UNW_EREADONLYREG;
+      *valp = c->dwarf.cfa;
+      return 0;
+
+    default:
+      Debug (1, "bad register number %u\n", reg);
+      return -UNW_EBADREG;
+    }
+
+  if (write)
+    return dwarf_put (&c->dwarf, loc, *valp);
+  else
+    return dwarf_get (&c->dwarf, loc, valp);
+}
+
+HIDDEN int
+tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
+                   int write)
+{
+  dwarf_loc_t loc = c->dwarf.loc[reg];
+  if (write)
+    return dwarf_putfp (&c->dwarf, loc, *valp);
+  else
+    return dwarf_getfp (&c->dwarf, loc, valp);
+}
diff --git a/src/aarch64/Gresume.c b/src/aarch64/Gresume.c
new file mode 100644
index 0000000..3d82739
--- /dev/null
+++ b/src/aarch64/Gresume.c
@@ -0,0 +1,198 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2011-2013 Linaro Limited
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "offsets.h"
+
+#ifndef UNW_REMOTE_ONLY
+
+HIDDEN inline int
+aarch64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
+{
+#ifdef __linux__
+  struct cursor *c = (struct cursor *) cursor;
+  unw_tdep_context_t *uc = c->dwarf.as_arg;
+
+  if (c->sigcontext_format == AARCH64_SCF_NONE)
+    {
+      /* Since there are no signals involved here we restore EH and non scratch
+         registers only.  */
+      unsigned long regs[24];
+      regs[0] = uc->uc_mcontext.regs[0];
+      regs[1] = uc->uc_mcontext.regs[1];
+      regs[2] = uc->uc_mcontext.regs[2];
+      regs[3] = uc->uc_mcontext.regs[3];
+      regs[4] = uc->uc_mcontext.regs[19];
+      regs[5] = uc->uc_mcontext.regs[20];
+      regs[6] = uc->uc_mcontext.regs[21];
+      regs[7] = uc->uc_mcontext.regs[22];
+      regs[8] = uc->uc_mcontext.regs[23];
+      regs[9] = uc->uc_mcontext.regs[24];
+      regs[10] = uc->uc_mcontext.regs[25];
+      regs[11] = uc->uc_mcontext.regs[26];
+      regs[12] = uc->uc_mcontext.regs[27];
+      regs[13] = uc->uc_mcontext.regs[28];
+      regs[14] = uc->uc_mcontext.regs[29]; /* FP */
+      regs[15] = uc->uc_mcontext.regs[30]; /* LR */
+      regs[16] = GET_FPCTX(uc)->vregs[8];
+      regs[17] = GET_FPCTX(uc)->vregs[9];
+      regs[18] = GET_FPCTX(uc)->vregs[10];
+      regs[19] = GET_FPCTX(uc)->vregs[11];
+      regs[20] = GET_FPCTX(uc)->vregs[12];
+      regs[21] = GET_FPCTX(uc)->vregs[13];
+      regs[22] = GET_FPCTX(uc)->vregs[14];
+      regs[23] = GET_FPCTX(uc)->vregs[15];
+      unsigned long sp = uc->uc_mcontext.sp;
+
+      struct regs_overlay {
+        char x[sizeof(regs)];
+      };
+
+      asm volatile (
+        "mov x4, %0\n"
+        "mov x5, %1\n"
+        "ldp x0,  x1,  [x4]\n"
+        "ldp x2,  x3,  [x4,16]\n"
+        "ldp x19, x20, [x4,32]\n"
+        "ldp x21, x22, [x4,48]\n"
+        "ldp x23, x24, [x4,64]\n"
+        "ldp x25, x26, [x4,80]\n"
+        "ldp x27, x28, [x4,96]\n"
+        "ldp x29, x30, [x4,112]\n"
+        "ldp d8, d9,   [x4,128]\n"
+        "ldp d10, d11, [x4,144]\n"
+        "ldp d12, d13, [x4,160]\n"
+        "ldp d14, d15, [x4,176]\n"
+        "mov sp, x5\n"
+        "ret \n"
+        :
+        : "r" (regs),
+          "r" (sp),
+          "m" (*(struct regs_overlay *)regs)
+      );
+    }
+  else
+    {
+      struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
+
+      if (c->dwarf.eh_valid_mask & 0x1) sc->regs[0] = c->dwarf.eh_args[0];
+      if (c->dwarf.eh_valid_mask & 0x2) sc->regs[1] = c->dwarf.eh_args[1];
+      if (c->dwarf.eh_valid_mask & 0x4) sc->regs[2] = c->dwarf.eh_args[2];
+      if (c->dwarf.eh_valid_mask & 0x8) sc->regs[3] = c->dwarf.eh_args[3];
+
+      sc->regs[4] = uc->uc_mcontext.regs[4];
+      sc->regs[5] = uc->uc_mcontext.regs[5];
+      sc->regs[6] = uc->uc_mcontext.regs[6];
+      sc->regs[7] = uc->uc_mcontext.regs[7];
+      sc->regs[8] = uc->uc_mcontext.regs[8];
+      sc->regs[9] = uc->uc_mcontext.regs[9];
+      sc->regs[10] = uc->uc_mcontext.regs[10];
+      sc->regs[11] = uc->uc_mcontext.regs[11];
+      sc->regs[12] = uc->uc_mcontext.regs[12];
+      sc->regs[13] = uc->uc_mcontext.regs[13];
+      sc->regs[14] = uc->uc_mcontext.regs[14];
+      sc->regs[15] = uc->uc_mcontext.regs[15];
+      sc->regs[16] = uc->uc_mcontext.regs[16];
+      sc->regs[17] = uc->uc_mcontext.regs[17];
+      sc->regs[18] = uc->uc_mcontext.regs[18];
+      sc->regs[19] = uc->uc_mcontext.regs[19];
+      sc->regs[20] = uc->uc_mcontext.regs[20];
+      sc->regs[21] = uc->uc_mcontext.regs[21];
+      sc->regs[22] = uc->uc_mcontext.regs[22];
+      sc->regs[23] = uc->uc_mcontext.regs[23];
+      sc->regs[24] = uc->uc_mcontext.regs[24];
+      sc->regs[25] = uc->uc_mcontext.regs[25];
+      sc->regs[26] = uc->uc_mcontext.regs[26];
+      sc->regs[27] = uc->uc_mcontext.regs[27];
+      sc->regs[28] = uc->uc_mcontext.regs[28];
+      sc->regs[29] = uc->uc_mcontext.regs[29];
+      sc->regs[30] = uc->uc_mcontext.regs[30];
+      sc->sp = uc->uc_mcontext.sp;
+      sc->pc = uc->uc_mcontext.pc;
+      sc->pstate = uc->uc_mcontext.pstate;
+
+      asm volatile (
+        "mov sp, %0\n"
+        "ret %1\n"
+        : : "r" (c->sigcontext_sp), "r" (c->sigcontext_pc)
+      );
+   }
+  unreachable();
+#else
+  printf ("%s: implement me\n", __FUNCTION__);
+#endif
+  return -UNW_EINVAL;
+}
+
+#endif /* !UNW_REMOTE_ONLY */
+
+static inline void
+establish_machine_state (struct cursor *c)
+{
+  unw_addr_space_t as = c->dwarf.as;
+  void *arg = c->dwarf.as_arg;
+  unw_fpreg_t fpval;
+  unw_word_t val;
+  int reg;
+
+  Debug (8, "copying out cursor state\n");
+
+  for (reg = 0; reg <= UNW_AARCH64_V31; ++reg)
+    {
+      Debug (16, "copying %s %d\n", unw_regname (reg), reg);
+      if (unw_is_fpreg (reg))
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            as->acc.access_fpreg (as, reg, &fpval, 1, arg);
+        }
+      else
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            as->acc.access_reg (as, reg, &val, 1, arg);
+        }
+    }
+}
+
+int
+unw_resume (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  if (!c->dwarf.ip)
+    {
+      /* This can happen easily when the frame-chain gets truncated
+         due to bad or missing unwind-info.  */
+      Debug (1, "refusing to resume execution at address 0\n");
+      return -UNW_EINVAL;
+    }
+
+  establish_machine_state (c);
+
+  return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
+                                     c->dwarf.as_arg);
+}
diff --git a/src/aarch64/Gstash_frame.c b/src/aarch64/Gstash_frame.c
new file mode 100644
index 0000000..6689af1
--- /dev/null
+++ b/src/aarch64/Gstash_frame.c
@@ -0,0 +1,89 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2010, 2011 by FERMI NATIONAL ACCELERATOR LABORATORY
+   Copyright (C) 2014 CERN and Aalto University
+        Contributed by Filip Nyback
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+HIDDEN void
+tdep_stash_frame (struct dwarf_cursor *d, struct dwarf_reg_state *rs)
+{
+  struct cursor *c = (struct cursor *) dwarf_to_cursor (d);
+  unw_tdep_frame_t *f = &c->frame_info;
+
+  Debug (4, "ip=0x%lx cfa=0x%lx type %d cfa [where=%d val=%ld] cfaoff=%ld"
+         " ra=0x%lx fp [where=%d val=%ld @0x%lx] lr [where=%d val=%ld @0x%lx] "
+         "sp [where=%d val=%ld @0x%lx]\n",
+         d->ip, d->cfa, f->frame_type,
+         rs->reg.where[DWARF_CFA_REG_COLUMN],
+         rs->reg.val[DWARF_CFA_REG_COLUMN],
+         rs->reg.val[DWARF_CFA_OFF_COLUMN],
+         DWARF_GET_LOC(d->loc[rs->ret_addr_column]),
+         rs->reg.where[FP], rs->reg.val[FP], DWARF_GET_LOC(d->loc[FP]),
+         rs->reg.where[LR], rs->reg.val[LR], DWARF_GET_LOC(d->loc[LR]),
+         rs->reg.where[SP], rs->reg.val[SP], DWARF_GET_LOC(d->loc[SP]));
+
+  /* A standard frame is defined as:
+      - CFA is register-relative offset off FP or SP;
+      - Return address is saved in LR;
+      - FP is unsaved or saved at CFA+offset, offset != -1;
+      - LR is unsaved or saved at CFA+offset, offset != -1;
+      - SP is unsaved or saved at CFA+offset, offset != -1.  */
+  if (f->frame_type == UNW_AARCH64_FRAME_OTHER
+      && (rs->reg.where[DWARF_CFA_REG_COLUMN] == DWARF_WHERE_REG)
+      && (rs->reg.val[DWARF_CFA_REG_COLUMN] == FP
+          || rs->reg.val[DWARF_CFA_REG_COLUMN] == SP)
+      && labs(rs->reg.val[DWARF_CFA_OFF_COLUMN]) < (1 << 29)
+      && rs->ret_addr_column == LR
+      && (rs->reg.where[FP] == DWARF_WHERE_UNDEF
+          || rs->reg.where[FP] == DWARF_WHERE_SAME
+          || (rs->reg.where[FP] == DWARF_WHERE_CFAREL
+              && labs(rs->reg.val[FP]) < (1 << 29)
+              && rs->reg.val[FP]+1 != 0))
+      && (rs->reg.where[LR] == DWARF_WHERE_UNDEF
+          || rs->reg.where[LR] == DWARF_WHERE_SAME
+          || (rs->reg.where[LR] == DWARF_WHERE_CFAREL
+              && labs(rs->reg.val[LR]) < (1 << 29)
+              && rs->reg.val[LR]+1 != 0))
+      && (rs->reg.where[SP] == DWARF_WHERE_UNDEF
+          || rs->reg.where[SP] == DWARF_WHERE_SAME
+          || (rs->reg.where[SP] == DWARF_WHERE_CFAREL
+              && labs(rs->reg.val[SP]) < (1 << 29)
+              && rs->reg.val[SP]+1 != 0)))
+  {
+    /* Save information for a standard frame. */
+    f->frame_type = UNW_AARCH64_FRAME_STANDARD;
+    f->cfa_reg_sp = (rs->reg.val[DWARF_CFA_REG_COLUMN] == SP);
+    f->cfa_reg_offset = rs->reg.val[DWARF_CFA_OFF_COLUMN];
+    if (rs->reg.where[FP] == DWARF_WHERE_CFAREL)
+      f->fp_cfa_offset = rs->reg.val[FP];
+    if (rs->reg.where[LR] == DWARF_WHERE_CFAREL)
+      f->lr_cfa_offset = rs->reg.val[LR];
+    if (rs->reg.where[SP] == DWARF_WHERE_CFAREL)
+      f->sp_cfa_offset = rs->reg.val[SP];
+    Debug (4, " standard frame\n");
+  }
+  else
+    Debug (4, " unusual frame\n");
+}
diff --git a/src/aarch64/Gstep.c b/src/aarch64/Gstep.c
new file mode 100644
index 0000000..fdf64a7
--- /dev/null
+++ b/src/aarch64/Gstep.c
@@ -0,0 +1,189 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2011-2013 Linaro Limited
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "offsets.h"
+
+/* Recognise PLT entries such as:
+  40ddf0:       b0000570        adrp    x16, 4ba000 <_GLOBAL_OFFSET_TABLE_+0x2a8>
+  40ddf4:       f9433611        ldr     x17, [x16,#1640]
+  40ddf8:       9119a210        add     x16, x16, #0x668
+  40ddfc:       d61f0220        br      x17 */
+static int
+is_plt_entry (struct dwarf_cursor *c)
+{
+  unw_word_t w0, w1;
+  unw_accessors_t *a;
+  int ret;
+
+  a = unw_get_accessors_int (c->as);
+  if ((ret = (*a->access_mem) (c->as, c->ip, &w0, 0, c->as_arg)) < 0
+      || (ret = (*a->access_mem) (c->as, c->ip + 8, &w1, 0, c->as_arg)) < 0)
+    return 0;
+
+  ret = (((w0 & 0xff0000009f000000) == 0xf900000090000000)
+         && ((w1 & 0xffffffffff000000) == 0xd61f022091000000));
+
+  Debug (14, "ip=0x%lx => 0x%016lx 0x%016lx, ret = %d\n", c->ip, w0, w1, ret);
+  return ret;
+}
+
+static int
+aarch64_handle_signal_frame (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+  unw_word_t sc_addr, sp, sp_addr = c->dwarf.cfa;
+  struct dwarf_loc sp_loc = DWARF_LOC (sp_addr, 0);
+
+  if ((ret = dwarf_get (&c->dwarf, sp_loc, &sp)) < 0)
+    return -UNW_EUNSPEC;
+
+  ret = unw_is_signal_frame (cursor);
+  Debug(1, "unw_is_signal_frame()=%d\n", ret);
+
+  /* Save the SP and PC to be able to return execution at this point
+     later in time (unw_resume).  */
+  c->sigcontext_sp = c->dwarf.cfa;
+  c->sigcontext_pc = c->dwarf.ip;
+
+  if (ret)
+    {
+      c->sigcontext_format = AARCH64_SCF_LINUX_RT_SIGFRAME;
+      sc_addr = sp_addr + sizeof (siginfo_t) + LINUX_UC_MCONTEXT_OFF;
+    }
+  else
+    return -UNW_EUNSPEC;
+
+  c->sigcontext_addr = sc_addr;
+  c->frame_info.frame_type = UNW_AARCH64_FRAME_SIGRETURN;
+  c->frame_info.cfa_reg_offset = sc_addr - sp_addr;
+
+  /* Update the dwarf cursor.
+     Set the location of the registers to the corresponding addresses of the
+     uc_mcontext / sigcontext structure contents.  */
+  c->dwarf.loc[UNW_AARCH64_X0]  = DWARF_LOC (sc_addr + LINUX_SC_X0_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X1]  = DWARF_LOC (sc_addr + LINUX_SC_X1_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X2]  = DWARF_LOC (sc_addr + LINUX_SC_X2_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X3]  = DWARF_LOC (sc_addr + LINUX_SC_X3_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X4]  = DWARF_LOC (sc_addr + LINUX_SC_X4_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X5]  = DWARF_LOC (sc_addr + LINUX_SC_X5_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X6]  = DWARF_LOC (sc_addr + LINUX_SC_X6_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X7]  = DWARF_LOC (sc_addr + LINUX_SC_X7_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X8]  = DWARF_LOC (sc_addr + LINUX_SC_X8_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X9]  = DWARF_LOC (sc_addr + LINUX_SC_X9_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X10] = DWARF_LOC (sc_addr + LINUX_SC_X10_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X11] = DWARF_LOC (sc_addr + LINUX_SC_X11_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X12] = DWARF_LOC (sc_addr + LINUX_SC_X12_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X13] = DWARF_LOC (sc_addr + LINUX_SC_X13_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X14] = DWARF_LOC (sc_addr + LINUX_SC_X14_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X15] = DWARF_LOC (sc_addr + LINUX_SC_X15_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X16] = DWARF_LOC (sc_addr + LINUX_SC_X16_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X17] = DWARF_LOC (sc_addr + LINUX_SC_X17_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X18] = DWARF_LOC (sc_addr + LINUX_SC_X18_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X19] = DWARF_LOC (sc_addr + LINUX_SC_X19_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X20] = DWARF_LOC (sc_addr + LINUX_SC_X20_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X21] = DWARF_LOC (sc_addr + LINUX_SC_X21_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X22] = DWARF_LOC (sc_addr + LINUX_SC_X22_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X23] = DWARF_LOC (sc_addr + LINUX_SC_X23_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X24] = DWARF_LOC (sc_addr + LINUX_SC_X24_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X25] = DWARF_LOC (sc_addr + LINUX_SC_X25_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X26] = DWARF_LOC (sc_addr + LINUX_SC_X26_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X27] = DWARF_LOC (sc_addr + LINUX_SC_X27_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X28] = DWARF_LOC (sc_addr + LINUX_SC_X28_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X29] = DWARF_LOC (sc_addr + LINUX_SC_X29_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_X30] = DWARF_LOC (sc_addr + LINUX_SC_X30_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_SP]  = DWARF_LOC (sc_addr + LINUX_SC_SP_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_PC]  = DWARF_LOC (sc_addr + LINUX_SC_PC_OFF, 0);
+  c->dwarf.loc[UNW_AARCH64_PSTATE]  = DWARF_LOC (sc_addr + LINUX_SC_PSTATE_OFF, 0);
+
+  /* Set SP/CFA and PC/IP.  */
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_AARCH64_SP], &c->dwarf.cfa);
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_AARCH64_PC], &c->dwarf.ip);
+
+  c->dwarf.pi_valid = 0;
+  c->dwarf.use_prev_instr = 0;
+
+  return 1;
+}
+
+int
+unw_step (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+
+  Debug (1, "(cursor=%p, ip=0x%016lx, cfa=0x%016lx))\n",
+         c, c->dwarf.ip, c->dwarf.cfa);
+
+  /* Check if this is a signal frame. */
+  if (unw_is_signal_frame (cursor) > 0)
+    return aarch64_handle_signal_frame (cursor);
+
+  ret = dwarf_step (&c->dwarf);
+  Debug(1, "dwarf_step()=%d\n", ret);
+
+  if (unlikely (ret == -UNW_ESTOPUNWIND))
+    return ret;
+
+  if (unlikely (ret < 0))
+    {
+      /* DWARF failed. */
+      if (is_plt_entry (&c->dwarf))
+        {
+          Debug (2, "found plt entry\n");
+          c->frame_info.frame_type = UNW_AARCH64_FRAME_STANDARD;
+        }
+      else
+        {
+          Debug (2, "fallback\n");
+          c->frame_info.frame_type = UNW_AARCH64_FRAME_GUESSED;
+        }
+      /* Use link register (X30). */
+      c->frame_info.cfa_reg_offset = 0;
+      c->frame_info.cfa_reg_sp = 0;
+      c->frame_info.fp_cfa_offset = -1;
+      c->frame_info.lr_cfa_offset = -1;
+      c->frame_info.sp_cfa_offset = -1;
+      c->dwarf.loc[UNW_AARCH64_PC] = c->dwarf.loc[UNW_AARCH64_X30];
+      c->dwarf.loc[UNW_AARCH64_X30] = DWARF_NULL_LOC;
+      if (!DWARF_IS_NULL_LOC (c->dwarf.loc[UNW_AARCH64_PC]))
+        {
+          ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_AARCH64_PC], &c->dwarf.ip);
+          if (ret < 0)
+            {
+              Debug (2, "failed to get pc from link register: %d\n", ret);
+              return ret;
+            }
+          Debug (2, "link register (x30) = 0x%016lx\n", c->dwarf.ip);
+          ret = 1;
+        }
+      else
+        c->dwarf.ip = 0;
+    }
+
+  return (c->dwarf.ip == 0) ? 0 : 1;
+}
diff --git a/src/aarch64/Gtrace.c b/src/aarch64/Gtrace.c
new file mode 100644
index 0000000..c67faf0
--- /dev/null
+++ b/src/aarch64/Gtrace.c
@@ -0,0 +1,548 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2010, 2011 by FERMI NATIONAL ACCELERATOR LABORATORY
+   Copyright (C) 2014 CERN and Aalto University
+        Contributed by Filip Nyback
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "offsets.h"
+#include <signal.h>
+#include <limits.h>
+
+#pragma weak pthread_once
+#pragma weak pthread_key_create
+#pragma weak pthread_getspecific
+#pragma weak pthread_setspecific
+
+/* Initial hash table size. Table expands by 2 bits (times four). */
+#define HASH_MIN_BITS 14
+
+typedef struct
+{
+  unw_tdep_frame_t *frames;
+  size_t log_size;
+  size_t used;
+  size_t dtor_count;  /* Counts how many times our destructor has already
+                         been called. */
+} unw_trace_cache_t;
+
+static const unw_tdep_frame_t empty_frame = { 0, UNW_AARCH64_FRAME_OTHER, -1, -1, 0, -1, -1, -1 };
+static define_lock (trace_init_lock);
+static pthread_once_t trace_cache_once = PTHREAD_ONCE_INIT;
+static sig_atomic_t trace_cache_once_happen;
+static pthread_key_t trace_cache_key;
+static struct mempool trace_cache_pool;
+static __thread  unw_trace_cache_t *tls_cache;
+static __thread  int tls_cache_destroyed;
+
+/* Free memory for a thread's trace cache. */
+static void
+trace_cache_free (void *arg)
+{
+  unw_trace_cache_t *cache = arg;
+  if (++cache->dtor_count < PTHREAD_DESTRUCTOR_ITERATIONS)
+  {
+    /* Not yet our turn to get destroyed. Re-install ourselves into the key. */
+    pthread_setspecific(trace_cache_key, cache);
+    Debug(5, "delayed freeing cache %p (%zx to go)\n", cache,
+          PTHREAD_DESTRUCTOR_ITERATIONS - cache->dtor_count);
+    return;
+  }
+  tls_cache_destroyed = 1;
+  tls_cache = NULL;
+  munmap (cache->frames, (1u << cache->log_size) * sizeof(unw_tdep_frame_t));
+  mempool_free (&trace_cache_pool, cache);
+  Debug(5, "freed cache %p\n", cache);
+}
+
+/* Initialise frame tracing for threaded use. */
+static void
+trace_cache_init_once (void)
+{
+  pthread_key_create (&trace_cache_key, &trace_cache_free);
+  mempool_init (&trace_cache_pool, sizeof (unw_trace_cache_t), 0);
+  trace_cache_once_happen = 1;
+}
+
+static unw_tdep_frame_t *
+trace_cache_buckets (size_t n)
+{
+  unw_tdep_frame_t *frames;
+  size_t i;
+
+  GET_MEMORY(frames, n * sizeof (unw_tdep_frame_t));
+  if (likely(frames != NULL))
+    for (i = 0; i < n; ++i)
+      frames[i] = empty_frame;
+
+  return frames;
+}
+
+/* Allocate and initialise hash table for frame cache lookups.
+   Returns the cache initialised with (1u << HASH_LOW_BITS) hash
+   buckets, or NULL if there was a memory allocation problem. */
+static unw_trace_cache_t *
+trace_cache_create (void)
+{
+  unw_trace_cache_t *cache;
+
+  if (tls_cache_destroyed)
+  {
+    /* The current thread is in the process of exiting. Don't recreate
+       cache, as we wouldn't have another chance to free it. */
+    Debug(5, "refusing to reallocate cache: "
+             "thread-locals are being deallocated\n");
+    return NULL;
+  }
+
+  if (! (cache = mempool_alloc(&trace_cache_pool)))
+  {
+    Debug(5, "failed to allocate cache\n");
+    return NULL;
+  }
+
+  if (! (cache->frames = trace_cache_buckets(1u << HASH_MIN_BITS)))
+  {
+    Debug(5, "failed to allocate buckets\n");
+    mempool_free(&trace_cache_pool, cache);
+    return NULL;
+  }
+
+  cache->log_size = HASH_MIN_BITS;
+  cache->used = 0;
+  cache->dtor_count = 0;
+  tls_cache_destroyed = 0;  /* Paranoia: should already be 0. */
+  Debug(5, "allocated cache %p\n", cache);
+  return cache;
+}
+
+/* Expand the hash table in the frame cache if possible. This always
+   quadruples the hash size, and clears all previous frame entries. */
+static int
+trace_cache_expand (unw_trace_cache_t *cache)
+{
+  size_t old_size = (1u << cache->log_size);
+  size_t new_log_size = cache->log_size + 2;
+  unw_tdep_frame_t *new_frames = trace_cache_buckets (1u << new_log_size);
+
+  if (unlikely(! new_frames))
+  {
+    Debug(5, "failed to expand cache to 2^%lu buckets\n", new_log_size);
+    return -UNW_ENOMEM;
+  }
+
+  Debug(5, "expanded cache from 2^%lu to 2^%lu buckets\n", cache->log_size, new_log_size);
+  munmap(cache->frames, old_size * sizeof(unw_tdep_frame_t));
+  cache->frames = new_frames;
+  cache->log_size = new_log_size;
+  cache->used = 0;
+  return 0;
+}
+
+static unw_trace_cache_t *
+trace_cache_get_unthreaded (void)
+{
+  unw_trace_cache_t *cache;
+  intrmask_t saved_mask;
+  static unw_trace_cache_t *global_cache = NULL;
+  lock_acquire (&trace_init_lock, saved_mask);
+  if (! global_cache)
+  {
+    mempool_init (&trace_cache_pool, sizeof (unw_trace_cache_t), 0);
+    global_cache = trace_cache_create ();
+  }
+  cache = global_cache;
+  lock_release (&trace_init_lock, saved_mask);
+  Debug(5, "using cache %p\n", cache);
+  return cache;
+}
+
+/* Get the frame cache for the current thread. Create it if there is none. */
+static unw_trace_cache_t *
+trace_cache_get (void)
+{
+  unw_trace_cache_t *cache;
+  if (likely (pthread_once != NULL))
+  {
+    pthread_once(&trace_cache_once, &trace_cache_init_once);
+    if (!trace_cache_once_happen)
+    {
+      return trace_cache_get_unthreaded();
+    }
+    if (! (cache = tls_cache))
+    {
+      cache = trace_cache_create();
+      pthread_setspecific(trace_cache_key, cache);
+      tls_cache = cache;
+    }
+    Debug(5, "using cache %p\n", cache);
+    return cache;
+  }
+  else
+  {
+    return trace_cache_get_unthreaded();
+  }
+}
+
+/* Initialise frame properties for address cache slot F at address
+   PC using current CFA, FP and SP values.  Modifies CURSOR to
+   that location, performs one unw_step(), and fills F with what
+   was discovered about the location.  Returns F.
+
+   FIXME: This probably should tell DWARF handling to never evaluate
+   or use registers other than FP, SP and PC in case there is
+   highly unusual unwind info which uses these creatively. */
+static unw_tdep_frame_t *
+trace_init_addr (unw_tdep_frame_t *f,
+                 unw_cursor_t *cursor,
+                 unw_word_t cfa,
+                 unw_word_t pc,
+                 unw_word_t fp,
+                 unw_word_t sp)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  struct dwarf_cursor *d = &c->dwarf;
+  int ret = -UNW_EINVAL;
+
+  /* Initialise frame properties: unknown, not last. */
+  f->virtual_address = pc;
+  f->frame_type = UNW_AARCH64_FRAME_OTHER;
+  f->last_frame = 0;
+  f->cfa_reg_sp = -1;
+  f->cfa_reg_offset = 0;
+  f->fp_cfa_offset = -1;
+  f->lr_cfa_offset = -1;
+  f->sp_cfa_offset = -1;
+
+  /* Reinitialise cursor to this instruction - but undo next/prev PC
+     adjustment because unw_step will redo it - and force PC, FP and
+     SP into register locations (=~ ucontext we keep), then set
+     their desired values. Then perform the step. */
+  d->ip = pc + d->use_prev_instr;
+  d->cfa = cfa;
+  d->loc[UNW_AARCH64_X29] = DWARF_REG_LOC (d, UNW_AARCH64_X29);
+  d->loc[UNW_AARCH64_SP] = DWARF_REG_LOC (d, UNW_AARCH64_SP);
+  d->loc[UNW_AARCH64_PC] = DWARF_REG_LOC (d, UNW_AARCH64_PC);
+  c->frame_info = *f;
+
+  if (likely(dwarf_put (d, d->loc[UNW_AARCH64_X29], fp) >= 0)
+      && likely(dwarf_put (d, d->loc[UNW_AARCH64_SP], sp) >= 0)
+      && likely(dwarf_put (d, d->loc[UNW_AARCH64_PC], pc) >= 0)
+      && likely((ret = unw_step (cursor)) >= 0))
+    *f = c->frame_info;
+
+  /* If unw_step() stopped voluntarily, remember that, even if it
+     otherwise could not determine anything useful.  This avoids
+     failing trace if we hit frames without unwind info, which is
+     common for the outermost frame (CRT stuff) on many systems.
+     This avoids failing trace in very common circumstances; failing
+     to unw_step() loop wouldn't produce any better result. */
+  if (ret == 0)
+    f->last_frame = -1;
+
+  Debug (3, "frame va %lx type %d last %d cfa %s+%d fp @ cfa%+d lr @ cfa%+d sp @ cfa%+d\n",
+         f->virtual_address, f->frame_type, f->last_frame,
+         f->cfa_reg_sp ? "sp" : "fp", f->cfa_reg_offset,
+         f->fp_cfa_offset, f->lr_cfa_offset, f->sp_cfa_offset);
+
+  return f;
+}
+
+/* Look up and if necessary fill in frame attributes for address PC
+   in CACHE using current CFA, FP and SP values.  Uses CURSOR to
+   perform any unwind steps necessary to fill the cache.  Returns the
+   frame cache slot which describes RIP. */
+static unw_tdep_frame_t *
+trace_lookup (unw_cursor_t *cursor,
+              unw_trace_cache_t *cache,
+              unw_word_t cfa,
+              unw_word_t pc,
+              unw_word_t fp,
+              unw_word_t sp)
+{
+  /* First look up for previously cached information using cache as
+     linear probing hash table with probe step of 1.  Majority of
+     lookups should be completed within few steps, but it is very
+     important the hash table does not fill up, or performance falls
+     off the cliff. */
+  uint64_t i, addr;
+  uint64_t cache_size = 1u << cache->log_size;
+  uint64_t slot = ((pc * 0x9e3779b97f4a7c16) >> 43) & (cache_size-1);
+  unw_tdep_frame_t *frame;
+
+  for (i = 0; i < 16; ++i)
+  {
+    frame = &cache->frames[slot];
+    addr = frame->virtual_address;
+
+    /* Return if we found the address. */
+    if (likely(addr == pc))
+    {
+      Debug (4, "found address after %ld steps\n", i);
+      return frame;
+    }
+
+    /* If slot is empty, reuse it. */
+    if (likely(! addr))
+      break;
+
+    /* Linear probe to next slot candidate, step = 1. */
+    if (++slot >= cache_size)
+      slot -= cache_size;
+  }
+
+  /* If we collided after 16 steps, or if the hash is more than half
+     full, force the hash to expand. Fill the selected slot, whether
+     it's free or collides. Note that hash expansion drops previous
+     contents; further lookups will refill the hash. */
+  Debug (4, "updating slot %lu after %ld steps, replacing 0x%lx\n", slot, i, addr);
+  if (unlikely(addr || cache->used >= cache_size / 2))
+  {
+    if (unlikely(trace_cache_expand (cache) < 0))
+      return NULL;
+
+    cache_size = 1u << cache->log_size;
+    slot = ((pc * 0x9e3779b97f4a7c16) >> 43) & (cache_size-1);
+    frame = &cache->frames[slot];
+    addr = frame->virtual_address;
+  }
+
+  if (! addr)
+    ++cache->used;
+
+  return trace_init_addr (frame, cursor, cfa, pc, fp, sp);
+}
+
+/* Fast stack backtrace for AArch64.
+
+   This is used by backtrace() implementation to accelerate frequent
+   queries for current stack, without any desire to unwind. It fills
+   BUFFER with the call tree from CURSOR upwards for at most SIZE
+   stack levels. The first frame, backtrace itself, is omitted. When
+   called, SIZE should give the maximum number of entries that can be
+   stored into BUFFER. Uses an internal thread-specific cache to
+   accelerate queries.
+
+   The caller should fall back to a unw_step() loop if this function
+   fails by returning -UNW_ESTOPUNWIND, meaning the routine hit a
+   stack frame that is too complex to be traced in the fast path.
+
+   This function is tuned for clients which only need to walk the
+   stack to get the call tree as fast as possible but without any
+   other details, for example profilers sampling the stack thousands
+   to millions of times per second.  The routine handles the most
+   common AArch64 ABI stack layouts: CFA is FP or SP plus/minus
+   constant offset, return address is in LR, and FP, LR and SP are
+   either unchanged or saved on stack at constant offset from the CFA;
+   the signal return frame; and frames without unwind info provided
+   they are at the outermost (final) frame or can conservatively be
+   assumed to be frame-pointer based.
+
+   Any other stack layout will cause the routine to give up. There
+   are only a handful of relatively rarely used functions which do
+   not have a stack in the standard form: vfork, longjmp, setcontext
+   and _dl_runtime_profile on common linux systems for example.
+
+   On success BUFFER and *SIZE reflect the trace progress up to *SIZE
+   stack levels or the outermost frame, which ever is less.  It may
+   stop short of outermost frame if unw_step() loop would also do so,
+   e.g. if there is no more unwind information; this is not reported
+   as an error.
+
+   The function returns a negative value for errors, -UNW_ESTOPUNWIND
+   if tracing stopped because of an unusual frame unwind info.  The
+   BUFFER and *SIZE reflect tracing progress up to the error frame.
+
+   Callers of this function would normally look like this:
+
+     unw_cursor_t     cur;
+     unw_context_t    ctx;
+     void             addrs[128];
+     int              depth = 128;
+     int              ret;
+
+     unw_getcontext(&ctx);
+     unw_init_local(&cur, &ctx);
+     if ((ret = unw_tdep_trace(&cur, addrs, &depth)) < 0)
+     {
+       depth = 0;
+       unw_getcontext(&ctx);
+       unw_init_local(&cur, &ctx);
+       while ((ret = unw_step(&cur)) > 0 && depth < 128)
+       {
+         unw_word_t ip;
+         unw_get_reg(&cur, UNW_REG_IP, &ip);
+         addresses[depth++] = (void *) ip;
+       }
+     }
+*/
+HIDDEN int
+tdep_trace (unw_cursor_t *cursor, void **buffer, int *size)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  struct dwarf_cursor *d = &c->dwarf;
+  unw_trace_cache_t *cache;
+  unw_word_t fp, sp, pc, cfa, lr;
+  int maxdepth = 0;
+  int depth = 0;
+  int ret;
+
+  /* Check input parametres. */
+  if (unlikely(! cursor || ! buffer || ! size || (maxdepth = *size) <= 0))
+    return -UNW_EINVAL;
+
+  Debug (1, "begin ip 0x%lx cfa 0x%lx\n", d->ip, d->cfa);
+
+  /* Tell core dwarf routines to call back to us. */
+  d->stash_frames = 1;
+
+  /* Determine initial register values. These are direct access safe
+     because we know they come from the initial machine context. */
+  pc = d->ip;
+  sp = cfa = d->cfa;
+  ACCESS_MEM_FAST(ret, 0, d, DWARF_GET_LOC(d->loc[UNW_AARCH64_X29]), fp);
+  assert(ret == 0);
+  lr = 0;
+
+  /* Get frame cache. */
+  if (unlikely(! (cache = trace_cache_get())))
+  {
+    Debug (1, "returning %d, cannot get trace cache\n", -UNW_ENOMEM);
+    *size = 0;
+    d->stash_frames = 0;
+    return -UNW_ENOMEM;
+  }
+
+  /* Trace the stack upwards, starting from current RIP.  Adjust
+     the RIP address for previous/next instruction as the main
+     unwinding logic would also do.  We undo this before calling
+     back into unw_step(). */
+  while (depth < maxdepth)
+  {
+    pc -= d->use_prev_instr;
+    Debug (2, "depth %d cfa 0x%lx pc 0x%lx sp 0x%lx fp 0x%lx\n",
+           depth, cfa, pc, sp, fp);
+
+    /* See if we have this address cached.  If not, evaluate enough of
+       the dwarf unwind information to fill the cache line data, or to
+       decide this frame cannot be handled in fast trace mode.  We
+       cache negative results too to prevent unnecessary dwarf parsing
+       for common failures. */
+    unw_tdep_frame_t *f = trace_lookup (cursor, cache, cfa, pc, fp, sp);
+
+    /* If we don't have information for this frame, give up. */
+    if (unlikely(! f))
+    {
+      ret = -UNW_ENOINFO;
+      break;
+    }
+
+    Debug (3, "frame va %lx type %d last %d cfa %s+%d fp @ cfa%+d lr @ cfa%+d sp @ cfa%+d\n",
+           f->virtual_address, f->frame_type, f->last_frame,
+           f->cfa_reg_sp ? "sp" : "fp", f->cfa_reg_offset,
+           f->fp_cfa_offset, f->lr_cfa_offset, f->sp_cfa_offset);
+
+    assert (f->virtual_address == pc);
+
+    /* Stop if this was the last frame.  In particular don't evaluate
+       new register values as it may not be safe - we don't normally
+       run with full validation on, and do not want to - and there's
+       enough bad unwind info floating around that we need to trust
+       what unw_step() previously said, in potentially bogus frames. */
+    if (f->last_frame)
+      break;
+
+    /* Evaluate CFA and registers for the next frame. */
+    switch (f->frame_type)
+    {
+    case UNW_AARCH64_FRAME_GUESSED:
+      /* Fall thru to standard processing after forcing validation. */
+      c->validate = 1;
+
+    case UNW_AARCH64_FRAME_STANDARD:
+      /* Advance standard traceable frame. */
+      cfa = (f->cfa_reg_sp ? sp : fp) + f->cfa_reg_offset;
+      if (likely(f->lr_cfa_offset != -1))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + f->lr_cfa_offset, pc);
+      else if (lr != 0)
+      {
+        /* Use the saved link register as the new pc. */
+        pc = lr;
+        lr = 0;
+      }
+      if (likely(ret >= 0) && likely(f->fp_cfa_offset != -1))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + f->fp_cfa_offset, fp);
+
+      /* Don't bother reading SP from DWARF, CFA becomes new SP. */
+      sp = cfa;
+
+      /* Next frame needs to back up for unwind info lookup. */
+      d->use_prev_instr = 1;
+      break;
+
+    case UNW_AARCH64_FRAME_SIGRETURN:
+      cfa = cfa + f->cfa_reg_offset; /* cfa now points to ucontext_t.  */
+
+      ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_PC_OFF, pc);
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_X29_OFF, fp);
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_SP_OFF, sp);
+      /* Save the link register here in case we end up in a function that
+         doesn't save the link register in the prologue, e.g. kill. */
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_X30_OFF, lr);
+
+      /* Resume stack at signal restoration point. The stack is not
+         necessarily continuous here, especially with sigaltstack(). */
+      cfa = sp;
+
+      /* Next frame should not back up. */
+      d->use_prev_instr = 0;
+      break;
+
+    default:
+      /* We cannot trace through this frame, give up and tell the
+          caller we had to stop.  Data collected so far may still be
+          useful to the caller, so let it know how far we got.  */
+      ret = -UNW_ESTOPUNWIND;
+      break;
+    }
+
+    Debug (4, "new cfa 0x%lx pc 0x%lx sp 0x%lx fp 0x%lx\n",
+           cfa, pc, sp, fp);
+
+    /* If we failed or ended up somewhere bogus, stop. */
+    if (unlikely(ret < 0 || pc < 0x4000))
+      break;
+
+    /* Record this address in stack trace. We skipped the first address. */
+    buffer[depth++] = (void *) (pc - d->use_prev_instr);
+  }
+
+#if UNW_DEBUG
+  Debug (1, "returning %d, depth %d\n", ret, depth);
+#endif
+  *size = depth;
+  return ret;
+}
diff --git a/src/aarch64/Lapply_reg_state.c b/src/aarch64/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/aarch64/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/aarch64/Lcreate_addr_space.c b/src/aarch64/Lcreate_addr_space.c
new file mode 100644
index 0000000..0f2dc6b
--- /dev/null
+++ b/src/aarch64/Lcreate_addr_space.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gcreate_addr_space.c"
+#endif
diff --git a/src/aarch64/Lget_proc_info.c b/src/aarch64/Lget_proc_info.c
new file mode 100644
index 0000000..69028b0
--- /dev/null
+++ b/src/aarch64/Lget_proc_info.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gget_proc_info.c"
+#endif
diff --git a/src/aarch64/Lget_save_loc.c b/src/aarch64/Lget_save_loc.c
new file mode 100644
index 0000000..9ea048a
--- /dev/null
+++ b/src/aarch64/Lget_save_loc.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gget_save_loc.c"
+#endif
diff --git a/src/aarch64/Lglobal.c b/src/aarch64/Lglobal.c
new file mode 100644
index 0000000..6d7b489
--- /dev/null
+++ b/src/aarch64/Lglobal.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gglobal.c"
+#endif
diff --git a/src/aarch64/Linit.c b/src/aarch64/Linit.c
new file mode 100644
index 0000000..e9abfdd
--- /dev/null
+++ b/src/aarch64/Linit.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit.c"
+#endif
diff --git a/src/aarch64/Linit_local.c b/src/aarch64/Linit_local.c
new file mode 100644
index 0000000..68a1687
--- /dev/null
+++ b/src/aarch64/Linit_local.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit_local.c"
+#endif
diff --git a/src/aarch64/Linit_remote.c b/src/aarch64/Linit_remote.c
new file mode 100644
index 0000000..58cb04a
--- /dev/null
+++ b/src/aarch64/Linit_remote.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit_remote.c"
+#endif
diff --git a/src/aarch64/Lis_signal_frame.c b/src/aarch64/Lis_signal_frame.c
new file mode 100644
index 0000000..b9a7c4f
--- /dev/null
+++ b/src/aarch64/Lis_signal_frame.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gis_signal_frame.c"
+#endif
diff --git a/src/aarch64/Lreg_states_iterate.c b/src/aarch64/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/aarch64/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/aarch64/Lregs.c b/src/aarch64/Lregs.c
new file mode 100644
index 0000000..2c9c75c
--- /dev/null
+++ b/src/aarch64/Lregs.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gregs.c"
+#endif
diff --git a/src/aarch64/Lresume.c b/src/aarch64/Lresume.c
new file mode 100644
index 0000000..41a8cf0
--- /dev/null
+++ b/src/aarch64/Lresume.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gresume.c"
+#endif
diff --git a/src/aarch64/Lstash_frame.c b/src/aarch64/Lstash_frame.c
new file mode 100644
index 0000000..7758780
--- /dev/null
+++ b/src/aarch64/Lstash_frame.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gstash_frame.c"
+#endif
diff --git a/src/aarch64/Lstep.c b/src/aarch64/Lstep.c
new file mode 100644
index 0000000..c1ac3c7
--- /dev/null
+++ b/src/aarch64/Lstep.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gstep.c"
+#endif
diff --git a/src/aarch64/Ltrace.c b/src/aarch64/Ltrace.c
new file mode 100644
index 0000000..fcd3f23
--- /dev/null
+++ b/src/aarch64/Ltrace.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gtrace.c"
+#endif
diff --git a/src/aarch64/getcontext.S b/src/aarch64/getcontext.S
new file mode 100644
index 0000000..25ed5b6
--- /dev/null
+++ b/src/aarch64/getcontext.S
@@ -0,0 +1,52 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 Google, Inc
+	Contributed by Paul Pluzhnikov <ppluzhnikov@google.com>
+   Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "offsets.h"
+
+/*  int _Uaarch64_getcontext_trace (unw_tdep_context_t *ucp)
+
+  Saves limited machine context in UCP necessary for fast trace. If fast trace
+  fails, caller will have to get the full context.
+*/
+
+	.global _Uaarch64_getcontext_trace
+	.hidden _Uaarch64_getcontext_trace
+	.type _Uaarch64_getcontext_trace, @function
+_Uaarch64_getcontext_trace:
+	.cfi_startproc
+
+	/* Save only FP, SP, PC - exclude this call. */
+	str x29, [x0, #(LINUX_UC_MCONTEXT_OFF + LINUX_SC_X29_OFF)]
+	mov x9, sp
+	str x9, [x0, #(LINUX_UC_MCONTEXT_OFF + LINUX_SC_SP_OFF)]
+	str x30, [x0, #(LINUX_UC_MCONTEXT_OFF + LINUX_SC_PC_OFF)]
+
+	ret
+	.cfi_endproc
+	.size _Uaarch64_getcontext_trace, . - _Uaarch64_getcontext_trace
+
+      /* We do not need executable stack.  */
+      .section        .note.GNU-stack,"",@progbits
diff --git a/src/aarch64/init.h b/src/aarch64/init.h
new file mode 100644
index 0000000..5dab60b
--- /dev/null
+++ b/src/aarch64/init.h
@@ -0,0 +1,126 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+static inline int
+common_init (struct cursor *c, unsigned use_prev_instr)
+{
+  int ret, i;
+
+  c->dwarf.loc[UNW_AARCH64_X0]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X0);
+  c->dwarf.loc[UNW_AARCH64_X1]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X1);
+  c->dwarf.loc[UNW_AARCH64_X2]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X2);
+  c->dwarf.loc[UNW_AARCH64_X3]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X3);
+  c->dwarf.loc[UNW_AARCH64_X4]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X4);
+  c->dwarf.loc[UNW_AARCH64_X5]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X5);
+  c->dwarf.loc[UNW_AARCH64_X6]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X6);
+  c->dwarf.loc[UNW_AARCH64_X7]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X7);
+  c->dwarf.loc[UNW_AARCH64_X8]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X8);
+  c->dwarf.loc[UNW_AARCH64_X9]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X9);
+  c->dwarf.loc[UNW_AARCH64_X10] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X10);
+  c->dwarf.loc[UNW_AARCH64_X11] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X11);
+  c->dwarf.loc[UNW_AARCH64_X12] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X12);
+  c->dwarf.loc[UNW_AARCH64_X13] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X13);
+  c->dwarf.loc[UNW_AARCH64_X14] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X14);
+  c->dwarf.loc[UNW_AARCH64_X15] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X15);
+  c->dwarf.loc[UNW_AARCH64_X16] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X16);
+  c->dwarf.loc[UNW_AARCH64_X17] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X17);
+  c->dwarf.loc[UNW_AARCH64_X18] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X18);
+  c->dwarf.loc[UNW_AARCH64_X19] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X19);
+  c->dwarf.loc[UNW_AARCH64_X20] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X20);
+  c->dwarf.loc[UNW_AARCH64_X21] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X21);
+  c->dwarf.loc[UNW_AARCH64_X22] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X22);
+  c->dwarf.loc[UNW_AARCH64_X23] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X23);
+  c->dwarf.loc[UNW_AARCH64_X24] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X24);
+  c->dwarf.loc[UNW_AARCH64_X25] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X25);
+  c->dwarf.loc[UNW_AARCH64_X26] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X26);
+  c->dwarf.loc[UNW_AARCH64_X27] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X27);
+  c->dwarf.loc[UNW_AARCH64_X28] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X28);
+  c->dwarf.loc[UNW_AARCH64_X29] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X29);
+  c->dwarf.loc[UNW_AARCH64_X30] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_X30);
+  c->dwarf.loc[UNW_AARCH64_SP]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_SP);
+  c->dwarf.loc[UNW_AARCH64_PC]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_PC);
+  c->dwarf.loc[UNW_AARCH64_PSTATE] = DWARF_REG_LOC (&c->dwarf,
+                                                    UNW_AARCH64_PSTATE);
+  c->dwarf.loc[UNW_AARCH64_V0]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V0);
+  c->dwarf.loc[UNW_AARCH64_V1]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V1);
+  c->dwarf.loc[UNW_AARCH64_V2]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V2);
+  c->dwarf.loc[UNW_AARCH64_V3]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V3);
+  c->dwarf.loc[UNW_AARCH64_V4]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V4);
+  c->dwarf.loc[UNW_AARCH64_V5]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V5);
+  c->dwarf.loc[UNW_AARCH64_V6]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V6);
+  c->dwarf.loc[UNW_AARCH64_V7]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V7);
+  c->dwarf.loc[UNW_AARCH64_V8]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V8);
+  c->dwarf.loc[UNW_AARCH64_V9]  = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V9);
+  c->dwarf.loc[UNW_AARCH64_V10] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V10);
+  c->dwarf.loc[UNW_AARCH64_V11] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V11);
+  c->dwarf.loc[UNW_AARCH64_V12] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V12);
+  c->dwarf.loc[UNW_AARCH64_V13] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V13);
+  c->dwarf.loc[UNW_AARCH64_V14] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V14);
+  c->dwarf.loc[UNW_AARCH64_V15] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V15);
+  c->dwarf.loc[UNW_AARCH64_V16] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V16);
+  c->dwarf.loc[UNW_AARCH64_V17] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V17);
+  c->dwarf.loc[UNW_AARCH64_V18] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V18);
+  c->dwarf.loc[UNW_AARCH64_V19] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V19);
+  c->dwarf.loc[UNW_AARCH64_V20] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V20);
+  c->dwarf.loc[UNW_AARCH64_V21] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V21);
+  c->dwarf.loc[UNW_AARCH64_V22] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V22);
+  c->dwarf.loc[UNW_AARCH64_V23] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V23);
+  c->dwarf.loc[UNW_AARCH64_V24] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V24);
+  c->dwarf.loc[UNW_AARCH64_V25] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V25);
+  c->dwarf.loc[UNW_AARCH64_V26] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V26);
+  c->dwarf.loc[UNW_AARCH64_V27] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V27);
+  c->dwarf.loc[UNW_AARCH64_V28] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V28);
+  c->dwarf.loc[UNW_AARCH64_V29] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V29);
+  c->dwarf.loc[UNW_AARCH64_V30] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V30);
+  c->dwarf.loc[UNW_AARCH64_V31] = DWARF_REG_LOC (&c->dwarf, UNW_AARCH64_V31);
+
+  for (i = UNW_AARCH64_PSTATE + 1; i < UNW_AARCH64_V0; ++i)
+    c->dwarf.loc[i] = DWARF_NULL_LOC;
+
+  ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_AARCH64_PC], &c->dwarf.ip);
+  if (ret < 0)
+    return ret;
+
+  ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_AARCH64_SP], &c->dwarf.cfa);
+  if (ret < 0)
+    return ret;
+
+  c->sigcontext_format = AARCH64_SCF_NONE;
+  c->sigcontext_addr = 0;
+  c->sigcontext_sp = 0;
+  c->sigcontext_pc = 0;
+
+  c->dwarf.args_size = 0;
+  c->dwarf.stash_frames = 0;
+  c->dwarf.use_prev_instr = use_prev_instr;
+  c->dwarf.pi_valid = 0;
+  c->dwarf.pi_is_dynamic = 0;
+  c->dwarf.hint = 0;
+  c->dwarf.prev_rs = 0;
+
+  return 0;
+}
diff --git a/src/aarch64/is_fpreg.c b/src/aarch64/is_fpreg.c
new file mode 100644
index 0000000..2981d27
--- /dev/null
+++ b/src/aarch64/is_fpreg.c
@@ -0,0 +1,32 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "libunwind_i.h"
+
+int
+unw_is_fpreg (int regnum)
+{
+  return (regnum >= UNW_AARCH64_V0 && regnum <= UNW_AARCH64_V31);
+}
diff --git a/src/aarch64/offsets.h b/src/aarch64/offsets.h
new file mode 100644
index 0000000..e78251d
--- /dev/null
+++ b/src/aarch64/offsets.h
@@ -0,0 +1,49 @@
+/* Linux-specific definitions: */
+
+/* Define various structure offsets to simplify cross-compilation.  */
+
+/* Offsets for AArch64 Linux "ucontext_t":  */
+
+#define LINUX_UC_FLAGS_OFF      0x0
+#define LINUX_UC_LINK_OFF       0x8
+#define LINUX_UC_STACK_OFF      0x10
+#define LINUX_UC_SIGMASK_OFF    0x28
+#define LINUX_UC_MCONTEXT_OFF   0xb0
+
+/* Offsets for AArch64 Linux "struct sigcontext":  */
+
+#define LINUX_SC_FAULTADDRESS_OFF       0x00
+#define LINUX_SC_X0_OFF         0x008
+#define LINUX_SC_X1_OFF         0x010
+#define LINUX_SC_X2_OFF         0x018
+#define LINUX_SC_X3_OFF         0x020
+#define LINUX_SC_X4_OFF         0x028
+#define LINUX_SC_X5_OFF         0x030
+#define LINUX_SC_X6_OFF         0x038
+#define LINUX_SC_X7_OFF         0x040
+#define LINUX_SC_X8_OFF         0x048
+#define LINUX_SC_X9_OFF         0x050
+#define LINUX_SC_X10_OFF        0x058
+#define LINUX_SC_X11_OFF        0x060
+#define LINUX_SC_X12_OFF        0x068
+#define LINUX_SC_X13_OFF        0x070
+#define LINUX_SC_X14_OFF        0x078
+#define LINUX_SC_X15_OFF        0x080
+#define LINUX_SC_X16_OFF        0x088
+#define LINUX_SC_X17_OFF        0x090
+#define LINUX_SC_X18_OFF        0x098
+#define LINUX_SC_X19_OFF        0x0a0
+#define LINUX_SC_X20_OFF        0x0a8
+#define LINUX_SC_X21_OFF        0x0b0
+#define LINUX_SC_X22_OFF        0x0b8
+#define LINUX_SC_X23_OFF        0x0c0
+#define LINUX_SC_X24_OFF        0x0c8
+#define LINUX_SC_X25_OFF        0x0d0
+#define LINUX_SC_X26_OFF        0x0d8
+#define LINUX_SC_X27_OFF        0x0e0
+#define LINUX_SC_X28_OFF        0x0e8
+#define LINUX_SC_X29_OFF        0x0f0
+#define LINUX_SC_X30_OFF        0x0f8
+#define LINUX_SC_SP_OFF         0x100
+#define LINUX_SC_PC_OFF         0x108
+#define LINUX_SC_PSTATE_OFF     0x110
diff --git a/src/aarch64/regname.c b/src/aarch64/regname.c
new file mode 100644
index 0000000..0f7a8bd
--- /dev/null
+++ b/src/aarch64/regname.c
@@ -0,0 +1,106 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+static const char *const regname[] =
+  {
+    [UNW_AARCH64_X0] = "x0",
+    [UNW_AARCH64_X1] = "x1",
+    [UNW_AARCH64_X2] = "x2",
+    [UNW_AARCH64_X3] = "x3",
+    [UNW_AARCH64_X4] = "x4",
+    [UNW_AARCH64_X5] = "x5",
+    [UNW_AARCH64_X6] = "x6",
+    [UNW_AARCH64_X7] = "x7",
+    [UNW_AARCH64_X8] = "x8",
+    [UNW_AARCH64_X9] = "x9",
+    [UNW_AARCH64_X10] = "x10",
+    [UNW_AARCH64_X11] = "x11",
+    [UNW_AARCH64_X12] = "x12",
+    [UNW_AARCH64_X13] = "x13",
+    [UNW_AARCH64_X14] = "x14",
+    [UNW_AARCH64_X15] = "x15",
+    [UNW_AARCH64_X16] = "ip0",
+    [UNW_AARCH64_X17] = "ip1",
+    [UNW_AARCH64_X18] = "x18",
+    [UNW_AARCH64_X19] = "x19",
+    [UNW_AARCH64_X20] = "x20",
+    [UNW_AARCH64_X21] = "x21",
+    [UNW_AARCH64_X22] = "x22",
+    [UNW_AARCH64_X23] = "x23",
+    [UNW_AARCH64_X24] = "x24",
+    [UNW_AARCH64_X25] = "x25",
+    [UNW_AARCH64_X26] = "x26",
+    [UNW_AARCH64_X27] = "x27",
+    [UNW_AARCH64_X28] = "x28",
+    [UNW_AARCH64_X29] = "fp",
+    [UNW_AARCH64_X30] = "lr",
+    [UNW_AARCH64_SP] = "sp",
+    [UNW_AARCH64_PC] = "pc",
+    [UNW_AARCH64_V0] = "v0",
+    [UNW_AARCH64_V1] = "v1",
+    [UNW_AARCH64_V2] = "v2",
+    [UNW_AARCH64_V3] = "v3",
+    [UNW_AARCH64_V4] = "v4",
+    [UNW_AARCH64_V5] = "v5",
+    [UNW_AARCH64_V6] = "v6",
+    [UNW_AARCH64_V7] = "v7",
+    [UNW_AARCH64_V8] = "v8",
+    [UNW_AARCH64_V9] = "v9",
+    [UNW_AARCH64_V10] = "v10",
+    [UNW_AARCH64_V11] = "v11",
+    [UNW_AARCH64_V12] = "v12",
+    [UNW_AARCH64_V13] = "v13",
+    [UNW_AARCH64_V14] = "v14",
+    [UNW_AARCH64_V15] = "v15",
+    [UNW_AARCH64_V16] = "v16",
+    [UNW_AARCH64_V17] = "v17",
+    [UNW_AARCH64_V18] = "v18",
+    [UNW_AARCH64_V19] = "v19",
+    [UNW_AARCH64_V20] = "v20",
+    [UNW_AARCH64_V21] = "v21",
+    [UNW_AARCH64_V22] = "v22",
+    [UNW_AARCH64_V23] = "v23",
+    [UNW_AARCH64_V24] = "v24",
+    [UNW_AARCH64_V25] = "v25",
+    [UNW_AARCH64_V26] = "v26",
+    [UNW_AARCH64_V27] = "v27",
+    [UNW_AARCH64_V28] = "v28",
+    [UNW_AARCH64_V29] = "v29",
+    [UNW_AARCH64_V30] = "v30",
+    [UNW_AARCH64_V31] = "v31",
+    [UNW_AARCH64_FPSR] = "fpsr",
+    [UNW_AARCH64_FPCR] = "fpcr",
+  };
+
+const char *
+unw_regname (unw_regnum_t reg)
+{
+  if (reg < (unw_regnum_t) ARRAY_SIZE (regname) && regname[reg] != NULL)
+    return regname[reg];
+  else
+    return "???";
+}
diff --git a/src/aarch64/siglongjmp.S b/src/aarch64/siglongjmp.S
new file mode 100644
index 0000000..9985c4b
--- /dev/null
+++ b/src/aarch64/siglongjmp.S
@@ -0,0 +1,12 @@
+	/* Dummy implementation for now.  */
+
+	.global _UI_siglongjmp_cont
+	.global _UI_longjmp_cont
+
+_UI_siglongjmp_cont:
+_UI_longjmp_cont:
+	ret
+#ifdef __linux__
+ /* We do not need executable stack.  */
+ .section  .note.GNU-stack,"",%progbits
+#endif
diff --git a/src/aarch64/unwind_i.h b/src/aarch64/unwind_i.h
new file mode 100644
index 0000000..db7e29d
--- /dev/null
+++ b/src/aarch64/unwind_i.h
@@ -0,0 +1,64 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2013 Linaro Limited
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef unwind_i_h
+#define unwind_i_h
+
+#include <stdint.h>
+
+#include <libunwind-aarch64.h>
+
+#include "libunwind_i.h"
+
+/* DWARF column numbers for AArch64: */
+#define X29     29
+#define FP      29
+#define X30     30
+#define LR      30
+#define SP      31
+
+#define aarch64_lock                    UNW_OBJ(lock)
+#define aarch64_local_resume            UNW_OBJ(local_resume)
+#define aarch64_local_addr_space_init   UNW_OBJ(local_addr_space_init)
+
+extern void aarch64_local_addr_space_init (void);
+extern int aarch64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
+                             void *arg);
+
+/* By-pass calls to access_mem() when known to be safe. */
+#ifdef UNW_LOCAL_ONLY
+# undef ACCESS_MEM_FAST
+# define ACCESS_MEM_FAST(ret,validate,cur,addr,to)                     \
+  do {                                                                 \
+    if (unlikely(validate))                                            \
+      (ret) = dwarf_get ((cur), DWARF_MEM_LOC ((cur), (addr)), &(to)); \
+    else                                                               \
+      (ret) = 0, (to) = *(unw_word_t *)(addr);                         \
+  } while (0)
+#endif
+
+#define GET_FPCTX(uc) ((unw_fpsimd_context_t *)(&uc->uc_mcontext.__reserved))
+
+#endif /* unwind_i_h */
diff --git a/src/arm/Gapply_reg_state.c b/src/arm/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/arm/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/arm/Gcreate_addr_space.c b/src/arm/Gcreate_addr_space.c
index 4d59a20..7b2d6ba 100644
--- a/src/arm/Gcreate_addr_space.c
+++ b/src/arm/Gcreate_addr_space.c
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED unw_addr_space_t
+unw_addr_space_t
 unw_create_addr_space (unw_accessors_t *a, int byte_order)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/arm/Gex_tables.c b/src/arm/Gex_tables.c
index 8004fb5..d6573a6 100644
--- a/src/arm/Gex_tables.c
+++ b/src/arm/Gex_tables.c
@@ -30,14 +30,14 @@ http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038a/IHI0038A_ehabi.pdf
 
 #include "libunwind_i.h"
 
-#define ARM_EXBUF_START(x)	(((x) >> 4) & 0x0f)
-#define ARM_EXBUF_COUNT(x)	((x) & 0x0f)
-#define ARM_EXBUF_END(x)	(ARM_EXBUF_START(x) + ARM_EXBUF_COUNT(x))
+#define ARM_EXBUF_START(x)      (((x) >> 4) & 0x0f)
+#define ARM_EXBUF_COUNT(x)      ((x) & 0x0f)
+#define ARM_EXBUF_END(x)        (ARM_EXBUF_START(x) + ARM_EXBUF_COUNT(x))
 
-#define ARM_EXIDX_CANT_UNWIND	0x00000001
-#define ARM_EXIDX_COMPACT	0x80000000
+#define ARM_EXIDX_CANT_UNWIND   0x00000001
+#define ARM_EXIDX_COMPACT       0x80000000
 
-#define ARM_EXTBL_OP_FINISH	0xb0
+#define ARM_EXTBL_OP_FINISH     0xb0
 
 enum arm_exbuf_cmd_flags {
   ARM_EXIDX_VFP_SHIFT_16 = 1 << 16,
@@ -61,7 +61,7 @@ prel31_read (uint32_t prel31)
 
 static inline int
 prel31_to_addr (unw_addr_space_t as, void *arg, unw_word_t prel31,
-		unw_word_t *val)
+                unw_word_t *val)
 {
   unw_word_t offset;
 
@@ -88,7 +88,7 @@ arm_exidx_apply_cmd (struct arm_exbuf_data *edata, struct dwarf_cursor *c)
     case ARM_EXIDX_CMD_FINISH:
       /* Set LR to PC if not set already.  */
       if (DWARF_IS_NULL_LOC (c->loc[UNW_ARM_R15]))
-	c->loc[UNW_ARM_R15] = c->loc[UNW_ARM_R14];
+        c->loc[UNW_ARM_R15] = c->loc[UNW_ARM_R14];
       /* Set IP.  */
       dwarf_get (c, c->loc[UNW_ARM_R15], &c->ip);
       break;
@@ -102,15 +102,15 @@ arm_exidx_apply_cmd (struct arm_exbuf_data *edata, struct dwarf_cursor *c)
       break;
     case ARM_EXIDX_CMD_REG_POP:
       for (i = 0; i < 16; i++)
-	if (edata->data & (1 << i))
-	  {
-	    Debug (2, "pop {r%d}\n", i);
-	    c->loc[UNW_ARM_R0 + i] = DWARF_LOC (c->cfa, 0);
-	    c->cfa += 4;
-	  }
+        if (edata->data & (1 << i))
+          {
+            Debug (2, "pop {r%d}\n", i);
+            c->loc[UNW_ARM_R0 + i] = DWARF_LOC (c->cfa, 0);
+            c->cfa += 4;
+          }
       /* Set cfa in case the SP got popped. */
       if (edata->data & (1 << 13))
-	dwarf_get (c, c->loc[UNW_ARM_R13], &c->cfa);
+        dwarf_get (c, c->loc[UNW_ARM_R13], &c->cfa);
       break;
     case ARM_EXIDX_CMD_REG_TO_SP:
       assert (edata->data < 16);
@@ -121,20 +121,20 @@ arm_exidx_apply_cmd (struct arm_exbuf_data *edata, struct dwarf_cursor *c)
     case ARM_EXIDX_CMD_VFP_POP:
       /* Skip VFP registers, but be sure to adjust stack */
       for (i = ARM_EXBUF_START (edata->data); i <= ARM_EXBUF_END (edata->data);
-	   i++)
-	c->cfa += 8;
+           i++)
+        c->cfa += 8;
       if (!(edata->data & ARM_EXIDX_VFP_DOUBLE))
-	c->cfa += 4;
+        c->cfa += 4;
       break;
     case ARM_EXIDX_CMD_WREG_POP:
       for (i = ARM_EXBUF_START (edata->data); i <= ARM_EXBUF_END (edata->data);
-	   i++)
-	c->cfa += 8;
+           i++)
+        c->cfa += 8;
       break;
     case ARM_EXIDX_CMD_WCGR_POP:
       for (i = 0; i < 4; i++)
-	if (edata->data & (1 << i))
-	  c->cfa += 4;
+        if (edata->data & (1 << i))
+          c->cfa += 4;
       break;
     case ARM_EXIDX_CMD_REFUSED:
     case ARM_EXIDX_CMD_RESERVED:
@@ -163,119 +163,119 @@ arm_exidx_decode (const uint8_t *buf, uint8_t len, struct dwarf_cursor *c)
     {
       uint8_t op = READ_OP ();
       if ((op & 0xc0) == 0x00)
-	{
-	  edata.cmd = ARM_EXIDX_CMD_DATA_POP;
-	  edata.data = (((int)op & 0x3f) << 2) + 4;
-	}
+        {
+          edata.cmd = ARM_EXIDX_CMD_DATA_POP;
+          edata.data = (((int)op & 0x3f) << 2) + 4;
+        }
       else if ((op & 0xc0) == 0x40)
-	{
-	  edata.cmd = ARM_EXIDX_CMD_DATA_PUSH;
-	  edata.data = (((int)op & 0x3f) << 2) + 4;
-	}
+        {
+          edata.cmd = ARM_EXIDX_CMD_DATA_PUSH;
+          edata.data = (((int)op & 0x3f) << 2) + 4;
+        }
       else if ((op & 0xf0) == 0x80)
-	{
-	  uint8_t op2 = READ_OP ();
-	  if (op == 0x80 && op2 == 0x00)
-	    edata.cmd = ARM_EXIDX_CMD_REFUSED;
-	  else
-	    {
-	      edata.cmd = ARM_EXIDX_CMD_REG_POP;
-	      edata.data = ((op & 0xf) << 8) | op2;
-	      edata.data = edata.data << 4;
-	    }
-	}
+        {
+          uint8_t op2 = READ_OP ();
+          if (op == 0x80 && op2 == 0x00)
+            edata.cmd = ARM_EXIDX_CMD_REFUSED;
+          else
+            {
+              edata.cmd = ARM_EXIDX_CMD_REG_POP;
+              edata.data = ((op & 0xf) << 8) | op2;
+              edata.data = edata.data << 4;
+            }
+        }
       else if ((op & 0xf0) == 0x90)
-	{
-	  if (op == 0x9d || op == 0x9f)
-	    edata.cmd = ARM_EXIDX_CMD_RESERVED;
-	  else
-	    {
-	      edata.cmd = ARM_EXIDX_CMD_REG_TO_SP;
-	      edata.data = op & 0x0f;
-	    }
-	}
+        {
+          if (op == 0x9d || op == 0x9f)
+            edata.cmd = ARM_EXIDX_CMD_RESERVED;
+          else
+            {
+              edata.cmd = ARM_EXIDX_CMD_REG_TO_SP;
+              edata.data = op & 0x0f;
+            }
+        }
       else if ((op & 0xf0) == 0xa0)
-	{
-	  unsigned end = (op & 0x07);
-	  edata.data = (1 << (end + 1)) - 1;
-	  edata.data = edata.data << 4;
-	  if (op & 0x08)
-	    edata.data |= 1 << 14;
-	  edata.cmd = ARM_EXIDX_CMD_REG_POP;
-	}
+        {
+          unsigned end = (op & 0x07);
+          edata.data = (1 << (end + 1)) - 1;
+          edata.data = edata.data << 4;
+          if (op & 0x08)
+            edata.data |= 1 << 14;
+          edata.cmd = ARM_EXIDX_CMD_REG_POP;
+        }
       else if (op == ARM_EXTBL_OP_FINISH)
-	{
-	  edata.cmd = ARM_EXIDX_CMD_FINISH;
-	  buf = end;
-	}
+        {
+          edata.cmd = ARM_EXIDX_CMD_FINISH;
+          buf = end;
+        }
       else if (op == 0xb1)
-	{
-	  uint8_t op2 = READ_OP ();
-	  if (op2 == 0 || (op2 & 0xf0))
-	    edata.cmd = ARM_EXIDX_CMD_RESERVED;
-	  else
-	    {
-	      edata.cmd = ARM_EXIDX_CMD_REG_POP;
-	      edata.data = op2 & 0x0f;
-	    }
-	}
+        {
+          uint8_t op2 = READ_OP ();
+          if (op2 == 0 || (op2 & 0xf0))
+            edata.cmd = ARM_EXIDX_CMD_RESERVED;
+          else
+            {
+              edata.cmd = ARM_EXIDX_CMD_REG_POP;
+              edata.data = op2 & 0x0f;
+            }
+        }
       else if (op == 0xb2)
-	{
-	  uint32_t offset = 0;
-	  uint8_t byte, shift = 0;
-	  do
-	    {
-	      byte = READ_OP ();
-	      offset |= (byte & 0x7f) << shift;
-	      shift += 7;
-	    }
-	  while (byte & 0x80);
-	  edata.data = offset * 4 + 0x204;
-	  edata.cmd = ARM_EXIDX_CMD_DATA_POP;
-	}
+        {
+          uint32_t offset = 0;
+          uint8_t byte, shift = 0;
+          do
+            {
+              byte = READ_OP ();
+              offset |= (byte & 0x7f) << shift;
+              shift += 7;
+            }
+          while (byte & 0x80);
+          edata.data = offset * 4 + 0x204;
+          edata.cmd = ARM_EXIDX_CMD_DATA_POP;
+        }
       else if (op == 0xb3 || op == 0xc8 || op == 0xc9)
-	{
-	  edata.cmd = ARM_EXIDX_CMD_VFP_POP;
-	  edata.data = READ_OP ();
-	  if (op == 0xc8)
-	    edata.data |= ARM_EXIDX_VFP_SHIFT_16;
-	  if (op != 0xb3)
-	    edata.data |= ARM_EXIDX_VFP_DOUBLE;
-	}
+        {
+          edata.cmd = ARM_EXIDX_CMD_VFP_POP;
+          edata.data = READ_OP ();
+          if (op == 0xc8)
+            edata.data |= ARM_EXIDX_VFP_SHIFT_16;
+          if (op != 0xb3)
+            edata.data |= ARM_EXIDX_VFP_DOUBLE;
+        }
       else if ((op & 0xf8) == 0xb8 || (op & 0xf8) == 0xd0)
-	{
-	  edata.cmd = ARM_EXIDX_CMD_VFP_POP;
-	  edata.data = 0x80 | (op & 0x07);
-	  if ((op & 0xf8) == 0xd0)
-	    edata.data |= ARM_EXIDX_VFP_DOUBLE;
-	}
+        {
+          edata.cmd = ARM_EXIDX_CMD_VFP_POP;
+          edata.data = 0x80 | (op & 0x07);
+          if ((op & 0xf8) == 0xd0)
+            edata.data |= ARM_EXIDX_VFP_DOUBLE;
+        }
       else if (op >= 0xc0 && op <= 0xc5)
-	{
-	  edata.cmd = ARM_EXIDX_CMD_WREG_POP;
-	  edata.data = 0xa0 | (op & 0x07);
-	}
+        {
+          edata.cmd = ARM_EXIDX_CMD_WREG_POP;
+          edata.data = 0xa0 | (op & 0x07);
+        }
       else if (op == 0xc6)
-	{
-	  edata.cmd = ARM_EXIDX_CMD_WREG_POP;
-	  edata.data = READ_OP ();
-	}
+        {
+          edata.cmd = ARM_EXIDX_CMD_WREG_POP;
+          edata.data = READ_OP ();
+        }
       else if (op == 0xc7)
-	{
-	  uint8_t op2 = READ_OP ();
-	  if (op2 == 0 || (op2 & 0xf0))
-	    edata.cmd = ARM_EXIDX_CMD_RESERVED;
-	  else
-	    {
-	      edata.cmd = ARM_EXIDX_CMD_WCGR_POP;
-	      edata.data = op2 & 0x0f;
-	    }
-	}
+        {
+          uint8_t op2 = READ_OP ();
+          if (op2 == 0 || (op2 & 0xf0))
+            edata.cmd = ARM_EXIDX_CMD_RESERVED;
+          else
+            {
+              edata.cmd = ARM_EXIDX_CMD_WCGR_POP;
+              edata.data = op2 & 0x0f;
+            }
+        }
       else
-	edata.cmd = ARM_EXIDX_CMD_RESERVED;
+        edata.cmd = ARM_EXIDX_CMD_RESERVED;
 
       ret = arm_exidx_apply_cmd (&edata, c);
       if (ret < 0)
-	return ret;
+        return ret;
     }
   return 0;
 }
@@ -299,7 +299,7 @@ arm_exidx_extract (struct dwarf_cursor *c, uint8_t *buf)
        * if set to 0x1: the function cannot be unwound (EXIDX_CANTUNWIND)
        * if bit 31 is one: this is a table entry itself (ARM_EXIDX_COMPACT)
        * if bit 31 is zero: this is a prel31 offset of the start of the
-	 table entry for this function  */
+         table entry for this function  */
   if (prel31_to_addr(c->as, c->as_arg, entry, &addr) < 0)
     return -UNW_EINVAL;
 
@@ -314,7 +314,7 @@ arm_exidx_extract (struct dwarf_cursor *c, uint8_t *buf)
   else if (data & ARM_EXIDX_COMPACT)
     {
       Debug (2, "%p compact model %d [%8.8x]\n", (void *)addr,
-	     (data >> 24) & 0x7f, data);
+             (data >> 24) & 0x7f, data);
       buf[nbuf++] = data >> 16;
       buf[nbuf++] = data >> 8;
       buf[nbuf++] = data;
@@ -328,51 +328,51 @@ arm_exidx_extract (struct dwarf_cursor *c, uint8_t *buf)
         return -UNW_EINVAL;
 
       if ((*c->as->acc.access_mem)(c->as, extbl_data, &data, 0, c->as_arg) < 0)
-	return -UNW_EINVAL;
+        return -UNW_EINVAL;
 
       if (data & ARM_EXIDX_COMPACT)
-	{
-	  int pers = (data >> 24) & 0x0f;
-	  Debug (2, "%p compact model %d [%8.8x]\n", (void *)addr, pers, data);
-	  if (pers == 1 || pers == 2)
-	    {
-	      n_table_words = (data >> 16) & 0xff;
-	      extbl_data += 4;
-	    }
-	  else
-	    buf[nbuf++] = data >> 16;
-	  buf[nbuf++] = data >> 8;
-	  buf[nbuf++] = data;
-	}
+        {
+          int pers = (data >> 24) & 0x0f;
+          Debug (2, "%p compact model %d [%8.8x]\n", (void *)addr, pers, data);
+          if (pers == 1 || pers == 2)
+            {
+              n_table_words = (data >> 16) & 0xff;
+              extbl_data += 4;
+            }
+          else
+            buf[nbuf++] = data >> 16;
+          buf[nbuf++] = data >> 8;
+          buf[nbuf++] = data;
+        }
       else
-	{
-	  unw_word_t pers;
- 	  if (prel31_to_addr (c->as, c->as_arg, extbl_data, &pers) < 0)
-	    return -UNW_EINVAL;
-	  Debug (2, "%p Personality routine: %8p\n", (void *)addr,
-		 (void *)pers);
-	  if ((*c->as->acc.access_mem)(c->as, extbl_data + 4, &data, 0,
-				       c->as_arg) < 0)
-	    return -UNW_EINVAL;
-	  n_table_words = data >> 24;
-	  buf[nbuf++] = data >> 16;
-	  buf[nbuf++] = data >> 8;
-	  buf[nbuf++] = data;
-	  extbl_data += 8;
-	}
+        {
+          unw_word_t pers;
+          if (prel31_to_addr (c->as, c->as_arg, extbl_data, &pers) < 0)
+            return -UNW_EINVAL;
+          Debug (2, "%p Personality routine: %8p\n", (void *)addr,
+                 (void *)pers);
+          if ((*c->as->acc.access_mem)(c->as, extbl_data + 4, &data, 0,
+                                       c->as_arg) < 0)
+            return -UNW_EINVAL;
+          n_table_words = data >> 24;
+          buf[nbuf++] = data >> 16;
+          buf[nbuf++] = data >> 8;
+          buf[nbuf++] = data;
+          extbl_data += 8;
+        }
       assert (n_table_words <= 5);
       unsigned j;
       for (j = 0; j < n_table_words; j++)
-	{
-	  if ((*c->as->acc.access_mem)(c->as, extbl_data, &data, 0,
-				       c->as_arg) < 0)
-	    return -UNW_EINVAL;
-	  extbl_data += 4;
-	  buf[nbuf++] = data >> 24;
-	  buf[nbuf++] = data >> 16;
-	  buf[nbuf++] = data >> 8;
-	  buf[nbuf++] = data >> 0;
-	}
+        {
+          if ((*c->as->acc.access_mem)(c->as, extbl_data, &data, 0,
+                                       c->as_arg) < 0)
+            return -UNW_EINVAL;
+          extbl_data += 4;
+          buf[nbuf++] = data >> 24;
+          buf[nbuf++] = data >> 16;
+          buf[nbuf++] = data >> 8;
+          buf[nbuf++] = data >> 0;
+        }
     }
 
   if (nbuf > 0 && buf[nbuf - 1] != ARM_EXTBL_OP_FINISH)
@@ -381,73 +381,79 @@ arm_exidx_extract (struct dwarf_cursor *c, uint8_t *buf)
   return nbuf;
 }
 
-PROTECTED int
-tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-			     unw_dyn_info_t *di, unw_proc_info_t *pi,
-			     int need_unwind_info, void *arg)
+int
+arm_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
+			 unw_dyn_info_t *di, unw_proc_info_t *pi,
+			 int need_unwind_info, void *arg)
 {
-  if (UNW_TRY_METHOD (UNW_ARM_METHOD_EXIDX)
-      && di->format == UNW_INFO_FORMAT_ARM_EXIDX)
+  /* The .ARM.exidx section contains a sorted list of key-value pairs -
+     the unwind entries.  The 'key' is a prel31 offset to the start of a
+     function.  We binary search this section in order to find the
+     appropriate unwind entry.  */
+  unw_word_t first = di->u.rti.table_data;
+  unw_word_t last = di->u.rti.table_data + di->u.rti.table_len - 8;
+  unw_word_t entry, val;
+
+  if (prel31_to_addr (as, arg, first, &val) < 0 || ip < val)
+    return -UNW_ENOINFO;
+
+  if (prel31_to_addr (as, arg, last, &val) < 0)
+    return -UNW_EINVAL;
+
+  if (ip >= val)
     {
-      /* The .ARM.exidx section contains a sorted list of key-value pairs -
-	 the unwind entries.  The 'key' is a prel31 offset to the start of a
-	 function.  We binary search this section in order to find the
-	 appropriate unwind entry.  */
-      unw_word_t first = di->u.rti.table_data;
-      unw_word_t last = di->u.rti.table_data + di->u.rti.table_len - 8;
-      unw_word_t entry, val;
-
-      if (prel31_to_addr (as, arg, first, &val) < 0 || ip < val)
-	return -UNW_ENOINFO;
-
-      if (prel31_to_addr (as, arg, last, &val) < 0)
+      entry = last;
+
+      if (prel31_to_addr (as, arg, last, &pi->start_ip) < 0)
 	return -UNW_EINVAL;
 
-      if (ip >= val)
+      pi->end_ip = di->end_ip -1;
+    }
+  else
+    {
+      while (first < last - 8)
 	{
-	  entry = last;
+	  entry = first + (((last - first) / 8 + 1) >> 1) * 8;
 
-	  if (prel31_to_addr (as, arg, last, &pi->start_ip) < 0)
+	  if (prel31_to_addr (as, arg, entry, &val) < 0)
 	    return -UNW_EINVAL;
 
-	  pi->end_ip = di->end_ip -1;
+	  if (ip < val)
+	    last = entry;
+	  else
+	    first = entry;
 	}
-      else
-	{
-	  while (first < last - 8)
-	    {
-	      entry = first + (((last - first) / 8 + 1) >> 1) * 8;
-
-	      if (prel31_to_addr (as, arg, entry, &val) < 0)
-		return -UNW_EINVAL;
 
-	      if (ip < val)
-		last = entry;
-	      else
-		first = entry;
-	    }
+      entry = first;
 
-	  entry = first;
-
-	  if (prel31_to_addr (as, arg, entry, &pi->start_ip) < 0)
-	    return -UNW_EINVAL;
+      if (prel31_to_addr (as, arg, entry, &pi->start_ip) < 0)
+	return -UNW_EINVAL;
 
-	  if (prel31_to_addr (as, arg, entry + 8, &pi->end_ip) < 0)
-	    return -UNW_EINVAL;
+      if (prel31_to_addr (as, arg, entry + 8, &pi->end_ip) < 0)
+	return -UNW_EINVAL;
 
-	  pi->end_ip--;
-	}
+      pi->end_ip--;
+    }
 
-      if (need_unwind_info)
-	{
-	  pi->unwind_info_size = 8;
-	  pi->unwind_info = (void *) entry;
-	  pi->format = UNW_INFO_FORMAT_ARM_EXIDX;
-	}
-      return 0;
+  if (need_unwind_info)
+    {
+      pi->unwind_info_size = 8;
+      pi->unwind_info = (void *) entry;
+      pi->format = UNW_INFO_FORMAT_ARM_EXIDX;
     }
+  return 0;
+}
+
+int
+tdep_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
+                             unw_dyn_info_t *di, unw_proc_info_t *pi,
+                             int need_unwind_info, void *arg)
+{
+  if (UNW_TRY_METHOD (UNW_ARM_METHOD_EXIDX)
+      && di->format == UNW_INFO_FORMAT_ARM_EXIDX)
+    return arm_search_unwind_table (as, ip, di, pi, need_unwind_info, arg);
   else if (UNW_TRY_METHOD(UNW_ARM_METHOD_DWARF)
-	   && di->format != UNW_INFO_FORMAT_ARM_EXIDX)
+           && di->format != UNW_INFO_FORMAT_ARM_EXIDX)
     return dwarf_search_unwind_table (as, ip, di, pi, need_unwind_info, arg);
 
   return -UNW_ENOINFO; 
@@ -469,20 +475,20 @@ arm_phdr_cb (struct dl_phdr_info *info, size_t size, void *data)
   for (n = info->dlpi_phnum; --n >= 0; phdr++)
     {
       switch (phdr->p_type)
-	{
-	case PT_LOAD:
-	  if (cb_data->ip >= phdr->p_vaddr + info->dlpi_addr &&
-	      cb_data->ip < phdr->p_vaddr + info->dlpi_addr + phdr->p_memsz)
-	    p_text = phdr;
-	  break;
-
-	case PT_ARM_EXIDX:
-	  p_arm_exidx = phdr;
-	  break;
-
-	default:
-	  break;
-	}
+        {
+        case PT_LOAD:
+          if (cb_data->ip >= phdr->p_vaddr + info->dlpi_addr &&
+              cb_data->ip < phdr->p_vaddr + info->dlpi_addr + phdr->p_memsz)
+            p_text = phdr;
+          break;
+
+        case PT_ARM_EXIDX:
+          p_arm_exidx = phdr;
+          break;
+
+        default:
+          break;
+        }
     }
 
   if (p_text && p_arm_exidx)
@@ -501,7 +507,7 @@ arm_phdr_cb (struct dl_phdr_info *info, size_t size, void *data)
 
 HIDDEN int
 arm_find_proc_info (unw_addr_space_t as, unw_word_t ip,
-		    unw_proc_info_t *pi, int need_unwind_info, void *arg)
+                    unw_proc_info_t *pi, int need_unwind_info, void *arg)
 {
   int ret = -1;
   intrmask_t saved_mask;
@@ -509,30 +515,7 @@ arm_find_proc_info (unw_addr_space_t as, unw_word_t ip,
   Debug (14, "looking for IP=0x%lx\n", (long) ip);
 
   if (UNW_TRY_METHOD(UNW_ARM_METHOD_DWARF))
-    {
-      struct dwarf_callback_data cb_data;
-
-      memset (&cb_data, 0, sizeof (cb_data));
-      cb_data.ip = ip;
-      cb_data.pi = pi;
-      cb_data.need_unwind_info = need_unwind_info;
-      cb_data.di.format = -1;
-      cb_data.di_debug.format = -1;
-
-      SIGPROCMASK (SIG_SETMASK, &unwi_full_mask, &saved_mask);
-      ret = dl_iterate_phdr (dwarf_callback, &cb_data);
-      SIGPROCMASK (SIG_SETMASK, &saved_mask, NULL);
-
-      if (cb_data.single_fde)
-	/* already got the result in *pi */
-	return 0;
-
-      if (cb_data.di_debug.format != -1)
-	ret = tdep_search_unwind_table (as, ip, &cb_data.di_debug, pi,
-					need_unwind_info, arg);
-      else
-	ret = -UNW_ENOINFO;
-    }
+    ret = dwarf_find_proc_info (as, ip, pi, need_unwind_info, arg);
 
   if (ret < 0 && UNW_TRY_METHOD (UNW_ARM_METHOD_EXIDX))
     {
@@ -548,15 +531,12 @@ arm_find_proc_info (unw_addr_space_t as, unw_word_t ip,
       SIGPROCMASK (SIG_SETMASK, &saved_mask, NULL);
 
       if (cb_data.di.format != -1)
-	ret = tdep_search_unwind_table (as, ip, &cb_data.di, pi,
-					need_unwind_info, arg);
+        ret = arm_search_unwind_table (as, ip, &cb_data.di, pi,
+				       need_unwind_info, arg);
       else
-	ret = -UNW_ENOINFO;
+        ret = -UNW_ENOINFO;
     }
 
-  if (ret < 0)
-    Debug (14, "IP=0x%lx not found\n", (long) ip);
-
   return ret;
 }
 
diff --git a/src/arm/Gget_proc_info.c b/src/arm/Gget_proc_info.c
index acb78a4..4051a10 100644
--- a/src/arm/Gget_proc_info.c
+++ b/src/arm/Gget_proc_info.c
@@ -24,7 +24,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/arm/Gget_save_loc.c b/src/arm/Gget_save_loc.c
index 151ba0f..9fb0704 100644
--- a/src/arm/Gget_save_loc.c
+++ b/src/arm/Gget_save_loc.c
@@ -24,13 +24,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   struct cursor *c = (struct cursor *) cursor;
   dwarf_loc_t loc;
 
-  loc = DWARF_NULL_LOC;		/* default to "not saved" */
+  loc = DWARF_NULL_LOC;         /* default to "not saved" */
 
   switch (reg)
     {
diff --git a/src/arm/Gglobal.c b/src/arm/Gglobal.c
index b3d3a6d..7b93fbd 100644
--- a/src/arm/Gglobal.c
+++ b/src/arm/Gglobal.c
@@ -58,7 +58,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     arm_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&arm_lock, saved_mask);
diff --git a/src/arm/Ginit.c b/src/arm/Ginit.c
index b6fabca..2720d06 100644
--- a/src/arm/Ginit.c
+++ b/src/arm/Ginit.c
@@ -30,13 +30,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 static inline void *
 uc_addr (unw_tdep_context_t *uc, int reg)
@@ -66,16 +66,71 @@ HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
   return 0;
 }
 
+#define PAGE_SIZE 4096
+#define PAGE_START(a)	((a) & ~(PAGE_SIZE-1))
+
+/* Cache of already validated addresses */
+#define NLGA 4
+static unw_word_t last_good_addr[NLGA];
+static int lga_victim;
+
+static int
+validate_mem (unw_word_t addr)
+{
+  int i, victim;
+  size_t len;
+
+  if (PAGE_START(addr + sizeof (unw_word_t) - 1) == PAGE_START(addr))
+    len = PAGE_SIZE;
+  else
+    len = PAGE_SIZE * 2;
+
+  addr = PAGE_START(addr);
+
+  if (addr == 0)
+    return -1;
+
+  for (i = 0; i < NLGA; i++)
+    {
+      if (last_good_addr[i] && (addr == last_good_addr[i]))
+      return 0;
+    }
+
+  if (msync ((void *) addr, len, MS_ASYNC) == -1)
+    return -1;
+
+  victim = lga_victim;
+  for (i = 0; i < NLGA; i++) {
+    if (!last_good_addr[victim]) {
+      last_good_addr[victim++] = addr;
+      return 0;
+    }
+    victim = (victim + 1) % NLGA;
+  }
+
+  /* All slots full. Evict the victim. */
+  last_good_addr[victim] = addr;
+  victim = (victim + 1) % NLGA;
+  lga_victim = victim;
+
+  return 0;
+}
+
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
+  /* validate address */
+    const struct cursor *c = (const struct cursor *) arg;
+    if (c && validate_mem(addr))
+      return -1;
+
   if (write)
     {
       Debug (16, "mem[%x] <- %x\n", addr, *val);
@@ -91,7 +146,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   unw_word_t *addr;
   unw_tdep_context_t *uc = arg;
@@ -122,7 +177,7 @@ Debug (16, "reg = %s\n", unw_regname (reg));
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   unw_tdep_context_t *uc = arg;
   unw_fpreg_t *addr;
@@ -136,14 +191,14 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   if (write)
     {
       Debug (12, "%s <- %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
       *(unw_fpreg_t *) addr = *val;
     }
   else
     {
       *val = *(unw_fpreg_t *) addr;
       Debug (12, "%s -> %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
     }
   return 0;
 
@@ -155,8 +210,8 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf32_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -165,7 +220,7 @@ HIDDEN void
 arm_local_addr_space_init (void)
 {
   memset (&local_addr_space, 0, sizeof (local_addr_space));
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = arm_find_proc_info;
   local_addr_space.acc.put_unwind_info = arm_put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
diff --git a/src/arm/Ginit_local.c b/src/arm/Ginit_local.c
index e1cc30c..e13519b 100644
--- a/src/arm/Ginit_local.c
+++ b/src/arm/Ginit_local.c
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
 {
   return -UNW_EINVAL;
@@ -36,8 +36,8 @@ unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
 
 #else /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
-unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
+static int
+unw_init_local_common (unw_cursor_t *cursor, unw_context_t *uc, unsigned use_prev_instr)
 {
   struct cursor *c = (struct cursor *) cursor;
 
@@ -49,7 +49,30 @@ unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
   c->dwarf.as = unw_local_addr_space;
   c->dwarf.as_arg = uc;
 
-  return common_init (c, 1);
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, unw_context_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
 }
 
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/arm/Ginit_remote.c b/src/arm/Ginit_remote.c
index f284e99..9b8ba5b 100644
--- a/src/arm/Ginit_remote.c
+++ b/src/arm/Ginit_remote.c
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "init.h"
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/arm/Gos-freebsd.c b/src/arm/Gos-freebsd.c
new file mode 100644
index 0000000..a106922
--- /dev/null
+++ b/src/arm/Gos-freebsd.c
@@ -0,0 +1,129 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright 2011 Linaro Limited
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright 2015 The FreeBSD Foundation
+
+   Portions of this software were developed by Konstantin Belousov
+   under sponsorship from the FreeBSD Foundation.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdio.h>
+#include <signal.h>
+#include "unwind_i.h"
+#include "offsets.h"
+#include "ex_tables.h"
+
+HIDDEN int
+arm_handle_signal_frame (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret, fmt;
+  unw_word_t sc_addr, sp, sp_addr = c->dwarf.cfa;
+  struct dwarf_loc sp_loc = DWARF_LOC (sp_addr, 0);
+
+  if ((ret = dwarf_get (&c->dwarf, sp_loc, &sp)) < 0)
+    return -UNW_EUNSPEC;
+  fmt = unw_is_signal_frame(cursor);
+
+  c->dwarf.pi_valid = 0;
+
+  if (fmt == UNW_ARM_FRAME_SYSCALL)
+   {
+    c->sigcontext_format = ARM_SCF_FREEBSD_SYSCALL;
+    c->frame_info.frame_type = UNW_ARM_FRAME_SYSCALL;
+    c->frame_info.cfa_reg_offset = 0;
+    c->dwarf.loc[UNW_ARM_R7] = c->dwarf.loc[UNW_ARM_R12];
+    dwarf_get (&c->dwarf, c->dwarf.loc[UNW_ARM_R14], &c->dwarf.ip);
+    return 1;
+   }
+
+  c->sigcontext_format = ARM_SCF_FREEBSD_SIGFRAME;
+  sc_addr = sp_addr;
+
+  /* Save the SP and PC to be able to return execution at this point
+     later in time (unw_resume).  */
+  c->sigcontext_sp = c->dwarf.cfa;
+  c->sigcontext_pc = c->dwarf.ip;
+
+  c->sigcontext_addr = sc_addr;
+  c->frame_info.frame_type = UNW_ARM_FRAME_SIGRETURN;
+  c->frame_info.cfa_reg_offset = sc_addr - sp_addr;
+
+  /* Update the dwarf cursor.
+     Set the location of the registers to the corresponding addresses of the
+     uc_mcontext / sigcontext structure contents.  */
+#define ROFF(n)	(FREEBSD_SC_UCONTEXT_OFF + FREEBSD_UC_MCONTEXT_OFF + \
+  FREEBSD_MC_R0_OFF + (n) * 4)
+#define SL(n) \
+  c->dwarf.loc[UNW_ARM_R ## n] = DWARF_LOC (sc_addr + ROFF(n), 0);
+  SL(0); SL(1); SL(2); SL(3); SL(4); SL(5); SL(6); SL(7);
+  SL(8); SL(9); SL(10); SL(11); SL(12); SL(13); SL(14); SL(15);
+#undef SL
+#undef ROFF
+
+  /* Set SP/CFA and PC/IP.  */
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_ARM_R13], &c->dwarf.cfa);
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_ARM_R15], &c->dwarf.ip);
+
+  return 1;
+}
+
+/* Returns 1 in case of a non-RT signal frame and 2 in case of a RT signal
+   frame. */
+int
+unw_is_signal_frame (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  unw_word_t w0, w1, w2, w3, ip;
+  unw_addr_space_t as;
+  unw_accessors_t *a;
+  void *arg;
+  int ret;
+
+  as = c->dwarf.as;
+  a = unw_get_accessors_int (as);
+  arg = c->dwarf.as_arg;
+
+  ip = c->dwarf.ip;
+
+  if ((ret = (*a->access_mem) (as, ip, &w0, 0, arg)) < 0)
+    return ret;
+  if ((ret = (*a->access_mem) (as, ip + 4, &w1, 0, arg)) < 0)
+    return ret;
+  if ((ret = (*a->access_mem) (as, ip + 8, &w2, 0, arg)) < 0)
+    return ret;
+  if ((ret = (*a->access_mem) (as, ip + 12, &w3, 0, arg)) < 0)
+    return ret;
+
+  if (w0 == 0xe1a0000d && w1 == 0xe2800040 && w2 == 0xe59f700c &&
+    w3 == 0xef0001a1)
+     return UNW_ARM_FRAME_SIGRETURN;
+
+  if ((ret = (*a->access_mem) (as, ip - 4, &w0, 0, arg)) < 0)
+    return ret;
+  if (w0 == 0xef000000)
+    return UNW_ARM_FRAME_SYSCALL;
+
+  return 0;
+}
diff --git a/src/arm/Gos-linux.c b/src/arm/Gos-linux.c
new file mode 100644
index 0000000..260e086
--- /dev/null
+++ b/src/arm/Gos-linux.c
@@ -0,0 +1,182 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright 2011 Linaro Limited
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdio.h>
+#include <signal.h>
+#include "unwind_i.h"
+#include "offsets.h"
+
+HIDDEN int
+arm_handle_signal_frame (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+  unw_word_t sc_addr, sp, sp_addr = c->dwarf.cfa;
+  struct dwarf_loc sp_loc = DWARF_LOC (sp_addr, 0);
+
+  if ((ret = dwarf_get (&c->dwarf, sp_loc, &sp)) < 0)
+    return -UNW_EUNSPEC;
+
+  /* Obtain signal frame type (non-RT or RT). */
+  ret = unw_is_signal_frame (cursor);
+
+  /* Save the SP and PC to be able to return execution at this point
+     later in time (unw_resume).  */
+  c->sigcontext_sp = c->dwarf.cfa;
+  c->sigcontext_pc = c->dwarf.ip;
+
+  /* Since kernel version 2.6.18 the non-RT signal frame starts with a
+     ucontext while the RT signal frame starts with a siginfo, followed
+     by a sigframe whose first element is an ucontext.
+     Prior 2.6.18 the non-RT signal frame starts with a sigcontext while
+     the RT signal frame starts with two pointers followed by a siginfo
+     and an ucontext. The first pointer points to the start of the siginfo
+     structure and the second one to the ucontext structure.  */
+
+  if (ret == 1)
+    {
+      /* Handle non-RT signal frames. Check if the first word on the stack
+         is the magic number.  */
+      if (sp == 0x5ac3c35a)
+        {
+          c->sigcontext_format = ARM_SCF_LINUX_SIGFRAME;
+          sc_addr = sp_addr + LINUX_UC_MCONTEXT_OFF;
+        }
+      else
+        {
+          c->sigcontext_format = ARM_SCF_LINUX_OLD_SIGFRAME;
+          sc_addr = sp_addr;
+        }
+    }
+  else if (ret == 2)
+    {
+      /* Handle RT signal frames. Check if the first word on the stack is a
+         pointer to the siginfo structure.  */
+      if (sp == sp_addr + 8)
+        {
+          c->sigcontext_format = ARM_SCF_LINUX_OLD_RT_SIGFRAME;
+          sc_addr = sp_addr + 8 + sizeof (siginfo_t) + LINUX_UC_MCONTEXT_OFF;
+        }
+      else
+        {
+          c->sigcontext_format = ARM_SCF_LINUX_RT_SIGFRAME;
+          sc_addr = sp_addr + sizeof (siginfo_t) + LINUX_UC_MCONTEXT_OFF;
+        }
+    }
+  else
+    return -UNW_EUNSPEC;
+
+  c->sigcontext_addr = sc_addr;
+  c->frame_info.frame_type = UNW_ARM_FRAME_SIGRETURN;
+  c->frame_info.cfa_reg_offset = sc_addr - sp_addr;
+
+  /* Update the dwarf cursor.
+     Set the location of the registers to the corresponding addresses of the
+     uc_mcontext / sigcontext structure contents.  */
+  c->dwarf.loc[UNW_ARM_R0] = DWARF_LOC (sc_addr + LINUX_SC_R0_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R1] = DWARF_LOC (sc_addr + LINUX_SC_R1_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R2] = DWARF_LOC (sc_addr + LINUX_SC_R2_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R3] = DWARF_LOC (sc_addr + LINUX_SC_R3_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R4] = DWARF_LOC (sc_addr + LINUX_SC_R4_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R5] = DWARF_LOC (sc_addr + LINUX_SC_R5_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R6] = DWARF_LOC (sc_addr + LINUX_SC_R6_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R7] = DWARF_LOC (sc_addr + LINUX_SC_R7_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R8] = DWARF_LOC (sc_addr + LINUX_SC_R8_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R9] = DWARF_LOC (sc_addr + LINUX_SC_R9_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R10] = DWARF_LOC (sc_addr + LINUX_SC_R10_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R11] = DWARF_LOC (sc_addr + LINUX_SC_FP_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R12] = DWARF_LOC (sc_addr + LINUX_SC_IP_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R13] = DWARF_LOC (sc_addr + LINUX_SC_SP_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R14] = DWARF_LOC (sc_addr + LINUX_SC_LR_OFF, 0);
+  c->dwarf.loc[UNW_ARM_R15] = DWARF_LOC (sc_addr + LINUX_SC_PC_OFF, 0);
+
+  /* Set SP/CFA and PC/IP.  */
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_ARM_R13], &c->dwarf.cfa);
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_ARM_R15], &c->dwarf.ip);
+
+  c->dwarf.pi_valid = 0;
+
+  return 1;
+}
+
+#define ARM_NR_sigreturn 119
+#define ARM_NR_rt_sigreturn 173
+#define ARM_NR_OABI_SYSCALL_BASE 0x900000
+
+/* ARM EABI sigreturn (the syscall number is loaded into r7) */
+#define MOV_R7_SIGRETURN (0xe3a07000UL | ARM_NR_sigreturn)
+#define MOV_R7_RT_SIGRETURN (0xe3a07000UL | ARM_NR_rt_sigreturn)
+
+/* ARM OABI sigreturn (using SWI) */
+#define ARM_SIGRETURN \
+  (0xef000000UL | ARM_NR_sigreturn | ARM_NR_OABI_SYSCALL_BASE)
+#define ARM_RT_SIGRETURN \
+  (0xef000000UL | ARM_NR_rt_sigreturn | ARM_NR_OABI_SYSCALL_BASE)
+
+/* Thumb sigreturn (two insns, syscall number is loaded into r7) */
+#define THUMB_SIGRETURN (0xdf00UL << 16 | 0x2700 | ARM_NR_sigreturn)
+#define THUMB_RT_SIGRETURN (0xdf00UL << 16 | 0x2700 | ARM_NR_rt_sigreturn)
+
+/* Thumb2 sigreturn (mov.w r7, $SYS_ify(rt_sigreturn/sigreturn)) */
+#define THUMB2_SIGRETURN (((0x0700 | ARM_NR_sigreturn) << 16) | \
+                                       0xf04f)
+#define THUMB2_RT_SIGRETURN (((0x0700 | ARM_NR_rt_sigreturn) << 16) | \
+                                       0xf04f)
+/* TODO: with different toolchains, there are a lot more possibilities */
+
+/* Returns 1 in case of a non-RT signal frame and 2 in case of a RT signal
+   frame. */
+int
+unw_is_signal_frame (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  unw_word_t w0, ip;
+  unw_addr_space_t as;
+  unw_accessors_t *a;
+  void *arg;
+  int ret;
+
+  as = c->dwarf.as;
+  a = unw_get_accessors_int (as);
+  arg = c->dwarf.as_arg;
+
+  /* The least bit denotes thumb/arm mode. Do not read there. */
+  ip = c->dwarf.ip & ~0x1;
+
+  if ((ret = (*a->access_mem) (as, ip, &w0, 0, arg)) < 0)
+    return ret;
+
+  /* Return 1 if the IP points to a non-RT sigreturn sequence.  */
+  if (w0 == MOV_R7_SIGRETURN || w0 == ARM_SIGRETURN || w0 == THUMB_SIGRETURN
+           || w0 == THUMB2_SIGRETURN)
+    return 1;
+  /* Return 2 if the IP points to a RT sigreturn sequence.  */
+  else if (w0 == MOV_R7_RT_SIGRETURN || w0 == ARM_RT_SIGRETURN
+           || w0 == THUMB_RT_SIGRETURN || w0 == THUMB2_RT_SIGRETURN)
+    return 2;
+
+  return 0;
+}
diff --git a/src/arm/Gos-other.c b/src/arm/Gos-other.c
new file mode 100644
index 0000000..73c102c
--- /dev/null
+++ b/src/arm/Gos-other.c
@@ -0,0 +1,48 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright 2011 Linaro Limited
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdio.h>
+#include <signal.h>
+#include "unwind_i.h"
+#include "offsets.h"
+
+HIDDEN int
+arm_handle_signal_frame (unw_cursor_t *cursor)
+{
+  return -UNW_EUNSPEC;
+}
+
+int
+unw_is_signal_frame (unw_cursor_t *cursor)
+{
+#if defined(__QNX__)
+  /* Not supported yet */
+  return 0;
+#else
+  printf ("%s: implement me\n", __FUNCTION__);
+  return -UNW_ENOINFO;
+#endif
+}
diff --git a/src/arm/Greg_states_iterate.c b/src/arm/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/arm/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/arm/Gregs.c b/src/arm/Gregs.c
index 03693a2..0d52f0b 100644
--- a/src/arm/Gregs.c
+++ b/src/arm/Gregs.c
@@ -26,12 +26,15 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   dwarf_loc_t loc = DWARF_NULL_LOC;
   
   switch (reg)
     {
+    case UNW_ARM_R15:
+      if (write)
+        c->dwarf.ip = *valp;            /* update the IP cache */
     case UNW_ARM_R0:
     case UNW_ARM_R1:
     case UNW_ARM_R2:
@@ -46,7 +49,6 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     case UNW_ARM_R11:
     case UNW_ARM_R12:
     case UNW_ARM_R14:
-    case UNW_ARM_R15:
       loc = c->dwarf.loc[reg - UNW_ARM_R0];
       break;
 
@@ -74,7 +76,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   Debug (1, "bad register number %u\n", reg);
   return -UNW_EBADREG;
diff --git a/src/arm/Gresume.c b/src/arm/Gresume.c
index 4100d87..a828862 100644
--- a/src/arm/Gresume.c
+++ b/src/arm/Gresume.c
@@ -39,7 +39,7 @@ arm_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
   if (c->sigcontext_format == ARM_SCF_NONE)
     {
       /* Since there are no signals involved here we restore the non scratch
-	 registers only.  */
+         registers only.  */
       unsigned long regs[10];
       regs[0] = uc->regs[4];
       regs[1] = uc->regs[5];
@@ -53,21 +53,21 @@ arm_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
       regs[9] = uc->regs[14]; /* LR */
 
       struct regs_overlay {
-	      char x[sizeof(regs)];
+              char x[sizeof(regs)];
       };
 
       asm __volatile__ (
-	"ldmia %0, {r4-r12, lr}\n"
-	"mov sp, r12\n"
-	"bx lr\n"
-	: : "r" (regs),
-	    "m" (*(struct regs_overlay *)regs)
+        "ldmia %0, {r4-r12, lr}\n"
+        "mov sp, r12\n"
+        "bx lr\n"
+        : : "r" (regs),
+            "m" (*(struct regs_overlay *)regs)
       );
     }
   else
     {
       /* In case a signal frame is involved, we're using its trampoline which
-	 calls sigreturn.  */
+         calls sigreturn.  */
       struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
       sc->arm_r0 = uc->regs[0];
       sc->arm_r1 = uc->regs[1];
@@ -89,14 +89,14 @@ arm_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
       sc->arm_cpsr &= 0xf9ff03ffUL;
 
       /* Set the SP and the PC in order to continue execution at the modified
-	 trampoline which restores the signal mask and the registers.  */
+         trampoline which restores the signal mask and the registers.  */
       asm __volatile__ (
-	"mov sp, %0\n"
-	"bx %1\n"
-	: : "r" (c->sigcontext_sp), "r" (c->sigcontext_pc)
+        "mov sp, %0\n"
+        "bx %1\n"
+        : : "r" (c->sigcontext_sp), "r" (c->sigcontext_pc)
       );
    }
-  __builtin_unreachable();
+  unreachable();
 #else
   printf ("%s: implement me\n", __FUNCTION__);
 #endif
@@ -120,19 +120,19 @@ establish_machine_state (struct cursor *c)
     {
       Debug (16, "copying %s %d\n", unw_regname (reg), reg);
       if (unw_is_fpreg (reg))
-	{
-	  if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
-	    as->acc.access_fpreg (as, reg, &fpval, 1, arg);
-	}
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            as->acc.access_fpreg (as, reg, &fpval, 1, arg);
+        }
       else
-	{
-	  if (tdep_access_reg (c, reg, &val, 0) >= 0)
-	    as->acc.access_reg (as, reg, &val, 1, arg);
-	}
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            as->acc.access_reg (as, reg, &val, 1, arg);
+        }
     }
 }
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -142,7 +142,7 @@ unw_resume (unw_cursor_t *cursor)
   if (!c->dwarf.ip)
     {
       /* This can happen easily when the frame-chain gets truncated
-	 due to bad or missing unwind-info.  */
+         due to bad or missing unwind-info.  */
       Debug (1, "refusing to resume execution at address 0\n");
       return -UNW_EINVAL;
     }
@@ -150,5 +150,5 @@ unw_resume (unw_cursor_t *cursor)
   establish_machine_state (c);
 
   return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
-				     c->dwarf.as_arg);
+                                     c->dwarf.as_arg);
 }
diff --git a/src/arm/Gstash_frame.c b/src/arm/Gstash_frame.c
new file mode 100644
index 0000000..c5a76b8
--- /dev/null
+++ b/src/arm/Gstash_frame.c
@@ -0,0 +1,90 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2010, 2011 by FERMI NATIONAL ACCELERATOR LABORATORY
+   Copyright (C) 2014 CERN and Aalto University
+        Contributed by Filip Nyback
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+HIDDEN void
+tdep_stash_frame (struct dwarf_cursor *d, struct dwarf_reg_state *rs)
+{
+  struct cursor *c = (struct cursor *) dwarf_to_cursor (d);
+  unw_tdep_frame_t *f = &c->frame_info;
+
+  Debug (4, "ip=0x%x cfa=0x%x type %d cfa [where=%d val=%d] cfaoff=%d"
+         " ra=0x%x r7 [where=%d val=%d @0x%x] lr [where=%d val=%d @0x%x] "
+         "sp [where=%d val=%d @0x%x]\n",
+         d->ip, d->cfa, f->frame_type,
+         rs->reg.where[DWARF_CFA_REG_COLUMN],
+         rs->reg.val[DWARF_CFA_REG_COLUMN],
+         rs->reg.val[DWARF_CFA_OFF_COLUMN],
+         DWARF_GET_LOC(d->loc[rs->ret_addr_column]),
+         rs->reg.where[R7], rs->reg.val[R7], DWARF_GET_LOC(d->loc[R7]),
+         rs->reg.where[LR], rs->reg.val[LR], DWARF_GET_LOC(d->loc[LR]),
+         rs->reg.where[SP], rs->reg.val[SP], DWARF_GET_LOC(d->loc[SP]));
+
+  /* A standard frame is defined as:
+      - CFA is register-relative offset off R7 or SP;
+      - Return address is saved in LR;
+      - R7 is unsaved or saved at CFA+offset, offset != -1;
+      - LR is unsaved or saved at CFA+offset, offset != -1;
+      - SP is unsaved or saved at CFA+offset, offset != -1.  */
+  if (f->frame_type == UNW_ARM_FRAME_OTHER
+      && (rs->reg.where[DWARF_CFA_REG_COLUMN] == DWARF_WHERE_REG)
+      && (rs->reg.val[DWARF_CFA_REG_COLUMN] == R7
+          || rs->reg.val[DWARF_CFA_REG_COLUMN] == SP)
+      && labs(rs->reg.val[DWARF_CFA_OFF_COLUMN]) < (1 << 29)
+      && rs->ret_addr_column == LR
+      && (rs->reg.where[R7] == DWARF_WHERE_UNDEF
+          || rs->reg.where[R7] == DWARF_WHERE_SAME
+          || (rs->reg.where[R7] == DWARF_WHERE_CFAREL
+              && labs(rs->reg.val[R7]) < (1 << 29)
+              && rs->reg.val[R7]+1 != 0))
+      && (rs->reg.where[LR] == DWARF_WHERE_UNDEF
+          || rs->reg.where[LR] == DWARF_WHERE_SAME
+          || (rs->reg.where[LR] == DWARF_WHERE_CFAREL
+              && labs(rs->reg.val[LR]) < (1 << 29)
+              && rs->reg.val[LR]+1 != 0))
+      && (rs->reg.where[SP] == DWARF_WHERE_UNDEF
+          || rs->reg.where[SP] == DWARF_WHERE_SAME
+          || (rs->reg.where[SP] == DWARF_WHERE_CFAREL
+              && labs(rs->reg.val[SP]) < (1 << 29)
+              && rs->reg.val[SP]+1 != 0)))
+  {
+    /* Save information for a standard frame. */
+    f->frame_type = UNW_ARM_FRAME_STANDARD;
+    f->cfa_reg_sp = (rs->reg.val[DWARF_CFA_REG_COLUMN] == SP);
+    f->cfa_reg_offset = rs->reg.val[DWARF_CFA_OFF_COLUMN];
+    if (rs->reg.where[R7] == DWARF_WHERE_CFAREL)
+      f->r7_cfa_offset = rs->reg.val[R7];
+    if (rs->reg.where[LR] == DWARF_WHERE_CFAREL)
+      f->lr_cfa_offset = rs->reg.val[LR];
+    if (rs->reg.where[SP] == DWARF_WHERE_CFAREL)
+      f->sp_cfa_offset = rs->reg.val[SP];
+    Debug (4, " standard frame\n");
+  }
+  else
+    Debug (4, " unusual frame\n");
+}
+
diff --git a/src/arm/Gstep.c b/src/arm/Gstep.c
index 3c65ac0..adec02e 100644
--- a/src/arm/Gstep.c
+++ b/src/arm/Gstep.c
@@ -30,7 +30,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include <signal.h>
 
-#define arm_exidx_step	UNW_OBJ(arm_exidx_step)
+#define arm_exidx_step  UNW_OBJ(arm_exidx_step)
 
 static inline int
 arm_exidx_step (struct cursor *c)
@@ -44,9 +44,18 @@ arm_exidx_step (struct cursor *c)
 
   /* mark PC unsaved */
   c->dwarf.loc[UNW_ARM_R15] = DWARF_NULL_LOC;
-
-  if ((ret = tdep_find_proc_info (&c->dwarf, c->dwarf.ip, 1)) < 0)
-     return ret;
+  unw_word_t ip = c->dwarf.ip;
+  if (c->dwarf.use_prev_instr)
+    --ip;
+
+  /* check dynamic info first --- it overrides everything else */
+  ret = unwi_find_dynamic_proc_info (c->dwarf.as, ip, &c->dwarf.pi, 1,
+                                     c->dwarf.as_arg);
+  if (ret == -UNW_ENOINFO)
+    {
+      if ((ret = tdep_find_proc_info (&c->dwarf, ip, 1)) < 0)
+        return ret;
+    }
 
   if (c->dwarf.pi.format != UNW_INFO_FORMAT_ARM_EXIDX)
     return -UNW_ENOINFO;
@@ -64,7 +73,7 @@ arm_exidx_step (struct cursor *c)
   if (c->dwarf.ip == old_ip && c->dwarf.cfa == old_cfa)
     {
       Dprintf ("%s: ip and cfa unchanged; stopping here (ip=0x%lx)\n",
-	       __FUNCTION__, (long) c->dwarf.ip);
+               __FUNCTION__, (long) c->dwarf.ip);
       return -UNW_EBADFRAME;
     }
 
@@ -73,98 +82,7 @@ arm_exidx_step (struct cursor *c)
   return (c->dwarf.ip == 0) ? 0 : 1;
 }
 
-PROTECTED int
-unw_handle_signal_frame (unw_cursor_t *cursor)
-{
-  struct cursor *c = (struct cursor *) cursor;
-  int ret;
-  unw_word_t sc_addr, sp, sp_addr = c->dwarf.cfa;
-  struct dwarf_loc sp_loc = DWARF_LOC (sp_addr, 0);
-
-  if ((ret = dwarf_get (&c->dwarf, sp_loc, &sp)) < 0)
-    return -UNW_EUNSPEC;
-
-  /* Obtain signal frame type (non-RT or RT). */
-  ret = unw_is_signal_frame (cursor);
-
-  /* Save the SP and PC to be able to return execution at this point
-     later in time (unw_resume).  */
-  c->sigcontext_sp = c->dwarf.cfa;
-  c->sigcontext_pc = c->dwarf.ip;
-
-  /* Since kernel version 2.6.18 the non-RT signal frame starts with a
-     ucontext while the RT signal frame starts with a siginfo, followed
-     by a sigframe whose first element is an ucontext.
-     Prior 2.6.18 the non-RT signal frame starts with a sigcontext while
-     the RT signal frame starts with two pointers followed by a siginfo
-     and an ucontext. The first pointer points to the start of the siginfo
-     structure and the second one to the ucontext structure.  */
-
-  if (ret == 1)
-    {
-      /* Handle non-RT signal frames. Check if the first word on the stack
-	 is the magic number.  */
-      if (sp == 0x5ac3c35a)
-	{
-	  c->sigcontext_format = ARM_SCF_LINUX_SIGFRAME;
-	  sc_addr = sp_addr + LINUX_UC_MCONTEXT_OFF;
-	}
-      else
-	{
-	  c->sigcontext_format = ARM_SCF_LINUX_OLD_SIGFRAME;
-	  sc_addr = sp_addr;
-	}
-    }
-  else if (ret == 2)
-    {
-      /* Handle RT signal frames. Check if the first word on the stack is a
-	 pointer to the siginfo structure.  */
-      if (sp == sp_addr + 8)
-	{
-	  c->sigcontext_format = ARM_SCF_LINUX_OLD_RT_SIGFRAME;
-	  sc_addr = sp_addr + 8 + sizeof (siginfo_t) + LINUX_UC_MCONTEXT_OFF;
-	}
-      else
-	{
-	  c->sigcontext_format = ARM_SCF_LINUX_RT_SIGFRAME;
-	  sc_addr = sp_addr + sizeof (siginfo_t) + LINUX_UC_MCONTEXT_OFF;
-	}
-    }
-  else
-    return -UNW_EUNSPEC;
-
-  c->sigcontext_addr = sc_addr;
-
-  /* Update the dwarf cursor.
-     Set the location of the registers to the corresponding addresses of the
-     uc_mcontext / sigcontext structure contents.  */
-  c->dwarf.loc[UNW_ARM_R0] = DWARF_LOC (sc_addr + LINUX_SC_R0_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R1] = DWARF_LOC (sc_addr + LINUX_SC_R1_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R2] = DWARF_LOC (sc_addr + LINUX_SC_R2_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R3] = DWARF_LOC (sc_addr + LINUX_SC_R3_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R4] = DWARF_LOC (sc_addr + LINUX_SC_R4_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R5] = DWARF_LOC (sc_addr + LINUX_SC_R5_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R6] = DWARF_LOC (sc_addr + LINUX_SC_R6_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R7] = DWARF_LOC (sc_addr + LINUX_SC_R7_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R8] = DWARF_LOC (sc_addr + LINUX_SC_R8_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R9] = DWARF_LOC (sc_addr + LINUX_SC_R9_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R10] = DWARF_LOC (sc_addr + LINUX_SC_R10_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R11] = DWARF_LOC (sc_addr + LINUX_SC_FP_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R12] = DWARF_LOC (sc_addr + LINUX_SC_IP_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R13] = DWARF_LOC (sc_addr + LINUX_SC_SP_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R14] = DWARF_LOC (sc_addr + LINUX_SC_LR_OFF, 0);
-  c->dwarf.loc[UNW_ARM_R15] = DWARF_LOC (sc_addr + LINUX_SC_PC_OFF, 0);
-
-  /* Set SP/CFA and PC/IP.  */
-  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_ARM_R13], &c->dwarf.cfa);
-  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_ARM_R15], &c->dwarf.ip);
-
-  c->dwarf.pi_valid = 0;
-
-  return 1;
-}
-
-PROTECTED int
+int
 unw_step (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -173,8 +91,8 @@ unw_step (unw_cursor_t *cursor)
   Debug (1, "(cursor=%p)\n", c);
 
   /* Check if this is a signal frame. */
-  if (unw_is_signal_frame (cursor))
-     return unw_handle_signal_frame (cursor);
+  if (unw_is_signal_frame (cursor) > 0)
+     return arm_handle_signal_frame (cursor);
 
 #ifdef CONFIG_DEBUG_FRAME
   /* First, try DWARF-based unwinding. */
@@ -184,38 +102,50 @@ unw_step (unw_cursor_t *cursor)
       Debug(1, "dwarf_step()=%d\n", ret);
 
       if (likely (ret > 0))
-	return 1;
+        return 1;
       else if (unlikely (ret == -UNW_ESTOPUNWIND))
-	return ret;
-
-    if (ret < 0 && ret != -UNW_ENOINFO)
-      {
-        Debug (2, "returning %d\n", ret);
         return ret;
-      }
+
+      if (ret < 0 && ret != -UNW_ENOINFO)
+        {
+          Debug (2, "returning %d\n", ret);
+          return ret;
+        }
     }
 #endif /* CONFIG_DEBUG_FRAME */
 
   /* Next, try extbl-based unwinding. */
   if (UNW_TRY_METHOD (UNW_ARM_METHOD_EXIDX))
     {
+      Debug (13, "%s(ret=%d), trying extbl\n",
+             UNW_TRY_METHOD(UNW_ARM_METHOD_DWARF) ? "dwarf_step() failed " : "",
+             ret);
       ret = arm_exidx_step (c);
       if (ret > 0)
-	return 1;
+        return 1;
       if (ret == -UNW_ESTOPUNWIND || ret == 0)
-	return ret;
+        return ret;
     }
 
   /* Fall back on APCS frame parsing.
      Note: This won't work in case the ARM EABI is used. */
+#ifdef __FreeBSD__
+  if (0)
+#else
   if (unlikely (ret < 0))
+#endif
     {
       if (UNW_TRY_METHOD(UNW_ARM_METHOD_FRAME))
         {
+          Debug (13, "%s%s%s%s(ret=%d), trying frame-chain\n",
+                 UNW_TRY_METHOD(UNW_ARM_METHOD_DWARF) ? "dwarf_step() " : "",
+                 (UNW_TRY_METHOD(UNW_ARM_METHOD_DWARF) && UNW_TRY_METHOD(UNW_ARM_METHOD_EXIDX)) ? "and " : "",
+                 UNW_TRY_METHOD(UNW_ARM_METHOD_EXIDX) ? "arm_exidx_step() " : "",
+                 (UNW_TRY_METHOD(UNW_ARM_METHOD_DWARF) || UNW_TRY_METHOD(UNW_ARM_METHOD_EXIDX)) ? "failed " : "",
+                 ret);
           ret = UNW_ESUCCESS;
           /* DWARF unwinding failed, try to follow APCS/optimized APCS frame chain */
           unw_word_t instr, i;
-          Debug (13, "dwarf_step() failed (ret=%d), trying frame-chain\n", ret);
           dwarf_loc_t ip_loc, fp_loc;
           unw_word_t frame;
           /* Mark all registers unsaved, since we don't know where
@@ -258,7 +188,7 @@ unw_step (unw_cursor_t *cursor)
               c->dwarf.loc[UNW_ARM_R12] = ip_loc;
               c->dwarf.loc[UNW_ARM_R11] = fp_loc;
               c->dwarf.pi_valid = 0;
-              Debug(15, "ip=%lx\n", c->dwarf.ip);
+              Debug(15, "ip=%x\n", c->dwarf.ip);
             }
           else
             {
@@ -266,5 +196,5 @@ unw_step (unw_cursor_t *cursor)
             }
         }
     }
-  return ret == -UNW_ENOINFO ? 0 : 1;
+  return ret == -UNW_ENOINFO ? 0 : ret;
 }
diff --git a/src/arm/Gtrace.c b/src/arm/Gtrace.c
new file mode 100644
index 0000000..2f27752
--- /dev/null
+++ b/src/arm/Gtrace.c
@@ -0,0 +1,557 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2010, 2011 by FERMI NATIONAL ACCELERATOR LABORATORY
+   Copyright (C) 2014 CERN and Aalto University
+        Contributed by Filip Nyback
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "offsets.h"
+#include <signal.h>
+#include <limits.h>
+
+#pragma weak pthread_once
+#pragma weak pthread_key_create
+#pragma weak pthread_getspecific
+#pragma weak pthread_setspecific
+
+/* Initial hash table size. Table expands by 2 bits (times four). */
+#define HASH_MIN_BITS 14
+
+typedef struct
+{
+  unw_tdep_frame_t *frames;
+  size_t log_size;
+  size_t used;
+  size_t dtor_count;  /* Counts how many times our destructor has already
+                         been called. */
+} unw_trace_cache_t;
+
+static const unw_tdep_frame_t empty_frame = { 0, UNW_ARM_FRAME_OTHER, -1, -1, 0, -1, -1, -1 };
+static define_lock (trace_init_lock);
+static pthread_once_t trace_cache_once = PTHREAD_ONCE_INIT;
+static sig_atomic_t trace_cache_once_happen;
+static pthread_key_t trace_cache_key;
+static struct mempool trace_cache_pool;
+static __thread  unw_trace_cache_t *tls_cache;
+static __thread  int tls_cache_destroyed;
+
+/* Free memory for a thread's trace cache. */
+static void
+trace_cache_free (void *arg)
+{
+  unw_trace_cache_t *cache = arg;
+  if (++cache->dtor_count < PTHREAD_DESTRUCTOR_ITERATIONS)
+  {
+    /* Not yet our turn to get destroyed. Re-install ourselves into the key. */
+    pthread_setspecific(trace_cache_key, cache);
+    Debug(5, "delayed freeing cache %p (%zx to go)\n", cache,
+          PTHREAD_DESTRUCTOR_ITERATIONS - cache->dtor_count);
+    return;
+  }
+  tls_cache_destroyed = 1;
+  tls_cache = NULL;
+  munmap (cache->frames, (1u << cache->log_size) * sizeof(unw_tdep_frame_t));
+  mempool_free (&trace_cache_pool, cache);
+  Debug(5, "freed cache %p\n", cache);
+}
+
+/* Initialise frame tracing for threaded use. */
+static void
+trace_cache_init_once (void)
+{
+  pthread_key_create (&trace_cache_key, &trace_cache_free);
+  mempool_init (&trace_cache_pool, sizeof (unw_trace_cache_t), 0);
+  trace_cache_once_happen = 1;
+}
+
+static unw_tdep_frame_t *
+trace_cache_buckets (size_t n)
+{
+  unw_tdep_frame_t *frames;
+  size_t i;
+
+  GET_MEMORY(frames, n * sizeof (unw_tdep_frame_t));
+  if (likely(frames != NULL))
+    for (i = 0; i < n; ++i)
+      frames[i] = empty_frame;
+
+  return frames;
+}
+
+/* Allocate and initialise hash table for frame cache lookups.
+   Returns the cache initialised with (1u << HASH_LOW_BITS) hash
+   buckets, or NULL if there was a memory allocation problem. */
+static unw_trace_cache_t *
+trace_cache_create (void)
+{
+  unw_trace_cache_t *cache;
+
+  if (tls_cache_destroyed)
+  {
+    /* The current thread is in the process of exiting. Don't recreate
+       cache, as we wouldn't have another chance to free it. */
+    Debug(5, "refusing to reallocate cache: "
+             "thread-locals are being deallocated\n");
+    return NULL;
+  }
+
+  if (! (cache = mempool_alloc(&trace_cache_pool)))
+  {
+    Debug(5, "failed to allocate cache\n");
+    return NULL;
+  }
+
+  if (! (cache->frames = trace_cache_buckets(1u << HASH_MIN_BITS)))
+  {
+    Debug(5, "failed to allocate buckets\n");
+    mempool_free(&trace_cache_pool, cache);
+    return NULL;
+  }
+
+  cache->log_size = HASH_MIN_BITS;
+  cache->used = 0;
+  cache->dtor_count = 0;
+  tls_cache_destroyed = 0;  /* Paranoia: should already be 0. */
+  Debug(5, "allocated cache %p\n", cache);
+  return cache;
+}
+
+/* Expand the hash table in the frame cache if possible. This always
+   quadruples the hash size, and clears all previous frame entries. */
+static int
+trace_cache_expand (unw_trace_cache_t *cache)
+{
+  size_t old_size = (1u << cache->log_size);
+  size_t new_log_size = cache->log_size + 2;
+  unw_tdep_frame_t *new_frames = trace_cache_buckets (1u << new_log_size);
+
+  if (unlikely(! new_frames))
+  {
+    Debug(5, "failed to expand cache to 2^%u buckets\n", new_log_size);
+    return -UNW_ENOMEM;
+  }
+
+  Debug(5, "expanded cache from 2^%u to 2^%u buckets\n", cache->log_size,
+        new_log_size);
+  munmap(cache->frames, old_size * sizeof(unw_tdep_frame_t));
+  cache->frames = new_frames;
+  cache->log_size = new_log_size;
+  cache->used = 0;
+  return 0;
+}
+
+static unw_trace_cache_t *
+trace_cache_get_unthreaded (void)
+{
+  unw_trace_cache_t *cache;
+  intrmask_t saved_mask;
+  static unw_trace_cache_t *global_cache = NULL;
+  lock_acquire (&trace_init_lock, saved_mask);
+  if (! global_cache)
+  {
+    mempool_init (&trace_cache_pool, sizeof (unw_trace_cache_t), 0);
+    global_cache = trace_cache_create ();
+  }
+  cache = global_cache;
+  lock_release (&trace_init_lock, saved_mask);
+  Debug(5, "using cache %p\n", cache);
+  return cache;
+}
+
+/* Get the frame cache for the current thread. Create it if there is none. */
+static unw_trace_cache_t *
+trace_cache_get (void)
+{
+  unw_trace_cache_t *cache;
+  if (likely (pthread_once != NULL))
+  {
+    pthread_once(&trace_cache_once, &trace_cache_init_once);
+    if (!trace_cache_once_happen)
+    {
+      return trace_cache_get_unthreaded();
+    }
+    if (! (cache = tls_cache))
+    {
+      cache = trace_cache_create();
+      pthread_setspecific(trace_cache_key, cache);
+      tls_cache = cache;
+    }
+    Debug(5, "using cache %p\n", cache);
+    return cache;
+  }
+  else
+  {
+    return trace_cache_get_unthreaded();
+  }
+}
+
+/* Initialise frame properties for address cache slot F at address
+   PC using current CFA, R7 and SP values.  Modifies CURSOR to
+   that location, performs one unw_step(), and fills F with what
+   was discovered about the location.  Returns F.
+
+   FIXME: This probably should tell DWARF handling to never evaluate
+   or use registers other than R7, SP and PC in case there is
+   highly unusual unwind info which uses these creatively. */
+static unw_tdep_frame_t *
+trace_init_addr (unw_tdep_frame_t *f,
+                 unw_cursor_t *cursor,
+                 unw_word_t cfa,
+                 unw_word_t pc,
+                 unw_word_t r7,
+                 unw_word_t sp)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  struct dwarf_cursor *d = &c->dwarf;
+  int ret = -UNW_EINVAL;
+
+  /* Initialise frame properties: unknown, not last. */
+  f->virtual_address = pc;
+  f->frame_type = UNW_ARM_FRAME_OTHER;
+  f->last_frame = 0;
+  f->cfa_reg_sp = -1;
+  f->cfa_reg_offset = 0;
+  f->r7_cfa_offset = -1;
+  f->lr_cfa_offset = -1;
+  f->sp_cfa_offset = -1;
+
+  /* Reinitialise cursor to this instruction - but undo next/prev RIP
+     adjustment because unw_step will redo it - and force PC, R7 and
+     SP into register locations (=~ ucontext we keep), then set
+     their desired values. Then perform the step. */
+  d->ip = pc + d->use_prev_instr;
+  d->cfa = cfa;
+  d->loc[UNW_ARM_R7] = DWARF_REG_LOC (d, UNW_ARM_R7);
+  d->loc[UNW_ARM_R13] = DWARF_REG_LOC (d, UNW_ARM_R13);
+  d->loc[UNW_ARM_R15] = DWARF_REG_LOC (d, UNW_ARM_R15);
+  c->frame_info = *f;
+
+  if (likely(dwarf_put (d, d->loc[UNW_ARM_R7], r7) >= 0)
+      && likely(dwarf_put (d, d->loc[UNW_ARM_R13], sp) >= 0)
+      && likely(dwarf_put (d, d->loc[UNW_ARM_R15], pc) >= 0)
+      && likely((ret = unw_step (cursor)) >= 0))
+    *f = c->frame_info;
+
+  /* If unw_step() stopped voluntarily, remember that, even if it
+     otherwise could not determine anything useful.  This avoids
+     failing trace if we hit frames without unwind info, which is
+     common for the outermost frame (CRT stuff) on many systems.
+     This avoids failing trace in very common circumstances; failing
+     to unw_step() loop wouldn't produce any better result. */
+  if (ret == 0)
+    f->last_frame = -1;
+
+  Debug (3, "frame va %x type %d last %d cfa %s+%d r7 @ cfa%+d lr @ cfa%+d sp @ cfa%+d\n",
+         f->virtual_address, f->frame_type, f->last_frame,
+         f->cfa_reg_sp ? "sp" : "r7", f->cfa_reg_offset,
+         f->r7_cfa_offset, f->lr_cfa_offset, f->sp_cfa_offset);
+
+  return f;
+}
+
+/* Look up and if necessary fill in frame attributes for address PC
+   in CACHE using current CFA, R7 and SP values.  Uses CURSOR to
+   perform any unwind steps necessary to fill the cache.  Returns the
+   frame cache slot which describes RIP. */
+static unw_tdep_frame_t *
+trace_lookup (unw_cursor_t *cursor,
+              unw_trace_cache_t *cache,
+              unw_word_t cfa,
+              unw_word_t pc,
+              unw_word_t r7,
+              unw_word_t sp)
+{
+  /* First look up for previously cached information using cache as
+     linear probing hash table with probe step of 1.  Majority of
+     lookups should be completed within few steps, but it is very
+     important the hash table does not fill up, or performance falls
+     off the cliff. */
+  uint32_t i, addr;
+  uint32_t cache_size = 1u << cache->log_size;
+  uint32_t slot = ((pc * 0x9e3779b9) >> 11) & (cache_size-1);
+  unw_tdep_frame_t *frame;
+
+  for (i = 0; i < 16; ++i)
+  {
+    frame = &cache->frames[slot];
+    addr = frame->virtual_address;
+
+    /* Return if we found the address. */
+    if (likely(addr == pc))
+    {
+      Debug (4, "found address after %d steps\n", i);
+      return frame;
+    }
+
+    /* If slot is empty, reuse it. */
+    if (likely(! addr))
+      break;
+
+    /* Linear probe to next slot candidate, step = 1. */
+    if (++slot >= cache_size)
+      slot -= cache_size;
+  }
+
+  /* If we collided after 16 steps, or if the hash is more than half
+     full, force the hash to expand. Fill the selected slot, whether
+     it's free or collides. Note that hash expansion drops previous
+     contents; further lookups will refill the hash. */
+  Debug (4, "updating slot %u after %d steps, replacing 0x%x\n", slot, i, addr);
+  if (unlikely(addr || cache->used >= cache_size / 2))
+  {
+    if (unlikely(trace_cache_expand (cache) < 0))
+      return NULL;
+
+    cache_size = 1u << cache->log_size;
+    slot = ((pc * 0x9e3779b9) >> 11) & (cache_size-1);
+    frame = &cache->frames[slot];
+    addr = frame->virtual_address;
+  }
+
+  if (! addr)
+    ++cache->used;
+
+  return trace_init_addr (frame, cursor, cfa, pc, r7, sp);
+}
+
+/* Fast stack backtrace for ARM.
+
+   This is used by backtrace() implementation to accelerate frequent
+   queries for current stack, without any desire to unwind. It fills
+   BUFFER with the call tree from CURSOR upwards for at most SIZE
+   stack levels. The first frame, backtrace itself, is omitted. When
+   called, SIZE should give the maximum number of entries that can be
+   stored into BUFFER. Uses an internal thread-specific cache to
+   accelerate queries.
+
+   The caller should fall back to a unw_step() loop if this function
+   fails by returning -UNW_ESTOPUNWIND, meaning the routine hit a
+   stack frame that is too complex to be traced in the fast path.
+
+   This function is tuned for clients which only need to walk the
+   stack to get the call tree as fast as possible but without any
+   other details, for example profilers sampling the stack thousands
+   to millions of times per second.  The routine handles the most
+   common ARM ABI stack layouts: CFA is R7 or SP plus/minus
+   constant offset, return address is in LR, and R7, LR and SP are
+   either unchanged or saved on stack at constant offset from the CFA;
+   the signal return frame; and frames without unwind info provided
+   they are at the outermost (final) frame or can conservatively be
+   assumed to be frame-pointer based.
+
+   Any other stack layout will cause the routine to give up. There
+   are only a handful of relatively rarely used functions which do
+   not have a stack in the standard form: vfork, longjmp, setcontext
+   and _dl_runtime_profile on common linux systems for example.
+
+   On success BUFFER and *SIZE reflect the trace progress up to *SIZE
+   stack levels or the outermost frame, which ever is less.  It may
+   stop short of outermost frame if unw_step() loop would also do so,
+   e.g. if there is no more unwind information; this is not reported
+   as an error.
+
+   The function returns a negative value for errors, -UNW_ESTOPUNWIND
+   if tracing stopped because of an unusual frame unwind info.  The
+   BUFFER and *SIZE reflect tracing progress up to the error frame.
+
+   Callers of this function would normally look like this:
+
+     unw_cursor_t     cur;
+     unw_context_t    ctx;
+     void             addrs[128];
+     int              depth = 128;
+     int              ret;
+
+     unw_getcontext(&ctx);
+     unw_init_local(&cur, &ctx);
+     if ((ret = unw_tdep_trace(&cur, addrs, &depth)) < 0)
+     {
+       depth = 0;
+       unw_getcontext(&ctx);
+       unw_init_local(&cur, &ctx);
+       while ((ret = unw_step(&cur)) > 0 && depth < 128)
+       {
+         unw_word_t ip;
+         unw_get_reg(&cur, UNW_REG_IP, &ip);
+         addresses[depth++] = (void *) ip;
+       }
+     }
+*/
+HIDDEN int
+tdep_trace (unw_cursor_t *cursor, void **buffer, int *size)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  struct dwarf_cursor *d = &c->dwarf;
+  unw_trace_cache_t *cache;
+  unw_word_t sp, pc, cfa, r7, lr;
+  int maxdepth = 0;
+  int depth = 0;
+  int ret;
+
+  /* Check input parametres. */
+  if (unlikely(! cursor || ! buffer || ! size || (maxdepth = *size) <= 0))
+    return -UNW_EINVAL;
+
+  Debug (1, "begin ip 0x%x cfa 0x%x\n", d->ip, d->cfa);
+
+  /* Tell core dwarf routines to call back to us. */
+  d->stash_frames = 1;
+
+  /* Determine initial register values. These are direct access safe
+     because we know they come from the initial machine context. */
+  pc = d->ip;
+  sp = cfa = d->cfa;
+  ACCESS_MEM_FAST(ret, 0, d, DWARF_GET_LOC(d->loc[UNW_ARM_R7]), r7);
+  assert(ret == 0);
+  lr = 0;
+
+  /* Get frame cache. */
+  if (unlikely(! (cache = trace_cache_get())))
+  {
+    Debug (1, "returning %d, cannot get trace cache\n", -UNW_ENOMEM);
+    *size = 0;
+    d->stash_frames = 0;
+    return -UNW_ENOMEM;
+  }
+
+  /* Trace the stack upwards, starting from current PC.  Adjust
+     the PC address for previous/next instruction as the main
+     unwinding logic would also do.  We undo this before calling
+     back into unw_step(). */
+  while (depth < maxdepth)
+  {
+    pc -= d->use_prev_instr;
+    Debug (2, "depth %d cfa 0x%x pc 0x%x sp 0x%x r7 0x%x\n",
+           depth, cfa, pc, sp, r7);
+
+    /* See if we have this address cached.  If not, evaluate enough of
+       the dwarf unwind information to fill the cache line data, or to
+       decide this frame cannot be handled in fast trace mode.  We
+       cache negative results too to prevent unnecessary dwarf parsing
+       for common failures. */
+    unw_tdep_frame_t *f = trace_lookup (cursor, cache, cfa, pc, r7, sp);
+
+    /* If we don't have information for this frame, give up. */
+    if (unlikely(! f))
+    {
+      ret = -UNW_ENOINFO;
+      break;
+    }
+
+    Debug (3, "frame va %x type %d last %d cfa %s+%d r7 @ cfa%+d lr @ cfa%+d sp @ cfa%+d\n",
+           f->virtual_address, f->frame_type, f->last_frame,
+           f->cfa_reg_sp ? "sp" : "r7", f->cfa_reg_offset,
+           f->r7_cfa_offset, f->lr_cfa_offset, f->sp_cfa_offset);
+
+    assert (f->virtual_address == pc);
+
+    /* Stop if this was the last frame.  In particular don't evaluate
+       new register values as it may not be safe - we don't normally
+       run with full validation on, and do not want to - and there's
+       enough bad unwind info floating around that we need to trust
+       what unw_step() previously said, in potentially bogus frames. */
+    if (f->last_frame)
+      break;
+
+    /* Evaluate CFA and registers for the next frame. */
+    switch (f->frame_type)
+    {
+    case UNW_ARM_FRAME_GUESSED:
+      /* Fall thru to standard processing after forcing validation. */
+      c->validate = 1;
+
+    case UNW_ARM_FRAME_STANDARD:
+      /* Advance standard traceable frame. */
+      cfa = (f->cfa_reg_sp ? sp : r7) + f->cfa_reg_offset;
+      if (likely(f->lr_cfa_offset != -1))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + f->lr_cfa_offset, pc);
+      else if (lr != 0)
+      {
+        /* Use the saved link register as the new pc. */
+        pc = lr;
+        lr = 0;
+      }
+      if (likely(ret >= 0) && likely(f->r7_cfa_offset != -1))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + f->r7_cfa_offset, r7);
+
+      /* Don't bother reading SP from DWARF, CFA becomes new SP. */
+      sp = cfa;
+
+      /* Next frame needs to back up for unwind info lookup. */
+      d->use_prev_instr = 1;
+      break;
+
+    case UNW_ARM_FRAME_SIGRETURN:
+      cfa = cfa + f->cfa_reg_offset; /* cfa now points to ucontext_t.  */
+#if defined(__linux__)
+      ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_PC_OFF, pc);
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_R7_OFF, r7);
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_SP_OFF, sp);
+      /* Save the link register here in case we end up in a function that
+         doesn't save the link register in the prologue, e.g. kill. */
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + LINUX_SC_LR_OFF, lr);
+#elif defined(__FreeBSD__)
+      printf("XXX\n");
+#endif
+
+      /* Resume stack at signal restoration point. The stack is not
+         necessarily continuous here, especially with sigaltstack(). */
+      cfa = sp;
+
+      /* Next frame should not back up. */
+      d->use_prev_instr = 0;
+      break;
+
+    case UNW_ARM_FRAME_SYSCALL:
+      printf("XXX1\n");
+      break;
+
+    default:
+      /* We cannot trace through this frame, give up and tell the
+          caller we had to stop.  Data collected so far may still be
+          useful to the caller, so let it know how far we got.  */
+      ret = -UNW_ESTOPUNWIND;
+      break;
+    }
+
+    Debug (4, "new cfa 0x%x pc 0x%x sp 0x%x r7 0x%x\n",
+           cfa, pc, sp, r7);
+
+    /* If we failed or ended up somewhere bogus, stop. */
+    if (unlikely(ret < 0 || pc < 0x4000))
+      break;
+
+    /* Record this address in stack trace. We skipped the first address. */
+    buffer[depth++] = (void *) (pc - d->use_prev_instr);
+  }
+
+#if UNW_DEBUG
+  Debug (1, "returning %d, depth %d\n", ret, depth);
+#endif
+  *size = depth;
+  return ret;
+}
+
diff --git a/src/arm/Lapply_reg_state.c b/src/arm/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/arm/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/arm/Los-freebsd.c b/src/arm/Los-freebsd.c
new file mode 100644
index 0000000..a75a205
--- /dev/null
+++ b/src/arm/Los-freebsd.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gos-freebsd.c"
+#endif
diff --git a/src/arm/Los-linux.c b/src/arm/Los-linux.c
new file mode 100644
index 0000000..3cc18aa
--- /dev/null
+++ b/src/arm/Los-linux.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gos-linux.c"
+#endif
diff --git a/src/arm/Los-other.c b/src/arm/Los-other.c
new file mode 100644
index 0000000..a75a205
--- /dev/null
+++ b/src/arm/Los-other.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gos-freebsd.c"
+#endif
diff --git a/src/arm/Lreg_states_iterate.c b/src/arm/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/arm/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/arm/Lstash_frame.c b/src/arm/Lstash_frame.c
new file mode 100644
index 0000000..7758780
--- /dev/null
+++ b/src/arm/Lstash_frame.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gstash_frame.c"
+#endif
diff --git a/src/arm/Ltrace.c b/src/arm/Ltrace.c
new file mode 100644
index 0000000..24b7b3c
--- /dev/null
+++ b/src/arm/Ltrace.c
@@ -0,0 +1,6 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gtrace.c"
+#endif
+
diff --git a/src/arm/getcontext.S b/src/arm/getcontext.S
index c52992b..7e18784 100644
--- a/src/arm/getcontext.S
+++ b/src/arm/getcontext.S
@@ -35,8 +35,15 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 _Uarm_getcontext:
 	stmfd sp!, {r0, r1}
 	@ store r0
+#if defined(__linux__)
 	str r0, [r0, #LINUX_UC_MCONTEXT_OFF + LINUX_SC_R0_OFF]
 	add r0, r0, #LINUX_UC_MCONTEXT_OFF + LINUX_SC_R0_OFF
+#elif defined(__FreeBSD__)
+	str r0, [r0, #FREEBSD_UC_MCONTEXT_OFF + FREEBSD_MC_R0_OFF]
+	add r0, r0, #FREEBSD_UC_MCONTEXT_OFF + FREEBSD_MC_R0_OFF
+#else
+#error Fix me
+#endif
 	@ store r1 to r12
 	stmib r0, {r1-r12}
 	@ reconstruct r13 at call site, then store
@@ -50,7 +57,7 @@ _Uarm_getcontext:
 	str r1, [r0, #15 * 4]
 	ldmfd sp!, {r0, r1}
 	bx lr
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
  /* We do not need executable stack.  */
  .section  .note.GNU-stack,"",%progbits
 #endif
diff --git a/src/arm/init.h b/src/arm/init.h
index 676c340..7d765ec 100644
--- a/src/arm/init.h
+++ b/src/arm/init.h
@@ -54,7 +54,7 @@ common_init (struct cursor *c, unsigned use_prev_instr)
 
   /* FIXME: correct for ARM?  */
   ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_ARM_R13),
-		   &c->dwarf.cfa);
+                   &c->dwarf.cfa);
   if (ret < 0)
     return ret;
 
@@ -66,7 +66,6 @@ common_init (struct cursor *c, unsigned use_prev_instr)
   /* FIXME: Initialisation for other registers.  */
 
   c->dwarf.args_size = 0;
-  c->dwarf.ret_addr_column = 0;
   c->dwarf.stash_frames = 0;
   c->dwarf.use_prev_instr = use_prev_instr;
   c->dwarf.pi_valid = 0;
diff --git a/src/arm/is_fpreg.c b/src/arm/is_fpreg.c
index d8b17ae..e55bcff 100644
--- a/src/arm/is_fpreg.c
+++ b/src/arm/is_fpreg.c
@@ -27,13 +27,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 /* FIXME: I'm not sure if libunwind's GP/FP register distinction is very useful
    on ARM.  Count all the FP or coprocessor registers we know about for now.  */
 
-PROTECTED int
+int
 unw_is_fpreg (int regnum)
 {
   return ((regnum >= UNW_ARM_S0 && regnum <= UNW_ARM_S31)
-	  || (regnum >= UNW_ARM_F0 && regnum <= UNW_ARM_F7)
-	  || (regnum >= UNW_ARM_wCGR0 && regnum <= UNW_ARM_wCGR7)
-	  || (regnum >= UNW_ARM_wR0 && regnum <= UNW_ARM_wR15)
-	  || (regnum >= UNW_ARM_wC0 && regnum <= UNW_ARM_wC7)
-	  || (regnum >= UNW_ARM_D0 && regnum <= UNW_ARM_D31));
+          || (regnum >= UNW_ARM_F0 && regnum <= UNW_ARM_F7)
+          || (regnum >= UNW_ARM_wCGR0 && regnum <= UNW_ARM_wCGR7)
+          || (regnum >= UNW_ARM_wR0 && regnum <= UNW_ARM_wR15)
+          || (regnum >= UNW_ARM_wC0 && regnum <= UNW_ARM_wC7)
+          || (regnum >= UNW_ARM_D0 && regnum <= UNW_ARM_D31));
 }
diff --git a/src/arm/offsets.h b/src/arm/offsets.h
index 0593685..6217011 100644
--- a/src/arm/offsets.h
+++ b/src/arm/offsets.h
@@ -4,33 +4,39 @@
 
 /* Offsets for ARM Linux "ucontext_t":  */
 
-#define LINUX_UC_FLAGS_OFF	0x00
-#define LINUX_UC_LINK_OFF	0x04
-#define LINUX_UC_STACK_OFF	0x08
-#define LINUX_UC_MCONTEXT_OFF	0x14
-#define LINUX_UC_SIGMASK_OFF	0x68
-#define LINUX_UC_REGSPACE_OFF	0xE8
+#define LINUX_UC_FLAGS_OFF      0x00
+#define LINUX_UC_LINK_OFF       0x04
+#define LINUX_UC_STACK_OFF      0x08
+#define LINUX_UC_MCONTEXT_OFF   0x14
+#define LINUX_UC_SIGMASK_OFF    0x68
+#define LINUX_UC_REGSPACE_OFF   0xE8
 
 /* Offsets for ARM Linux "struct sigcontext":  */
 
-#define LINUX_SC_TRAPNO_OFF	0x00
-#define LINUX_SC_ERRORCODE_OFF	0x04
-#define LINUX_SC_OLDMASK_OFF	0x08
-#define LINUX_SC_R0_OFF		0x0C
-#define LINUX_SC_R1_OFF		0x10
-#define LINUX_SC_R2_OFF		0x14
-#define LINUX_SC_R3_OFF		0x18
-#define LINUX_SC_R4_OFF		0x1C
-#define LINUX_SC_R5_OFF		0x20
-#define LINUX_SC_R6_OFF		0x24
-#define LINUX_SC_R7_OFF		0x28
-#define LINUX_SC_R8_OFF		0x2C
-#define LINUX_SC_R9_OFF		0x30
-#define LINUX_SC_R10_OFF	0x34
-#define LINUX_SC_FP_OFF		0x38
-#define LINUX_SC_IP_OFF		0x3C
-#define LINUX_SC_SP_OFF		0x40
-#define LINUX_SC_LR_OFF		0x44
-#define LINUX_SC_PC_OFF		0x48
-#define LINUX_SC_CPSR_OFF	0x4C
-#define LINUX_SC_FAULTADDR_OFF	0x50
+#define LINUX_SC_TRAPNO_OFF     0x00
+#define LINUX_SC_ERRORCODE_OFF  0x04
+#define LINUX_SC_OLDMASK_OFF    0x08
+#define LINUX_SC_R0_OFF         0x0C
+#define LINUX_SC_R1_OFF         0x10
+#define LINUX_SC_R2_OFF         0x14
+#define LINUX_SC_R3_OFF         0x18
+#define LINUX_SC_R4_OFF         0x1C
+#define LINUX_SC_R5_OFF         0x20
+#define LINUX_SC_R6_OFF         0x24
+#define LINUX_SC_R7_OFF         0x28
+#define LINUX_SC_R8_OFF         0x2C
+#define LINUX_SC_R9_OFF         0x30
+#define LINUX_SC_R10_OFF        0x34
+#define LINUX_SC_FP_OFF         0x38
+#define LINUX_SC_IP_OFF         0x3C
+#define LINUX_SC_SP_OFF         0x40
+#define LINUX_SC_LR_OFF         0x44
+#define LINUX_SC_PC_OFF         0x48
+#define LINUX_SC_CPSR_OFF       0x4C
+#define LINUX_SC_FAULTADDR_OFF  0x50
+
+/* FreeBSD-specific definitions: */
+
+#define FREEBSD_SC_UCONTEXT_OFF		0x40
+#define	FREEBSD_UC_MCONTEXT_OFF		0x10
+#define FREEBSD_MC_R0_OFF		0
diff --git a/src/arm/regname.c b/src/arm/regname.c
index 474337a..7cac630 100644
--- a/src/arm/regname.c
+++ b/src/arm/regname.c
@@ -80,7 +80,7 @@ static const char *regname[] =
     "d24", "d25", "d26", "d27", "d28", "d29", "d30", "d31",
   };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
diff --git a/src/arm/unwind_i.h b/src/arm/unwind_i.h
index 9f6af2f..fe0bca0 100644
--- a/src/arm/unwind_i.h
+++ b/src/arm/unwind_i.h
@@ -31,12 +31,32 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-#define arm_lock			UNW_OBJ(lock)
-#define arm_local_resume		UNW_OBJ(local_resume)
-#define arm_local_addr_space_init	UNW_OBJ(local_addr_space_init)
+/* DWARF column numbers for ARM: */
+#define R7      7
+#define SP      13
+#define LR      14
+#define PC      15
+
+#define arm_lock                        UNW_OBJ(lock)
+#define arm_local_resume                UNW_OBJ(local_resume)
+#define arm_local_addr_space_init       UNW_OBJ(local_addr_space_init)
 
 extern void arm_local_addr_space_init (void);
 extern int arm_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			     void *arg);
+                             void *arg);
+#define arm_handle_signal_frame UNW_OBJ(handle_signal_frame)
+extern int arm_handle_signal_frame(unw_cursor_t *cursor);
+
+/* By-pass calls to access_mem() when known to be safe. */
+#ifdef UNW_LOCAL_ONLY
+# undef ACCESS_MEM_FAST
+# define ACCESS_MEM_FAST(ret,validate,cur,addr,to)                     \
+  do {                                                                 \
+    if (unlikely(validate))                                            \
+      (ret) = dwarf_get ((cur), DWARF_MEM_LOC ((cur), (addr)), &(to)); \
+    else                                                               \
+      (ret) = 0, (to) = *(unw_word_t *)(addr);                         \
+  } while (0)
+#endif
 
 #endif /* unwind_i_h */
diff --git a/src/coredump/_UCD_access_mem.c b/src/coredump/_UCD_access_mem.c
index 62d4183..1fdbd12 100644
--- a/src/coredump/_UCD_access_mem.c
+++ b/src/coredump/_UCD_access_mem.c
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 int
 _UCD_access_mem(unw_addr_space_t as, unw_word_t addr, unw_word_t *val,
-		 int write, void *arg)
+                 int write, void *arg)
 {
   if (write)
     {
@@ -43,9 +43,9 @@ _UCD_access_mem(unw_addr_space_t as, unw_word_t addr, unw_word_t *val,
     {
       phdr = &ui->phdrs[i];
       if (phdr->p_vaddr <= addr && addr_last < phdr->p_vaddr + phdr->p_memsz)
-	{
-	  goto found;
-	}
+        {
+          goto found;
+        }
     }
   Debug(1, "addr 0x%llx is unmapped\n", (unsigned long long)addr);
   return -UNW_EINVAL;
@@ -62,8 +62,8 @@ _UCD_access_mem(unw_addr_space_t as, unw_word_t addr, unw_word_t *val,
       if (phdr->backing_fd < 0)
         {
           Debug(1, "access to not-present data in phdr[%d]: addr:0x%llx\n",
-				i, (unsigned long long)addr
-			);
+                                i, (unsigned long long)addr
+                        );
           return -UNW_EINVAL;
         }
       filename = phdr->backing_filename;
@@ -82,17 +82,17 @@ _UCD_access_mem(unw_addr_space_t as, unw_word_t addr, unw_word_t *val,
     goto read_error;
 
   Debug(1, "0x%llx <- [addr:0x%llx fileofs:0x%llx]\n",
-	(unsigned long long)(*val),
-	(unsigned long long)addr,
-	(unsigned long long)fileofs
+        (unsigned long long)(*val),
+        (unsigned long long)addr,
+        (unsigned long long)fileofs
   );
   return 0;
 
  read_error:
   Debug(1, "access out of file: addr:0x%llx fileofs:%llx file:'%s'\n",
-	(unsigned long long)addr,
-	(unsigned long long)fileofs,
-	filename
+        (unsigned long long)addr,
+        (unsigned long long)fileofs,
+        filename
   );
   return -UNW_EINVAL;
 }
diff --git a/src/coredump/_UCD_access_reg_freebsd.c b/src/coredump/_UCD_access_reg_freebsd.c
index 585b7e2..930a114 100644
--- a/src/coredump/_UCD_access_reg_freebsd.c
+++ b/src/coredump/_UCD_access_reg_freebsd.c
@@ -76,7 +76,7 @@ _UCD_access_reg (unw_addr_space_t as,
   default:
       Debug(0, "bad regnum:%d\n", regnum);
       return -UNW_EINVAL;
-  };
+  }
 #elif defined(UNW_TARGET_X86_64)
   switch (regnum) {
   case UNW_X86_64_RAX:
@@ -109,7 +109,46 @@ _UCD_access_reg (unw_addr_space_t as,
   default:
       Debug(0, "bad regnum:%d\n", regnum);
       return -UNW_EINVAL;
-  };
+  }
+#elif defined(UNW_TARGET_ARM)
+  if (regnum >= UNW_ARM_R0 && regnum <= UNW_ARM_R12) {
+     *valp = ui->prstatus->pr_reg.r[regnum];
+  } else {
+     switch (regnum) {
+     case UNW_ARM_R13:
+       *valp = ui->prstatus->pr_reg.r_sp;
+       break;
+     case UNW_ARM_R14:
+       *valp = ui->prstatus->pr_reg.r_lr;
+       break;
+     case UNW_ARM_R15:
+       *valp = ui->prstatus->pr_reg.r_pc;
+       break;
+     default:
+       Debug(0, "bad regnum:%d\n", regnum);
+       return -UNW_EINVAL;
+     }
+  }
+#elif defined(UNW_TARGET_AARCH64)
+  if (regnum >= UNW_AARCH64_X0 && regnum < UNW_AARCH64_X30) {
+     *valp = ui->prstatus->pr_reg.x[regnum];
+  } else {
+     switch (regnum) {
+     case UNW_AARCH64_SP:
+       *valp = ui->prstatus->pr_reg.sp;
+       break;
+     case UNW_AARCH64_X30:
+       *valp = ui->prstatus->pr_reg.lr;
+       break;
+     case UNW_AARCH64_PC:
+       *valp = ui->prstatus->pr_reg.elr;
+       break;
+     default:
+       Debug(0, "bad regnum:%d\n", regnum);
+       return -UNW_EINVAL;
+     }
+  }
+
 #else
 #error Port me
 #endif
diff --git a/src/coredump/_UCD_access_reg_linux.c b/src/coredump/_UCD_access_reg_linux.c
index bc360ad..43792f8 100644
--- a/src/coredump/_UCD_access_reg_linux.c
+++ b/src/coredump/_UCD_access_reg_linux.c
@@ -39,11 +39,23 @@ _UCD_access_reg (unw_addr_space_t as,
       return -UNW_EINVAL;
     }
 
-#if defined(UNW_TARGET_ARM)
-  if (regnum < 0 || regnum >= 16)
+  if (regnum < 0)
+    goto badreg;
+
+#if defined(UNW_TARGET_AARCH64)
+  if (regnum >= UNW_AARCH64_FPCR)
+    goto badreg;
+#elif defined(UNW_TARGET_ARM)
+  if (regnum >= 16)
     goto badreg;
 #elif defined(UNW_TARGET_SH)
-  if (regnum < 0 || regnum > UNW_SH_PR)
+  if (regnum > UNW_SH_PR)
+    goto badreg;
+#elif defined(UNW_TARGET_TILEGX)
+  if (regnum > UNW_TILEGX_CFA)
+    goto badreg;
+#elif defined(UNW_TARGET_S390X)
+  if (regnum > UNW_S390X_R15)
     goto badreg;
 #else
 #if defined(UNW_TARGET_MIPS)
@@ -114,7 +126,7 @@ _UCD_access_reg (unw_addr_space_t as,
 #error Port me
 #endif
 
-  if (regnum < 0 || regnum >= (unw_regnum_t)ARRAY_SIZE(remap_regs))
+  if (regnum >= (unw_regnum_t)ARRAY_SIZE(remap_regs))
     goto badreg;
 
   regnum = remap_regs[regnum];
@@ -124,8 +136,8 @@ _UCD_access_reg (unw_addr_space_t as,
    * image.
    */
   Debug(1, "pr_reg[%d]:%ld (0x%lx)\n", regnum,
-		(long)ui->prstatus->pr_reg[regnum],
-		(long)ui->prstatus->pr_reg[regnum]
+                (long)ui->prstatus->pr_reg[regnum],
+                (long)ui->prstatus->pr_reg[regnum]
   );
   *valp = ui->prstatus->pr_reg[regnum];
 
diff --git a/src/coredump/_UCD_accessors.c b/src/coredump/_UCD_accessors.c
index 9bbe34e..ae5c23d 100644
--- a/src/coredump/_UCD_accessors.c
+++ b/src/coredump/_UCD_accessors.c
@@ -23,14 +23,14 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "_UCD_internal.h"
 
-PROTECTED unw_accessors_t _UCD_accessors =
+unw_accessors_t _UCD_accessors =
   {
-    .find_proc_info		= _UCD_find_proc_info,
-    .put_unwind_info		= _UCD_put_unwind_info,
-    .get_dyn_info_list_addr	= _UCD_get_dyn_info_list_addr,
-    .access_mem			= _UCD_access_mem,
-    .access_reg			= _UCD_access_reg,
-    .access_fpreg		= _UCD_access_fpreg,
-    .resume			= _UCD_resume,
-    .get_proc_name		= _UCD_get_proc_name
+    .find_proc_info             = _UCD_find_proc_info,
+    .put_unwind_info            = _UCD_put_unwind_info,
+    .get_dyn_info_list_addr     = _UCD_get_dyn_info_list_addr,
+    .access_mem                 = _UCD_access_mem,
+    .access_reg                 = _UCD_access_reg,
+    .access_fpreg               = _UCD_access_fpreg,
+    .resume                     = _UCD_resume,
+    .get_proc_name              = _UCD_get_proc_name
   };
diff --git a/src/coredump/_UCD_create.c b/src/coredump/_UCD_create.c
index f22664b..62f6ee0 100644
--- a/src/coredump/_UCD_create.c
+++ b/src/coredump/_UCD_create.c
@@ -67,7 +67,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "_UCD_internal.h"
 
 #define NOTE_DATA(_hdr) STRUCT_MEMBER_P((_hdr), sizeof (Elf32_Nhdr) + UNW_ALIGN((_hdr)->n_namesz, 4))
-#define NOTE_SIZE(_hdr) (sizeof (Elf32_Nhdr) + UNW_ALIGN((_hdr)->n_namesz, 4) + (_hdr)->n_descsz)
+#define NOTE_SIZE(_hdr) (sizeof (Elf32_Nhdr) + UNW_ALIGN((_hdr)->n_namesz, 4) + UNW_ALIGN((_hdr)->n_descsz, 4))
 #define NOTE_NEXT(_hdr) STRUCT_MEMBER_P((_hdr), NOTE_SIZE(_hdr))
 #define NOTE_FITS_IN(_hdr, _size) ((_size) >= sizeof (Elf32_Nhdr) && (_size) >= NOTE_SIZE (_hdr))
 #define NOTE_FITS(_hdr, _end) NOTE_FITS_IN((_hdr), (unsigned long)((char *)(_end) - (char *)(_hdr)))
diff --git a/src/coredump/_UCD_destroy.c b/src/coredump/_UCD_destroy.c
index 5aff989..ddc36ec 100644
--- a/src/coredump/_UCD_destroy.c
+++ b/src/coredump/_UCD_destroy.c
@@ -44,7 +44,9 @@ _UCD_destroy (struct UCD_info *ui)
         close(phdr->backing_fd);
     }
 
+  free(ui->phdrs);
   free(ui->note_phdr);
+  free(ui->threads);
 
   free(ui);
 }
diff --git a/src/coredump/_UCD_elf_map_image.c b/src/coredump/_UCD_elf_map_image.c
index 63eb22a..4b3db0b 100644
--- a/src/coredump/_UCD_elf_map_image.c
+++ b/src/coredump/_UCD_elf_map_image.c
@@ -40,17 +40,17 @@ CD_elf_map_image(struct UCD_info *ui, coredump_phdr_t *phdr)
       /* addr, length, prot, flags, fd, fd_offset */
       ei->image = mmap(NULL, phdr->p_memsz, PROT_READ, MAP_PRIVATE, ui->coredump_fd, phdr->p_offset);
       if (ei->image == MAP_FAILED)
-	{
-	  ei->image = NULL;
-	  return NULL;
-	}
+        {
+          ei->image = NULL;
+          return NULL;
+        }
       ei->size = phdr->p_filesz;
       size_t remainder_len = phdr->p_memsz - phdr->p_filesz;
       if (remainder_len > 0)
-	{
-	  void *remainder_base = (char*) ei->image + phdr->p_filesz;
-	  munmap(remainder_base, remainder_len);
-	}
+        {
+          void *remainder_base = (char*) ei->image + phdr->p_filesz;
+          munmap(remainder_base, remainder_len);
+        }
     } else {
       /* We have a backing file for this segment.
        * This file is always longer than phdr->p_memsz,
@@ -62,10 +62,10 @@ CD_elf_map_image(struct UCD_info *ui, coredump_phdr_t *phdr)
       /* addr, length, prot, flags, fd, fd_offset */
       ei->image = mmap(NULL, phdr->backing_filesize, PROT_READ, MAP_PRIVATE, phdr->backing_fd, 0);
       if (ei->image == MAP_FAILED)
-	{
-	  ei->image = NULL;
-	  return NULL;
-	}
+        {
+          ei->image = NULL;
+          return NULL;
+        }
       ei->size = phdr->backing_filesize;
     }
 
@@ -89,10 +89,10 @@ _UCD_get_elf_image(struct UCD_info *ui, unw_word_t ip)
     {
       coredump_phdr_t *phdr = &ui->phdrs[i];
       if (phdr->p_vaddr <= ip && ip < phdr->p_vaddr + phdr->p_memsz)
-	{
-	  phdr = CD_elf_map_image(ui, phdr);
-	  return phdr;
-	}
+        {
+          phdr = CD_elf_map_image(ui, phdr);
+          return phdr;
+        }
     }
   return NULL;
 }
diff --git a/src/coredump/_UCD_find_proc_info.c b/src/coredump/_UCD_find_proc_info.c
index febbdb8..33b66c8 100644
--- a/src/coredump/_UCD_find_proc_info.c
+++ b/src/coredump/_UCD_find_proc_info.c
@@ -102,7 +102,7 @@ get_unwind_info(struct UCD_info *ui, unw_addr_space_t as, unw_word_t ip)
 
 int
 _UCD_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
-		     int need_unwind_info, void *arg)
+                     int need_unwind_info, void *arg)
 {
   struct UCD_info *ui = arg;
 
@@ -119,33 +119,33 @@ _UCD_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
   if (ui->edi.ktab.format != -1)
     {
       /* The kernel unwind table resides in local memory, so we have
-	 to use the local address space to search it.  Since
-	 _UCD_put_unwind_info() has no easy way of detecting this
-	 case, we simply make a copy of the unwind-info, so
-	 _UCD_put_unwind_info() can always free() the unwind-info
-	 without ill effects.  */
+         to use the local address space to search it.  Since
+         _UCD_put_unwind_info() has no easy way of detecting this
+         case, we simply make a copy of the unwind-info, so
+         _UCD_put_unwind_info() can always free() the unwind-info
+         without ill effects.  */
       ret = tdep_search_unwind_table (unw_local_addr_space, ip, &ui->edi.ktab, pi,
-				      need_unwind_info, arg);
+                                      need_unwind_info, arg);
       if (ret >= 0)
-	{
-	  if (!need_unwind_info)
-	    pi->unwind_info = NULL;
-	  else
-	    {
-	      void *mem = malloc (pi->unwind_info_size);
-
-	      if (!mem)
-		return -UNW_ENOMEM;
-	      memcpy (mem, pi->unwind_info, pi->unwind_info_size);
-	      pi->unwind_info = mem;
-	    }
-	}
+        {
+          if (!need_unwind_info)
+            pi->unwind_info = NULL;
+          else
+            {
+              void *mem = malloc (pi->unwind_info_size);
+
+              if (!mem)
+                return -UNW_ENOMEM;
+              memcpy (mem, pi->unwind_info, pi->unwind_info_size);
+              pi->unwind_info = mem;
+            }
+        }
     }
 #endif
 
   if (ret == -UNW_ENOINFO && ui->edi.di_cache.format != -1)
     ret = tdep_search_unwind_table (as, ip, &ui->edi.di_cache,
-				    pi, need_unwind_info, arg);
+                                    pi, need_unwind_info, arg);
 
 #if UNW_TARGET_ARM
   if (ret == -UNW_ENOINFO && ui->edi.di_arm.format != -1)
@@ -155,7 +155,7 @@ _UCD_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
 
   if (ret == -UNW_ENOINFO && ui->edi.di_debug.format != -1)
     ret = tdep_search_unwind_table (as, ip, &ui->edi.di_debug, pi,
-				    need_unwind_info, arg);
+                                    need_unwind_info, arg);
 
   Debug(1, "returns %d\n", ret);
 
diff --git a/src/coredump/_UCD_get_proc_name.c b/src/coredump/_UCD_get_proc_name.c
index eae88c1..00096c4 100644
--- a/src/coredump/_UCD_get_proc_name.c
+++ b/src/coredump/_UCD_get_proc_name.c
@@ -31,7 +31,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
    sensitive to the performance of this routine, why bother...  */
 static int
 elf_w (CD_get_proc_name) (struct UCD_info *ui, unw_addr_space_t as, unw_word_t ip,
-		       char *buf, size_t buf_len, unw_word_t *offp)
+                       char *buf, size_t buf_len, unw_word_t *offp)
 {
   unsigned long segbase, mapoff;
   int ret;
@@ -56,7 +56,7 @@ elf_w (CD_get_proc_name) (struct UCD_info *ui, unw_addr_space_t as, unw_word_t i
 
 int
 _UCD_get_proc_name (unw_addr_space_t as, unw_word_t ip,
-		    char *buf, size_t buf_len, unw_word_t *offp, void *arg)
+                    char *buf, size_t buf_len, unw_word_t *offp, void *arg)
 {
   struct UCD_info *ui = arg;
 
diff --git a/src/coredump/_UPT_access_fpreg.c b/src/coredump/_UPT_access_fpreg.c
index a578af1..0b8b86a 100644
--- a/src/coredump/_UPT_access_fpreg.c
+++ b/src/coredump/_UPT_access_fpreg.c
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 int
 _UCD_access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-		   int write, void *arg)
+                   int write, void *arg)
 {
   print_error (__func__);
   print_error (" not implemented\n");
diff --git a/src/coredump/_UPT_elf.c b/src/coredump/_UPT_elf.c
index 8f30c69..fb7b19a 100644
--- a/src/coredump/_UPT_elf.c
+++ b/src/coredump/_UPT_elf.c
@@ -1,5 +1,5 @@
 /* We need to get a separate copy of the ELF-code into
    libunwind-coredump since it cannot (and must not) have any ELF
    dependencies on libunwind.  */
-#include "libunwind_i.h"	/* get ELFCLASS defined */
+#include "libunwind_i.h"        /* get ELFCLASS defined */
 #include "../elfxx.c"
diff --git a/src/coredump/_UPT_get_dyn_info_list_addr.c b/src/coredump/_UPT_get_dyn_info_list_addr.c
index c245ac1..0d11905 100644
--- a/src/coredump/_UPT_get_dyn_info_list_addr.c
+++ b/src/coredump/_UPT_get_dyn_info_list_addr.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -32,7 +32,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 static inline int
 get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
-	       int *countp)
+               int *countp)
 {
   unsigned long lo, hi, off;
   struct UPT_info *ui = arg;
@@ -46,26 +46,26 @@ get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
   while (maps_next (&mi, &lo, &hi, &off))
     {
       if (off)
-	continue;
+        continue;
 
       invalidate_edi (&ui->edi);
 
       if (elf_map_image (&ui->ei, path) < 0)
-	/* ignore unmappable stuff like "/SYSV00001b58 (deleted)" */
-	continue;
+        /* ignore unmappable stuff like "/SYSV00001b58 (deleted)" */
+        continue;
 
       Debug (16, "checking object %s\n", path);
 
       di = tdep_find_unwind_table (&ui->edi, as, path, lo, off);
       if (di)
-	{
-	  res = _Uia64_find_dyn_list (as, di, arg);
-	  if (res && count++ == 0)
-	    {
-	      Debug (12, "dyn_info_list_addr = 0x%lx\n", (long) res);
-	      *dil_addr = res;
-	    }
-	}
+        {
+          res = _Uia64_find_dyn_list (as, di, arg);
+          if (res && count++ == 0)
+            {
+              Debug (12, "dyn_info_list_addr = 0x%lx\n", (long) res);
+              *dil_addr = res;
+            }
+        }
     }
   maps_close (&mi);
   *countp = count;
@@ -76,7 +76,7 @@ get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
 
 static inline int
 get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
-	       int *countp)
+               int *countp)
 {
 # warning Implement get_list_addr(), please.
   *countp = 0;
@@ -87,7 +87,7 @@ get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
 
 int
 _UCD_get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dil_addr,
-			     void *arg)
+                             void *arg)
 {
   int count, ret;
 
diff --git a/src/coredump/_UPT_put_unwind_info.c b/src/coredump/_UPT_put_unwind_info.c
index 2f5a647..462e1d0 100644
--- a/src/coredump/_UPT_put_unwind_info.c
+++ b/src/coredump/_UPT_put_unwind_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
diff --git a/src/coredump/_UPT_resume.c b/src/coredump/_UPT_resume.c
index 368aae1..a729c90 100644
--- a/src/coredump/_UPT_resume.c
+++ b/src/coredump/_UPT_resume.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
diff --git a/src/coredump/libunwind-coredump.pc.in b/src/coredump/libunwind-coredump.pc.in
index edbb5ec..9cb62c0 100644
--- a/src/coredump/libunwind-coredump.pc.in
+++ b/src/coredump/libunwind-coredump.pc.in
@@ -8,3 +8,4 @@ Description: libunwind coredump library
 Version: @VERSION@
 Requires: libunwind-generic libunwind
 Libs: -L${libdir} -lunwind-coredump
+Cflags: -I${includedir}
diff --git a/src/dwarf/Gexpr.c b/src/dwarf/Gexpr.c
index b4f2bc9..2af4543 100644
--- a/src/dwarf/Gexpr.c
+++ b/src/dwarf/Gexpr.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -30,81 +30,83 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
    that the stack could at least have a depth of up to 256 elements,
    but the GCC unwinder restricts the depth to 64, which seems
    reasonable so we use the same value here.  */
-#define MAX_EXPR_STACK_SIZE	64
+#define MAX_EXPR_STACK_SIZE     64
 
-#define NUM_OPERANDS(signature)	(((signature) >> 6) & 0x3)
-#define OPND1_TYPE(signature)	(((signature) >> 3) & 0x7)
-#define OPND2_TYPE(signature)	(((signature) >> 0) & 0x7)
+#define NUM_OPERANDS(signature) (((signature) >> 6) & 0x3)
+#define OPND1_TYPE(signature)   (((signature) >> 3) & 0x7)
+#define OPND2_TYPE(signature)   (((signature) >> 0) & 0x7)
 
 #define OPND_SIGNATURE(n, t1, t2) (((n) << 6) | ((t1) << 3) | ((t2) << 0))
-#define OPND1(t1)		OPND_SIGNATURE(1, t1, 0)
-#define OPND2(t1, t2)		OPND_SIGNATURE(2, t1, t2)
-
-#define VAL8	0x0
-#define VAL16	0x1
-#define VAL32	0x2
-#define VAL64	0x3
-#define ULEB128	0x4
-#define SLEB128	0x5
-#define OFFSET	0x6	/* 32-bit offset for 32-bit DWARF, 64-bit otherwise */
-#define ADDR	0x7	/* Machine address.  */
+#define OPND1(t1)               OPND_SIGNATURE(1, t1, 0)
+#define OPND2(t1, t2)           OPND_SIGNATURE(2, t1, t2)
+
+#define VAL8    0x0
+#define VAL16   0x1
+#define VAL32   0x2
+#define VAL64   0x3
+#define ULEB128 0x4
+#define SLEB128 0x5
+#define OFFSET  0x6     /* 32-bit offset for 32-bit DWARF, 64-bit otherwise */
+#define ADDR    0x7     /* Machine address.  */
 
 static const uint8_t operands[256] =
   {
-    [DW_OP_addr] =		OPND1 (ADDR),
-    [DW_OP_const1u] =		OPND1 (VAL8),
-    [DW_OP_const1s] =		OPND1 (VAL8),
-    [DW_OP_const2u] =		OPND1 (VAL16),
-    [DW_OP_const2s] =		OPND1 (VAL16),
-    [DW_OP_const4u] =		OPND1 (VAL32),
-    [DW_OP_const4s] =		OPND1 (VAL32),
-    [DW_OP_const8u] =		OPND1 (VAL64),
-    [DW_OP_const8s] =		OPND1 (VAL64),
-    [DW_OP_pick] =		OPND1 (VAL8),
-    [DW_OP_plus_uconst] =	OPND1 (ULEB128),
-    [DW_OP_skip] =		OPND1 (VAL16),
-    [DW_OP_bra] =		OPND1 (VAL16),
-    [DW_OP_breg0 +  0] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  1] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  2] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  3] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  4] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  5] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  6] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  7] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  8] =	OPND1 (SLEB128),
-    [DW_OP_breg0 +  9] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 10] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 11] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 12] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 13] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 14] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 15] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 16] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 17] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 18] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 19] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 20] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 21] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 22] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 23] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 24] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 25] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 26] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 27] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 28] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 29] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 30] =	OPND1 (SLEB128),
-    [DW_OP_breg0 + 31] =	OPND1 (SLEB128),
-    [DW_OP_regx] =		OPND1 (ULEB128),
-    [DW_OP_fbreg] =		OPND1 (SLEB128),
-    [DW_OP_bregx] =		OPND2 (ULEB128, SLEB128),
-    [DW_OP_piece] =		OPND1 (ULEB128),
-    [DW_OP_deref_size] =	OPND1 (VAL8),
-    [DW_OP_xderef_size] =	OPND1 (VAL8),
-    [DW_OP_call2] =		OPND1 (VAL16),
-    [DW_OP_call4] =		OPND1 (VAL32),
-    [DW_OP_call_ref] =		OPND1 (OFFSET)
+    [DW_OP_addr] =              OPND1 (ADDR),
+    [DW_OP_const1u] =           OPND1 (VAL8),
+    [DW_OP_const1s] =           OPND1 (VAL8),
+    [DW_OP_const2u] =           OPND1 (VAL16),
+    [DW_OP_const2s] =           OPND1 (VAL16),
+    [DW_OP_const4u] =           OPND1 (VAL32),
+    [DW_OP_const4s] =           OPND1 (VAL32),
+    [DW_OP_const8u] =           OPND1 (VAL64),
+    [DW_OP_const8s] =           OPND1 (VAL64),
+    [DW_OP_constu]  =           OPND1 (ULEB128),
+    [DW_OP_consts]  =           OPND1 (SLEB128),
+    [DW_OP_pick] =              OPND1 (VAL8),
+    [DW_OP_plus_uconst] =       OPND1 (ULEB128),
+    [DW_OP_skip] =              OPND1 (VAL16),
+    [DW_OP_bra] =               OPND1 (VAL16),
+    [DW_OP_breg0 +  0] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  1] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  2] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  3] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  4] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  5] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  6] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  7] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  8] =        OPND1 (SLEB128),
+    [DW_OP_breg0 +  9] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 10] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 11] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 12] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 13] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 14] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 15] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 16] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 17] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 18] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 19] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 20] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 21] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 22] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 23] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 24] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 25] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 26] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 27] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 28] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 29] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 30] =        OPND1 (SLEB128),
+    [DW_OP_breg0 + 31] =        OPND1 (SLEB128),
+    [DW_OP_regx] =              OPND1 (ULEB128),
+    [DW_OP_fbreg] =             OPND1 (SLEB128),
+    [DW_OP_bregx] =             OPND2 (ULEB128, SLEB128),
+    [DW_OP_piece] =             OPND1 (ULEB128),
+    [DW_OP_deref_size] =        OPND1 (VAL8),
+    [DW_OP_xderef_size] =       OPND1 (VAL8),
+    [DW_OP_call2] =             OPND1 (VAL16),
+    [DW_OP_call4] =             OPND1 (VAL32),
+    [DW_OP_call_ref] =          OPND1 (OFFSET)
   };
 
 static inline unw_sword_t
@@ -122,7 +124,7 @@ sword (unw_addr_space_t as, unw_word_t val)
 
 static inline unw_word_t
 read_operand (unw_addr_space_t as, unw_accessors_t *a,
-	      unw_word_t *addr, int operand_type, unw_word_t *val, void *arg)
+              unw_word_t *addr, int operand_type, unw_word_t *val, void *arg)
 {
   uint8_t u8;
   uint16_t u16;
@@ -145,28 +147,28 @@ read_operand (unw_addr_space_t as, unw_accessors_t *a,
     case VAL8:
       ret = dwarf_readu8 (as, a, addr, &u8, arg);
       if (ret < 0)
-	return ret;
+        return ret;
       *val = u8;
       break;
 
     case VAL16:
       ret = dwarf_readu16 (as, a, addr, &u16, arg);
       if (ret < 0)
-	return ret;
+        return ret;
       *val = u16;
       break;
 
     case VAL32:
       ret = dwarf_readu32 (as, a, addr, &u32, arg);
       if (ret < 0)
-	return ret;
+        return ret;
       *val = u32;
       break;
 
     case VAL64:
       ret = dwarf_readu64 (as, a, addr, &u64, arg);
       if (ret < 0)
-	return ret;
+        return ret;
       *val = u64;
       break;
 
@@ -187,10 +189,58 @@ read_operand (unw_addr_space_t as, unw_accessors_t *a,
 }
 
 HIDDEN int
-dwarf_eval_expr (struct dwarf_cursor *c, unw_word_t *addr, unw_word_t len,
-		 unw_word_t *valp, int *is_register)
+dwarf_stack_aligned(struct dwarf_cursor *c, unw_word_t cfa_addr,
+                    unw_word_t rbp_addr, unw_word_t *cfa_offset) {
+  unw_accessors_t *a;
+  int ret;
+  void *arg;
+  unw_word_t len;
+  uint8_t opcode;
+  unw_word_t operand1;
+
+  a = unw_get_accessors_int (c->as);
+  arg = c->as_arg;
+
+  ret = dwarf_read_uleb128(c->as, a, &rbp_addr, &len, arg);
+  if (len != 2 || ret < 0)
+    return 0;
+
+  ret = dwarf_readu8(c->as, a, &rbp_addr, &opcode, arg);
+  if (ret < 0 || opcode != DW_OP_breg6)
+    return 0;
+
+  ret = read_operand(c->as, a, &rbp_addr,
+                     OPND1_TYPE(operands[opcode]), &operand1, arg);
+
+  if (ret < 0 || operand1 != 0)
+    return 0;
+
+  ret = dwarf_read_uleb128(c->as, a, &cfa_addr, &len, arg);
+  if (ret < 0 || len != 3)
+    return 0;
+
+  ret = dwarf_readu8(c->as, a, &cfa_addr, &opcode, arg);
+  if (ret < 0 || opcode != DW_OP_breg6)
+    return 0;
+
+  ret = read_operand(c->as, a, &cfa_addr,
+                     OPND1_TYPE(operands[opcode]), &operand1, arg);
+  if (ret < 0)
+    return 0;
+
+  ret = dwarf_readu8(c->as, a, &cfa_addr, &opcode, arg);
+  if (ret < 0 || opcode != DW_OP_deref)
+    return 0;
+
+  *cfa_offset = operand1;
+  return 1;
+}
+
+HIDDEN int
+dwarf_eval_expr (struct dwarf_cursor *c, unw_word_t stack_val, unw_word_t *addr,
+                 unw_word_t len, unw_word_t *valp, int *is_register)
 {
-  unw_word_t operand1 = 0, operand2 = 0, tmp1, tmp2, tmp3, end_addr;
+  unw_word_t operand1 = 0, operand2 = 0, tmp1, tmp2 = 0, tmp3, end_addr;
   uint8_t opcode, operands_signature, u8;
   unw_addr_space_t as;
   unw_accessors_t *a;
@@ -201,445 +251,450 @@ dwarf_eval_expr (struct dwarf_cursor *c, unw_word_t *addr, unw_word_t len,
   uint32_t u32;
   uint64_t u64;
   int ret;
-# define pop()					\
-({						\
-  if ((tos - 1) >= MAX_EXPR_STACK_SIZE)		\
-    {						\
-      Debug (1, "Stack underflow\n");		\
-      return -UNW_EINVAL;			\
-    }						\
-  stack[--tos];					\
+# define pop()                                  \
+({                                              \
+  if ((tos - 1) >= MAX_EXPR_STACK_SIZE)         \
+    {                                           \
+      Debug (1, "Stack underflow\n");           \
+      return -UNW_EINVAL;                       \
+    }                                           \
+  stack[--tos];                                 \
 })
-# define push(x)				\
-do {						\
-  if (tos >= MAX_EXPR_STACK_SIZE)		\
-    {						\
-      Debug (1, "Stack overflow\n");		\
-      return -UNW_EINVAL;			\
-    }						\
-  stack[tos++] = (x);				\
+# define push(x)                                \
+do {                                            \
+  unw_word_t _x = (x);                          \
+  if (tos >= MAX_EXPR_STACK_SIZE)               \
+    {                                           \
+      Debug (1, "Stack overflow\n");            \
+      return -UNW_EINVAL;                       \
+    }                                           \
+  stack[tos++] = _x;                            \
 } while (0)
-# define pick(n)				\
-({						\
-  unsigned int _index = tos - 1 - (n);		\
-  if (_index >= MAX_EXPR_STACK_SIZE)		\
-    {						\
-      Debug (1, "Out-of-stack pick\n");		\
-      return -UNW_EINVAL;			\
-    }						\
-  stack[_index];				\
+# define pick(n)                                \
+({                                              \
+  unsigned int _index = tos - 1 - (n);          \
+  if (_index >= MAX_EXPR_STACK_SIZE)            \
+    {                                           \
+      Debug (1, "Out-of-stack pick\n");         \
+      return -UNW_EINVAL;                       \
+    }                                           \
+  stack[_index];                                \
 })
 
   as = c->as;
   arg = c->as_arg;
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   end_addr = *addr + len;
   *is_register = 0;
 
-  Debug (14, "len=%lu, pushing cfa=0x%lx\n",
-	 (unsigned long) len, (unsigned long) c->cfa);
+  Debug (14, "len=%lu, pushing initial value=0x%lx\n",
+         (unsigned long) len, (unsigned long) stack_val);
 
-  push (c->cfa);	/* push current CFA as required by DWARF spec */
+  /* The DWARF standard requires the current CFA to be pushed onto the stack */
+  /* before evaluating DW_CFA_expression and DW_CFA_val_expression programs. */
+  /* DW_CFA_def_cfa_expressions do not take an initial value, but we push on */
+  /* a dummy value to keep this logic consistent. */
+  push (stack_val);
 
   while (*addr < end_addr)
     {
       if ((ret = dwarf_readu8 (as, a, addr, &opcode, arg)) < 0)
-	return ret;
+        return ret;
 
       operands_signature = operands[opcode];
 
       if (unlikely (NUM_OPERANDS (operands_signature) > 0))
-	{
-	  if ((ret = read_operand (as, a, addr,
-				   OPND1_TYPE (operands_signature),
-				   &operand1, arg)) < 0)
-	    return ret;
-	  if (NUM_OPERANDS (operands_signature) > 1)
-	    if ((ret = read_operand (as, a, addr,
-				     OPND2_TYPE (operands_signature),
-				     &operand2, arg)) < 0)
-	      return ret;
-	}
+        {
+          if ((ret = read_operand (as, a, addr,
+                                   OPND1_TYPE (operands_signature),
+                                   &operand1, arg)) < 0)
+            return ret;
+          if (NUM_OPERANDS (operands_signature) > 1)
+            if ((ret = read_operand (as, a, addr,
+                                     OPND2_TYPE (operands_signature),
+                                     &operand2, arg)) < 0)
+              return ret;
+        }
 
       switch ((dwarf_expr_op_t) opcode)
-	{
-	case DW_OP_lit0:  case DW_OP_lit1:  case DW_OP_lit2:
-	case DW_OP_lit3:  case DW_OP_lit4:  case DW_OP_lit5:
-	case DW_OP_lit6:  case DW_OP_lit7:  case DW_OP_lit8:
-	case DW_OP_lit9:  case DW_OP_lit10: case DW_OP_lit11:
-	case DW_OP_lit12: case DW_OP_lit13: case DW_OP_lit14:
-	case DW_OP_lit15: case DW_OP_lit16: case DW_OP_lit17:
-	case DW_OP_lit18: case DW_OP_lit19: case DW_OP_lit20:
-	case DW_OP_lit21: case DW_OP_lit22: case DW_OP_lit23:
-	case DW_OP_lit24: case DW_OP_lit25: case DW_OP_lit26:
-	case DW_OP_lit27: case DW_OP_lit28: case DW_OP_lit29:
-	case DW_OP_lit30: case DW_OP_lit31:
-	  Debug (15, "OP_lit(%d)\n", (int) opcode - DW_OP_lit0);
-	  push (opcode - DW_OP_lit0);
-	  break;
-
-	case DW_OP_breg0:  case DW_OP_breg1:  case DW_OP_breg2:
-	case DW_OP_breg3:  case DW_OP_breg4:  case DW_OP_breg5:
-	case DW_OP_breg6:  case DW_OP_breg7:  case DW_OP_breg8:
-	case DW_OP_breg9:  case DW_OP_breg10: case DW_OP_breg11:
-	case DW_OP_breg12: case DW_OP_breg13: case DW_OP_breg14:
-	case DW_OP_breg15: case DW_OP_breg16: case DW_OP_breg17:
-	case DW_OP_breg18: case DW_OP_breg19: case DW_OP_breg20:
-	case DW_OP_breg21: case DW_OP_breg22: case DW_OP_breg23:
-	case DW_OP_breg24: case DW_OP_breg25: case DW_OP_breg26:
-	case DW_OP_breg27: case DW_OP_breg28: case DW_OP_breg29:
-	case DW_OP_breg30: case DW_OP_breg31:
-	  Debug (15, "OP_breg(r%d,0x%lx)\n",
-		 (int) opcode - DW_OP_breg0, (unsigned long) operand1);
-	  if ((ret = unw_get_reg (dwarf_to_cursor (c),
-				  dwarf_to_unw_regnum (opcode - DW_OP_breg0),
-				  &tmp1)) < 0)
-	    return ret;
-	  push (tmp1 + operand1);
-	  break;
-
-	case DW_OP_bregx:
-	  Debug (15, "OP_bregx(r%d,0x%lx)\n",
-		 (int) operand1, (unsigned long) operand2);
-	  if ((ret = unw_get_reg (dwarf_to_cursor (c),
-				  dwarf_to_unw_regnum (operand1), &tmp1)) < 0)
-	    return ret;
-	  push (tmp1 + operand2);
-	  break;
-
-	case DW_OP_reg0:  case DW_OP_reg1:  case DW_OP_reg2:
-	case DW_OP_reg3:  case DW_OP_reg4:  case DW_OP_reg5:
-	case DW_OP_reg6:  case DW_OP_reg7:  case DW_OP_reg8:
-	case DW_OP_reg9:  case DW_OP_reg10: case DW_OP_reg11:
-	case DW_OP_reg12: case DW_OP_reg13: case DW_OP_reg14:
-	case DW_OP_reg15: case DW_OP_reg16: case DW_OP_reg17:
-	case DW_OP_reg18: case DW_OP_reg19: case DW_OP_reg20:
-	case DW_OP_reg21: case DW_OP_reg22: case DW_OP_reg23:
-	case DW_OP_reg24: case DW_OP_reg25: case DW_OP_reg26:
-	case DW_OP_reg27: case DW_OP_reg28: case DW_OP_reg29:
-	case DW_OP_reg30: case DW_OP_reg31:
-	  Debug (15, "OP_reg(r%d)\n", (int) opcode - DW_OP_reg0);
-	  *valp = dwarf_to_unw_regnum (opcode - DW_OP_reg0);
-	  *is_register = 1;
-	  return 0;
-
-	case DW_OP_regx:
-	  Debug (15, "OP_regx(r%d)\n", (int) operand1);
-	  *valp = dwarf_to_unw_regnum (operand1);
-	  *is_register = 1;
-	  return 0;
-
-	case DW_OP_addr:
-	case DW_OP_const1u:
-	case DW_OP_const2u:
-	case DW_OP_const4u:
-	case DW_OP_const8u:
-	case DW_OP_constu:
-	case DW_OP_const8s:
-	case DW_OP_consts:
-	  Debug (15, "OP_const(0x%lx)\n", (unsigned long) operand1);
-	  push (operand1);
-	  break;
-
-	case DW_OP_const1s:
-	  if (operand1 & 0x80)
-	    operand1 |= ((unw_word_t) -1) << 8;
-	  Debug (15, "OP_const1s(%ld)\n", (long) operand1);
-	  push (operand1);
-	  break;
-
-	case DW_OP_const2s:
-	  if (operand1 & 0x8000)
-	    operand1 |= ((unw_word_t) -1) << 16;
-	  Debug (15, "OP_const2s(%ld)\n", (long) operand1);
-	  push (operand1);
-	  break;
-
-	case DW_OP_const4s:
-	  if (operand1 & 0x80000000)
-	    operand1 |= (((unw_word_t) -1) << 16) << 16;
-	  Debug (15, "OP_const4s(%ld)\n", (long) operand1);
-	  push (operand1);
-	  break;
-
-	case DW_OP_deref:
-	  Debug (15, "OP_deref\n");
-	  tmp1 = pop ();
-	  if ((ret = dwarf_readw (as, a, &tmp1, &tmp2, arg)) < 0)
-	    return ret;
-	  push (tmp2);
-	  break;
-
-	case DW_OP_deref_size:
-	  Debug (15, "OP_deref_size(%d)\n", (int) operand1);
-	  tmp1 = pop ();
-	  switch (operand1)
-	    {
-	    default:
-	      Debug (1, "Unexpected DW_OP_deref_size size %d\n",
-		     (int) operand1);
-	      return -UNW_EINVAL;
-
-	    case 1:
-	      if ((ret = dwarf_readu8 (as, a, &tmp1, &u8, arg)) < 0)
-		return ret;
-	      tmp2 = u8;
-	      break;
-
-	    case 2:
-	      if ((ret = dwarf_readu16 (as, a, &tmp1, &u16, arg)) < 0)
-		return ret;
-	      tmp2 = u16;
-	      break;
-
-	    case 3:
-	    case 4:
-	      if ((ret = dwarf_readu32 (as, a, &tmp1, &u32, arg)) < 0)
-		return ret;
-	      tmp2 = u32;
-	      if (operand1 == 3)
-		{
-		  if (dwarf_is_big_endian (as))
-		    tmp2 >>= 8;
-		  else
-		    tmp2 &= 0xffffff;
-		}
-	      break;
-	    case 5:
-	    case 6:
-	    case 7:
-	    case 8:
-	      if ((ret = dwarf_readu64 (as, a, &tmp1, &u64, arg)) < 0)
-		return ret;
-	      tmp2 = u64;
-	      if (operand1 != 8)
-		{
-		  if (dwarf_is_big_endian (as))
-		    tmp2 >>= 64 - 8 * operand1;
-		  else
-		    tmp2 &= (~ (unw_word_t) 0) << (8 * operand1);
-		}
-	      break;
-	    }
-	  push (tmp2);
-	  break;
-
-	case DW_OP_dup:
-	  Debug (15, "OP_dup\n");
-	  push (pick (0));
-	  break;
-
-	case DW_OP_drop:
-	  Debug (15, "OP_drop\n");
-	  (void) pop ();
-	  break;
-
-	case DW_OP_pick:
-	  Debug (15, "OP_pick(%d)\n", (int) operand1);
-	  push (pick (operand1));
-	  break;
-
-	case DW_OP_over:
-	  Debug (15, "OP_over\n");
-	  push (pick (1));
-	  break;
-
-	case DW_OP_swap:
-	  Debug (15, "OP_swap\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (tmp1);
-	  push (tmp2);
-	  break;
-
-	case DW_OP_rot:
-	  Debug (15, "OP_rot\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  tmp3 = pop ();
-	  push (tmp1);
-	  push (tmp3);
-	  push (tmp2);
-	  break;
-
-	case DW_OP_abs:
-	  Debug (15, "OP_abs\n");
-	  tmp1 = pop ();
-	  if (tmp1 & ((unw_word_t) 1 << (8 * dwarf_addr_size (as) - 1)))
-	    tmp1 = -tmp1;
-	  push (tmp1);
-	  break;
-
-	case DW_OP_and:
-	  Debug (15, "OP_and\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (tmp1 & tmp2);
-	  break;
-
-	case DW_OP_div:
-	  Debug (15, "OP_div\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  if (tmp1)
-	    tmp1 = sword (as, tmp2) / sword (as, tmp1);
-	  push (tmp1);
-	  break;
-
-	case DW_OP_minus:
-	  Debug (15, "OP_minus\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  tmp1 = tmp2 - tmp1;
-	  push (tmp1);
-	  break;
-
-	case DW_OP_mod:
-	  Debug (15, "OP_mod\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  if (tmp1)
-	    tmp1 = tmp2 % tmp1;
-	  push (tmp1);
-	  break;
-
-	case DW_OP_mul:
-	  Debug (15, "OP_mul\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  if (tmp1)
-	    tmp1 = tmp2 * tmp1;
-	  push (tmp1);
-	  break;
-
-	case DW_OP_neg:
-	  Debug (15, "OP_neg\n");
-	  push (-pop ());
-	  break;
-
-	case DW_OP_not:
-	  Debug (15, "OP_not\n");
-	  push (~pop ());
-	  break;
-
-	case DW_OP_or:
-	  Debug (15, "OP_or\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (tmp1 | tmp2);
-	  break;
-
-	case DW_OP_plus:
-	  Debug (15, "OP_plus\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (tmp1 + tmp2);
-	  break;
-
-	case DW_OP_plus_uconst:
-	  Debug (15, "OP_plus_uconst(%lu)\n", (unsigned long) operand1);
-	  tmp1 = pop ();
-	  push (tmp1 + operand1);
-	  break;
-
-	case DW_OP_shl:
-	  Debug (15, "OP_shl\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (tmp2 << tmp1);
-	  break;
-
-	case DW_OP_shr:
-	  Debug (15, "OP_shr\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (tmp2 >> tmp1);
-	  break;
-
-	case DW_OP_shra:
-	  Debug (15, "OP_shra\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (sword (as, tmp2) >> tmp1);
-	  break;
-
-	case DW_OP_xor:
-	  Debug (15, "OP_xor\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (tmp1 ^ tmp2);
-	  break;
-
-	case DW_OP_le:
-	  Debug (15, "OP_le\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (sword (as, tmp1) <= sword (as, tmp2));
-	  break;
-
-	case DW_OP_ge:
-	  Debug (15, "OP_ge\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (sword (as, tmp1) >= sword (as, tmp2));
-	  break;
-
-	case DW_OP_eq:
-	  Debug (15, "OP_eq\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (sword (as, tmp1) == sword (as, tmp2));
-	  break;
-
-	case DW_OP_lt:
-	  Debug (15, "OP_lt\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (sword (as, tmp1) < sword (as, tmp2));
-	  break;
-
-	case DW_OP_gt:
-	  Debug (15, "OP_gt\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (sword (as, tmp1) > sword (as, tmp2));
-	  break;
-
-	case DW_OP_ne:
-	  Debug (15, "OP_ne\n");
-	  tmp1 = pop ();
-	  tmp2 = pop ();
-	  push (sword (as, tmp1) != sword (as, tmp2));
-	  break;
-
-	case DW_OP_skip:
-	  Debug (15, "OP_skip(%d)\n", (int16_t) operand1);
-	  *addr += (int16_t) operand1;
-	  break;
-
-	case DW_OP_bra:
-	  Debug (15, "OP_skip(%d)\n", (int16_t) operand1);
-	  tmp1 = pop ();
-	  if (tmp1)
-	    *addr += (int16_t) operand1;
-	  break;
-
-	case DW_OP_nop:
-	  Debug (15, "OP_nop\n");
-	  break;
-
-	case DW_OP_call2:
-	case DW_OP_call4:
-	case DW_OP_call_ref:
-	case DW_OP_fbreg:
-	case DW_OP_piece:
-	case DW_OP_push_object_address:
-	case DW_OP_xderef:
-	case DW_OP_xderef_size:
-	default:
-	  Debug (1, "Unexpected opcode 0x%x\n", opcode);
-	  return -UNW_EINVAL;
-	}
+        {
+        case DW_OP_lit0:  case DW_OP_lit1:  case DW_OP_lit2:
+        case DW_OP_lit3:  case DW_OP_lit4:  case DW_OP_lit5:
+        case DW_OP_lit6:  case DW_OP_lit7:  case DW_OP_lit8:
+        case DW_OP_lit9:  case DW_OP_lit10: case DW_OP_lit11:
+        case DW_OP_lit12: case DW_OP_lit13: case DW_OP_lit14:
+        case DW_OP_lit15: case DW_OP_lit16: case DW_OP_lit17:
+        case DW_OP_lit18: case DW_OP_lit19: case DW_OP_lit20:
+        case DW_OP_lit21: case DW_OP_lit22: case DW_OP_lit23:
+        case DW_OP_lit24: case DW_OP_lit25: case DW_OP_lit26:
+        case DW_OP_lit27: case DW_OP_lit28: case DW_OP_lit29:
+        case DW_OP_lit30: case DW_OP_lit31:
+          Debug (15, "OP_lit(%d)\n", (int) opcode - DW_OP_lit0);
+          push (opcode - DW_OP_lit0);
+          break;
+
+        case DW_OP_breg0:  case DW_OP_breg1:  case DW_OP_breg2:
+        case DW_OP_breg3:  case DW_OP_breg4:  case DW_OP_breg5:
+        case DW_OP_breg6:  case DW_OP_breg7:  case DW_OP_breg8:
+        case DW_OP_breg9:  case DW_OP_breg10: case DW_OP_breg11:
+        case DW_OP_breg12: case DW_OP_breg13: case DW_OP_breg14:
+        case DW_OP_breg15: case DW_OP_breg16: case DW_OP_breg17:
+        case DW_OP_breg18: case DW_OP_breg19: case DW_OP_breg20:
+        case DW_OP_breg21: case DW_OP_breg22: case DW_OP_breg23:
+        case DW_OP_breg24: case DW_OP_breg25: case DW_OP_breg26:
+        case DW_OP_breg27: case DW_OP_breg28: case DW_OP_breg29:
+        case DW_OP_breg30: case DW_OP_breg31:
+          Debug (15, "OP_breg(r%d,0x%lx)\n",
+                 (int) opcode - DW_OP_breg0, (unsigned long) operand1);
+          if ((ret = unw_get_reg (dwarf_to_cursor (c),
+                                  dwarf_to_unw_regnum (opcode - DW_OP_breg0),
+                                  &tmp1)) < 0)
+            return ret;
+          push (tmp1 + operand1);
+          break;
+
+        case DW_OP_bregx:
+          Debug (15, "OP_bregx(r%d,0x%lx)\n",
+                 (int) operand1, (unsigned long) operand2);
+          if ((ret = unw_get_reg (dwarf_to_cursor (c),
+                                  dwarf_to_unw_regnum (operand1), &tmp1)) < 0)
+            return ret;
+          push (tmp1 + operand2);
+          break;
+
+        case DW_OP_reg0:  case DW_OP_reg1:  case DW_OP_reg2:
+        case DW_OP_reg3:  case DW_OP_reg4:  case DW_OP_reg5:
+        case DW_OP_reg6:  case DW_OP_reg7:  case DW_OP_reg8:
+        case DW_OP_reg9:  case DW_OP_reg10: case DW_OP_reg11:
+        case DW_OP_reg12: case DW_OP_reg13: case DW_OP_reg14:
+        case DW_OP_reg15: case DW_OP_reg16: case DW_OP_reg17:
+        case DW_OP_reg18: case DW_OP_reg19: case DW_OP_reg20:
+        case DW_OP_reg21: case DW_OP_reg22: case DW_OP_reg23:
+        case DW_OP_reg24: case DW_OP_reg25: case DW_OP_reg26:
+        case DW_OP_reg27: case DW_OP_reg28: case DW_OP_reg29:
+        case DW_OP_reg30: case DW_OP_reg31:
+          Debug (15, "OP_reg(r%d)\n", (int) opcode - DW_OP_reg0);
+          *valp = dwarf_to_unw_regnum (opcode - DW_OP_reg0);
+          *is_register = 1;
+          return 0;
+
+        case DW_OP_regx:
+          Debug (15, "OP_regx(r%d)\n", (int) operand1);
+          *valp = dwarf_to_unw_regnum (operand1);
+          *is_register = 1;
+          return 0;
+
+        case DW_OP_addr:
+        case DW_OP_const1u:
+        case DW_OP_const2u:
+        case DW_OP_const4u:
+        case DW_OP_const8u:
+        case DW_OP_constu:
+        case DW_OP_const8s:
+        case DW_OP_consts:
+          Debug (15, "OP_const(0x%lx)\n", (unsigned long) operand1);
+          push (operand1);
+          break;
+
+        case DW_OP_const1s:
+          if (operand1 & 0x80)
+            operand1 |= ((unw_word_t) -1) << 8;
+          Debug (15, "OP_const1s(%ld)\n", (long) operand1);
+          push (operand1);
+          break;
+
+        case DW_OP_const2s:
+          if (operand1 & 0x8000)
+            operand1 |= ((unw_word_t) -1) << 16;
+          Debug (15, "OP_const2s(%ld)\n", (long) operand1);
+          push (operand1);
+          break;
+
+        case DW_OP_const4s:
+          if (operand1 & 0x80000000)
+            operand1 |= (((unw_word_t) -1) << 16) << 16;
+          Debug (15, "OP_const4s(%ld)\n", (long) operand1);
+          push (operand1);
+          break;
+
+        case DW_OP_deref:
+          Debug (15, "OP_deref\n");
+          tmp1 = pop ();
+          if ((ret = dwarf_readw (as, a, &tmp1, &tmp2, arg)) < 0)
+            return ret;
+          push (tmp2);
+          break;
+
+        case DW_OP_deref_size:
+          Debug (15, "OP_deref_size(%d)\n", (int) operand1);
+          tmp1 = pop ();
+          switch (operand1)
+            {
+            default:
+              Debug (1, "Unexpected DW_OP_deref_size size %d\n",
+                     (int) operand1);
+              return -UNW_EINVAL;
+
+            case 1:
+              if ((ret = dwarf_readu8 (as, a, &tmp1, &u8, arg)) < 0)
+                return ret;
+              tmp2 = u8;
+              break;
+
+            case 2:
+              if ((ret = dwarf_readu16 (as, a, &tmp1, &u16, arg)) < 0)
+                return ret;
+              tmp2 = u16;
+              break;
+
+            case 3:
+            case 4:
+              if ((ret = dwarf_readu32 (as, a, &tmp1, &u32, arg)) < 0)
+                return ret;
+              tmp2 = u32;
+              if (operand1 == 3)
+                {
+                  if (dwarf_is_big_endian (as))
+                    tmp2 >>= 8;
+                  else
+                    tmp2 &= 0xffffff;
+                }
+              break;
+            case 5:
+            case 6:
+            case 7:
+            case 8:
+              if ((ret = dwarf_readu64 (as, a, &tmp1, &u64, arg)) < 0)
+                return ret;
+              tmp2 = u64;
+              if (operand1 != 8)
+                {
+                  if (dwarf_is_big_endian (as))
+                    tmp2 >>= 64 - 8 * operand1;
+                  else
+                    tmp2 &= (~ (unw_word_t) 0) << (8 * operand1);
+                }
+              break;
+            }
+          push (tmp2);
+          break;
+
+        case DW_OP_dup:
+          Debug (15, "OP_dup\n");
+          push (pick (0));
+          break;
+
+        case DW_OP_drop:
+          Debug (15, "OP_drop\n");
+          (void) pop ();
+          break;
+
+        case DW_OP_pick:
+          Debug (15, "OP_pick(%d)\n", (int) operand1);
+          push (pick (operand1));
+          break;
+
+        case DW_OP_over:
+          Debug (15, "OP_over\n");
+          push (pick (1));
+          break;
+
+        case DW_OP_swap:
+          Debug (15, "OP_swap\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (tmp1);
+          push (tmp2);
+          break;
+
+        case DW_OP_rot:
+          Debug (15, "OP_rot\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          tmp3 = pop ();
+          push (tmp1);
+          push (tmp3);
+          push (tmp2);
+          break;
+
+        case DW_OP_abs:
+          Debug (15, "OP_abs\n");
+          tmp1 = pop ();
+          if (tmp1 & ((unw_word_t) 1 << (8 * dwarf_addr_size (as) - 1)))
+            tmp1 = -tmp1;
+          push (tmp1);
+          break;
+
+        case DW_OP_and:
+          Debug (15, "OP_and\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (tmp1 & tmp2);
+          break;
+
+        case DW_OP_div:
+          Debug (15, "OP_div\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          if (tmp1)
+            tmp1 = sword (as, tmp2) / sword (as, tmp1);
+          push (tmp1);
+          break;
+
+        case DW_OP_minus:
+          Debug (15, "OP_minus\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          tmp1 = tmp2 - tmp1;
+          push (tmp1);
+          break;
+
+        case DW_OP_mod:
+          Debug (15, "OP_mod\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          if (tmp1)
+            tmp1 = tmp2 % tmp1;
+          push (tmp1);
+          break;
+
+        case DW_OP_mul:
+          Debug (15, "OP_mul\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          if (tmp1)
+            tmp1 = tmp2 * tmp1;
+          push (tmp1);
+          break;
+
+        case DW_OP_neg:
+          Debug (15, "OP_neg\n");
+          push (-pop ());
+          break;
+
+        case DW_OP_not:
+          Debug (15, "OP_not\n");
+          push (~pop ());
+          break;
+
+        case DW_OP_or:
+          Debug (15, "OP_or\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (tmp1 | tmp2);
+          break;
+
+        case DW_OP_plus:
+          Debug (15, "OP_plus\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (tmp1 + tmp2);
+          break;
+
+        case DW_OP_plus_uconst:
+          Debug (15, "OP_plus_uconst(%lu)\n", (unsigned long) operand1);
+          tmp1 = pop ();
+          push (tmp1 + operand1);
+          break;
+
+        case DW_OP_shl:
+          Debug (15, "OP_shl\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (tmp2 << tmp1);
+          break;
+
+        case DW_OP_shr:
+          Debug (15, "OP_shr\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (tmp2 >> tmp1);
+          break;
+
+        case DW_OP_shra:
+          Debug (15, "OP_shra\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (sword (as, tmp2) >> tmp1);
+          break;
+
+        case DW_OP_xor:
+          Debug (15, "OP_xor\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (tmp1 ^ tmp2);
+          break;
+
+        case DW_OP_le:
+          Debug (15, "OP_le\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (sword (as, tmp2) <= sword (as, tmp1));
+          break;
+
+        case DW_OP_ge:
+          Debug (15, "OP_ge\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (sword (as, tmp2) >= sword (as, tmp1));
+          break;
+
+        case DW_OP_eq:
+          Debug (15, "OP_eq\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (sword (as, tmp2) == sword (as, tmp1));
+          break;
+
+        case DW_OP_lt:
+          Debug (15, "OP_lt\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (sword (as, tmp2) < sword (as, tmp1));
+          break;
+
+        case DW_OP_gt:
+          Debug (15, "OP_gt\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (sword (as, tmp2) > sword (as, tmp1));
+          break;
+
+        case DW_OP_ne:
+          Debug (15, "OP_ne\n");
+          tmp1 = pop ();
+          tmp2 = pop ();
+          push (sword (as, tmp2) != sword (as, tmp1));
+          break;
+
+        case DW_OP_skip:
+          Debug (15, "OP_skip(%d)\n", (int16_t) operand1);
+          *addr += (int16_t) operand1;
+          break;
+
+        case DW_OP_bra:
+          Debug (15, "OP_skip(%d)\n", (int16_t) operand1);
+          tmp1 = pop ();
+          if (tmp1)
+            *addr += (int16_t) operand1;
+          break;
+
+        case DW_OP_nop:
+          Debug (15, "OP_nop\n");
+          break;
+
+        case DW_OP_call2:
+        case DW_OP_call4:
+        case DW_OP_call_ref:
+        case DW_OP_fbreg:
+        case DW_OP_piece:
+        case DW_OP_push_object_address:
+        case DW_OP_xderef:
+        case DW_OP_xderef_size:
+        default:
+          Debug (1, "Unexpected opcode 0x%x\n", opcode);
+          return -UNW_EINVAL;
+        }
     }
   *valp = pop ();
   Debug (14, "final value = 0x%lx\n", (unsigned long) *valp);
diff --git a/src/dwarf/Gfde.c b/src/dwarf/Gfde.c
index 8659624..9250b89 100644
--- a/src/dwarf/Gfde.c
+++ b/src/dwarf/Gfde.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -32,7 +32,7 @@ is_cie_id (unw_word_t val, int is_debug_frame)
      0xffffffffffffffff (for 64-bit ELF).  However, .eh_frame
      uses 0.  */
   if (is_debug_frame)
-    return (val == - (uint32_t) 1 || val == - (uint64_t) 1);
+      return (val == (uint32_t)(-1) || val == (uint64_t)(-1));
   else
     return (val == 0);
 }
@@ -44,8 +44,8 @@ is_cie_id (unw_word_t val, int is_debug_frame)
    repeated.  */
 static inline int
 parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
-	   const unw_proc_info_t *pi, struct dwarf_cie_info *dci,
-	   unw_word_t base, void *arg)
+           const unw_proc_info_t *pi, struct dwarf_cie_info *dci,
+           int is_debug_frame, void *arg)
 {
   uint8_t version, ch, augstr[5], fde_encoding, handler_encoding;
   unw_word_t len, cie_end_addr, aug_size;
@@ -53,8 +53,8 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
   uint64_t u64val;
   size_t i;
   int ret;
-# define STR2(x)	#x
-# define STR(x)		STR2(x)
+# define STR2(x)        #x
+# define STR(x)         STR2(x)
 
   /* Pick appropriate default for FDE-encoding.  DWARF spec says
      start-IP (initial_location) and the code-size (address_range) are
@@ -63,9 +63,9 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
      for fde_encoding.  */
   switch (dwarf_addr_size (as))
     {
-    case 4:	fde_encoding = DW_EH_PE_udata4; break;
-    case 8:	fde_encoding = DW_EH_PE_udata8; break;
-    default:	fde_encoding = DW_EH_PE_omit; break;
+    case 4:     fde_encoding = DW_EH_PE_udata4; break;
+    case 8:     fde_encoding = DW_EH_PE_udata8; break;
+    default:    fde_encoding = DW_EH_PE_omit; break;
     }
 
   dci->lsda_encoding = DW_EH_PE_omit;
@@ -79,47 +79,48 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
       /* the CIE is in the 32-bit DWARF format */
       uint32_t cie_id;
       /* DWARF says CIE id should be 0xffffffff, but in .eh_frame, it's 0 */
-      const uint32_t expected_id = (base) ? 0xffffffff : 0;
+      const uint32_t expected_id = (is_debug_frame) ? 0xffffffff : 0;
 
       len = u32val;
       cie_end_addr = addr + len;
       if ((ret = dwarf_readu32 (as, a, &addr, &cie_id, arg)) < 0)
-	return ret;
+        return ret;
       if (cie_id != expected_id)
-	{
-	  Debug (1, "Unexpected CIE id %x\n", cie_id);
-	  return -UNW_EINVAL;
-	}
+        {
+          Debug (1, "Unexpected CIE id %x\n", cie_id);
+          return -UNW_EINVAL;
+        }
     }
   else
     {
       /* the CIE is in the 64-bit DWARF format */
       uint64_t cie_id;
       /* DWARF says CIE id should be 0xffffffffffffffff, but in
-	 .eh_frame, it's 0 */
-      const uint64_t expected_id = (base) ? 0xffffffffffffffffull : 0;
+         .eh_frame, it's 0 */
+      const uint64_t expected_id = (is_debug_frame) ? 0xffffffffffffffffull : 0;
 
       if ((ret = dwarf_readu64 (as, a, &addr, &u64val, arg)) < 0)
-	return ret;
+        return ret;
       len = u64val;
       cie_end_addr = addr + len;
       if ((ret = dwarf_readu64 (as, a, &addr, &cie_id, arg)) < 0)
-	return ret;
+        return ret;
       if (cie_id != expected_id)
-	{
-	  Debug (1, "Unexpected CIE id %llx\n", (long long) cie_id);
-	  return -UNW_EINVAL;
-	}
+        {
+          Debug (1, "Unexpected CIE id %llx\n", (long long) cie_id);
+          return -UNW_EINVAL;
+        }
     }
   dci->cie_instr_end = cie_end_addr;
 
   if ((ret = dwarf_readu8 (as, a, &addr, &version, arg)) < 0)
     return ret;
 
-  if (version != 1 && version != DWARF_CIE_VERSION)
+  /* GCC emits version 1??? */
+  if (version != 1 && (version < DWARF_CIE_VERSION || version > DWARF_CIE_VERSION_MAX))
     {
-      Debug (1, "Got CIE version %u, expected version 1 or "
-	     STR (DWARF_CIE_VERSION) "\n", version);
+      Debug (1, "Got CIE version %u, expected version 1 or between "
+             STR (DWARF_CIE_VERSION) " and " STR (DWARF_CIE_VERSION_MAX) "\n", version);
       return -UNW_EBADVERSION;
     }
 
@@ -128,13 +129,13 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
   for (i = 0;;)
     {
       if ((ret = dwarf_readu8 (as, a, &addr, &ch, arg)) < 0)
-	return ret;
+        return ret;
 
       if (!ch)
-	break;	/* end of augmentation string */
+        break;  /* end of augmentation string */
 
       if (i < sizeof (augstr) - 1)
-	augstr[i++] = ch;
+        augstr[i++] = ch;
     }
 
   if ((ret = dwarf_read_uleb128 (as, a, &addr, &dci->code_align, arg)) < 0
@@ -145,11 +146,11 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
   if (version == 1)
     {
       if ((ret = dwarf_readu8 (as, a, &addr, &ch, arg)) < 0)
-	return ret;
+        return ret;
       dci->ret_addr_column = ch;
     }
   else if ((ret = dwarf_read_uleb128 (as, a, &addr, &dci->ret_addr_column,
-				      arg)) < 0)
+                                      arg)) < 0)
     return ret;
 
   i = 0;
@@ -157,7 +158,7 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
     {
       dci->sized_augmentation = 1;
       if ((ret = dwarf_read_uleb128 (as, a, &addr, &aug_size, arg)) < 0)
-	return ret;
+        return ret;
       i++;
     }
 
@@ -165,50 +166,50 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
     switch (augstr[i])
       {
       case 'L':
-	/* read the LSDA pointer-encoding format.  */
-	if ((ret = dwarf_readu8 (as, a, &addr, &ch, arg)) < 0)
-	  return ret;
-	dci->lsda_encoding = ch;
-	break;
+        /* read the LSDA pointer-encoding format.  */
+        if ((ret = dwarf_readu8 (as, a, &addr, &ch, arg)) < 0)
+          return ret;
+        dci->lsda_encoding = ch;
+        break;
 
       case 'R':
-	/* read the FDE pointer-encoding format.  */
-	if ((ret = dwarf_readu8 (as, a, &addr, &fde_encoding, arg)) < 0)
-	  return ret;
-	break;
+        /* read the FDE pointer-encoding format.  */
+        if ((ret = dwarf_readu8 (as, a, &addr, &fde_encoding, arg)) < 0)
+          return ret;
+        break;
 
       case 'P':
-	/* read the personality-routine pointer-encoding format.  */
-	if ((ret = dwarf_readu8 (as, a, &addr, &handler_encoding, arg)) < 0)
-	  return ret;
-	if ((ret = dwarf_read_encoded_pointer (as, a, &addr, handler_encoding,
-					       pi, &dci->handler, arg)) < 0)
-	  return ret;
-	break;
+        /* read the personality-routine pointer-encoding format.  */
+        if ((ret = dwarf_readu8 (as, a, &addr, &handler_encoding, arg)) < 0)
+          return ret;
+        if ((ret = dwarf_read_encoded_pointer (as, a, &addr, handler_encoding,
+                                               pi, &dci->handler, arg)) < 0)
+          return ret;
+        break;
 
       case 'S':
-	/* This is a signal frame. */
-	dci->signal_frame = 1;
+        /* This is a signal frame. */
+        dci->signal_frame = 1;
 
-	/* Temporarily set it to one so dwarf_parse_fde() knows that
-	   it should fetch the actual ABI/TAG pair from the FDE.  */
-	dci->have_abi_marker = 1;
-	break;
+        /* Temporarily set it to one so dwarf_parse_fde() knows that
+           it should fetch the actual ABI/TAG pair from the FDE.  */
+        dci->have_abi_marker = 1;
+        break;
 
       default:
-	Debug (1, "Unexpected augmentation string `%s'\n", augstr);
-	if (dci->sized_augmentation)
-	  /* If we have the size of the augmentation body, we can skip
-	     over the parts that we don't understand, so we're OK. */
-	  goto done;
-	else
-	  return -UNW_EINVAL;
+        Debug (1, "Unexpected augmentation string `%s'\n", augstr);
+        if (dci->sized_augmentation)
+          /* If we have the size of the augmentation body, we can skip
+             over the parts that we don't understand, so we're OK. */
+          goto done;
+        else
+          return -UNW_EINVAL;
       }
  done:
   dci->fde_encoding = fde_encoding;
   dci->cie_instr_start = addr;
   Debug (15, "CIE parsed OK, augmentation = \"%s\", handler=0x%lx\n",
-	 augstr, (long) dci->handler);
+         augstr, (long) dci->handler);
   return 0;
 }
 
@@ -219,9 +220,10 @@ parse_cie (unw_addr_space_t as, unw_accessors_t *a, unw_word_t addr,
 
 HIDDEN int
 dwarf_extract_proc_info_from_fde (unw_addr_space_t as, unw_accessors_t *a,
-				  unw_word_t *addrp, unw_proc_info_t *pi,
-				  int need_unwind_info, unw_word_t base,
-				  void *arg)
+                                  unw_word_t *addrp, unw_proc_info_t *pi,
+                                  unw_word_t base,
+                                  int need_unwind_info, int is_debug_frame,
+                                  void *arg)
 {
   unw_word_t fde_end_addr, cie_addr, cie_offset_addr, aug_end_addr = 0;
   unw_word_t start_ip, ip_range, aug_size, addr = *addrp;
@@ -239,12 +241,12 @@ dwarf_extract_proc_info_from_fde (unw_addr_space_t as, unw_accessors_t *a,
 
   if (u32val != 0xffffffff)
     {
-      int32_t cie_offset;
+      int32_t cie_offset = 0;
 
       /* In some configurations, an FDE with a 0 length indicates the
-	 end of the FDE-table.  */
+         end of the FDE-table.  */
       if (u32val == 0)
-	return -UNW_ENOINFO;
+        return -UNW_ENOINFO;
 
       /* the FDE is in the 32-bit DWARF format */
 
@@ -252,53 +254,53 @@ dwarf_extract_proc_info_from_fde (unw_addr_space_t as, unw_accessors_t *a,
       cie_offset_addr = addr;
 
       if ((ret = dwarf_reads32 (as, a, &addr, &cie_offset, arg)) < 0)
-	return ret;
+        return ret;
 
-      if (is_cie_id (cie_offset, base != 0))
-	/* ignore CIEs (happens during linear searches) */
-	return 0;
+      if (is_cie_id (cie_offset, is_debug_frame))
+        /* ignore CIEs (happens during linear searches) */
+        return 0;
 
-      if (base != 0)
+      if (is_debug_frame)
         cie_addr = base + cie_offset;
       else
-	/* DWARF says that the CIE_pointer in the FDE is a
-	   .debug_frame-relative offset, but the GCC-generated .eh_frame
-	   sections instead store a "pcrelative" offset, which is just
-	   as fine as it's self-contained.  */
-	cie_addr = cie_offset_addr - cie_offset;
+        /* DWARF says that the CIE_pointer in the FDE is a
+           .debug_frame-relative offset, but the GCC-generated .eh_frame
+           sections instead store a "pcrelative" offset, which is just
+           as fine as it's self-contained.  */
+        cie_addr = cie_offset_addr - cie_offset;
     }
   else
     {
-      int64_t cie_offset;
+      int64_t cie_offset = 0;
 
       /* the FDE is in the 64-bit DWARF format */
 
       if ((ret = dwarf_readu64 (as, a, &addr, &u64val, arg)) < 0)
-	return ret;
+        return ret;
 
       *addrp = fde_end_addr = addr + u64val;
       cie_offset_addr = addr;
 
       if ((ret = dwarf_reads64 (as, a, &addr, &cie_offset, arg)) < 0)
-	return ret;
+        return ret;
 
-      if (is_cie_id (cie_offset, base != 0))
-	/* ignore CIEs (happens during linear searches) */
-	return 0;
+      if (is_cie_id (cie_offset, is_debug_frame))
+        /* ignore CIEs (happens during linear searches) */
+        return 0;
 
-      if (base != 0)
-	cie_addr = base + cie_offset;
+      if (is_debug_frame)
+        cie_addr = base + cie_offset;
       else
-	/* DWARF says that the CIE_pointer in the FDE is a
-	   .debug_frame-relative offset, but the GCC-generated .eh_frame
-	   sections instead store a "pcrelative" offset, which is just
-	   as fine as it's self-contained.  */
-	cie_addr = (unw_word_t) ((uint64_t) cie_offset_addr - cie_offset);
+        /* DWARF says that the CIE_pointer in the FDE is a
+           .debug_frame-relative offset, but the GCC-generated .eh_frame
+           sections instead store a "pcrelative" offset, which is just
+           as fine as it's self-contained.  */
+        cie_addr = (unw_word_t) ((uint64_t) cie_offset_addr - cie_offset);
     }
 
   Debug (15, "looking for CIE at address %lx\n", (long) cie_addr);
 
-  if ((ret = parse_cie (as, a, cie_addr, pi, &dci, base, arg)) < 0)
+  if ((ret = parse_cie (as, a, cie_addr, pi, &dci, is_debug_frame, arg)) < 0)
     return ret;
 
   /* IP-range has same encoding as FDE pointers, except that it's
@@ -306,9 +308,9 @@ dwarf_extract_proc_info_from_fde (unw_addr_space_t as, unw_accessors_t *a,
   ip_range_encoding = dci.fde_encoding & DW_EH_PE_FORMAT_MASK;
 
   if ((ret = dwarf_read_encoded_pointer (as, a, &addr, dci.fde_encoding,
-					 pi, &start_ip, arg)) < 0
+                                         pi, &start_ip, arg)) < 0
       || (ret = dwarf_read_encoded_pointer (as, a, &addr, ip_range_encoding,
-					    pi, &ip_range, arg)) < 0)
+                                            pi, &ip_range, arg)) < 0)
     return ret;
   pi->start_ip = start_ip;
   pi->end_ip = start_ip + ip_range;
@@ -317,16 +319,16 @@ dwarf_extract_proc_info_from_fde (unw_addr_space_t as, unw_accessors_t *a,
   if (dci.sized_augmentation)
     {
       if ((ret = dwarf_read_uleb128 (as, a, &addr, &aug_size, arg)) < 0)
-	return ret;
+        return ret;
       aug_end_addr = addr + aug_size;
     }
 
   if ((ret = dwarf_read_encoded_pointer (as, a, &addr, dci.lsda_encoding,
-					 pi, &pi->lsda, arg)) < 0)
+                                         pi, &pi->lsda, arg)) < 0)
     return ret;
 
   Debug (15, "FDE covers IP 0x%lx-0x%lx, LSDA=0x%lx\n",
-	 (long) pi->start_ip, (long) pi->end_ip, (long) pi->lsda);
+         (long) pi->start_ip, (long) pi->end_ip, (long) pi->lsda);
 
   if (need_unwind_info)
     {
@@ -334,21 +336,21 @@ dwarf_extract_proc_info_from_fde (unw_addr_space_t as, unw_accessors_t *a,
       pi->unwind_info_size = sizeof (dci);
       pi->unwind_info = mempool_alloc (&dwarf_cie_info_pool);
       if (!pi->unwind_info)
-	return -UNW_ENOMEM;
+        return -UNW_ENOMEM;
 
       if (dci.have_abi_marker)
-	{
-	  if ((ret = dwarf_readu16 (as, a, &addr, &dci.abi, arg)) < 0
-	      || (ret = dwarf_readu16 (as, a, &addr, &dci.tag, arg)) < 0)
-	    return ret;
-	  Debug (13, "Found ABI marker = (abi=%u, tag=%u)\n",
-		 dci.abi, dci.tag);
-	}
+        {
+          if ((ret = dwarf_readu16 (as, a, &addr, &dci.abi, arg)) < 0
+              || (ret = dwarf_readu16 (as, a, &addr, &dci.tag, arg)) < 0)
+            return ret;
+          Debug (13, "Found ABI marker = (abi=%u, tag=%u)\n",
+                 dci.abi, dci.tag);
+        }
 
       if (dci.sized_augmentation)
-	dci.fde_instr_start = aug_end_addr;
+        dci.fde_instr_start = aug_end_addr;
       else
-	dci.fde_instr_start = addr;
+        dci.fde_instr_start = addr;
       dci.fde_instr_end = fde_end_addr;
 
       memcpy (pi->unwind_info, &dci, sizeof (dci));
diff --git a/src/dwarf/Gfind_proc_info-lsb.c b/src/dwarf/Gfind_proc_info-lsb.c
index 975c969..a186f87 100644
--- a/src/dwarf/Gfind_proc_info-lsb.c
+++ b/src/dwarf/Gfind_proc_info-lsb.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -26,9 +26,6 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 /* Locate an FDE via the ELF data-structures defined by LSB v1.3
    (http://www.linuxbase.org/spec/).  */
 
-#ifndef UNW_REMOTE_ONLY
-#include <link.h>
-#endif /* !UNW_REMOTE_ONLY */
 #include <stddef.h>
 #include <stdio.h>
 #include <limits.h>
@@ -49,35 +46,43 @@ struct table_entry
 #include "os-linux.h"
 #endif
 
+static ALIAS(dwarf_search_unwind_table) int
+dwarf_search_unwind_table_int (unw_addr_space_t as,
+                               unw_word_t ip,
+                               unw_dyn_info_t *di,
+                               unw_proc_info_t *pi,
+                               int need_unwind_info, void *arg);
 static int
 linear_search (unw_addr_space_t as, unw_word_t ip,
-	       unw_word_t eh_frame_start, unw_word_t eh_frame_end,
-	       unw_word_t fde_count,
-	       unw_proc_info_t *pi, int need_unwind_info, void *arg)
+               unw_word_t eh_frame_start, unw_word_t eh_frame_end,
+               unw_word_t fde_count,
+               unw_proc_info_t *pi, int need_unwind_info, void *arg)
 {
-  unw_accessors_t *a = unw_get_accessors (unw_local_addr_space);
+  unw_accessors_t *a = unw_get_accessors_int (unw_local_addr_space);
   unw_word_t i = 0, fde_addr, addr = eh_frame_start;
   int ret;
 
   while (i++ < fde_count && addr < eh_frame_end)
     {
       fde_addr = addr;
-      if ((ret = dwarf_extract_proc_info_from_fde (as, a, &addr, pi, 0, 0, arg))
-	  < 0)
-	return ret;
+      if ((ret = dwarf_extract_proc_info_from_fde (as, a, &addr, pi,
+                                                   eh_frame_start,
+                                                   0, 0, arg)) < 0)
+        return ret;
 
       if (ip >= pi->start_ip && ip < pi->end_ip)
-	{
-	  if (!need_unwind_info)
-	    return 1;
-	  addr = fde_addr;
-	  if ((ret = dwarf_extract_proc_info_from_fde (as, a, &addr, pi,
-						       need_unwind_info, 0,
-						       arg))
-	      < 0)
-	    return ret;
-	  return 1;
-	}
+        {
+          if (!need_unwind_info)
+            return 1;
+          addr = fde_addr;
+          if ((ret = dwarf_extract_proc_info_from_fde (as, a, &addr, pi,
+                                                       eh_frame_start,
+                                                       need_unwind_info, 0,
+                                                       arg))
+              < 0)
+            return ret;
+          return 1;
+        }
     }
   return -UNW_ENOINFO;
 }
@@ -87,151 +92,42 @@ linear_search (unw_addr_space_t as, unw_word_t ip,
 /* Load .debug_frame section from FILE.  Allocates and returns space
    in *BUF, and sets *BUFSIZE to its size.  IS_LOCAL is 1 if using the
    local process, in which case we can search the system debug file
-   directory; 0 for other address spaces, in which case we do not; or
-   -1 for recursive calls following .gnu_debuglink.  Returns 0 on
-   success, 1 on error.  Succeeds even if the file contains no
-   .debug_frame.  */
+   directory; 0 for other address spaces, in which case we do
+   not. Returns 0 on success, 1 on error.  Succeeds even if the file
+   contains no .debug_frame.  */
 /* XXX: Could use mmap; but elf_map_image keeps tons mapped in.  */
 
 static int
 load_debug_frame (const char *file, char **buf, size_t *bufsize, int is_local)
 {
-  FILE *f;
-  Elf_W (Ehdr) ehdr;
-  Elf_W (Half) shstrndx;
-  Elf_W (Shdr) *sec_hdrs = NULL;
-  char *stringtab = NULL;
-  unsigned int i;
-  size_t linksize = 0;
-  char *linkbuf = NULL;
-  
-  *buf = NULL;
-  *bufsize = 0;
-  
-  f = fopen (file, "r");
-  
-  if (!f)
-    return 1;
-  
-  if (fread (&ehdr, sizeof (Elf_W (Ehdr)), 1, f) != 1)
-    goto file_error;
-  
-  shstrndx = ehdr.e_shstrndx;
-  
-  Debug (4, "opened file '%s'. Section header at offset %d\n",
-         file, (int) ehdr.e_shoff);
-
-  fseek (f, ehdr.e_shoff, SEEK_SET);
-  sec_hdrs = calloc (ehdr.e_shnum, sizeof (Elf_W (Shdr)));
-  if (fread (sec_hdrs, sizeof (Elf_W (Shdr)), ehdr.e_shnum, f) != ehdr.e_shnum)
-    goto file_error;
-  
-  Debug (4, "loading string table of size %zd\n",
-	   sec_hdrs[shstrndx].sh_size);
-  stringtab = malloc (sec_hdrs[shstrndx].sh_size);
-  fseek (f, sec_hdrs[shstrndx].sh_offset, SEEK_SET);
-  if (fread (stringtab, 1, sec_hdrs[shstrndx].sh_size, f) != sec_hdrs[shstrndx].sh_size)
-    goto file_error;
-  
-  for (i = 1; i < ehdr.e_shnum && *buf == NULL; i++)
-    {
-      char *secname = &stringtab[sec_hdrs[i].sh_name];
-
-      if (strcmp (secname, ".debug_frame") == 0)
-        {
-	  *bufsize = sec_hdrs[i].sh_size;
-	  *buf = malloc (*bufsize);
-
-	  fseek (f, sec_hdrs[i].sh_offset, SEEK_SET);
-	  if (fread (*buf, 1, *bufsize, f) != *bufsize)
-	    goto file_error;
-
-	  Debug (4, "read %zd bytes of .debug_frame from offset %zd\n",
-		 *bufsize, sec_hdrs[i].sh_offset);
-	}
-      else if (strcmp (secname, ".gnu_debuglink") == 0)
-	{
-	  linksize = sec_hdrs[i].sh_size;
-	  linkbuf = malloc (linksize);
-
-	  fseek (f, sec_hdrs[i].sh_offset, SEEK_SET);
-	  if (fread (linkbuf, 1, linksize, f) != linksize)
-	    goto file_error;
-
-	  Debug (4, "read %zd bytes of .gnu_debuglink from offset %zd\n",
-		 linksize, sec_hdrs[i].sh_offset);
-	}
-    }
+  struct elf_image ei;
+  Elf_W (Shdr) *shdr;
+  int ret;
 
-  free (stringtab);
-  free (sec_hdrs);
+  ei.image = NULL;
 
-  fclose (f);
+  ret = elf_w (load_debuglink) (file, &ei, is_local);
+  if (ret != 0)
+    return ret;
 
-  /* Ignore separate debug files which contain a .gnu_debuglink section. */
-  if (linkbuf && is_local == -1)
+  shdr = elf_w (find_section) (&ei, ".debug_frame");
+  if (!shdr ||
+      (shdr->sh_offset + shdr->sh_size > ei.size))
     {
-      free (linkbuf);
+      munmap(ei.image, ei.size);
       return 1;
     }
 
-  if (*buf == NULL && linkbuf != NULL && memchr (linkbuf, 0, linksize) != NULL)
-    {
-      char *newname, *basedir, *p;
-      static const char *debugdir = "/usr/lib/debug";
-      int ret;
+  *bufsize = shdr->sh_size;
+  GET_MEMORY(*buf, *bufsize);
 
-      /* XXX: Don't bother with the checksum; just search for the file.  */
-      basedir = malloc (strlen (file) + 1);
-      newname = malloc (strlen (linkbuf) + strlen (debugdir)
-			+ strlen (file) + 9);
+  memcpy(*buf, shdr->sh_offset + ei.image, *bufsize);
 
-      p = strrchr (file, '/');
-      if (p != NULL)
-	{
-	  memcpy (basedir, file, p - file);
-	  basedir[p - file] = '\0';
-	}
-      else
-	basedir[0] = 0;
-
-      strcpy (newname, basedir);
-      strcat (newname, "/");
-      strcat (newname, linkbuf);
-      ret = load_debug_frame (newname, buf, bufsize, -1);
-
-      if (ret == 1)
-	{
-	  strcpy (newname, basedir);
-	  strcat (newname, "/.debug/");
-	  strcat (newname, linkbuf);
-	  ret = load_debug_frame (newname, buf, bufsize, -1);
-	}
-
-      if (ret == 1 && is_local == 1)
-	{
-	  strcpy (newname, debugdir);
-	  strcat (newname, basedir);
-	  strcat (newname, "/");
-	  strcat (newname, linkbuf);
-	  ret = load_debug_frame (newname, buf, bufsize, -1);
-	}
-
-      free (basedir);
-      free (newname);
-    }
-  free (linkbuf);
+  Debug (4, "read %zd bytes of .debug_frame from offset %zd\n",
+	 *bufsize, shdr->sh_offset);
 
+  munmap(ei.image, ei.size);
   return 0;
-
-/* An error reading image file. Release resources and return error code */
-file_error:
-  free(stringtab);
-  free(sec_hdrs);
-  free(linkbuf);
-  fclose(f);
-
-  return 1;
 }
 
 /* Locate the binary which originated the contents of address ADDR. Return
@@ -247,18 +143,20 @@ find_binary_for_address (unw_word_t ip, char *name, size_t name_size)
   int pid = getpid ();
   unsigned long segbase, mapoff, hi;
 
-  maps_init (&mi, pid);
+  if (maps_init (&mi, pid) != 0)
+    return 1;
+
   while (maps_next (&mi, &segbase, &hi, &mapoff))
     if (ip >= segbase && ip < hi)
       {
-	size_t len = strlen (mi.path);
-
-	if (len + 1 <= name_size)
-	  {
-	    memcpy (name, mi.path, len + 1);
-	    found = 1;
-	  }
-	break;
+        size_t len = strlen (mi.path);
+
+        if (len + 1 <= name_size)
+          {
+            memcpy (name, mi.path, len + 1);
+            found = 1;
+          }
+        break;
       }
   maps_close (&mi);
   return !found;
@@ -272,7 +170,7 @@ find_binary_for_address (unw_word_t ip, char *name, size_t name_size)
 
 static struct unw_debug_frame_list *
 locate_debug_info (unw_addr_space_t as, unw_word_t addr, const char *dlname,
-		   unw_word_t start, unw_word_t end)
+                   unw_word_t start, unw_word_t end)
 {
   struct unw_debug_frame_list *w, *fdesc = 0;
   char path[PATH_MAX];
@@ -287,7 +185,7 @@ locate_debug_info (unw_addr_space_t as, unw_word_t addr, const char *dlname,
     {
       Debug (4, "checking %p: %lx-%lx\n", w, (long)w->start, (long)w->end);
       if (addr >= w->start && addr < w->end)
-	return w;
+        return w;
     }
 
   /* If the object name we receive is blank, there's still a chance of locating
@@ -298,19 +196,19 @@ locate_debug_info (unw_addr_space_t as, unw_word_t addr, const char *dlname,
       err = find_binary_for_address (addr, name, sizeof(path));
       if (err)
         {
-	  Debug (15, "tried to locate binary for 0x%" PRIx64 ", but no luck\n",
-		 (uint64_t) addr);
+          Debug (15, "tried to locate binary for 0x%" PRIx64 ", but no luck\n",
+                 (uint64_t) addr);
           return 0;
-	}
+        }
     }
   else
     name = (char*) dlname;
 
   err = load_debug_frame (name, &buf, &bufsize, as == unw_local_addr_space);
-  
+
   if (!err)
     {
-      fdesc = malloc (sizeof (struct unw_debug_frame_list));
+      GET_MEMORY(fdesc, sizeof (struct unw_debug_frame_list));
 
       fdesc->start = start;
       fdesc->end = end;
@@ -318,73 +216,138 @@ locate_debug_info (unw_addr_space_t as, unw_word_t addr, const char *dlname,
       fdesc->debug_frame_size = bufsize;
       fdesc->index = NULL;
       fdesc->next = as->debug_frames;
-      
+
       as->debug_frames = fdesc;
     }
-  
+
   return fdesc;
 }
 
-struct debug_frame_tab
-  {
-    struct table_entry *tab;
-    uint32_t length;
-    uint32_t size;
-  };
-
-static void
-debug_frame_tab_append (struct debug_frame_tab *tab,
-			unw_word_t fde_offset, unw_word_t start_ip)
+static size_t
+debug_frame_index_make (struct unw_debug_frame_list *fdesc)
 {
-  unsigned int length = tab->length;
+  unw_accessors_t *a = unw_get_accessors_int (unw_local_addr_space);
+  char *buf = fdesc->debug_frame;
+  size_t bufsize = fdesc->debug_frame_size;
+  unw_word_t addr = (unw_word_t) (uintptr_t) buf;
+  size_t count = 0;
 
-  if (length == tab->size)
+  while (addr < (unw_word_t) (uintptr_t) (buf + bufsize))
     {
-      tab->size *= 2;
-      tab->tab = realloc (tab->tab, sizeof (struct table_entry) * tab->size);
+      unw_word_t item_start = addr, item_end = 0;
+      uint32_t u32val = 0;
+      uint64_t cie_id = 0;
+      uint64_t id_for_cie;
+
+      dwarf_readu32 (unw_local_addr_space, a, &addr, &u32val, NULL);
+
+      if (u32val == 0)
+        break;
+
+      if (u32val != 0xffffffff)
+        {
+          uint32_t cie_id32 = 0;
+
+          item_end = addr + u32val;
+          dwarf_readu32 (unw_local_addr_space, a, &addr, &cie_id32, NULL);
+          cie_id = cie_id32;
+          id_for_cie = 0xffffffff;
+        }
+      else
+        {
+          uint64_t u64val = 0;
+
+          /* Extended length.  */
+          dwarf_readu64 (unw_local_addr_space, a, &addr, &u64val, NULL);
+          item_end = addr + u64val;
+
+          dwarf_readu64 (unw_local_addr_space, a, &addr, &cie_id, NULL);
+          id_for_cie = 0xffffffffffffffffull;
+        }
+
+      /*Debug (1, "CIE/FDE id = %.8x\n", (int) cie_id);*/
+
+      if (cie_id == id_for_cie)
+        {
+          ;
+          /*Debug (1, "Found CIE at %.8x.\n", item_start);*/
+        }
+      else
+        {
+          unw_word_t fde_addr = item_start;
+          unw_proc_info_t this_pi;
+          int err;
+
+          /*Debug (1, "Found FDE at %.8x\n", item_start);*/
+
+          err = dwarf_extract_proc_info_from_fde (unw_local_addr_space,
+                                                  a, &fde_addr,
+                                                  &this_pi,
+                                                  (uintptr_t) buf, 0, 1,
+                                                  NULL);
+
+          if (!err)
+            {
+              Debug (15, "start_ip = %lx, end_ip = %lx\n",
+                     (long) this_pi.start_ip, (long) this_pi.end_ip);
+
+              if (fdesc->index)
+                {
+                  struct table_entry *e = &fdesc->index[count];
+
+                  e->fde_offset = item_start - (unw_word_t) (uintptr_t) buf;
+                  e->start_ip_offset = this_pi.start_ip;
+                }
+
+              count++;
+            }
+        /*else
+            Debug (1, "FDE parse failed\n");*/
+        }
+
+      addr = item_end;
     }
-  
-  tab->tab[length].fde_offset = fde_offset;
-  tab->tab[length].start_ip_offset = start_ip;
-  
-  tab->length = length + 1;
+  return count;
 }
 
 static void
-debug_frame_tab_shrink (struct debug_frame_tab *tab)
+debug_frame_index_sort (struct unw_debug_frame_list *fdesc)
 {
-  if (tab->size > tab->length)
+  size_t i, j, k, n = fdesc->index_size / sizeof (*fdesc->index);
+  struct table_entry *a = fdesc->index;
+  struct table_entry t;
+
+  /* Use a simple Shell sort as it relatively fast and
+   * does not require additional memory. */
+
+  for (k = n / 2; k > 0; k /= 2)
     {
-      tab->tab = realloc (tab->tab, sizeof (struct table_entry) * tab->length);
-      tab->size = tab->length;
-    }
-}
+      for (i = k; i < n; i++)
+        {
+          t = a[i];
 
-static int
-debug_frame_tab_compare (const void *a, const void *b)
-{
-  const struct table_entry *fa = a, *fb = b;
-  
-  if (fa->start_ip_offset > fb->start_ip_offset)
-    return 1;
-  else if (fa->start_ip_offset < fb->start_ip_offset)
-    return -1;
-  else
-    return 0;
+          for (j = i; j >= k; j -= k)
+            {
+              if (t.start_ip_offset >= a[j - k].start_ip_offset)
+                break;
+
+              a[j] = a[j - k];
+            }
+
+          a[j] = t;
+        }
+    }
 }
 
-PROTECTED int
+int
 dwarf_find_debug_frame (int found, unw_dyn_info_t *di_debug, unw_word_t ip,
-			unw_word_t segbase, const char* obj_name,
-			unw_word_t start, unw_word_t end)
+                        unw_word_t segbase, const char* obj_name,
+                        unw_word_t start, unw_word_t end)
 {
-  unw_dyn_info_t *di;
-  struct unw_debug_frame_list *fdesc = 0;
-  unw_accessors_t *a;
-  unw_word_t addr;
+  unw_dyn_info_t *di = di_debug;
+  struct unw_debug_frame_list *fdesc;
 
   Debug (15, "Trying to find .debug_frame for %s\n", obj_name);
-  di = di_debug;
 
   fdesc = locate_debug_info (unw_local_addr_space, ip, obj_name, start, end);
 
@@ -393,130 +356,69 @@ dwarf_find_debug_frame (int found, unw_dyn_info_t *di_debug, unw_word_t ip,
       Debug (15, "couldn't load .debug_frame\n");
       return found;
     }
-  else
+
+  Debug (15, "loaded .debug_frame\n");
+
+  if (fdesc->debug_frame_size == 0)
     {
-      char *buf;
-      size_t bufsize;
-      unw_word_t item_start, item_end = 0;
-      uint32_t u32val = 0;
-      uint64_t cie_id = 0;
-      struct debug_frame_tab tab;
+      Debug (15, "zero-length .debug_frame\n");
+      return found;
+    }
 
-      Debug (15, "loaded .debug_frame\n");
+  /* Now create a binary-search table, if it does not already exist. */
 
-      buf = fdesc->debug_frame;
-      bufsize = fdesc->debug_frame_size;
+  if (!fdesc->index)
+    {
+      /* Find all FDE entries in debug_frame, and make into a sorted
+         index. First determine an index element count. */
 
-      if (bufsize == 0)
-       {
-         Debug (15, "zero-length .debug_frame\n");
-         return found;
-       }
+      size_t count = debug_frame_index_make (fdesc);
+
+      if (!count)
+        {
+          Debug (15, "no CIE/FDE found in .debug_frame\n");
+          return found;
+        }
+
+      fdesc->index_size = count * sizeof (*fdesc->index);
+      GET_MEMORY (fdesc->index, fdesc->index_size);
 
-      /* Now create a binary-search table, if it does not already exist.  */
       if (!fdesc->index)
-       {
-         addr = (unw_word_t) (uintptr_t) buf;
-
-         a = unw_get_accessors (unw_local_addr_space);
-
-         /* Find all FDE entries in debug_frame, and make into a sorted
-            index.  */
-
-         tab.length = 0;
-         tab.size = 16;
-         tab.tab = calloc (tab.size, sizeof (struct table_entry));
-
-         while (addr < (unw_word_t) (uintptr_t) (buf + bufsize))
-           {
-             uint64_t id_for_cie;
-             item_start = addr;
-
-             dwarf_readu32 (unw_local_addr_space, a, &addr, &u32val, NULL);
-
-             if (u32val == 0)
-               break;
-             else if (u32val != 0xffffffff)
-               {
-                 uint32_t cie_id32 = 0;
-                 item_end = addr + u32val;
-                 dwarf_readu32 (unw_local_addr_space, a, &addr, &cie_id32,
-                                NULL);
-                 cie_id = cie_id32;
-                 id_for_cie = 0xffffffff;
-               }
-             else
-               {
-                 uint64_t u64val = 0;
-                 /* Extended length.  */
-                 dwarf_readu64 (unw_local_addr_space, a, &addr, &u64val, NULL);
-                 item_end = addr + u64val;
-
-                 dwarf_readu64 (unw_local_addr_space, a, &addr, &cie_id, NULL);
-                 id_for_cie = 0xffffffffffffffffull;
-               }
-
-             /*Debug (1, "CIE/FDE id = %.8x\n", (int) cie_id);*/
-
-             if (cie_id == id_for_cie)
-               ;
-             /*Debug (1, "Found CIE at %.8x.\n", item_start);*/
-             else
-               {
-                 unw_word_t fde_addr = item_start;
-                 unw_proc_info_t this_pi;
-                 int err;
-
-                 /*Debug (1, "Found FDE at %.8x\n", item_start);*/
-
-                 err = dwarf_extract_proc_info_from_fde (unw_local_addr_space,
-                                                         a, &fde_addr,
-                                                         &this_pi, 0,
-                                                         (uintptr_t) buf,
-                                                         NULL);
-                 if (err == 0)
-                   {
-                     Debug (15, "start_ip = %lx, end_ip = %lx\n",
-                            (long) this_pi.start_ip, (long) this_pi.end_ip);
-                     debug_frame_tab_append (&tab,
-                                             item_start - (unw_word_t) (uintptr_t) buf,
-                                             this_pi.start_ip);
-                   }
-                 /*else
-                   Debug (1, "FDE parse failed\n");*/
-               }
-
-             addr = item_end;
-           }
-
-         debug_frame_tab_shrink (&tab);
-         qsort (tab.tab, tab.length, sizeof (struct table_entry),
-                debug_frame_tab_compare);
-         /* for (i = 0; i < tab.length; i++)
-            {
-            fprintf (stderr, "ip %x, fde offset %x\n",
-            (int) tab.tab[i].start_ip_offset,
-            (int) tab.tab[i].fde_offset);
-            }*/
-         fdesc->index = tab.tab;
-         fdesc->index_size = tab.length;
-       }
-
-      di->format = UNW_INFO_FORMAT_TABLE;
-      di->start_ip = fdesc->start;
-      di->end_ip = fdesc->end;
-      di->u.ti.name_ptr = (unw_word_t) (uintptr_t) obj_name;
-      di->u.ti.table_data = (unw_word_t *) fdesc;
-      di->u.ti.table_len = sizeof (*fdesc) / sizeof (unw_word_t);
-      di->u.ti.segbase = segbase;
-
-      found = 1;
-      Debug (15, "found debug_frame table `%s': segbase=0x%lx, len=%lu, "
-            "gp=0x%lx, table_data=0x%lx\n",
-            (char *) (uintptr_t) di->u.ti.name_ptr,
-            (long) di->u.ti.segbase, (long) di->u.ti.table_len,
-            (long) di->gp, (long) di->u.ti.table_data);
+        {
+          Debug (15, "couldn't allocate a frame index table\n");
+          fdesc->index_size = 0;
+          return found;
+        }
+
+      /* Then fill and sort the index. */
+
+      debug_frame_index_make (fdesc);
+      debug_frame_index_sort (fdesc);
+
+    /*for (i = 0; i < count; i++)
+        {
+          const struct table_entry *e = &fdesc->index[i];
+
+          Debug (15, "ip %x, FDE offset %x\n",
+                 e->start_ip_offset, e->fde_offset);
+        }*/
     }
+
+  di->format = UNW_INFO_FORMAT_TABLE;
+  di->start_ip = fdesc->start;
+  di->end_ip = fdesc->end;
+  di->u.ti.name_ptr = (unw_word_t) (uintptr_t) obj_name;
+  di->u.ti.table_data = (unw_word_t *) fdesc;
+  di->u.ti.table_len = sizeof (*fdesc) / sizeof (unw_word_t);
+  di->u.ti.segbase = segbase;
+
+  found = 1;
+  Debug (15, "found debug_frame table `%s': segbase=0x%lx, len=%lu, "
+         "gp=0x%lx, table_data=0x%lx\n",
+         (char *) (uintptr_t) di->u.ti.name_ptr,
+         (long) di->u.ti.segbase, (long) di->u.ti.table_len,
+         (long) di->gp, (long) di->u.ti.table_data);
+
   return found;
 }
 
@@ -524,6 +426,55 @@ dwarf_find_debug_frame (int found, unw_dyn_info_t *di_debug, unw_word_t ip,
 
 #ifndef UNW_REMOTE_ONLY
 
+static Elf_W (Addr)
+dwarf_find_eh_frame_section(struct dl_phdr_info *info)
+{
+  int rc;
+  struct elf_image ei;
+  Elf_W (Addr) eh_frame = 0;
+  Elf_W (Shdr)* shdr;
+  const char *file = info->dlpi_name;
+  char exepath[PATH_MAX];
+
+  if (strlen(file) == 0)
+    {
+      tdep_get_exe_image_path(exepath);
+      file = exepath;
+    }
+
+  Debug (1, "looking for .eh_frame section in %s\n",
+         file);
+
+  rc = elf_map_image (&ei, file);
+  if (rc != 0)
+    return 0;
+
+  shdr = elf_w (find_section) (&ei, ".eh_frame");
+  if (!shdr)
+    goto out;
+
+  eh_frame = shdr->sh_addr + info->dlpi_addr;
+  Debug (4, "found .eh_frame at address %lx\n",
+         eh_frame);
+
+out:
+  munmap (ei.image, ei.size);
+
+  return eh_frame;
+}
+
+struct dwarf_callback_data
+  {
+    /* in: */
+    unw_word_t ip;              /* instruction-pointer we're looking for */
+    unw_proc_info_t *pi;        /* proc-info pointer */
+    int need_unwind_info;
+    /* out: */
+    int single_fde;             /* did we find a single FDE? (vs. a table) */
+    unw_dyn_info_t di;          /* table info (if single_fde is false) */
+    unw_dyn_info_t di_debug;    /* additional table info for .debug_frame */
+  };
+
 /* ptr is a pointer to a dwarf_callback_data structure and, on entry,
    member ip contains the instruction-pointer we're looking
    for.  */
@@ -537,10 +488,11 @@ dwarf_callback (struct dl_phdr_info *info, size_t size, void *ptr)
   Elf_W(Addr) load_base, max_load_addr = 0;
   int ret, need_unwind_info = cb_data->need_unwind_info;
   unw_proc_info_t *pi = cb_data->pi;
-  struct dwarf_eh_frame_hdr *hdr;
+  struct dwarf_eh_frame_hdr *hdr = NULL;
   unw_accessors_t *a;
   long n;
   int found = 0;
+  struct dwarf_eh_frame_hdr synth_eh_frame_hdr;
 #ifdef CONFIG_DEBUG_FRAME
   unw_word_t start, end;
 #endif /* CONFIG_DEBUG_FRAME*/
@@ -549,11 +501,11 @@ dwarf_callback (struct dl_phdr_info *info, size_t size, void *ptr)
 
   /* Make sure struct dl_phdr_info is at least as big as we need.  */
   if (size < offsetof (struct dl_phdr_info, dlpi_phnum)
-	     + sizeof (info->dlpi_phnum))
+             + sizeof (info->dlpi_phnum))
     return -1;
 
   Debug (15, "checking %s, base=0x%lx)\n",
-	 info->dlpi_name, (long) info->dlpi_addr);
+         info->dlpi_name, (long) info->dlpi_addr);
 
   phdr = info->dlpi_phdr;
   load_base = info->dlpi_addr;
@@ -566,118 +518,144 @@ dwarf_callback (struct dl_phdr_info *info, size_t size, void *ptr)
   for (n = info->dlpi_phnum; --n >= 0; phdr++)
     {
       if (phdr->p_type == PT_LOAD)
-	{
-	  Elf_W(Addr) vaddr = phdr->p_vaddr + load_base;
+        {
+          Elf_W(Addr) vaddr = phdr->p_vaddr + load_base;
 
-	  if (ip >= vaddr && ip < vaddr + phdr->p_memsz)
-	    p_text = phdr;
+          if (ip >= vaddr && ip < vaddr + phdr->p_memsz)
+            p_text = phdr;
 
-	  if (vaddr + phdr->p_filesz > max_load_addr)
-	    max_load_addr = vaddr + phdr->p_filesz;
-	}
+          if (vaddr + phdr->p_filesz > max_load_addr)
+            max_load_addr = vaddr + phdr->p_filesz;
+        }
       else if (phdr->p_type == PT_GNU_EH_FRAME)
-	p_eh_hdr = phdr;
+        p_eh_hdr = phdr;
       else if (phdr->p_type == PT_DYNAMIC)
-	p_dynamic = phdr;
+        p_dynamic = phdr;
     }
-  
+
   if (!p_text)
     return 0;
 
   if (p_eh_hdr)
     {
+      hdr = (struct dwarf_eh_frame_hdr *) (p_eh_hdr->p_vaddr + load_base);
+    }
+  else
+    {
+      Elf_W (Addr) eh_frame;
+      Debug (1, "no .eh_frame_hdr section found\n");
+      eh_frame = dwarf_find_eh_frame_section (info);
+      if (eh_frame)
+        {
+          Debug (1, "using synthetic .eh_frame_hdr section for %s\n",
+                 info->dlpi_name);
+	  synth_eh_frame_hdr.version = DW_EH_VERSION;
+	  synth_eh_frame_hdr.eh_frame_ptr_enc = DW_EH_PE_absptr |
+	    ((sizeof(Elf_W (Addr)) == 4) ? DW_EH_PE_udata4 : DW_EH_PE_udata8);
+          synth_eh_frame_hdr.fde_count_enc = DW_EH_PE_omit;
+          synth_eh_frame_hdr.table_enc = DW_EH_PE_omit;
+	  synth_eh_frame_hdr.eh_frame = eh_frame;
+          hdr = &synth_eh_frame_hdr;
+        }
+    }
+
+  if (hdr)
+    {
       if (p_dynamic)
-	{
-	  /* For dynamicly linked executables and shared libraries,
-	     DT_PLTGOT is the value that data-relative addresses are
-	     relative to for that object.  We call this the "gp".  */
-	  Elf_W(Dyn) *dyn = (Elf_W(Dyn) *)(p_dynamic->p_vaddr + load_base);
-	  for (; dyn->d_tag != DT_NULL; ++dyn)
-	    if (dyn->d_tag == DT_PLTGOT)
-	      {
-		/* Assume that _DYNAMIC is writable and GLIBC has
-		   relocated it (true for x86 at least).  */
-		di->gp = dyn->d_un.d_ptr;
-		break;
-	      }
-	}
+        {
+          /* For dynamicly linked executables and shared libraries,
+             DT_PLTGOT is the value that data-relative addresses are
+             relative to for that object.  We call this the "gp".  */
+          Elf_W(Dyn) *dyn = (Elf_W(Dyn) *)(p_dynamic->p_vaddr + load_base);
+          for (; dyn->d_tag != DT_NULL; ++dyn)
+            if (dyn->d_tag == DT_PLTGOT)
+              {
+                /* Assume that _DYNAMIC is writable and GLIBC has
+                   relocated it (true for x86 at least).  */
+                di->gp = dyn->d_un.d_ptr;
+                break;
+              }
+        }
       else
-	/* Otherwise this is a static executable with no _DYNAMIC.  Assume
-	   that data-relative addresses are relative to 0, i.e.,
-	   absolute.  */
-	di->gp = 0;
+        /* Otherwise this is a static executable with no _DYNAMIC.  Assume
+           that data-relative addresses are relative to 0, i.e.,
+           absolute.  */
+        di->gp = 0;
       pi->gp = di->gp;
 
-      hdr = (struct dwarf_eh_frame_hdr *) (p_eh_hdr->p_vaddr + load_base);
       if (hdr->version != DW_EH_VERSION)
-	{
-	  Debug (1, "table `%s' has unexpected version %d\n",
-		 info->dlpi_name, hdr->version);
-	  return 0;
-	}
+        {
+          Debug (1, "table `%s' has unexpected version %d\n",
+                 info->dlpi_name, hdr->version);
+          return 0;
+        }
 
-      a = unw_get_accessors (unw_local_addr_space);
-      addr = (unw_word_t) (uintptr_t) (hdr + 1);
+      a = unw_get_accessors_int (unw_local_addr_space);
+      addr = (unw_word_t) (uintptr_t) (&hdr->eh_frame);
 
       /* (Optionally) read eh_frame_ptr: */
       if ((ret = dwarf_read_encoded_pointer (unw_local_addr_space, a,
-					     &addr, hdr->eh_frame_ptr_enc, pi,
-					     &eh_frame_start, NULL)) < 0)
-	return ret;
+                                             &addr, hdr->eh_frame_ptr_enc, pi,
+                                             &eh_frame_start, NULL)) < 0)
+        return ret;
 
       /* (Optionally) read fde_count: */
       if ((ret = dwarf_read_encoded_pointer (unw_local_addr_space, a,
-					     &addr, hdr->fde_count_enc, pi,
-					     &fde_count, NULL)) < 0)
-	return ret;
+                                             &addr, hdr->fde_count_enc, pi,
+                                             &fde_count, NULL)) < 0)
+        return ret;
 
       if (hdr->table_enc != (DW_EH_PE_datarel | DW_EH_PE_sdata4))
-	{
-	  /* If there is no search table or it has an unsupported
-	     encoding, fall back on linear search.  */
-	  if (hdr->table_enc == DW_EH_PE_omit)
-	    Debug (4, "table `%s' lacks search table; doing linear search\n",
-		   info->dlpi_name);
+        {
+          /* If there is no search table or it has an unsupported
+             encoding, fall back on linear search.  */
+          if (hdr->table_enc == DW_EH_PE_omit)
+            Debug (4, "table `%s' lacks search table; doing linear search\n",
+                   info->dlpi_name);
+          else
+            Debug (4, "table `%s' has encoding 0x%x; doing linear search\n",
+                   info->dlpi_name, hdr->table_enc);
+
+          eh_frame_end = max_load_addr; /* XXX can we do better? */
+
+          if (hdr->fde_count_enc == DW_EH_PE_omit)
+            fde_count = ~0UL;
+          if (hdr->eh_frame_ptr_enc == DW_EH_PE_omit)
+            abort ();
+
+          Debug (1, "eh_frame_start = %lx eh_frame_end = %lx\n",
+                 eh_frame_start, eh_frame_end);
+
+          /* XXX we know how to build a local binary search table for
+             .debug_frame, so we could do that here too.  */
+          found = linear_search (unw_local_addr_space, ip,
+                                 eh_frame_start, eh_frame_end, fde_count,
+                                 pi, need_unwind_info, NULL);
+          if (found != 1)
+            found = 0;
 	  else
-	    Debug (4, "table `%s' has encoding 0x%x; doing linear search\n",
-		   info->dlpi_name, hdr->table_enc);
-
-	  eh_frame_end = max_load_addr;	/* XXX can we do better? */
-
-	  if (hdr->fde_count_enc == DW_EH_PE_omit)
-	    fde_count = ~0UL;
-	  if (hdr->eh_frame_ptr_enc == DW_EH_PE_omit)
-	    abort ();
-
-	  /* XXX we know how to build a local binary search table for
-	     .debug_frame, so we could do that here too.  */
-	  cb_data->single_fde = 1;
-	  found = linear_search (unw_local_addr_space, ip,
-				 eh_frame_start, eh_frame_end, fde_count,
-				 pi, need_unwind_info, NULL);
-	  if (found != 1)
-	    found = 0;
-	}
+	    cb_data->single_fde = 1;
+        }
       else
-	{
-	  di->format = UNW_INFO_FORMAT_REMOTE_TABLE;
-	  di->start_ip = p_text->p_vaddr + load_base;
-	  di->end_ip = p_text->p_vaddr + load_base + p_text->p_memsz;
-	  di->u.rti.name_ptr = (unw_word_t) (uintptr_t) info->dlpi_name;
-	  di->u.rti.table_data = addr;
-	  assert (sizeof (struct table_entry) % sizeof (unw_word_t) == 0);
-	  di->u.rti.table_len = (fde_count * sizeof (struct table_entry)
-				 / sizeof (unw_word_t));
-	  /* For the binary-search table in the eh_frame_hdr, data-relative
-	     means relative to the start of that section... */
-	  di->u.rti.segbase = (unw_word_t) (uintptr_t) hdr;
-
-	  found = 1;
-	  Debug (15, "found table `%s': segbase=0x%lx, len=%lu, gp=0x%lx, "
-		 "table_data=0x%lx\n", (char *) (uintptr_t) di->u.rti.name_ptr,
-		 (long) di->u.rti.segbase, (long) di->u.rti.table_len,
-		 (long) di->gp, (long) di->u.rti.table_data);
-	}
+        {
+          di->format = UNW_INFO_FORMAT_REMOTE_TABLE;
+          di->start_ip = p_text->p_vaddr + load_base;
+          di->end_ip = p_text->p_vaddr + load_base + p_text->p_memsz;
+          di->u.rti.name_ptr = (unw_word_t) (uintptr_t) info->dlpi_name;
+          di->u.rti.table_data = addr;
+          assert (sizeof (struct table_entry) % sizeof (unw_word_t) == 0);
+          di->u.rti.table_len = (fde_count * sizeof (struct table_entry)
+                                 / sizeof (unw_word_t));
+          /* For the binary-search table in the eh_frame_hdr, data-relative
+             means relative to the start of that section... */
+          di->u.rti.segbase = (unw_word_t) (uintptr_t) hdr;
+
+          found = 1;
+          Debug (15, "found table `%s': segbase=0x%lx, len=%lu, gp=0x%lx, "
+                 "table_data=0x%lx\n", (char *) (uintptr_t) di->u.rti.name_ptr,
+                 (long) di->u.rti.segbase, (long) di->u.rti.table_len,
+                 (long) di->gp, (long) di->u.rti.table_data);
+        }
     }
 
 #ifdef CONFIG_DEBUG_FRAME
@@ -690,20 +668,20 @@ dwarf_callback (struct dl_phdr_info *info, size_t size, void *ptr)
     {
       if (info->dlpi_phdr[n].p_type == PT_LOAD)
         {
-	  unw_word_t seg_start = info->dlpi_addr + info->dlpi_phdr[n].p_vaddr;
+          unw_word_t seg_start = info->dlpi_addr + info->dlpi_phdr[n].p_vaddr;
           unw_word_t seg_end = seg_start + info->dlpi_phdr[n].p_memsz;
 
-	  if (seg_start < start)
-	    start = seg_start;
+          if (seg_start < start)
+            start = seg_start;
 
-	  if (seg_end > end)
-	    end = seg_end;
-	}
+          if (seg_end > end)
+            end = seg_end;
+        }
     }
 
   found = dwarf_find_debug_frame (found, &cb_data->di_debug, ip,
-				  info->dlpi_addr, info->dlpi_name, start,
-				  end);
+                                  info->dlpi_addr, info->dlpi_name, start,
+                                  end);
 #endif  /* CONFIG_DEBUG_FRAME */
 
   return found;
@@ -711,7 +689,7 @@ dwarf_callback (struct dl_phdr_info *info, size_t size, void *ptr)
 
 HIDDEN int
 dwarf_find_proc_info (unw_addr_space_t as, unw_word_t ip,
-		      unw_proc_info_t *pi, int need_unwind_info, void *arg)
+                      unw_proc_info_t *pi, int need_unwind_info, void *arg)
 {
   struct dwarf_callback_data cb_data;
   intrmask_t saved_mask;
@@ -730,26 +708,26 @@ dwarf_find_proc_info (unw_addr_space_t as, unw_word_t ip,
   ret = dl_iterate_phdr (dwarf_callback, &cb_data);
   SIGPROCMASK (SIG_SETMASK, &saved_mask, NULL);
 
-  if (ret <= 0)
+  if (ret > 0)
     {
-      Debug (14, "IP=0x%lx not found\n", (long) ip);
-      return -UNW_ENOINFO;
-    }
-
-  if (cb_data.single_fde)
-    /* already got the result in *pi */
-    return 0;
+      if (cb_data.single_fde)
+	/* already got the result in *pi */
+	return 0;
+
+      /* search the table: */
+      if (cb_data.di.format != -1)
+	ret = dwarf_search_unwind_table_int (as, ip, &cb_data.di,
+					     pi, need_unwind_info, arg);
+      else
+	ret = -UNW_ENOINFO;
 
-  /* search the table: */
-  if (cb_data.di.format != -1)
-    ret = dwarf_search_unwind_table (as, ip, &cb_data.di,
-				      pi, need_unwind_info, arg);
+      if (ret == -UNW_ENOINFO && cb_data.di_debug.format != -1)
+	ret = dwarf_search_unwind_table_int (as, ip, &cb_data.di_debug, pi,
+					     need_unwind_info, arg);
+    }
   else
     ret = -UNW_ENOINFO;
 
-  if (ret == -UNW_ENOINFO && cb_data.di_debug.format != -1)
-    ret = dwarf_search_unwind_table (as, ip, &cb_data.di_debug, pi,
-				     need_unwind_info, arg);
   return ret;
 }
 
@@ -767,12 +745,12 @@ lookup (const struct table_entry *table, size_t table_size, int32_t rel_ip)
       e = table + mid;
       Debug (15, "e->start_ip_offset = %lx\n", (long) e->start_ip_offset);
       if (rel_ip < e->start_ip_offset)
-	hi = mid;
+        hi = mid;
       else
-	lo = mid + 1;
+        lo = mid + 1;
     }
   if (hi <= 0)
-	return NULL;
+        return NULL;
   e = table + hi - 1;
   return e;
 }
@@ -786,14 +764,14 @@ lookup (const struct table_entry *table, size_t table_size, int32_t rel_ip)
    occurred reading remote memory.  */
 static int
 remote_lookup (unw_addr_space_t as,
-	       unw_word_t table, size_t table_size, int32_t rel_ip,
-	       struct table_entry *e, void *arg)
+               unw_word_t table, size_t table_size, int32_t rel_ip,
+               struct table_entry *e, int32_t *last_ip_offset, void *arg)
 {
   unsigned long table_len = table_size / sizeof (struct table_entry);
-  unw_accessors_t *a = unw_get_accessors (as);
+  unw_accessors_t *a = unw_get_accessors_int (as);
   unsigned long lo, hi, mid;
   unw_word_t e_addr = 0;
-  int32_t start;
+  int32_t start = 0;
   int ret;
 
   /* do a binary search for right entry: */
@@ -802,31 +780,39 @@ remote_lookup (unw_addr_space_t as,
       mid = (lo + hi) / 2;
       e_addr = table + mid * sizeof (struct table_entry);
       if ((ret = dwarf_reads32 (as, a, &e_addr, &start, arg)) < 0)
-	return ret;
+        return ret;
 
       if (rel_ip < start)
-	hi = mid;
+        hi = mid;
       else
-	lo = mid + 1;
+        lo = mid + 1;
     }
   if (hi <= 0)
     return 0;
   e_addr = table + (hi - 1) * sizeof (struct table_entry);
   if ((ret = dwarf_reads32 (as, a, &e_addr, &e->start_ip_offset, arg)) < 0
-   || (ret = dwarf_reads32 (as, a, &e_addr, &e->fde_offset, arg)) < 0)
+   || (ret = dwarf_reads32 (as, a, &e_addr, &e->fde_offset, arg)) < 0
+   || (hi < table_len &&
+       (ret = dwarf_reads32 (as, a, &e_addr, last_ip_offset, arg)) < 0))
     return ret;
   return 1;
 }
 
 #endif /* !UNW_LOCAL_ONLY */
 
-PROTECTED int
+static int is_remote_table(int format)
+{
+  return (format == UNW_INFO_FORMAT_REMOTE_TABLE ||
+          format == UNW_INFO_FORMAT_IP_OFFSET);
+}
+
+int
 dwarf_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
-			   unw_dyn_info_t *di, unw_proc_info_t *pi,
-			   int need_unwind_info, void *arg)
+                           unw_dyn_info_t *di, unw_proc_info_t *pi,
+                           int need_unwind_info, void *arg)
 {
   const struct table_entry *e = NULL, *table;
-  unw_word_t segbase = 0, fde_addr;
+  unw_word_t ip_base = 0, segbase = 0, last_ip, fde_addr;
   unw_accessors_t *a;
 #ifndef UNW_LOCAL_ONLY
   struct table_entry ent;
@@ -836,14 +822,14 @@ dwarf_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
   size_t table_len;
 
 #ifdef UNW_REMOTE_ONLY
-  assert (di->format == UNW_INFO_FORMAT_REMOTE_TABLE);
+  assert (is_remote_table(di->format));
 #else
-  assert (di->format == UNW_INFO_FORMAT_REMOTE_TABLE
-	  || di->format == UNW_INFO_FORMAT_TABLE);
+  assert (is_remote_table(di->format)
+          || di->format == UNW_INFO_FORMAT_TABLE);
 #endif
   assert (ip >= di->start_ip && ip < di->end_ip);
 
-  if (di->format == UNW_INFO_FORMAT_REMOTE_TABLE)
+  if (is_remote_table(di->format))
     {
       table = (const struct table_entry *) (uintptr_t) di->u.rti.table_data;
       table_len = di->u.rti.table_len * sizeof (unw_word_t);
@@ -851,6 +837,7 @@ dwarf_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
     }
   else
     {
+      assert(di->format == UNW_INFO_FORMAT_TABLE);
 #ifndef UNW_REMOTE_ONLY
       struct unw_debug_frame_list *fdesc = (void *) di->u.ti.table_data;
 
@@ -860,53 +847,69 @@ dwarf_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
          endianness is the target one.  */
       as = unw_local_addr_space;
       table = fdesc->index;
-      table_len = fdesc->index_size * sizeof (struct table_entry);
+      table_len = fdesc->index_size;
       debug_frame_base = (uintptr_t) fdesc->debug_frame;
 #endif
     }
 
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
+
+  segbase = di->u.rti.segbase;
+  if (di->format == UNW_INFO_FORMAT_IP_OFFSET) {
+    ip_base = di->start_ip;
+  } else {
+    ip_base = segbase;
+  }
 
 #ifndef UNW_REMOTE_ONLY
   if (as == unw_local_addr_space)
     {
-      segbase = di->u.rti.segbase;
-      e = lookup (table, table_len, ip - segbase);
+      e = lookup (table, table_len, ip - ip_base);
+      if (e && &e[1] < &table[table_len])
+	last_ip = e[1].start_ip_offset + ip_base;
+      else
+	last_ip = di->end_ip;
     }
   else
 #endif
     {
 #ifndef UNW_LOCAL_ONLY
+      int32_t last_ip_offset = di->end_ip - ip_base;
       segbase = di->u.rti.segbase;
       if ((ret = remote_lookup (as, (uintptr_t) table, table_len,
-				ip - segbase, &ent, arg)) < 0)
-	return ret;
+                                ip - ip_base, &ent, &last_ip_offset, arg)) < 0)
+        return ret;
       if (ret)
-	e = &ent;
+	{
+	  e = &ent;
+	  last_ip = last_ip_offset + ip_base;
+	}
       else
-	e = NULL;	/* no info found */
+        e = NULL;       /* no info found */
 #endif
     }
   if (!e)
     {
       Debug (1, "IP %lx inside range %lx-%lx, but no explicit unwind info found\n",
-	     (long) ip, (long) di->start_ip, (long) di->end_ip);
+             (long) ip, (long) di->start_ip, (long) di->end_ip);
       /* IP is inside this table's range, but there is no explicit
-	 unwind info.  */
+         unwind info.  */
       return -UNW_ENOINFO;
     }
   Debug (15, "ip=0x%lx, start_ip=0x%lx\n",
-	 (long) ip, (long) (e->start_ip_offset));
+         (long) ip, (long) (e->start_ip_offset));
   if (debug_frame_base)
     fde_addr = e->fde_offset + debug_frame_base;
   else
     fde_addr = e->fde_offset + segbase;
   Debug (1, "e->fde_offset = %lx, segbase = %lx, debug_frame_base = %lx, "
-	    "fde_addr = %lx\n", (long) e->fde_offset, (long) segbase,
-	    (long) debug_frame_base, (long) fde_addr);
+            "fde_addr = %lx\n", (long) e->fde_offset, (long) segbase,
+            (long) debug_frame_base, (long) fde_addr);
   if ((ret = dwarf_extract_proc_info_from_fde (as, a, &fde_addr, pi,
-					       need_unwind_info,
-					       debug_frame_base, arg)) < 0)
+                                               debug_frame_base ?
+                                               debug_frame_base : segbase,
+                                               need_unwind_info,
+                                               debug_frame_base != 0, arg)) < 0)
     return ret;
 
   /* .debug_frame uses an absolute encoding that does not know about any
@@ -918,6 +921,11 @@ dwarf_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
       pi->flags = UNW_PI_FLAG_DEBUG_FRAME;
     }
 
+#if defined(NEED_LAST_IP)
+  pi->last_ip = last_ip;
+#else
+  (void)last_ip;
+#endif
   if (ip < pi->start_ip || ip >= pi->end_ip)
     return -UNW_ENOINFO;
 
@@ -927,5 +935,5 @@ dwarf_search_unwind_table (unw_addr_space_t as, unw_word_t ip,
 HIDDEN void
 dwarf_put_unwind_info (unw_addr_space_t as, unw_proc_info_t *pi, void *arg)
 {
-  return;	/* always a nop */
+  return;       /* always a nop */
 }
diff --git a/src/dwarf/Gfind_unwind_table.c b/src/dwarf/Gfind_unwind_table.c
index 961226a..6a2ad50 100644
--- a/src/dwarf/Gfind_unwind_table.c
+++ b/src/dwarf/Gfind_unwind_table.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -23,7 +23,6 @@ LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
-#include <elf.h>
 #include <fcntl.h>
 #include <string.h>
 #include <unistd.h>
@@ -34,15 +33,17 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "dwarf-eh.h"
 #include "dwarf_i.h"
 
+#define to_unw_word(p) ((unw_word_t) (uintptr_t) (p))
+
 int
 dwarf_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
-			 char *path, unw_word_t segbase, unw_word_t mapoff,
-			 unw_word_t ip)
+                         char *path, unw_word_t segbase, unw_word_t mapoff,
+                         unw_word_t ip)
 {
   Elf_W(Phdr) *phdr, *ptxt = NULL, *peh_hdr = NULL, *pdyn = NULL;
   unw_word_t addr, eh_frame_start, fde_count, load_base;
   unw_word_t max_load_addr = 0;
-  unw_word_t start_ip = (unw_word_t) -1;
+  unw_word_t start_ip = to_unw_word (-1);
   unw_word_t end_ip = 0;
   struct dwarf_eh_frame_hdr *hdr;
   unw_proc_info_t pi;
@@ -64,37 +65,37 @@ dwarf_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
   for (i = 0; i < ehdr->e_phnum; ++i)
     {
       switch (phdr[i].p_type)
-	{
-	case PT_LOAD:
-	  if (phdr[i].p_vaddr < start_ip)
-	    start_ip = phdr[i].p_vaddr;
+        {
+        case PT_LOAD:
+          if (phdr[i].p_vaddr < start_ip)
+            start_ip = phdr[i].p_vaddr;
 
-	  if (phdr[i].p_vaddr + phdr[i].p_memsz > end_ip)
-	    end_ip = phdr[i].p_vaddr + phdr[i].p_memsz;
+          if (phdr[i].p_vaddr + phdr[i].p_memsz > end_ip)
+            end_ip = phdr[i].p_vaddr + phdr[i].p_memsz;
 
-	  if (phdr[i].p_offset == mapoff)
-	    ptxt = phdr + i;
-	  if ((uintptr_t) edi->ei.image + phdr->p_filesz > max_load_addr)
-	    max_load_addr = (uintptr_t) edi->ei.image + phdr->p_filesz;
-	  break;
+          if (phdr[i].p_offset == mapoff)
+            ptxt = phdr + i;
+          if ((uintptr_t) edi->ei.image + phdr->p_filesz > max_load_addr)
+            max_load_addr = (uintptr_t) edi->ei.image + phdr->p_filesz;
+          break;
 
-	case PT_GNU_EH_FRAME:
-	  peh_hdr = phdr + i;
-	  break;
+        case PT_GNU_EH_FRAME:
+          peh_hdr = phdr + i;
+          break;
 
-	case PT_DYNAMIC:
-	  pdyn = phdr + i;
-	  break;
+        case PT_DYNAMIC:
+          pdyn = phdr + i;
+          break;
 
 #if UNW_TARGET_ARM
-	case PT_ARM_EXIDX:
-	  parm_exidx = phdr + i;
-	  break;
+        case PT_ARM_EXIDX:
+          parm_exidx = phdr + i;
+          break;
 #endif
 
-	default:
-	  break;
-	}
+        default:
+          break;
+        }
     }
 
   if (!ptxt)
@@ -107,85 +108,85 @@ dwarf_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
   if (peh_hdr)
     {
       if (pdyn)
-	{
-	  /* For dynamicly linked executables and shared libraries,
-	     DT_PLTGOT is the value that data-relative addresses are
-	     relative to for that object.  We call this the "gp".  */
-		Elf_W(Dyn) *dyn = (Elf_W(Dyn) *)(pdyn->p_offset
-						 + (char *) edi->ei.image);
-	  for (; dyn->d_tag != DT_NULL; ++dyn)
-	    if (dyn->d_tag == DT_PLTGOT)
-	      {
-		/* Assume that _DYNAMIC is writable and GLIBC has
-		   relocated it (true for x86 at least).  */
-		edi->di_cache.gp = dyn->d_un.d_ptr;
-		break;
-	      }
-	}
+        {
+          /* For dynamicly linked executables and shared libraries,
+             DT_PLTGOT is the value that data-relative addresses are
+             relative to for that object.  We call this the "gp".  */
+                Elf_W(Dyn) *dyn = (Elf_W(Dyn) *)(pdyn->p_offset
+                                                 + (char *) edi->ei.image);
+          for (; dyn->d_tag != DT_NULL; ++dyn)
+            if (dyn->d_tag == DT_PLTGOT)
+              {
+                /* Assume that _DYNAMIC is writable and GLIBC has
+                   relocated it (true for x86 at least).  */
+                edi->di_cache.gp = dyn->d_un.d_ptr;
+                break;
+              }
+        }
       else
-	/* Otherwise this is a static executable with no _DYNAMIC.  Assume
-	   that data-relative addresses are relative to 0, i.e.,
-	   absolute.  */
-	edi->di_cache.gp = 0;
+        /* Otherwise this is a static executable with no _DYNAMIC.  Assume
+           that data-relative addresses are relative to 0, i.e.,
+           absolute.  */
+        edi->di_cache.gp = 0;
 
       hdr = (struct dwarf_eh_frame_hdr *) (peh_hdr->p_offset
-					   + (char *) edi->ei.image);
+                                           + (char *) edi->ei.image);
       if (hdr->version != DW_EH_VERSION)
-	{
-	  Debug (1, "table `%s' has unexpected version %d\n",
-		 path, hdr->version);
-	  return -UNW_ENOINFO;
-	}
+        {
+          Debug (1, "table `%s' has unexpected version %d\n",
+                 path, hdr->version);
+          return -UNW_ENOINFO;
+        }
 
-      a = unw_get_accessors (unw_local_addr_space);
-      addr = (unw_word_t) (hdr + 1);
+      a = unw_get_accessors_int (unw_local_addr_space);
+      addr = to_unw_word (&hdr->eh_frame);
 
       /* Fill in a dummy proc_info structure.  We just need to fill in
-	 enough to ensure that dwarf_read_encoded_pointer() can do it's
-	 job.  Since we don't have a procedure-context at this point, all
-	 we have to do is fill in the global-pointer.  */
+         enough to ensure that dwarf_read_encoded_pointer() can do it's
+         job.  Since we don't have a procedure-context at this point, all
+         we have to do is fill in the global-pointer.  */
       memset (&pi, 0, sizeof (pi));
       pi.gp = edi->di_cache.gp;
 
       /* (Optionally) read eh_frame_ptr: */
       if ((ret = dwarf_read_encoded_pointer (unw_local_addr_space, a,
-					     &addr, hdr->eh_frame_ptr_enc, &pi,
-					     &eh_frame_start, NULL)) < 0)
-	return -UNW_ENOINFO;
+                                             &addr, hdr->eh_frame_ptr_enc, &pi,
+                                             &eh_frame_start, NULL)) < 0)
+        return -UNW_ENOINFO;
 
       /* (Optionally) read fde_count: */
       if ((ret = dwarf_read_encoded_pointer (unw_local_addr_space, a,
-					     &addr, hdr->fde_count_enc, &pi,
-					     &fde_count, NULL)) < 0)
-	return -UNW_ENOINFO;
+                                             &addr, hdr->fde_count_enc, &pi,
+                                             &fde_count, NULL)) < 0)
+        return -UNW_ENOINFO;
 
       if (hdr->table_enc != (DW_EH_PE_datarel | DW_EH_PE_sdata4))
-	{
+        {
     #if 1
-	  abort ();
+          abort ();
     #else
-	  unw_word_t eh_frame_end;
-
-	  /* If there is no search table or it has an unsupported
-	     encoding, fall back on linear search.  */
-	  if (hdr->table_enc == DW_EH_PE_omit)
-	    Debug (4, "EH lacks search table; doing linear search\n");
-	  else
-	    Debug (4, "EH table has encoding 0x%x; doing linear search\n",
-		   hdr->table_enc);
-
-	  eh_frame_end = max_load_addr;	/* XXX can we do better? */
-
-	  if (hdr->fde_count_enc == DW_EH_PE_omit)
-	    fde_count = ~0UL;
-	  if (hdr->eh_frame_ptr_enc == DW_EH_PE_omit)
-	    abort ();
-
-	  return linear_search (unw_local_addr_space, ip,
-				eh_frame_start, eh_frame_end, fde_count,
-				pi, need_unwind_info, NULL);
+          unw_word_t eh_frame_end;
+
+          /* If there is no search table or it has an unsupported
+             encoding, fall back on linear search.  */
+          if (hdr->table_enc == DW_EH_PE_omit)
+            Debug (4, "EH lacks search table; doing linear search\n");
+          else
+            Debug (4, "EH table has encoding 0x%x; doing linear search\n",
+                   hdr->table_enc);
+
+          eh_frame_end = max_load_addr; /* XXX can we do better? */
+
+          if (hdr->fde_count_enc == DW_EH_PE_omit)
+            fde_count = ~0UL;
+          if (hdr->eh_frame_ptr_enc == DW_EH_PE_omit)
+            abort ();
+
+          return linear_search (unw_local_addr_space, ip,
+                                eh_frame_start, eh_frame_end, fde_count,
+                                pi, need_unwind_info, NULL);
     #endif
-	}
+        }
 
       edi->di_cache.start_ip = start_ip;
       edi->di_cache.end_ip = end_ip;
@@ -194,14 +195,15 @@ dwarf_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
       /* two 32-bit values (ip_offset/fde_offset) per table-entry: */
       edi->di_cache.u.rti.table_len = (fde_count * 8) / sizeof (unw_word_t);
       edi->di_cache.u.rti.table_data = ((load_base + peh_hdr->p_vaddr)
-				       + (addr - (unw_word_t) edi->ei.image
-					  - peh_hdr->p_offset));
+                                       + (addr - to_unw_word (edi->ei.image)
+                                          - peh_hdr->p_offset));
 
       /* For the binary-search table in the eh_frame_hdr, data-relative
-	 means relative to the start of that section... */
+         means relative to the start of that section... */
       edi->di_cache.u.rti.segbase = ((load_base + peh_hdr->p_vaddr)
-				    + ((unw_word_t) hdr - (unw_word_t) edi->ei.image
-				       - peh_hdr->p_offset));
+                                    + (to_unw_word (hdr) -
+                                       to_unw_word (edi->ei.image)
+                                       - peh_hdr->p_offset));
       found = 1;
     }
 
@@ -211,7 +213,7 @@ dwarf_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
       edi->di_arm.format = UNW_INFO_FORMAT_ARM_EXIDX;
       edi->di_arm.start_ip = start_ip;
       edi->di_arm.end_ip = end_ip;
-      edi->di_arm.u.rti.name_ptr = (unw_word_t) path;
+      edi->di_arm.u.rti.name_ptr = to_unw_word (path);
       edi->di_arm.u.rti.table_data = load_base + parm_exidx->p_vaddr;
       edi->di_arm.u.rti.table_len = parm_exidx->p_memsz;
       found = 1;
@@ -221,7 +223,7 @@ dwarf_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
 #ifdef CONFIG_DEBUG_FRAME
   /* Try .debug_frame. */
   found = dwarf_find_debug_frame (found, &edi->di_debug, ip, load_base, path,
-				  start_ip, end_ip);
+                                  start_ip, end_ip);
 #endif
 
   return found;
diff --git a/src/dwarf/Gparser.c b/src/dwarf/Gparser.c
index 49c79db..fe7c581 100644
--- a/src/dwarf/Gparser.c
+++ b/src/dwarf/Gparser.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -23,16 +23,20 @@ LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
-#include <stddef.h>
 #include "dwarf_i.h"
 #include "libunwind_i.h"
+#include <stddef.h>
+#include <limits.h>
+
+#define alloc_reg_state()       (mempool_alloc (&dwarf_reg_state_pool))
+#define free_reg_state(rs)      (mempool_free (&dwarf_reg_state_pool, rs))
 
-#define alloc_reg_state()	(mempool_alloc (&dwarf_reg_state_pool))
-#define free_reg_state(rs)	(mempool_free (&dwarf_reg_state_pool, rs))
+#define DWARF_UNW_CACHE_SIZE(log_size)   (1 << log_size)
+#define DWARF_UNW_HASH_SIZE(log_size)    (1 << (log_size + 1))
 
 static inline int
 read_regnum (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	     unw_word_t *valp, void *arg)
+             unw_word_t *valp, void *arg)
 {
   int ret;
 
@@ -49,344 +53,375 @@ read_regnum (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static inline void
 set_reg (dwarf_state_record_t *sr, unw_word_t regnum, dwarf_where_t where,
-	 unw_word_t val)
+         unw_word_t val)
+{
+  sr->rs_current.reg.where[regnum] = where;
+  sr->rs_current.reg.val[regnum] = val;
+}
+
+static inline int
+push_rstate_stack(dwarf_stackable_reg_state_t **rs_stack)
+{
+  dwarf_stackable_reg_state_t *old_rs = *rs_stack;
+  if (NULL == (*rs_stack = alloc_reg_state ()))
+    {
+      *rs_stack = old_rs;
+      return -1;
+    }
+  (*rs_stack)->next = old_rs;
+  return 0;
+}
+
+static inline void
+pop_rstate_stack(dwarf_stackable_reg_state_t **rs_stack)
+{
+  dwarf_stackable_reg_state_t *old_rs = *rs_stack;
+  *rs_stack = old_rs->next;
+  free_reg_state (old_rs);
+}
+
+static inline void
+empty_rstate_stack(dwarf_stackable_reg_state_t **rs_stack)
 {
-  sr->rs_current.reg[regnum].where = where;
-  sr->rs_current.reg[regnum].val = val;
+  while (*rs_stack)
+    pop_rstate_stack(rs_stack);
 }
 
 /* Run a CFI program to update the register state.  */
 static int
 run_cfi_program (struct dwarf_cursor *c, dwarf_state_record_t *sr,
-		 unw_word_t ip, unw_word_t *addr, unw_word_t end_addr,
-		 struct dwarf_cie_info *dci)
+                 unw_word_t *ip, unw_word_t end_ip,
+		 unw_word_t *addr, unw_word_t end_addr,
+		 dwarf_stackable_reg_state_t **rs_stack,
+                 struct dwarf_cie_info *dci)
 {
-  unw_word_t curr_ip, operand = 0, regnum, val, len, fde_encoding;
-  dwarf_reg_state_t *rs_stack = NULL, *new_rs, *old_rs;
   unw_addr_space_t as;
-  unw_accessors_t *a;
-  uint8_t u8, op;
-  uint16_t u16;
-  uint32_t u32;
   void *arg;
-  int ret;
 
-  as = c->as;
-  arg = c->as_arg;
   if (c->pi.flags & UNW_PI_FLAG_DEBUG_FRAME)
     {
       /* .debug_frame CFI is stored in local address space.  */
       as = unw_local_addr_space;
       arg = NULL;
     }
-  a = unw_get_accessors (as);
-  curr_ip = c->pi.start_ip;
+  else
+    {
+      as = c->as;
+      arg = c->as_arg;
+    }
+  unw_accessors_t *a = unw_get_accessors_int (as);
+  int ret = 0;
 
-  /* Process everything up to and including the current 'ip',
-     including all the DW_CFA_advance_loc instructions.  See
-     'c->use_prev_instr' use in 'fetch_proc_info' for details. */
-  while (curr_ip <= ip && *addr < end_addr)
+  while (*ip <= end_ip && *addr < end_addr && ret >= 0)
     {
+      unw_word_t operand = 0, regnum, val, len;
+      uint8_t u8, op;
+      uint16_t u16;
+      uint32_t u32;
+
       if ((ret = dwarf_readu8 (as, a, addr, &op, arg)) < 0)
-	return ret;
+        break;
 
       if (op & DWARF_CFA_OPCODE_MASK)
-	{
-	  operand = op & DWARF_CFA_OPERAND_MASK;
-	  op &= ~DWARF_CFA_OPERAND_MASK;
-	}
+        {
+          operand = op & DWARF_CFA_OPERAND_MASK;
+          op &= ~DWARF_CFA_OPERAND_MASK;
+        }
       switch ((dwarf_cfa_t) op)
-	{
-	case DW_CFA_advance_loc:
-	  curr_ip += operand * dci->code_align;
-	  Debug (15, "CFA_advance_loc to 0x%lx\n", (long) curr_ip);
-	  break;
-
-	case DW_CFA_advance_loc1:
-	  if ((ret = dwarf_readu8 (as, a, addr, &u8, arg)) < 0)
-	    goto fail;
-	  curr_ip += u8 * dci->code_align;
-	  Debug (15, "CFA_advance_loc1 to 0x%lx\n", (long) curr_ip);
-	  break;
-
-	case DW_CFA_advance_loc2:
-	  if ((ret = dwarf_readu16 (as, a, addr, &u16, arg)) < 0)
-	    goto fail;
-	  curr_ip += u16 * dci->code_align;
-	  Debug (15, "CFA_advance_loc2 to 0x%lx\n", (long) curr_ip);
-	  break;
-
-	case DW_CFA_advance_loc4:
-	  if ((ret = dwarf_readu32 (as, a, addr, &u32, arg)) < 0)
-	    goto fail;
-	  curr_ip += u32 * dci->code_align;
-	  Debug (15, "CFA_advance_loc4 to 0x%lx\n", (long) curr_ip);
-	  break;
-
-	case DW_CFA_MIPS_advance_loc8:
+        {
+        case DW_CFA_advance_loc:
+          *ip += operand * dci->code_align;
+          Debug (15, "CFA_advance_loc to 0x%lx\n", (long) *ip);
+          break;
+
+        case DW_CFA_advance_loc1:
+          if ((ret = dwarf_readu8 (as, a, addr, &u8, arg)) < 0)
+            break;
+          *ip += u8 * dci->code_align;
+          Debug (15, "CFA_advance_loc1 to 0x%lx\n", (long) *ip);
+          break;
+
+        case DW_CFA_advance_loc2:
+          if ((ret = dwarf_readu16 (as, a, addr, &u16, arg)) < 0)
+            break;
+          *ip += u16 * dci->code_align;
+          Debug (15, "CFA_advance_loc2 to 0x%lx\n", (long) *ip);
+          break;
+
+        case DW_CFA_advance_loc4:
+          if ((ret = dwarf_readu32 (as, a, addr, &u32, arg)) < 0)
+            break;
+          *ip += u32 * dci->code_align;
+          Debug (15, "CFA_advance_loc4 to 0x%lx\n", (long) *ip);
+          break;
+
+        case DW_CFA_MIPS_advance_loc8:
 #ifdef UNW_TARGET_MIPS
-	  {
-	    uint64_t u64;
-
-	    if ((ret = dwarf_readu64 (as, a, addr, &u64, arg)) < 0)
-	      goto fail;
-	    curr_ip += u64 * dci->code_align;
-	    Debug (15, "CFA_MIPS_advance_loc8\n");
-	    break;
-	  }
+          {
+            uint64_t u64 = 0;
+
+            if ((ret = dwarf_readu64 (as, a, addr, &u64, arg)) < 0)
+              break;
+            *ip += u64 * dci->code_align;
+            Debug (15, "CFA_MIPS_advance_loc8\n");
+            break;
+          }
 #else
-	  Debug (1, "DW_CFA_MIPS_advance_loc8 on non-MIPS target\n");
-	  ret = -UNW_EINVAL;
-	  goto fail;
+          Debug (1, "DW_CFA_MIPS_advance_loc8 on non-MIPS target\n");
+          ret = -UNW_EINVAL;
+          break;
 #endif
 
-	case DW_CFA_offset:
-	  regnum = operand;
-	  if (regnum >= DWARF_NUM_PRESERVED_REGS)
-	    {
-	      Debug (1, "Invalid register number %u in DW_cfa_OFFSET\n",
-		     (unsigned int) regnum);
-	      ret = -UNW_EBADREG;
-	      goto fail;
-	    }
-	  if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
-	    goto fail;
-	  set_reg (sr, regnum, DWARF_WHERE_CFAREL, val * dci->data_align);
-	  Debug (15, "CFA_offset r%lu at cfa+0x%lx\n",
-		 (long) regnum, (long) (val * dci->data_align));
-	  break;
-
-	case DW_CFA_offset_extended:
-	  if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	      || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
-	    goto fail;
-	  set_reg (sr, regnum, DWARF_WHERE_CFAREL, val * dci->data_align);
-	  Debug (15, "CFA_offset_extended r%lu at cf+0x%lx\n",
-		 (long) regnum, (long) (val * dci->data_align));
-	  break;
-
-	case DW_CFA_offset_extended_sf:
-	  if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	      || ((ret = dwarf_read_sleb128 (as, a, addr, &val, arg)) < 0))
-	    goto fail;
-	  set_reg (sr, regnum, DWARF_WHERE_CFAREL, val * dci->data_align);
-	  Debug (15, "CFA_offset_extended_sf r%lu at cf+0x%lx\n",
-		 (long) regnum, (long) (val * dci->data_align));
-	  break;
-
-	case DW_CFA_restore:
-	  regnum = operand;
-	  if (regnum >= DWARF_NUM_PRESERVED_REGS)
+        case DW_CFA_offset:
+          regnum = operand;
+          if (regnum >= DWARF_NUM_PRESERVED_REGS)
+            {
+              Debug (1, "Invalid register number %u in DW_cfa_OFFSET\n",
+                     (unsigned int) regnum);
+              ret = -UNW_EBADREG;
+              break;
+            }
+          if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
+            break;
+          set_reg (sr, regnum, DWARF_WHERE_CFAREL, val * dci->data_align);
+          Debug (15, "CFA_offset r%lu at cfa+0x%lx\n",
+                 (long) regnum, (long) (val * dci->data_align));
+          break;
+
+        case DW_CFA_offset_extended:
+          if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+              || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
+            break;
+          set_reg (sr, regnum, DWARF_WHERE_CFAREL, val * dci->data_align);
+          Debug (15, "CFA_offset_extended r%lu at cf+0x%lx\n",
+                 (long) regnum, (long) (val * dci->data_align));
+          break;
+
+        case DW_CFA_offset_extended_sf:
+          if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+              || ((ret = dwarf_read_sleb128 (as, a, addr, &val, arg)) < 0))
+            break;
+          set_reg (sr, regnum, DWARF_WHERE_CFAREL, val * dci->data_align);
+          Debug (15, "CFA_offset_extended_sf r%lu at cf+0x%lx\n",
+                 (long) regnum, (long) (val * dci->data_align));
+          break;
+
+        case DW_CFA_restore:
+          regnum = operand;
+          if (regnum >= DWARF_NUM_PRESERVED_REGS)
+            {
+              Debug (1, "Invalid register number %u in DW_CFA_restore\n",
+                     (unsigned int) regnum);
+              ret = -UNW_EINVAL;
+              break;
+            }
+          sr->rs_current.reg.where[regnum] = sr->rs_initial.reg.where[regnum];
+          sr->rs_current.reg.val[regnum] = sr->rs_initial.reg.val[regnum];
+          Debug (15, "CFA_restore r%lu\n", (long) regnum);
+          break;
+
+        case DW_CFA_restore_extended:
+          if ((ret = dwarf_read_uleb128 (as, a, addr, &regnum, arg)) < 0)
+            break;
+          if (regnum >= DWARF_NUM_PRESERVED_REGS)
+            {
+              Debug (1, "Invalid register number %u in "
+                     "DW_CFA_restore_extended\n", (unsigned int) regnum);
+              ret = -UNW_EINVAL;
+              break;
+            }
+          sr->rs_current.reg.where[regnum] = sr->rs_initial.reg.where[regnum];
+          sr->rs_current.reg.val[regnum] = sr->rs_initial.reg.val[regnum];
+          Debug (15, "CFA_restore_extended r%lu\n", (long) regnum);
+          break;
+
+        case DW_CFA_nop:
+          break;
+
+        case DW_CFA_set_loc:
+          if ((ret = dwarf_read_encoded_pointer (as, a, addr, dci->fde_encoding,
+                                                 &c->pi, ip,
+                                                 arg)) < 0)
+            break;
+          Debug (15, "CFA_set_loc to 0x%lx\n", (long) *ip);
+          break;
+
+        case DW_CFA_undefined:
+          if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+            break;
+          set_reg (sr, regnum, DWARF_WHERE_UNDEF, 0);
+          Debug (15, "CFA_undefined r%lu\n", (long) regnum);
+          break;
+
+        case DW_CFA_same_value:
+          if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+            break;
+          set_reg (sr, regnum, DWARF_WHERE_SAME, 0);
+          Debug (15, "CFA_same_value r%lu\n", (long) regnum);
+          break;
+
+        case DW_CFA_register:
+          if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+              || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
+            break;
+          set_reg (sr, regnum, DWARF_WHERE_REG, val);
+          Debug (15, "CFA_register r%lu to r%lu\n", (long) regnum, (long) val);
+          break;
+
+        case DW_CFA_remember_state:
+	  if (push_rstate_stack(rs_stack) < 0)
 	    {
-	      Debug (1, "Invalid register number %u in DW_CFA_restore\n",
-		     (unsigned int) regnum);
-	      ret = -UNW_EINVAL;
-	      goto fail;
+              Debug (1, "Out of memory in DW_CFA_remember_state\n");
+              ret = -UNW_ENOMEM;
+              break;
 	    }
-	  sr->rs_current.reg[regnum] = sr->rs_initial.reg[regnum];
-	  Debug (15, "CFA_restore r%lu\n", (long) regnum);
-	  break;
-
-	case DW_CFA_restore_extended:
-	  if ((ret = dwarf_read_uleb128 (as, a, addr, &regnum, arg)) < 0)
-	    goto fail;
-	  if (regnum >= DWARF_NUM_PRESERVED_REGS)
-	    {
-	      Debug (1, "Invalid register number %u in "
-		     "DW_CFA_restore_extended\n", (unsigned int) regnum);
-	      ret = -UNW_EINVAL;
-	      goto fail;
-	    }
-	  sr->rs_current.reg[regnum] = sr->rs_initial.reg[regnum];
-	  Debug (15, "CFA_restore_extended r%lu\n", (long) regnum);
-	  break;
-
-	case DW_CFA_nop:
-	  break;
-
-	case DW_CFA_set_loc:
-	  fde_encoding = dci->fde_encoding;
-	  if ((ret = dwarf_read_encoded_pointer (as, a, addr, fde_encoding,
-						 &c->pi, &curr_ip,
-						 arg)) < 0)
-	    goto fail;
-	  Debug (15, "CFA_set_loc to 0x%lx\n", (long) curr_ip);
-	  break;
-
-	case DW_CFA_undefined:
-	  if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	    goto fail;
-	  set_reg (sr, regnum, DWARF_WHERE_UNDEF, 0);
-	  Debug (15, "CFA_undefined r%lu\n", (long) regnum);
-	  break;
-
-	case DW_CFA_same_value:
-	  if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	    goto fail;
-	  set_reg (sr, regnum, DWARF_WHERE_SAME, 0);
-	  Debug (15, "CFA_same_value r%lu\n", (long) regnum);
-	  break;
-
-	case DW_CFA_register:
-	  if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	      || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
-	    goto fail;
-	  set_reg (sr, regnum, DWARF_WHERE_REG, val);
-	  Debug (15, "CFA_register r%lu to r%lu\n", (long) regnum, (long) val);
-	  break;
-
-	case DW_CFA_remember_state:
-	  new_rs = alloc_reg_state ();
-	  if (!new_rs)
-	    {
-	      Debug (1, "Out of memory in DW_CFA_remember_state\n");
-	      ret = -UNW_ENOMEM;
-	      goto fail;
-	    }
-
-	  memcpy (new_rs->reg, sr->rs_current.reg, sizeof (new_rs->reg));
-	  new_rs->next = rs_stack;
-	  rs_stack = new_rs;
-	  Debug (15, "CFA_remember_state\n");
-	  break;
-
-	case DW_CFA_restore_state:
-	  if (!rs_stack)
-	    {
-	      Debug (1, "register-state stack underflow\n");
-	      ret = -UNW_EINVAL;
-	      goto fail;
-	    }
-	  memcpy (&sr->rs_current.reg, &rs_stack->reg, sizeof (rs_stack->reg));
-	  old_rs = rs_stack;
-	  rs_stack = rs_stack->next;
-	  free_reg_state (old_rs);
-	  Debug (15, "CFA_restore_state\n");
-	  break;
-
-	case DW_CFA_def_cfa:
-	  if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	      || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
-	    goto fail;
-	  set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_REG, regnum);
-	  set_reg (sr, DWARF_CFA_OFF_COLUMN, 0, val);	/* NOT factored! */
-	  Debug (15, "CFA_def_cfa r%lu+0x%lx\n", (long) regnum, (long) val);
-	  break;
-
-	case DW_CFA_def_cfa_sf:
-	  if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	      || ((ret = dwarf_read_sleb128 (as, a, addr, &val, arg)) < 0))
-	    goto fail;
-	  set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_REG, regnum);
-	  set_reg (sr, DWARF_CFA_OFF_COLUMN, 0,
-		   val * dci->data_align);		/* factored! */
-	  Debug (15, "CFA_def_cfa_sf r%lu+0x%lx\n",
-		 (long) regnum, (long) (val * dci->data_align));
-	  break;
-
-	case DW_CFA_def_cfa_register:
-	  if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	    goto fail;
-	  set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_REG, regnum);
-	  Debug (15, "CFA_def_cfa_register r%lu\n", (long) regnum);
-	  break;
-
-	case DW_CFA_def_cfa_offset:
-	  if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
-	    goto fail;
-	  set_reg (sr, DWARF_CFA_OFF_COLUMN, 0, val);	/* NOT factored! */
-	  Debug (15, "CFA_def_cfa_offset 0x%lx\n", (long) val);
-	  break;
-
-	case DW_CFA_def_cfa_offset_sf:
-	  if ((ret = dwarf_read_sleb128 (as, a, addr, &val, arg)) < 0)
-	    goto fail;
-	  set_reg (sr, DWARF_CFA_OFF_COLUMN, 0,
-		   val * dci->data_align);	/* factored! */
-	  Debug (15, "CFA_def_cfa_offset_sf 0x%lx\n",
-		 (long) (val * dci->data_align));
-	  break;
-
-	case DW_CFA_def_cfa_expression:
-	  /* Save the address of the DW_FORM_block for later evaluation. */
-	  set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_EXPR, *addr);
-
-	  if ((ret = dwarf_read_uleb128 (as, a, addr, &len, arg)) < 0)
-	    goto fail;
-
-	  Debug (15, "CFA_def_cfa_expr @ 0x%lx [%lu bytes]\n",
-		 (long) *addr, (long) len);
-	  *addr += len;
-	  break;
-
-	case DW_CFA_expression:
-	  if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	    goto fail;
-
-	  /* Save the address of the DW_FORM_block for later evaluation. */
-	  set_reg (sr, regnum, DWARF_WHERE_EXPR, *addr);
-
-	  if ((ret = dwarf_read_uleb128 (as, a, addr, &len, arg)) < 0)
-	    goto fail;
-
-	  Debug (15, "CFA_expression r%lu @ 0x%lx [%lu bytes]\n",
-		 (long) regnum, (long) addr, (long) len);
-	  *addr += len;
-	  break;
-
-	case DW_CFA_GNU_args_size:
-	  if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
-	    goto fail;
-	  sr->args_size = val;
-	  Debug (15, "CFA_GNU_args_size %lu\n", (long) val);
-	  break;
-
-	case DW_CFA_GNU_negative_offset_extended:
-	  /* A comment in GCC says that this is obsoleted by
-	     DW_CFA_offset_extended_sf, but that it's used by older
-	     PowerPC code.  */
-	  if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
-	      || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
-	    goto fail;
-	  set_reg (sr, regnum, DWARF_WHERE_CFAREL, -(val * dci->data_align));
-	  Debug (15, "CFA_GNU_negative_offset_extended cfa+0x%lx\n",
-		 (long) -(val * dci->data_align));
-	  break;
-
-	case DW_CFA_GNU_window_save:
+          (*rs_stack)->state = sr->rs_current;
+          Debug (15, "CFA_remember_state\n");
+          break;
+
+        case DW_CFA_restore_state:
+          if (!*rs_stack)
+            {
+              Debug (1, "register-state stack underflow\n");
+              ret = -UNW_EINVAL;
+              break;
+            }
+          sr->rs_current = (*rs_stack)->state;
+          pop_rstate_stack(rs_stack);
+          Debug (15, "CFA_restore_state\n");
+          break;
+
+        case DW_CFA_def_cfa:
+          if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+              || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
+            break;
+          set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_REG, regnum);
+          set_reg (sr, DWARF_CFA_OFF_COLUMN, 0, val);   /* NOT factored! */
+          Debug (15, "CFA_def_cfa r%lu+0x%lx\n", (long) regnum, (long) val);
+          break;
+
+        case DW_CFA_def_cfa_sf:
+          if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+              || ((ret = dwarf_read_sleb128 (as, a, addr, &val, arg)) < 0))
+            break;
+          set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_REG, regnum);
+          set_reg (sr, DWARF_CFA_OFF_COLUMN, 0,
+                   val * dci->data_align);              /* factored! */
+          Debug (15, "CFA_def_cfa_sf r%lu+0x%lx\n",
+                 (long) regnum, (long) (val * dci->data_align));
+          break;
+
+        case DW_CFA_def_cfa_register:
+          if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+            break;
+          set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_REG, regnum);
+          Debug (15, "CFA_def_cfa_register r%lu\n", (long) regnum);
+          break;
+
+        case DW_CFA_def_cfa_offset:
+          if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
+            break;
+          set_reg (sr, DWARF_CFA_OFF_COLUMN, 0, val);   /* NOT factored! */
+          Debug (15, "CFA_def_cfa_offset 0x%lx\n", (long) val);
+          break;
+
+        case DW_CFA_def_cfa_offset_sf:
+          if ((ret = dwarf_read_sleb128 (as, a, addr, &val, arg)) < 0)
+            break;
+          set_reg (sr, DWARF_CFA_OFF_COLUMN, 0,
+                   val * dci->data_align);      /* factored! */
+          Debug (15, "CFA_def_cfa_offset_sf 0x%lx\n",
+                 (long) (val * dci->data_align));
+          break;
+
+        case DW_CFA_def_cfa_expression:
+          /* Save the address of the DW_FORM_block for later evaluation. */
+          set_reg (sr, DWARF_CFA_REG_COLUMN, DWARF_WHERE_EXPR, *addr);
+
+          if ((ret = dwarf_read_uleb128 (as, a, addr, &len, arg)) < 0)
+            break;
+
+          Debug (15, "CFA_def_cfa_expr @ 0x%lx [%lu bytes]\n",
+                 (long) *addr, (long) len);
+          *addr += len;
+          break;
+
+        case DW_CFA_expression:
+          if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+            break;
+
+          /* Save the address of the DW_FORM_block for later evaluation. */
+          set_reg (sr, regnum, DWARF_WHERE_EXPR, *addr);
+
+          if ((ret = dwarf_read_uleb128 (as, a, addr, &len, arg)) < 0)
+            break;
+
+          Debug (15, "CFA_expression r%lu @ 0x%lx [%lu bytes]\n",
+                 (long) regnum, (long) addr, (long) len);
+          *addr += len;
+          break;
+
+        case DW_CFA_val_expression:
+          if ((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+            break;
+
+          /* Save the address of the DW_FORM_block for later evaluation. */
+          set_reg (sr, regnum, DWARF_WHERE_VAL_EXPR, *addr);
+
+          if ((ret = dwarf_read_uleb128 (as, a, addr, &len, arg)) < 0)
+            break;
+
+          Debug (15, "CFA_val_expression r%lu @ 0x%lx [%lu bytes]\n",
+                 (long) regnum, (long) addr, (long) len);
+          *addr += len;
+          break;
+
+        case DW_CFA_GNU_args_size:
+          if ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0)
+            break;
+          sr->args_size = val;
+          Debug (15, "CFA_GNU_args_size %lu\n", (long) val);
+          break;
+
+        case DW_CFA_GNU_negative_offset_extended:
+          /* A comment in GCC says that this is obsoleted by
+             DW_CFA_offset_extended_sf, but that it's used by older
+             PowerPC code.  */
+          if (((ret = read_regnum (as, a, addr, &regnum, arg)) < 0)
+              || ((ret = dwarf_read_uleb128 (as, a, addr, &val, arg)) < 0))
+            break;
+          set_reg (sr, regnum, DWARF_WHERE_CFAREL, -(val * dci->data_align));
+          Debug (15, "CFA_GNU_negative_offset_extended cfa+0x%lx\n",
+                 (long) -(val * dci->data_align));
+          break;
+
+        case DW_CFA_GNU_window_save:
 #ifdef UNW_TARGET_SPARC
-	  /* This is a special CFA to handle all 16 windowed registers
-	     on SPARC.  */
-	  for (regnum = 16; regnum < 32; ++regnum)
-	    set_reg (sr, regnum, DWARF_WHERE_CFAREL,
-		     (regnum - 16) * sizeof (unw_word_t));
-	  Debug (15, "CFA_GNU_window_save\n");
-	  break;
+          /* This is a special CFA to handle all 16 windowed registers
+             on SPARC.  */
+          for (regnum = 16; regnum < 32; ++regnum)
+            set_reg (sr, regnum, DWARF_WHERE_CFAREL,
+                     (regnum - 16) * sizeof (unw_word_t));
+          Debug (15, "CFA_GNU_window_save\n");
+          break;
 #else
-	  /* FALL THROUGH */
+          /* FALL THROUGH */
 #endif
-	case DW_CFA_lo_user:
-	case DW_CFA_hi_user:
-	  Debug (1, "Unexpected CFA opcode 0x%x\n", op);
-	  ret = -UNW_EINVAL;
-	  goto fail;
-	}
+        case DW_CFA_lo_user:
+        case DW_CFA_hi_user:
+          Debug (1, "Unexpected CFA opcode 0x%x\n", op);
+          ret = -UNW_EINVAL;
+          break;
+        }
     }
-  ret = 0;
 
- fail:
-  /* Free the register-state stack, if not empty already.  */
-  while (rs_stack)
-    {
-      old_rs = rs_stack;
-      rs_stack = rs_stack->next;
-      free_reg_state (old_rs);
-    }
+  if (ret > 0)
+    ret = 0;
   return ret;
 }
 
 static int
-fetch_proc_info (struct dwarf_cursor *c, unw_word_t ip, int need_unwind_info)
+fetch_proc_info (struct dwarf_cursor *c, unw_word_t ip)
 {
   int ret, dynamic = 1;
 
@@ -400,7 +435,7 @@ fetch_proc_info (struct dwarf_cursor *c, unw_word_t ip, int need_unwind_info)
      and b) so that run_cfi_program() runs locations up to the call
      but not more.
 
-     For execution resume, we need to do the exact opposite and look
+     For signal frame, we need to do the exact opposite and look
      up using the current 'ip' value.  That is where execution will
      continue, and it's important we get this right, as 'ip' could be
      right at the function entry and hence FDE edge, or at instruction
@@ -408,19 +443,16 @@ fetch_proc_info (struct dwarf_cursor *c, unw_word_t ip, int need_unwind_info)
   if (c->use_prev_instr)
     --ip;
 
-  if (c->pi_valid && !need_unwind_info)
-    return 0;
-
   memset (&c->pi, 0, sizeof (c->pi));
 
   /* check dynamic info first --- it overrides everything else */
-  ret = unwi_find_dynamic_proc_info (c->as, ip, &c->pi, need_unwind_info,
-				     c->as_arg);
+  ret = unwi_find_dynamic_proc_info (c->as, ip, &c->pi, 1,
+                                     c->as_arg);
   if (ret == -UNW_ENOINFO)
     {
       dynamic = 0;
-      if ((ret = tdep_find_proc_info (c, ip, need_unwind_info)) < 0)
-	return ret;
+      if ((ret = tdep_find_proc_info (c, ip, 1)) < 0)
+        return ret;
     }
 
   if (c->pi.format != UNW_INFO_FORMAT_DYNAMIC
@@ -433,15 +465,7 @@ fetch_proc_info (struct dwarf_cursor *c, unw_word_t ip, int need_unwind_info)
 
   /* Let system/machine-dependent code determine frame-specific attributes. */
   if (ret >= 0)
-    tdep_fetch_frame (c, ip, need_unwind_info);
-
-  /* Update use_prev_instr for the next frame. */
-  if (need_unwind_info)
-  {
-    assert(c->pi.unwind_info);
-    struct dwarf_cie_info *dci = c->pi.unwind_info;
-    c->use_prev_instr = ! dci->signal_frame;
-  }
+    tdep_fetch_frame (c, ip, 1);
 
   return ret;
 }
@@ -450,70 +474,115 @@ static int
 parse_dynamic (struct dwarf_cursor *c, unw_word_t ip, dwarf_state_record_t *sr)
 {
   Debug (1, "Not yet implemented\n");
-#if 0
-  /* Don't forget to set the ret_addr_column!  */
-  c->ret_addr_column = XXX;
-#endif
   return -UNW_ENOINFO;
 }
 
 static inline void
 put_unwind_info (struct dwarf_cursor *c, unw_proc_info_t *pi)
 {
-  if (!c->pi_valid)
-    return;
-
   if (c->pi_is_dynamic)
     unwi_put_dynamic_unwind_info (c->as, pi, c->as_arg);
-  else if (pi->unwind_info)
+  else if (pi->unwind_info && pi->format == UNW_INFO_FORMAT_TABLE)
     {
       mempool_free (&dwarf_cie_info_pool, pi->unwind_info);
       pi->unwind_info = NULL;
     }
+  c->pi_valid = 0;
 }
 
 static inline int
-parse_fde (struct dwarf_cursor *c, unw_word_t ip, dwarf_state_record_t *sr)
+setup_fde (struct dwarf_cursor *c, dwarf_state_record_t *sr)
 {
-  struct dwarf_cie_info *dci;
-  unw_word_t addr;
-  int ret;
+  int i, ret;
 
-  dci = c->pi.unwind_info;
-  c->ret_addr_column = dci->ret_addr_column;
+  assert (c->pi_valid);
 
-  addr = dci->cie_instr_start;
-  if ((ret = run_cfi_program (c, sr, ~(unw_word_t) 0, &addr,
-			      dci->cie_instr_end, dci)) < 0)
+  memset (sr, 0, sizeof (*sr));
+  for (i = 0; i < DWARF_NUM_PRESERVED_REGS + 2; ++i)
+    set_reg (sr, i, DWARF_WHERE_SAME, 0);
+
+  struct dwarf_cie_info *dci = c->pi.unwind_info;
+  sr->rs_current.ret_addr_column  = dci->ret_addr_column;
+  unw_word_t addr = dci->cie_instr_start;
+  unw_word_t curr_ip = 0;
+  dwarf_stackable_reg_state_t *rs_stack = NULL;
+  ret = run_cfi_program (c, sr, &curr_ip, ~(unw_word_t) 0, &addr,
+			 dci->cie_instr_end,
+			 &rs_stack, dci);
+  empty_rstate_stack(&rs_stack);
+  if (ret < 0)
     return ret;
 
   memcpy (&sr->rs_initial, &sr->rs_current, sizeof (sr->rs_initial));
+  return 0;
+}
 
-  addr = dci->fde_instr_start;
-  if ((ret = run_cfi_program (c, sr, ip, &addr, dci->fde_instr_end, dci)) < 0)
+static inline int
+parse_fde (struct dwarf_cursor *c, unw_word_t ip, dwarf_state_record_t *sr)
+{
+  int ret;
+  struct dwarf_cie_info *dci = c->pi.unwind_info;
+  unw_word_t addr = dci->fde_instr_start;
+  unw_word_t curr_ip = c->pi.start_ip;
+  dwarf_stackable_reg_state_t *rs_stack = NULL;
+  /* Process up to current `ip` for signal frame and `ip - 1` for normal call frame
+     See `c->use_prev_instr` use in `fetch_proc_info` for details. */
+  ret = run_cfi_program (c, sr, &curr_ip, ip - c->use_prev_instr, &addr, dci->fde_instr_end,
+			 &rs_stack, dci);
+  empty_rstate_stack(&rs_stack);
+  if (ret < 0)
     return ret;
 
   return 0;
 }
 
-static inline void
-flush_rs_cache (struct dwarf_rs_cache *cache)
+HIDDEN int
+dwarf_flush_rs_cache (struct dwarf_rs_cache *cache)
 {
   int i;
 
-  cache->lru_head = DWARF_UNW_CACHE_SIZE - 1;
-  cache->lru_tail = 0;
+  if (cache->log_size == DWARF_DEFAULT_LOG_UNW_CACHE_SIZE
+      || !cache->hash) {
+    cache->hash = cache->default_hash;
+    cache->buckets = cache->default_buckets;
+    cache->links = cache->default_links;
+    cache->log_size = DWARF_DEFAULT_LOG_UNW_CACHE_SIZE;
+  } else {
+    if (cache->hash && cache->hash != cache->default_hash)
+      munmap(cache->hash, DWARF_UNW_HASH_SIZE(cache->prev_log_size)
+                           * sizeof (cache->hash[0]));
+    if (cache->buckets && cache->buckets != cache->default_buckets)
+      munmap(cache->buckets, DWARF_UNW_CACHE_SIZE(cache->prev_log_size)
+	                      * sizeof (cache->buckets[0]));
+    if (cache->links && cache->links != cache->default_links)
+      munmap(cache->links, DWARF_UNW_CACHE_SIZE(cache->prev_log_size)
+	                      * sizeof (cache->links[0]));
+    GET_MEMORY(cache->hash, DWARF_UNW_HASH_SIZE(cache->log_size)
+                             * sizeof (cache->hash[0]));
+    GET_MEMORY(cache->buckets, DWARF_UNW_CACHE_SIZE(cache->log_size)
+                                * sizeof (cache->buckets[0]));
+    GET_MEMORY(cache->links, DWARF_UNW_CACHE_SIZE(cache->log_size)
+                                * sizeof (cache->links[0]));
+    if (!cache->hash || !cache->buckets || !cache->links)
+      {
+        Debug (1, "Unable to allocate cache memory");
+        return -UNW_ENOMEM;
+      }
+    cache->prev_log_size = cache->log_size;
+  }
+
+  cache->rr_head = 0;
 
-  for (i = 0; i < DWARF_UNW_CACHE_SIZE; ++i)
+  for (i = 0; i < DWARF_UNW_CACHE_SIZE(cache->log_size); ++i)
     {
-      if (i > 0)
-	cache->buckets[i].lru_chain = (i - 1);
-      cache->buckets[i].coll_chain = -1;
-      cache->buckets[i].ip = 0;
-      cache->buckets[i].valid = 0;
+      cache->links[i].coll_chain = -1;
+      cache->links[i].ip = 0;
+      cache->links[i].valid = 0;
     }
-  for (i = 0; i<DWARF_UNW_HASH_SIZE; ++i)
+  for (i = 0; i< DWARF_UNW_HASH_SIZE(cache->log_size); ++i)
     cache->hash[i] = -1;
+
+  return 0;
 }
 
 static inline struct dwarf_rs_cache *
@@ -525,15 +594,29 @@ get_rs_cache (unw_addr_space_t as, intrmask_t *saved_maskp)
   if (caching == UNW_CACHE_NONE)
     return NULL;
 
+#if defined(HAVE___THREAD) && HAVE___THREAD
+  if (likely (caching == UNW_CACHE_PER_THREAD))
+    {
+      static __thread struct dwarf_rs_cache tls_cache __attribute__((tls_model("initial-exec")));
+      Debug (16, "using TLS cache\n");
+      cache = &tls_cache;
+    }
+  else
+#else
   if (likely (caching == UNW_CACHE_GLOBAL))
+#endif
     {
       Debug (16, "acquiring lock\n");
       lock_acquire (&cache->lock, *saved_maskp);
     }
 
-  if (atomic_read (&as->cache_generation) != atomic_read (&cache->generation))
+  if ((atomic_read (&as->cache_generation) != atomic_read (&cache->generation))
+       || !cache->hash)
     {
-      flush_rs_cache (cache);
+      /* cache_size is only set in the global_cache, copy it over before flushing */
+      cache->log_size = as->global_cache.log_size;
+      if (dwarf_flush_rs_cache (cache) < 0)
+        return NULL;
       cache->generation = as->cache_generation;
     }
 
@@ -542,7 +625,7 @@ get_rs_cache (unw_addr_space_t as, intrmask_t *saved_maskp)
 
 static inline void
 put_rs_cache (unw_addr_space_t as, struct dwarf_rs_cache *cache,
-		  intrmask_t *saved_maskp)
+                  intrmask_t *saved_maskp)
 {
   assert (as->caching_policy != UNW_CACHE_NONE);
 
@@ -552,125 +635,90 @@ put_rs_cache (unw_addr_space_t as, struct dwarf_rs_cache *cache,
 }
 
 static inline unw_hash_index_t CONST_ATTR
-hash (unw_word_t ip)
+hash (unw_word_t ip, unsigned short log_size)
 {
   /* based on (sqrt(5)/2-1)*2^64 */
-# define magic	((unw_word_t) 0x9e3779b97f4a7c16ULL)
+# define magic  ((unw_word_t) 0x9e3779b97f4a7c16ULL)
 
-  return ip * magic >> ((sizeof(unw_word_t) * 8) - DWARF_LOG_UNW_HASH_SIZE);
+  return ip * magic >> ((sizeof(unw_word_t) * 8) - (log_size + 1));
 }
 
 static inline long
-cache_match (dwarf_reg_state_t *rs, unw_word_t ip)
+cache_match (struct dwarf_rs_cache *cache, unsigned short index, unw_word_t ip)
 {
-  if (rs->valid && (ip == rs->ip))
-    return 1;
-  return 0;
+  return (cache->links[index].valid && (ip == cache->links[index].ip));
 }
 
 static dwarf_reg_state_t *
 rs_lookup (struct dwarf_rs_cache *cache, struct dwarf_cursor *c)
 {
-  dwarf_reg_state_t *rs = cache->buckets + c->hint;
   unsigned short index;
-  unw_word_t ip;
-
-  ip = c->ip;
-
-  if (cache_match (rs, ip))
-    return rs;
+  unw_word_t ip = c->ip;
 
-  index = cache->hash[hash (ip)];
-  if (index >= DWARF_UNW_CACHE_SIZE)
-    return NULL;
+  if (c->hint > 0)
+    {
+      index = c->hint - 1;
+      if (cache_match (cache, index, ip))
+	return &cache->buckets[index];
+    }
 
-  rs = cache->buckets + index;
-  while (1)
+  for (index = cache->hash[hash (ip, cache->log_size)];
+       index < DWARF_UNW_CACHE_SIZE(cache->log_size);
+       index = cache->links[index].coll_chain)
     {
-      if (cache_match (rs, ip))
-        {
-          /* update hint; no locking needed: single-word writes are atomic */
-          c->hint = cache->buckets[c->prev_rs].hint =
-            (rs - cache->buckets);
-          return rs;
-        }
-      if (rs->coll_chain >= DWARF_UNW_HASH_SIZE)
-        return NULL;
-      rs = cache->buckets + rs->coll_chain;
+      if (cache_match (cache, index, ip))
+	return &cache->buckets[index];
     }
+  return NULL;
 }
 
 static inline dwarf_reg_state_t *
 rs_new (struct dwarf_rs_cache *cache, struct dwarf_cursor * c)
 {
-  dwarf_reg_state_t *rs, *prev, *tmp;
   unw_hash_index_t index;
   unsigned short head;
 
-  head = cache->lru_head;
-  rs = cache->buckets + head;
-  cache->lru_head = rs->lru_chain;
-
-  /* re-insert rs at the tail of the LRU chain: */
-  cache->buckets[cache->lru_tail].lru_chain = head;
-  cache->lru_tail = head;
+  head = cache->rr_head;
+  cache->rr_head = (head + 1) & (DWARF_UNW_CACHE_SIZE(cache->log_size) - 1);
 
   /* remove the old rs from the hash table (if it's there): */
-  if (rs->ip)
+  if (cache->links[head].ip)
     {
-      index = hash (rs->ip);
-      tmp = cache->buckets + cache->hash[index];
-      prev = NULL;
-      while (1)
+      unsigned short *pindex;
+      for (pindex = &cache->hash[hash (cache->links[head].ip, cache->log_size)];
+	   *pindex < DWARF_UNW_CACHE_SIZE(cache->log_size);
+	   pindex = &cache->links[*pindex].coll_chain)
 	{
-	  if (tmp == rs)
+	  if (*pindex == head)
 	    {
-	      if (prev)
-		prev->coll_chain = tmp->coll_chain;
-	      else
-		cache->hash[index] = tmp->coll_chain;
+	      *pindex = cache->links[*pindex].coll_chain;
 	      break;
 	    }
-	  else
-	    prev = tmp;
-	  if (tmp->coll_chain >= DWARF_UNW_CACHE_SIZE)
-	    /* old rs wasn't in the hash-table */
-	    break;
-	  tmp = cache->buckets + tmp->coll_chain;
 	}
     }
 
   /* enter new rs in the hash table */
-  index = hash (c->ip);
-  rs->coll_chain = cache->hash[index];
-  cache->hash[index] = rs - cache->buckets;
-
-  rs->hint = 0;
-  rs->ip = c->ip;
-  rs->valid = 1;
-  rs->ret_addr_column = c->ret_addr_column;
-  rs->signal_frame = 0;
-  tdep_cache_frame (c, rs);
-
-  return rs;
+  index = hash (c->ip, cache->log_size);
+  cache->links[head].coll_chain = cache->hash[index];
+  cache->hash[index] = head;
+
+  cache->links[head].ip = c->ip;
+  cache->links[head].valid = 1;
+  cache->links[head].signal_frame = tdep_cache_frame(c);
+  return cache->buckets + head;
 }
 
 static int
 create_state_record_for (struct dwarf_cursor *c, dwarf_state_record_t *sr,
-			 unw_word_t ip)
+                         unw_word_t ip)
 {
-  int i, ret;
-
-  assert (c->pi_valid);
-
-  memset (sr, 0, sizeof (*sr));
-  for (i = 0; i < DWARF_NUM_PRESERVED_REGS + 2; ++i)
-    set_reg (sr, i, DWARF_WHERE_SAME, 0);
-
+  int ret;
   switch (c->pi.format)
     {
     case UNW_INFO_FORMAT_TABLE:
     case UNW_INFO_FORMAT_REMOTE_TABLE:
+      if ((ret = setup_fde(c, sr)) < 0)
+	return ret;
       ret = parse_fde (c, ip, sr);
       break;
 
@@ -686,9 +734,9 @@ create_state_record_for (struct dwarf_cursor *c, dwarf_state_record_t *sr,
 }
 
 static inline int
-eval_location_expr (struct dwarf_cursor *c, unw_addr_space_t as,
-		    unw_accessors_t *a, unw_word_t addr,
-		    dwarf_loc_t *locp, void *arg)
+eval_location_expr (struct dwarf_cursor *c, unw_word_t stack_val, unw_addr_space_t as,
+                    unw_accessors_t *a, unw_word_t addr,
+                    dwarf_loc_t *locp, void *arg)
 {
   int ret, is_register;
   unw_word_t len, val;
@@ -698,7 +746,7 @@ eval_location_expr (struct dwarf_cursor *c, unw_addr_space_t as,
     return ret;
 
   /* evaluate the expression: */
-  if ((ret = dwarf_eval_expr (c, &addr, len, &val, &is_register)) < 0)
+  if ((ret = dwarf_eval_expr (c, stack_val, &addr, len, &val, &is_register)) < 0)
     return ret;
 
   if (is_register)
@@ -725,174 +773,198 @@ apply_reg_state (struct dwarf_cursor *c, struct dwarf_reg_state *rs)
 
   as = c->as;
   arg = c->as_arg;
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
 
   /* Evaluate the CFA first, because it may be referred to by other
      expressions.  */
 
-  if (rs->reg[DWARF_CFA_REG_COLUMN].where == DWARF_WHERE_REG)
+  if (rs->reg.where[DWARF_CFA_REG_COLUMN] == DWARF_WHERE_REG)
     {
       /* CFA is equal to [reg] + offset: */
 
       /* As a special-case, if the stack-pointer is the CFA and the
-	 stack-pointer wasn't saved, popping the CFA implicitly pops
-	 the stack-pointer as well.  */
-      if ((rs->reg[DWARF_CFA_REG_COLUMN].val == UNW_TDEP_SP)
-          && (UNW_TDEP_SP < ARRAY_SIZE(rs->reg))
-	  && (rs->reg[UNW_TDEP_SP].where == DWARF_WHERE_SAME))
-	  cfa = c->cfa;
+         stack-pointer wasn't saved, popping the CFA implicitly pops
+         the stack-pointer as well.  */
+      if ((rs->reg.val[DWARF_CFA_REG_COLUMN] == UNW_TDEP_SP)
+          && (UNW_TDEP_SP < ARRAY_SIZE(rs->reg.val))
+          && (rs->reg.where[UNW_TDEP_SP] == DWARF_WHERE_SAME))
+          cfa = c->cfa;
       else
-	{
-	  regnum = dwarf_to_unw_regnum (rs->reg[DWARF_CFA_REG_COLUMN].val);
-	  if ((ret = unw_get_reg ((unw_cursor_t *) c, regnum, &cfa)) < 0)
-	    return ret;
-	}
-      cfa += rs->reg[DWARF_CFA_OFF_COLUMN].val;
+        {
+          regnum = dwarf_to_unw_regnum (rs->reg.val[DWARF_CFA_REG_COLUMN]);
+          if ((ret = unw_get_reg ((unw_cursor_t *) c, regnum, &cfa)) < 0)
+            return ret;
+        }
+      cfa += rs->reg.val[DWARF_CFA_OFF_COLUMN];
     }
   else
     {
       /* CFA is equal to EXPR: */
 
-      assert (rs->reg[DWARF_CFA_REG_COLUMN].where == DWARF_WHERE_EXPR);
+      assert (rs->reg.where[DWARF_CFA_REG_COLUMN] == DWARF_WHERE_EXPR);
 
-      addr = rs->reg[DWARF_CFA_REG_COLUMN].val;
-      if ((ret = eval_location_expr (c, as, a, addr, &cfa_loc, arg)) < 0)
-	return ret;
+      addr = rs->reg.val[DWARF_CFA_REG_COLUMN];
+      /* The dwarf standard doesn't specify an initial value to be pushed on */
+      /* the stack before DW_CFA_def_cfa_expression evaluation. We push on a */
+      /* dummy value (0) to keep the eval_location_expr function consistent. */
+      if ((ret = eval_location_expr (c, 0, as, a, addr, &cfa_loc, arg)) < 0)
+        return ret;
       /* the returned location better be a memory location... */
       if (DWARF_IS_REG_LOC (cfa_loc))
-	return -UNW_EBADFRAME;
+        return -UNW_EBADFRAME;
       cfa = DWARF_GET_LOC (cfa_loc);
     }
 
+  dwarf_loc_t new_loc[DWARF_NUM_PRESERVED_REGS];
+  memcpy(new_loc, c->loc, sizeof(new_loc));
+
   for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
     {
-      switch ((dwarf_where_t) rs->reg[i].where)
-	{
-	case DWARF_WHERE_UNDEF:
-	  c->loc[i] = DWARF_NULL_LOC;
-	  break;
-
-	case DWARF_WHERE_SAME:
-	  break;
-
-	case DWARF_WHERE_CFAREL:
-	  c->loc[i] = DWARF_MEM_LOC (c, cfa + rs->reg[i].val);
-	  break;
-
-	case DWARF_WHERE_REG:
-	  c->loc[i] = DWARF_REG_LOC (c, dwarf_to_unw_regnum (rs->reg[i].val));
-	  break;
-
-	case DWARF_WHERE_EXPR:
-	  addr = rs->reg[i].val;
-	  if ((ret = eval_location_expr (c, as, a, addr, c->loc + i, arg)) < 0)
-	    return ret;
-	  break;
-	}
+      switch ((dwarf_where_t) rs->reg.where[i])
+        {
+        case DWARF_WHERE_UNDEF:
+          new_loc[i] = DWARF_NULL_LOC;
+          break;
+
+        case DWARF_WHERE_SAME:
+          break;
+
+        case DWARF_WHERE_CFAREL:
+          new_loc[i] = DWARF_MEM_LOC (c, cfa + rs->reg.val[i]);
+          break;
+
+        case DWARF_WHERE_REG:
+#ifdef __s390x__
+          /* GPRs can be saved in FPRs on s390x */
+          if (unw_is_fpreg (dwarf_to_unw_regnum (rs->reg.val[i])))
+            {
+              new_loc[i] = DWARF_FPREG_LOC (c, dwarf_to_unw_regnum (rs->reg.val[i]));
+              break;
+            }
+#endif
+          new_loc[i] = new_loc[rs->reg.val[i]];
+          break;
+
+        case DWARF_WHERE_EXPR:
+          addr = rs->reg.val[i];
+          /* The dwarf standard requires the current CFA to be pushed on the */
+          /* stack before DW_CFA_expression evaluation. */
+          if ((ret = eval_location_expr (c, cfa, as, a, addr, new_loc + i, arg)) < 0)
+            return ret;
+          break;
+
+        case DWARF_WHERE_VAL_EXPR:
+          addr = rs->reg.val[i];
+          /* The dwarf standard requires the current CFA to be pushed on the */
+          /* stack before DW_CFA_val_expression evaluation. */
+          if ((ret = eval_location_expr (c, cfa, as, a, addr, new_loc + i, arg)) < 0)
+            return ret;
+          new_loc[i] = DWARF_VAL_LOC (c, DWARF_GET_LOC (new_loc[i]));
+          break;
+        }
     }
 
+  memcpy(c->loc, new_loc, sizeof(new_loc));
+
   c->cfa = cfa;
   /* DWARF spec says undefined return address location means end of stack. */
-  if (DWARF_IS_NULL_LOC (c->loc[c->ret_addr_column]))
-    c->ip = 0;
+  if (DWARF_IS_NULL_LOC (c->loc[rs->ret_addr_column]))
+    {
+      c->ip = 0;
+      ret = 0;
+    }
   else
   {
-    ret = dwarf_get (c, c->loc[c->ret_addr_column], &ip);
+    ret = dwarf_get (c, c->loc[rs->ret_addr_column], &ip);
     if (ret < 0)
       return ret;
     c->ip = ip;
+    ret = 1;
   }
 
   /* XXX: check for ip to be code_aligned */
   if (c->ip == prev_ip && c->cfa == prev_cfa)
     {
       Dprintf ("%s: ip and cfa unchanged; stopping here (ip=0x%lx)\n",
-	       __FUNCTION__, (long) c->ip);
+               __FUNCTION__, (long) c->ip);
       return -UNW_EBADFRAME;
     }
 
   if (c->stash_frames)
     tdep_stash_frame (c, rs);
 
-  return 0;
+  return ret;
 }
 
+/* Find the saved locations. */
 static int
-uncached_dwarf_find_save_locs (struct dwarf_cursor *c)
+find_reg_state (struct dwarf_cursor *c, dwarf_state_record_t *sr)
 {
-  dwarf_state_record_t sr;
-  int ret;
-
-  if ((ret = fetch_proc_info (c, c->ip, 1)) < 0)
-    return ret;
-
-  if ((ret = create_state_record_for (c, &sr, c->ip)) < 0)
-    return ret;
-
-  if ((ret = apply_reg_state (c, &sr.rs_current)) < 0)
-    return ret;
-
-  put_unwind_info (c, &c->pi);
-  return 0;
-}
-
-/* The function finds the saved locations and applies the register
-   state as well. */
-HIDDEN int
-dwarf_find_save_locs (struct dwarf_cursor *c)
-{
-  dwarf_state_record_t sr;
-  dwarf_reg_state_t *rs, rs_copy;
+  dwarf_reg_state_t *rs;
   struct dwarf_rs_cache *cache;
   int ret = 0;
   intrmask_t saved_mask;
 
-  if (c->as->caching_policy == UNW_CACHE_NONE)
-    return uncached_dwarf_find_save_locs (c);
-
-  cache = get_rs_cache(c->as, &saved_mask);
-  rs = rs_lookup(cache, c);
-
-  if (rs)
+  if ((cache = get_rs_cache(c->as, &saved_mask)) &&
+      (rs = rs_lookup(cache, c)))
     {
-      c->ret_addr_column = rs->ret_addr_column;
-      c->use_prev_instr = ! rs->signal_frame;
+      /* update hint; no locking needed: single-word writes are atomic */
+      unsigned short index = rs - cache->buckets;
+      c->use_prev_instr = ! cache->links[index].signal_frame;
+      memcpy (&sr->rs_current, rs, sizeof (*rs));
     }
   else
     {
-      if ((ret = fetch_proc_info (c, c->ip, 1)) < 0 ||
-	  (ret = create_state_record_for (c, &sr, c->ip)) < 0)
+      ret = fetch_proc_info (c, c->ip);
+      int next_use_prev_instr = c->use_prev_instr;
+      if (ret >= 0)
 	{
-	  put_rs_cache (c->as, cache, &saved_mask);
-	  return ret;
+	  /* Update use_prev_instr for the next frame. */
+	  assert(c->pi.unwind_info);
+	  struct dwarf_cie_info *dci = c->pi.unwind_info;
+	  next_use_prev_instr = ! dci->signal_frame;
+	  ret = create_state_record_for (c, sr, c->ip);
 	}
-
-      rs = rs_new (cache, c);
-      memcpy(rs, &sr.rs_current, offsetof(struct dwarf_reg_state, ip));
-      cache->buckets[c->prev_rs].hint = rs - cache->buckets;
-
-      c->hint = rs->hint;
-      c->prev_rs = rs - cache->buckets;
-
       put_unwind_info (c, &c->pi);
-    }
-
-  memcpy (&rs_copy, rs, sizeof (rs_copy));
-  put_rs_cache (c->as, cache, &saved_mask);
+      c->use_prev_instr = next_use_prev_instr;
 
-  tdep_reuse_frame (c, &rs_copy);
-  if ((ret = apply_reg_state (c, &rs_copy)) < 0)
-    return ret;
+      if (cache && ret >= 0)
+	{
+	  rs = rs_new (cache, c);
+	  cache->links[rs - cache->buckets].hint = 0;
+	  memcpy(rs, &sr->rs_current, sizeof(*rs));
+	}
+    }
 
+  unsigned short index = -1;
+  if (cache)
+    {
+      if (rs)
+	{
+	  index = rs - cache->buckets;
+	  c->hint = cache->links[index].hint;
+	  cache->links[c->prev_rs].hint = index + 1;
+	  c->prev_rs = index;
+	}
+      put_rs_cache (c->as, cache, &saved_mask);
+    }
+  if (ret < 0)
+      return ret;
+  if (cache)
+    tdep_reuse_frame (c, cache->links[index].signal_frame);
   return 0;
 }
 
-/* The proc-info must be valid for IP before this routine can be
-   called.  */
+/* The function finds the saved locations and applies the register
+   state as well. */
 HIDDEN int
-dwarf_create_state_record (struct dwarf_cursor *c, dwarf_state_record_t *sr)
+dwarf_step (struct dwarf_cursor *c)
 {
-  return create_state_record_for (c, sr, c->ip);
+  int ret;
+  dwarf_state_record_t sr;
+  if ((ret = find_reg_state (c, &sr)) < 0)
+    return ret;
+  return apply_reg_state (c, &sr.rs_current);
 }
 
 HIDDEN int
@@ -902,7 +974,101 @@ dwarf_make_proc_info (struct dwarf_cursor *c)
   if (c->as->caching_policy == UNW_CACHE_NONE
       || get_cached_proc_info (c) < 0)
 #endif
-    /* Lookup it up the slow way... */
-    return fetch_proc_info (c, c->ip, 0);
+  /* Need to check if current frame contains
+     args_size, and set cursor appropriately.  Only
+     needed for unw_resume */
+  dwarf_state_record_t sr;
+  int ret;
+
+  /* Lookup it up the slow way... */
+  ret = fetch_proc_info (c, c->ip);
+  if (ret >= 0)
+      ret = create_state_record_for (c, &sr, c->ip);
+  put_unwind_info (c, &c->pi);
+  if (ret < 0)
+    return ret;
+  c->args_size = sr.args_size;
+
   return 0;
 }
+
+static int
+dwarf_reg_states_dynamic_iterate(struct dwarf_cursor *c,
+				 unw_reg_states_callback cb,
+				 void *token)
+{
+  Debug (1, "Not yet implemented\n");
+  return -UNW_ENOINFO;
+}
+
+static int
+dwarf_reg_states_table_iterate(struct dwarf_cursor *c,
+			       unw_reg_states_callback cb,
+			       void *token)
+{
+  dwarf_state_record_t sr;
+  int ret = setup_fde(c, &sr);
+  struct dwarf_cie_info *dci = c->pi.unwind_info;
+  unw_word_t addr = dci->fde_instr_start;
+  unw_word_t curr_ip = c->pi.start_ip;
+  dwarf_stackable_reg_state_t *rs_stack = NULL;
+  while (ret >= 0 && curr_ip < c->pi.end_ip && addr < dci->fde_instr_end)
+    {
+      unw_word_t prev_ip = curr_ip;
+      ret = run_cfi_program (c, &sr, &curr_ip, prev_ip, &addr, dci->fde_instr_end,
+			     &rs_stack, dci);
+      if (ret >= 0 && prev_ip < curr_ip)
+	ret = cb(token, &sr.rs_current, sizeof(sr.rs_current), prev_ip, curr_ip);
+    }
+  empty_rstate_stack(&rs_stack);
+#if defined(NEED_LAST_IP)
+  if (ret >= 0 && curr_ip < c->pi.last_ip)
+    /* report the dead zone after the procedure ends */
+    ret = cb(token, &sr.rs_current, sizeof(sr.rs_current), curr_ip, c->pi.last_ip);
+#else
+  if (ret >= 0 && curr_ip < c->pi.end_ip)
+    /* report for whatever is left before procedure end */
+    ret = cb(token, &sr.rs_current, sizeof(sr.rs_current), curr_ip, c->pi.end_ip);
+#endif
+  return ret;
+}
+
+HIDDEN int
+dwarf_reg_states_iterate(struct dwarf_cursor *c,
+			 unw_reg_states_callback cb,
+			 void *token)
+{
+  int ret = fetch_proc_info (c, c->ip);
+  int next_use_prev_instr = c->use_prev_instr;
+  if (ret >= 0)
+    {
+      /* Update use_prev_instr for the next frame. */
+      assert(c->pi.unwind_info);
+      struct dwarf_cie_info *dci = c->pi.unwind_info;
+      next_use_prev_instr = ! dci->signal_frame;
+      switch (c->pi.format)
+	{
+	case UNW_INFO_FORMAT_TABLE:
+	case UNW_INFO_FORMAT_REMOTE_TABLE:
+	  ret = dwarf_reg_states_table_iterate(c, cb, token);
+	  break;
+
+	case UNW_INFO_FORMAT_DYNAMIC:
+	  ret = dwarf_reg_states_dynamic_iterate (c, cb, token);
+	  break;
+
+	default:
+	  Debug (1, "Unexpected unwind-info format %d\n", c->pi.format);
+	  ret = -UNW_EINVAL;
+	}
+    }
+  put_unwind_info (c, &c->pi);
+  c->use_prev_instr = next_use_prev_instr;
+  return ret;
+}
+
+HIDDEN int
+dwarf_apply_reg_state (struct dwarf_cursor *c, struct dwarf_reg_state *rs)
+{
+  return apply_reg_state(c, rs);
+}
diff --git a/src/dwarf/Gpe.c b/src/dwarf/Gpe.c
index c271d76..a0e37ba 100644
--- a/src/dwarf/Gpe.c
+++ b/src/dwarf/Gpe.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -30,10 +30,10 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 dwarf_read_encoded_pointer (unw_addr_space_t as, unw_accessors_t *a,
-			    unw_word_t *addr, unsigned char encoding,
-			    const unw_proc_info_t *pi,
-			    unw_word_t *valp, void *arg)
+                            unw_word_t *addr, unsigned char encoding,
+                            const unw_proc_info_t *pi,
+                            unw_word_t *valp, void *arg)
 {
   return dwarf_read_encoded_pointer_inlined (as, a, addr, encoding,
-					     pi, valp, arg);
+                                             pi, valp, arg);
 }
diff --git a/src/dwarf/global.c b/src/dwarf/global.c
index 4658ccf..7098507 100644
--- a/src/dwarf/global.c
+++ b/src/dwarf/global.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003-2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -31,7 +31,7 @@ HIDDEN struct mempool dwarf_cie_info_pool;
 HIDDEN int
 dwarf_init (void)
 {
-  mempool_init (&dwarf_reg_state_pool, sizeof (dwarf_reg_state_t), 0);
+  mempool_init (&dwarf_reg_state_pool, sizeof (dwarf_stackable_reg_state_t), 0);
   mempool_init (&dwarf_cie_info_pool, sizeof (struct dwarf_cie_info), 0);
   return 0;
 }
diff --git a/src/elf32.h b/src/elf32.h
index 63fef83..2c7bca4 100644
--- a/src/elf32.h
+++ b/src/elf32.h
@@ -2,7 +2,7 @@
 #define elf32_h
 
 #ifndef ELF_CLASS
-#define ELF_CLASS	ELFCLASS32
+#define ELF_CLASS       ELFCLASS32
 #endif
 #include "elfxx.h"
 
diff --git a/src/elf64.h b/src/elf64.h
index fd10ed8..091fba8 100644
--- a/src/elf64.h
+++ b/src/elf64.h
@@ -2,7 +2,7 @@
 #define elf64_h
 
 #ifndef ELF_CLASS
-#define ELF_CLASS	ELFCLASS64
+#define ELF_CLASS       ELFCLASS64
 #endif
 #include "elfxx.h"
 
diff --git a/src/elfxx.c b/src/elfxx.c
index 3d87331..b03dfcb 100644
--- a/src/elfxx.c
+++ b/src/elfxx.c
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -43,8 +43,8 @@ elf_w (section_table) (struct elf_image *ei)
   if (soff + ehdr->e_shnum * ehdr->e_shentsize > ei->size)
     {
       Debug (1, "section table outside of image? (%lu > %lu)\n",
-	     (unsigned long) (soff + ehdr->e_shnum * ehdr->e_shentsize),
-	     (unsigned long) ei->size);
+             (unsigned long) (soff + ehdr->e_shnum * ehdr->e_shentsize),
+             (unsigned long) ei->size);
       return NULL;
     }
 
@@ -65,8 +65,8 @@ elf_w (string_table) (struct elf_image *ei, int section)
   if (str_soff + ehdr->e_shentsize > ei->size)
     {
       Debug (1, "string shdr table outside of image? (%lu > %lu)\n",
-	     (unsigned long) (str_soff + ehdr->e_shentsize),
-	     (unsigned long) ei->size);
+             (unsigned long) (str_soff + ehdr->e_shentsize),
+             (unsigned long) ei->size);
       return NULL;
     }
   str_shdr = (Elf_W (Shdr) *) ((char *) ei->image + str_soff);
@@ -74,8 +74,8 @@ elf_w (string_table) (struct elf_image *ei, int section)
   if (str_shdr->sh_offset + str_shdr->sh_size > ei->size)
     {
       Debug (1, "string table outside of image? (%lu > %lu)\n",
-	     (unsigned long) (str_shdr->sh_offset + str_shdr->sh_size),
-	     (unsigned long) ei->size);
+             (unsigned long) (str_shdr->sh_offset + str_shdr->sh_size),
+             (unsigned long) ei->size);
       return NULL;
     }
 
@@ -85,9 +85,9 @@ elf_w (string_table) (struct elf_image *ei, int section)
 
 static int
 elf_w (lookup_symbol) (unw_addr_space_t as,
-		       unw_word_t ip, struct elf_image *ei,
-		       Elf_W (Addr) load_offset,
-		       char *buf, size_t buf_len, Elf_W (Addr) *min_dist)
+                       unw_word_t ip, struct elf_image *ei,
+                       Elf_W (Addr) load_offset,
+                       char *buf, size_t buf_len, Elf_W (Addr) *min_dist)
 {
   size_t syment_size;
   Elf_W (Ehdr) *ehdr = ei->image;
@@ -107,49 +107,50 @@ elf_w (lookup_symbol) (unw_addr_space_t as,
   for (i = 0; i < ehdr->e_shnum; ++i)
     {
       switch (shdr->sh_type)
-	{
-	case SHT_SYMTAB:
-	case SHT_DYNSYM:
-	  symtab = (Elf_W (Sym) *) ((char *) ei->image + shdr->sh_offset);
-	  symtab_end = (Elf_W (Sym) *) ((char *) symtab + shdr->sh_size);
-	  syment_size = shdr->sh_entsize;
-
-	  strtab = elf_w (string_table) (ei, shdr->sh_link);
-	  if (!strtab)
-	    break;
-
-	  Debug (16, "symtab=0x%lx[%d]\n",
-		 (long) shdr->sh_offset, shdr->sh_type);
-
-	  for (sym = symtab;
-	       sym < symtab_end;
-	       sym = (Elf_W (Sym) *) ((char *) sym + syment_size))
-	    {
-	      if (ELF_W (ST_TYPE) (sym->st_info) == STT_FUNC
-		  && sym->st_shndx != SHN_UNDEF)
-		{
-		  if (tdep_get_func_addr (as, sym->st_value, &val) < 0)
-		    continue;
-		  if (sym->st_shndx != SHN_ABS)
-		    val += load_offset;
-		  Debug (16, "0x%016lx info=0x%02x %s\n",
-			 (long) val, sym->st_info, strtab + sym->st_name);
-
-		  if ((Elf_W (Addr)) (ip - val) < *min_dist)
-		    {
-		      *min_dist = (Elf_W (Addr)) (ip - val);
-		      strncpy (buf, strtab + sym->st_name, buf_len);
-		      buf[buf_len - 1] = '\0';
-		      ret = (strlen (strtab + sym->st_name) >= buf_len
-			     ? -UNW_ENOMEM : 0);
-		    }
-		}
-	    }
-	  break;
-
-	default:
-	  break;
-	}
+        {
+        case SHT_SYMTAB:
+        case SHT_DYNSYM:
+          symtab = (Elf_W (Sym) *) ((char *) ei->image + shdr->sh_offset);
+          symtab_end = (Elf_W (Sym) *) ((char *) symtab + shdr->sh_size);
+          syment_size = shdr->sh_entsize;
+
+          strtab = elf_w (string_table) (ei, shdr->sh_link);
+          if (!strtab)
+            break;
+
+          Debug (16, "symtab=0x%lx[%d]\n",
+                 (long) shdr->sh_offset, shdr->sh_type);
+
+          for (sym = symtab;
+               sym < symtab_end;
+               sym = (Elf_W (Sym) *) ((char *) sym + syment_size))
+            {
+              if (ELF_W (ST_TYPE) (sym->st_info) == STT_FUNC
+                  && sym->st_shndx != SHN_UNDEF)
+                {
+                  val = sym->st_value;
+                  if (sym->st_shndx != SHN_ABS)
+                    val += load_offset;
+                  if (tdep_get_func_addr (as, val, &val) < 0)
+                    continue;
+                  Debug (16, "0x%016lx info=0x%02x %s\n",
+                         (long) val, sym->st_info, strtab + sym->st_name);
+
+                  if ((Elf_W (Addr)) (ip - val) < *min_dist)
+                    {
+                      *min_dist = (Elf_W (Addr)) (ip - val);
+                      strncpy (buf, strtab + sym->st_name, buf_len);
+                      buf[buf_len - 1] = '\0';
+                      ret = (strlen (strtab + sym->st_name) >= buf_len
+                             ? -UNW_ENOMEM : 0);
+                    }
+                }
+            }
+          break;
+
+        default:
+          break;
+        }
       shdr = (Elf_W (Shdr) *) (((char *) shdr) + ehdr->e_shentsize);
     }
   return ret;
@@ -157,7 +158,7 @@ elf_w (lookup_symbol) (unw_addr_space_t as,
 
 static Elf_W (Addr)
 elf_w (get_load_offset) (struct elf_image *ei, unsigned long segbase,
-			 unsigned long mapoff)
+                         unsigned long mapoff)
 {
   Elf_W (Addr) offset = 0;
   Elf_W (Ehdr) *ehdr;
@@ -170,8 +171,8 @@ elf_w (get_load_offset) (struct elf_image *ei, unsigned long segbase,
   for (i = 0; i < ehdr->e_phnum; ++i)
     if (phdr[i].p_type == PT_LOAD && phdr[i].p_offset == mapoff)
       {
-	offset = segbase - phdr[i].p_vaddr;
-	break;
+        offset = segbase - phdr[i].p_vaddr;
+        break;
       }
 
   return offset;
@@ -198,7 +199,7 @@ xz_uncompressed_size (uint8_t *compressed, size_t length)
 
   uint8_t *indexdata = footer - options.backward_size;
   if (lzma_index_buffer_decode (&index, &memlimit, NULL, indexdata,
-				&pos, options.backward_size) != LZMA_OK)
+                                &pos, options.backward_size) != LZMA_OK)
     return 0;
 
   if (lzma_index_size (index) == options.backward_size)
@@ -213,50 +214,17 @@ xz_uncompressed_size (uint8_t *compressed, size_t length)
 static int
 elf_w (extract_minidebuginfo) (struct elf_image *ei, struct elf_image *mdi)
 {
-  Elf_W (Ehdr) *ehdr = ei->image;
   Elf_W (Shdr) *shdr;
-  char *strtab;
-  int i;
   uint8_t *compressed = NULL;
   uint64_t memlimit = UINT64_MAX; /* no memory limit */
   size_t compressed_len, uncompressed_len;
 
-  if (!elf_w (valid_object) (ei))
-    return 0;
-
-  shdr = elf_w (section_table) (ei);
+  shdr = elf_w (find_section) (ei, ".gnu_debugdata");
   if (!shdr)
     return 0;
 
-  strtab = elf_w (string_table) (ei, ehdr->e_shstrndx);
-  if (!strtab)
-    return 0;
-
-  for (i = 0; i < ehdr->e_shnum; ++i)
-    {
-      if (strcmp (strtab + shdr->sh_name, ".gnu_debugdata") == 0)
-	{
-	  if (shdr->sh_offset + shdr->sh_size > ei->size)
-	    {
-	      Debug (1, ".gnu_debugdata outside image? (0x%lu > 0x%lu)\n",
-		     (unsigned long) shdr->sh_offset + shdr->sh_size,
-		     (unsigned long) ei->size);
-	      return 0;
-	    }
-
-	  Debug (16, "found .gnu_debugdata at 0x%lx\n",
-		 (unsigned long) shdr->sh_offset);
-	  compressed = ((uint8_t *) ei->image) + shdr->sh_offset;
-	  compressed_len = shdr->sh_size;
-	  break;
-	}
-
-      shdr = (Elf_W (Shdr) *) (((char *) shdr) + ehdr->e_shentsize);
-    }
-
-  /* not found */
-  if (!compressed)
-    return 0;
+  compressed = ((uint8_t *) ei->image) + shdr->sh_offset;
+  compressed_len = shdr->sh_size;
 
   uncompressed_len = xz_uncompressed_size (compressed, compressed_len);
   if (uncompressed_len == 0)
@@ -267,7 +235,7 @@ elf_w (extract_minidebuginfo) (struct elf_image *ei, struct elf_image *mdi)
 
   mdi->size = uncompressed_len;
   mdi->image = mmap (NULL, uncompressed_len, PROT_READ|PROT_WRITE,
-		     MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+                     MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
 
   if (mdi->image == MAP_FAILED)
     return 0;
@@ -275,8 +243,8 @@ elf_w (extract_minidebuginfo) (struct elf_image *ei, struct elf_image *mdi)
   size_t in_pos = 0, out_pos = 0;
   lzma_ret lret;
   lret = lzma_stream_buffer_decode (&memlimit, 0, NULL,
-				    compressed, &in_pos, compressed_len,
-				    mdi->image, &out_pos, mdi->size);
+                                    compressed, &in_pos, compressed_len,
+                                    mdi->image, &out_pos, mdi->size);
   if (lret != LZMA_OK)
     {
       Debug (1, "LZMA decompression failed: %d\n", lret);
@@ -301,10 +269,10 @@ elf_w (extract_minidebuginfo) (struct elf_image *ei, struct elf_image *mdi)
 
 HIDDEN int
 elf_w (get_proc_name_in_image) (unw_addr_space_t as, struct elf_image *ei,
-		       unsigned long segbase,
-		       unsigned long mapoff,
-		       unw_word_t ip,
-		       char *buf, size_t buf_len, unw_word_t *offp)
+                       unsigned long segbase,
+                       unsigned long mapoff,
+                       unw_word_t ip,
+                       char *buf, size_t buf_len, unw_word_t *offp)
 {
   Elf_W (Addr) load_offset;
   Elf_W (Addr) min_dist = ~(Elf_W (Addr))0;
@@ -318,23 +286,20 @@ elf_w (get_proc_name_in_image) (unw_addr_space_t as, struct elf_image *ei,
   struct elf_image mdi;
   if (elf_w (extract_minidebuginfo) (ei, &mdi))
     {
-      int ret_mdi;
-
-      load_offset = elf_w (get_load_offset) (&mdi, segbase, mapoff);
-      ret_mdi = elf_w (lookup_symbol) (as, ip, &mdi, load_offset, buf,
-				       buf_len, &min_dist);
+      int ret_mdi = elf_w (lookup_symbol) (as, ip, &mdi, load_offset, buf,
+                                           buf_len, &min_dist);
 
       /* Closer symbol was found (possibly truncated). */
       if (ret_mdi == 0 || ret_mdi == -UNW_ENOMEM)
-	{
-	  ret = ret_mdi;
-	}
+        {
+          ret = ret_mdi;
+        }
 
       munmap (mdi.image, mdi.size);
     }
 
   if (min_dist >= ei->size)
-    return -UNW_ENOINFO;		/* not found */
+    return -UNW_ENOINFO;                /* not found */
   if (offp)
     *offp = min_dist;
   return ret;
@@ -342,13 +307,18 @@ elf_w (get_proc_name_in_image) (unw_addr_space_t as, struct elf_image *ei,
 
 HIDDEN int
 elf_w (get_proc_name) (unw_addr_space_t as, pid_t pid, unw_word_t ip,
-		       char *buf, size_t buf_len, unw_word_t *offp)
+                       char *buf, size_t buf_len, unw_word_t *offp)
 {
   unsigned long segbase, mapoff;
   struct elf_image ei;
   int ret;
+  char file[PATH_MAX];
+
+  ret = tdep_get_elf_image (&ei, pid, ip, &segbase, &mapoff, file, PATH_MAX);
+  if (ret < 0)
+    return ret;
 
-  ret = tdep_get_elf_image (&ei, pid, ip, &segbase, &mapoff, NULL, 0);
+  ret = elf_w (load_debuglink) (file, &ei, 1);
   if (ret < 0)
     return ret;
 
@@ -359,3 +329,153 @@ elf_w (get_proc_name) (unw_addr_space_t as, pid_t pid, unw_word_t ip,
 
   return ret;
 }
+
+HIDDEN Elf_W (Shdr)*
+elf_w (find_section) (struct elf_image *ei, const char* secname)
+{
+  Elf_W (Ehdr) *ehdr = ei->image;
+  Elf_W (Shdr) *shdr;
+  char *strtab;
+  int i;
+
+  if (!elf_w (valid_object) (ei))
+    return 0;
+
+  shdr = elf_w (section_table) (ei);
+  if (!shdr)
+    return 0;
+
+  strtab = elf_w (string_table) (ei, ehdr->e_shstrndx);
+  if (!strtab)
+    return 0;
+
+  for (i = 0; i < ehdr->e_shnum; ++i)
+    {
+      if (strcmp (strtab + shdr->sh_name, secname) == 0)
+        {
+          if (shdr->sh_offset + shdr->sh_size > ei->size)
+            {
+              Debug (1, "section \"%s\" outside image? (0x%lu > 0x%lu)\n",
+                     secname,
+                     (unsigned long) shdr->sh_offset + shdr->sh_size,
+                     (unsigned long) ei->size);
+              return 0;
+            }
+
+          Debug (16, "found section \"%s\" at 0x%lx\n",
+                 secname, (unsigned long) shdr->sh_offset);
+          return shdr;
+        }
+
+      shdr = (Elf_W (Shdr) *) (((char *) shdr) + ehdr->e_shentsize);
+    }
+
+  /* section not found */
+  return 0;
+}
+
+/* Load a debug section, following .gnu_debuglink if appropriate
+ * Loads ei from file if not already mapped.
+ * If is_local, will also search sys directories /usr/local/dbg
+ *
+ * Returns 0 on success, failure otherwise.
+ * ei will be mapped to file or the located .gnu_debuglink from file
+ */
+HIDDEN int
+elf_w (load_debuglink) (const char* file, struct elf_image *ei, int is_local)
+{
+  int ret;
+  Elf_W (Shdr) *shdr;
+  Elf_W (Ehdr) *prev_image;
+  off_t prev_size;
+
+  if (!ei->image)
+    {
+      ret = elf_map_image(ei, file);
+      if (ret)
+	return ret;
+    }
+
+  prev_image = ei->image;
+  prev_size = ei->size;
+
+  /* Ignore separate debug files which contain a .gnu_debuglink section. */
+  if (is_local == -1) {
+    return 0;
+  }
+
+  shdr = elf_w (find_section) (ei, ".gnu_debuglink");
+  if (shdr) {
+    if (shdr->sh_size >= PATH_MAX ||
+	(shdr->sh_offset + shdr->sh_size > ei->size))
+      {
+	return 0;
+      }
+
+    {
+      char linkbuf[shdr->sh_size];
+      char *link = ((char *) ei->image) + shdr->sh_offset;
+      char *p;
+      static const char *debugdir = "/usr/lib/debug";
+      char basedir[strlen(file) + 1];
+      char newname[shdr->sh_size + strlen (debugdir) + strlen (file) + 9];
+
+      memcpy(linkbuf, link, shdr->sh_size);
+
+      if (memchr (linkbuf, 0, shdr->sh_size) == NULL)
+	return 0;
+
+      ei->image = NULL;
+
+      Debug(1, "Found debuglink section, following %s\n", linkbuf);
+
+      p = strrchr (file, '/');
+      if (p != NULL)
+	{
+	  memcpy (basedir, file, p - file);
+	  basedir[p - file] = '\0';
+	}
+      else
+	basedir[0] = 0;
+
+      strcpy (newname, basedir);
+      strcat (newname, "/");
+      strcat (newname, linkbuf);
+      ret = elf_w (load_debuglink) (newname, ei, -1);
+
+      if (ret == -1)
+	{
+	  strcpy (newname, basedir);
+	  strcat (newname, "/.debug/");
+	  strcat (newname, linkbuf);
+	  ret = elf_w (load_debuglink) (newname, ei, -1);
+	}
+
+      if (ret == -1 && is_local == 1)
+	{
+	  strcpy (newname, debugdir);
+	  strcat (newname, basedir);
+	  strcat (newname, "/");
+	  strcat (newname, linkbuf);
+	  ret = elf_w (load_debuglink) (newname, ei, -1);
+	}
+
+      if (ret == -1)
+        {
+          /* No debuglink file found even though .gnu_debuglink existed */
+          ei->image = prev_image;
+          ei->size = prev_size;
+
+          return 0;
+        }
+      else
+        {
+          munmap (prev_image, prev_size);
+        }
+
+      return ret;
+    }
+  }
+
+  return 0;
+}
diff --git a/src/elfxx.h b/src/elfxx.h
index dea0463..830432c 100644
--- a/src/elfxx.h
+++ b/src/elfxx.h
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003, 2005 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -24,41 +24,38 @@ LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
-#include <elf.h>
 #include <fcntl.h>
 #include <unistd.h>
 
 #include <sys/mman.h>
 #include <sys/stat.h>
 
+#include "libunwind_i.h"
+
 #if ELF_CLASS == ELFCLASS32
-# define ELF_W(x)	ELF32_##x
-# define Elf_W(x)	Elf32_##x
-# define elf_w(x)	_Uelf32_##x
+# define ELF_W(x)       ELF32_##x
+# define Elf_W(x)       Elf32_##x
+# define elf_w(x)       _Uelf32_##x
 #else
-# define ELF_W(x)	ELF64_##x
-# define Elf_W(x)	Elf64_##x
-# define elf_w(x)	_Uelf64_##x
+# define ELF_W(x)       ELF64_##x
+# define Elf_W(x)       Elf64_##x
+# define elf_w(x)       _Uelf64_##x
 #endif
 
-#include "libunwind_i.h"
-
 extern int elf_w (get_proc_name) (unw_addr_space_t as,
-				  pid_t pid, unw_word_t ip,
-				  char *buf, size_t len,
-				  unw_word_t *offp);
+                                  pid_t pid, unw_word_t ip,
+                                  char *buf, size_t len,
+                                  unw_word_t *offp);
 
 extern int elf_w (get_proc_name_in_image) (unw_addr_space_t as,
-					   struct elf_image *ei,
-					   unsigned long segbase,
-					   unsigned long mapoff,
-					   unw_word_t ip,
-					   char *buf, size_t buf_len, unw_word_t *offp);
+                                           struct elf_image *ei,
+                                           unsigned long segbase,
+                                           unsigned long mapoff,
+                                           unw_word_t ip,
+                                           char *buf, size_t buf_len, unw_word_t *offp);
 
-extern int elf_w (get_proc_name) (unw_addr_space_t as,
-				  pid_t pid, unw_word_t ip,
-				  char *buf, size_t len,
-				  unw_word_t *offp);
+extern Elf_W (Shdr)* elf_w (find_section) (struct elf_image *ei, const char* secname);
+extern int elf_w (load_debuglink) (const char* file, struct elf_image *ei, int is_local);
 
 static inline int
 elf_w (valid_object) (struct elf_image *ei)
@@ -67,9 +64,9 @@ elf_w (valid_object) (struct elf_image *ei)
     return 0;
 
   return (memcmp (ei->image, ELFMAG, SELFMAG) == 0
-	  && ((uint8_t *) ei->image)[EI_CLASS] == ELF_CLASS
-	  && ((uint8_t *) ei->image)[EI_VERSION] != EV_NONE
-	  && ((uint8_t *) ei->image)[EI_VERSION] <= EV_CURRENT);
+          && ((uint8_t *) ei->image)[EI_CLASS] == ELF_CLASS
+          && ((uint8_t *) ei->image)[EI_VERSION] != EV_NONE
+          && ((uint8_t *) ei->image)[EI_VERSION] <= EV_CURRENT);
 }
 
 static inline int
diff --git a/src/hppa/Gapply_reg_state.c b/src/hppa/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/hppa/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/hppa/Gcreate_addr_space.c b/src/hppa/Gcreate_addr_space.c
index ecc805d..8a6cb8b 100644
--- a/src/hppa/Gcreate_addr_space.c
+++ b/src/hppa/Gcreate_addr_space.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED unw_addr_space_t
+unw_addr_space_t
 unw_create_addr_space (unw_accessors_t *a, int byte_order)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/hppa/Gget_proc_info.c b/src/hppa/Gget_proc_info.c
index 8d2c1fd..e10efcf 100644
--- a/src/hppa/Gget_proc_info.c
+++ b/src/hppa/Gget_proc_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -33,9 +33,9 @@ unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
   if (dwarf_make_proc_info (&c->dwarf) < 0)
     {
       /* On hppa, some key routines such as _start() and _dl_start()
-	 are missing DWARF unwind info.  We don't want to fail in that
-	 case, because those frames are uninteresting and just mark
-	 the end of the frame-chain anyhow.  */
+         are missing DWARF unwind info.  We don't want to fail in that
+         case, because those frames are uninteresting and just mark
+         the end of the frame-chain anyhow.  */
       memset (pi, 0, sizeof (*pi));
       pi->start_ip = c->dwarf.ip;
       pi->end_ip = c->dwarf.ip + 4;
diff --git a/src/hppa/Gget_save_loc.c b/src/hppa/Gget_save_loc.c
index 2b415b7..02dfa30 100644
--- a/src/hppa/Gget_save_loc.c
+++ b/src/hppa/Gget_save_loc.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,13 +25,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   /* struct cursor *c = (struct cursor *) cursor; */
   dwarf_loc_t loc;
 
-  loc = DWARF_NULL_LOC;		/* default to "not saved" */
+  loc = DWARF_NULL_LOC;         /* default to "not saved" */
 
 #warning FIX ME!
 
diff --git a/src/hppa/Gglobal.c b/src/hppa/Gglobal.c
index 2f1b593..351a501 100644
--- a/src/hppa/Gglobal.c
+++ b/src/hppa/Gglobal.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2004-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -48,7 +48,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     hppa_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&hppa_lock, saved_mask);
diff --git a/src/hppa/Ginit.c b/src/hppa/Ginit.c
index 5326b82..461e4b9 100644
--- a/src/hppa/Ginit.c
+++ b/src/hppa/Ginit.c
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002, 2004 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -32,13 +32,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 static inline void *
 uc_addr (ucontext_t *uc, int reg)
@@ -79,7 +79,7 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
   return 0;
@@ -87,7 +87,7 @@ get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (write)
     {
@@ -104,7 +104,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   unw_word_t *addr;
   ucontext_t *uc = arg;
@@ -135,7 +135,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = arg;
   unw_fpreg_t *addr;
@@ -150,14 +150,14 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   if (write)
     {
       Debug (12, "%s <- %08x.%08x\n",
-	     unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
+             unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
       *(unw_fpreg_t *) addr = *val;
     }
   else
     {
       *val = *(unw_fpreg_t *) addr;
       Debug (12, "%s -> %08x.%08x\n",
-	     unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
+             unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
     }
   return 0;
 
@@ -169,8 +169,8 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf32_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -179,7 +179,7 @@ HIDDEN void
 hppa_local_addr_space_init (void)
 {
   memset (&local_addr_space, 0, sizeof (local_addr_space));
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
diff --git a/src/hppa/Ginit_local.c b/src/hppa/Ginit_local.c
index 40277f2..1fdc771 100644
--- a/src/hppa/Ginit_local.c
+++ b/src/hppa/Ginit_local.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by ...
+        Contributed by ...
 
 This file is part of libunwind.
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 {
   return -UNW_EINVAL;
@@ -36,8 +36,8 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 
 #else /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
-unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+static int
+unw_init_local_common (unw_cursor_t *cursor, ucontext_t *uc, unsigned use_prev_instr)
 {
   struct cursor *c = (struct cursor *) cursor;
 
@@ -48,7 +48,30 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 
   c->dwarf.as = unw_local_addr_space;
   c->dwarf.as_arg = uc;
-  return common_init (c, 1);
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
 }
 
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/hppa/Ginit_remote.c b/src/hppa/Ginit_remote.c
index 50ec62c..71096ce 100644
--- a/src/hppa/Ginit_remote.c
+++ b/src/hppa/Ginit_remote.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "init.h"
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/hppa/Gis_signal_frame.c b/src/hppa/Gis_signal_frame.c
index 202b570..addb551 100644
--- a/src/hppa/Gis_signal_frame.c
+++ b/src/hppa/Gis_signal_frame.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
 #ifdef __linux__ 
@@ -37,7 +37,7 @@ unw_is_signal_frame (unw_cursor_t *cursor)
   int ret;
 
   as = c->dwarf.as;
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   arg = c->dwarf.as_arg;
 
   /* Check if IP points at sigreturn() sequence.  On Linux, this normally is:
@@ -64,7 +64,7 @@ unw_is_signal_frame (unw_cursor_t *cursor)
       return ret;
     }
   ret = ((w0 == 0x34190000 || w0 == 0x34190002)
-	 && w1 == 0x3414015a && w2 == 0xe4008200 && w3 == 0x08000240);
+         && w1 == 0x3414015a && w2 == 0xe4008200 && w3 == 0x08000240);
   Debug (1, "(cursor=%p, ip=0x%08lx) -> %d\n", c, (unsigned) ip, ret);
   return ret;
 #else
diff --git a/src/hppa/Greg_states_iterate.c b/src/hppa/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/hppa/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/hppa/Gregs.c b/src/hppa/Gregs.c
index e6d84e3..da0542c 100644
--- a/src/hppa/Gregs.c
+++ b/src/hppa/Gregs.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   struct dwarf_loc loc;
 
@@ -35,16 +35,16 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     {
     case UNW_HPPA_IP:
       if (write)
-	c->dwarf.ip = *valp;		/* update the IP cache */
+        c->dwarf.ip = *valp;            /* update the IP cache */
       if (c->dwarf.pi_valid && (*valp < c->dwarf.pi.start_ip
-				|| *valp >= c->dwarf.pi.end_ip))
-	c->dwarf.pi_valid = 0;		/* new IP outside of current proc */
+                                || *valp >= c->dwarf.pi.end_ip))
+        c->dwarf.pi_valid = 0;          /* new IP outside of current proc */
       break;
 
     case UNW_HPPA_CFA:
     case UNW_HPPA_SP:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = c->dwarf.cfa;
       return 0;
 
@@ -71,7 +71,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   struct dwarf_loc loc;
 
diff --git a/src/hppa/Gresume.c b/src/hppa/Gresume.c
index 92d506d..6c11f14 100644
--- a/src/hppa/Gresume.c
+++ b/src/hppa/Gresume.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -40,11 +40,11 @@ my_rt_sigreturn (void *new_sp, int in_syscall)
   register unsigned long r20 __asm__ ("r20") = SYS_rt_sigreturn;
 
   __asm__ __volatile__ ("copy %0, %%sp\n"
-			"be,l 0x100(%%sr2,%%r0),%%sr0,%%r31\n"
-			"nop"
-			:
-			: "r"(new_sp), "r"(r20), "r"(r25)
-			: "memory");
+                        "be,l 0x100(%%sr2,%%r0),%%sr0,%%r31\n"
+                        "nop"
+                        :
+                        : "r"(new_sp), "r"(r20), "r"(r25)
+                        : "memory");
   abort ();
 }
 
@@ -90,9 +90,9 @@ static inline int
 establish_machine_state (struct cursor *c)
 {
   int (*access_reg) (unw_addr_space_t, unw_regnum_t, unw_word_t *,
-		     int write, void *);
+                     int write, void *);
   int (*access_fpreg) (unw_addr_space_t, unw_regnum_t, unw_fpreg_t *,
-		       int write, void *);
+                       int write, void *);
   unw_addr_space_t as = c->dwarf.as;
   void *arg = c->dwarf.as_arg;
   unw_fpreg_t fpval;
@@ -108,20 +108,20 @@ establish_machine_state (struct cursor *c)
     {
       Debug (16, "copying %s %d\n", unw_regname (reg), reg);
       if (unw_is_fpreg (reg))
-	{
-	  if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
-	    (*access_fpreg) (as, reg, &fpval, 1, arg);
-	}
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            (*access_fpreg) (as, reg, &fpval, 1, arg);
+        }
       else
-	{
-	  if (tdep_access_reg (c, reg, &val, 0) >= 0)
-	    (*access_reg) (as, reg, &val, 1, arg);
-	}
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            (*access_reg) (as, reg, &val, 1, arg);
+        }
     }
   return 0;
 }
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -141,5 +141,5 @@ unw_resume (unw_cursor_t *cursor)
     return ret;
 
   return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
-				     c->dwarf.as_arg);
+                                     c->dwarf.as_arg);
 }
diff --git a/src/hppa/Gstep.c b/src/hppa/Gstep.c
index 1362013..4fc8a87 100644
--- a/src/hppa/Gstep.c
+++ b/src/hppa/Gstep.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger
+        Contributed by David Mosberger
 
 This file is part of libunwind.
 
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include "offsets.h"
 
-PROTECTED int
+int
 unw_step (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -46,49 +46,48 @@ unw_step (unw_cursor_t *cursor)
   if (unlikely (ret < 0))
     {
       /* DWARF failed, let's see if we can follow the frame-chain
-	 or skip over the signal trampoline.  */
+         or skip over the signal trampoline.  */
 
       Debug (13, "dwarf_step() failed (ret=%d), trying fallback\n", ret);
 
       if (unw_is_signal_frame (cursor))
-	{
+        {
 #ifdef __linux__
-	  /* Assume that the trampoline is at the beginning of the
-	     sigframe.  */
-	  unw_word_t ip, sc_addr = c->dwarf.ip + LINUX_RT_SIGFRAME_UC_OFF;
-	  dwarf_loc_t iaoq_loc = DWARF_LOC (sc_addr + LINUX_SC_IAOQ_OFF, 0);
-
-	  c->sigcontext_format = HPPA_SCF_LINUX_RT_SIGFRAME;
-	  c->sigcontext_addr = sc_addr;
-	  c->dwarf.ret_addr_column = UNW_HPPA_RP;
-
-	  if ((ret = dwarf_get (&c->dwarf, iaoq_loc, &ip)) < 0)
-	    {
-	      Debug (2, "failed to read IAOQ[1] (ret=%d)\n", ret);
-	      return ret;
-	    }
-	  c->dwarf.ip = ip & ~0x3;	/* mask out the privilege level */
-
-	  for (i = 0; i < 32; ++i)
-	    {
-	      c->dwarf.loc[UNW_HPPA_GR + i]
-		= DWARF_LOC (sc_addr + LINUX_SC_GR_OFF + 4*i, 0);
-	      c->dwarf.loc[UNW_HPPA_FR + i]
-		= DWARF_LOC (sc_addr + LINUX_SC_FR_OFF + 4*i, 0);
-	    }
-
-	  if ((ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_HPPA_SP],
-				&c->dwarf.cfa)) < 0)
-	    {
-	      Debug (2, "failed to read SP (ret=%d)\n", ret);
-	      return ret;
-	    }
+          /* Assume that the trampoline is at the beginning of the
+             sigframe.  */
+          unw_word_t ip, sc_addr = c->dwarf.ip + LINUX_RT_SIGFRAME_UC_OFF;
+          dwarf_loc_t iaoq_loc = DWARF_LOC (sc_addr + LINUX_SC_IAOQ_OFF, 0);
+
+          c->sigcontext_format = HPPA_SCF_LINUX_RT_SIGFRAME;
+          c->sigcontext_addr = sc_addr;
+
+          if ((ret = dwarf_get (&c->dwarf, iaoq_loc, &ip)) < 0)
+            {
+              Debug (2, "failed to read IAOQ[1] (ret=%d)\n", ret);
+              return ret;
+            }
+          c->dwarf.ip = ip & ~0x3;      /* mask out the privilege level */
+
+          for (i = 0; i < 32; ++i)
+            {
+              c->dwarf.loc[UNW_HPPA_GR + i]
+                = DWARF_LOC (sc_addr + LINUX_SC_GR_OFF + 4*i, 0);
+              c->dwarf.loc[UNW_HPPA_FR + i]
+                = DWARF_LOC (sc_addr + LINUX_SC_FR_OFF + 4*i, 0);
+            }
+
+          if ((ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_HPPA_SP],
+                                &c->dwarf.cfa)) < 0)
+            {
+              Debug (2, "failed to read SP (ret=%d)\n", ret);
+              return ret;
+            }
 #else
 # error Implement me!
 #endif
-	}
+        }
       else
-	c->dwarf.ip = 0;
+        c->dwarf.ip = 0;
     }
   ret = (c->dwarf.ip == 0) ? 0 : 1;
   Debug (2, "returning %d\n", ret);
diff --git a/src/hppa/Lapply_reg_state.c b/src/hppa/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/hppa/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/hppa/Lreg_states_iterate.c b/src/hppa/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/hppa/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/hppa/init.h b/src/hppa/init.h
index f51e3b4..4e23b86 100644
--- a/src/hppa/init.h
+++ b/src/hppa/init.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by ...
+        Contributed by ...
 
 This file is part of libunwind.
 
diff --git a/src/hppa/offsets.h b/src/hppa/offsets.h
index d824770..24e6453 100644
--- a/src/hppa/offsets.h
+++ b/src/hppa/offsets.h
@@ -1,17 +1,17 @@
-#define LINUX_UC_FLAGS_OFF	0x000
-#define LINUX_UC_LINK_OFF	0x004
-#define LINUX_UC_STACK_OFF	0x008
-#define LINUX_UC_MCONTEXT_OFF	0x018
-#define LINUX_UC_SIGMASK_OFF	0x1b8
+#define LINUX_UC_FLAGS_OFF      0x000
+#define LINUX_UC_LINK_OFF       0x004
+#define LINUX_UC_STACK_OFF      0x008
+#define LINUX_UC_MCONTEXT_OFF   0x018
+#define LINUX_UC_SIGMASK_OFF    0x1b8
 
-#define LINUX_SC_FLAGS_OFF	0x000
-#define LINUX_SC_GR_OFF		0x004
-#define LINUX_SC_FR_OFF		0x088
-#define LINUX_SC_IASQ_OFF	0x188
-#define LINUX_SC_IAOQ_OFF	0x190
-#define LINUX_SC_SAR_OFF	0x198
+#define LINUX_SC_FLAGS_OFF      0x000
+#define LINUX_SC_GR_OFF         0x004
+#define LINUX_SC_FR_OFF         0x088
+#define LINUX_SC_IASQ_OFF       0x188
+#define LINUX_SC_IAOQ_OFF       0x190
+#define LINUX_SC_SAR_OFF        0x198
 
 /* The signal frame contains 4 words of space for the sigreturn
    trampoline, the siginfo structure, and then the sigcontext
    structure.  See include/asm-parisc/compat_rt_sigframe.h.  */
-#define LINUX_RT_SIGFRAME_UC_OFF	0xac
+#define LINUX_RT_SIGFRAME_UC_OFF        0xac
diff --git a/src/hppa/regname.c b/src/hppa/regname.c
index 07cae8e..5698a58 100644
--- a/src/hppa/regname.c
+++ b/src/hppa/regname.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2004-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -40,7 +40,7 @@ static const char *regname[] =
     "cfa"
   };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
diff --git a/src/hppa/unwind_i.h b/src/hppa/unwind_i.h
index 0f566d0..cafeab5 100644
--- a/src/hppa/unwind_i.h
+++ b/src/hppa/unwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -32,15 +32,15 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-#define hppa_lock			UNW_OBJ(lock)
-#define hppa_local_resume		UNW_OBJ(local_resume)
-#define hppa_local_addr_space_init	UNW_OBJ(local_addr_space_init)
-#define hppa_scratch_loc		UNW_OBJ(scratch_loc)
-#define setcontext			UNW_ARCH_OBJ (setcontext)
+#define hppa_lock                       UNW_OBJ(lock)
+#define hppa_local_resume               UNW_OBJ(local_resume)
+#define hppa_local_addr_space_init      UNW_OBJ(local_addr_space_init)
+#define hppa_scratch_loc                UNW_OBJ(scratch_loc)
+#define setcontext                      UNW_ARCH_OBJ (setcontext)
 
 extern void hppa_local_addr_space_init (void);
 extern int hppa_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			      void *arg);
+                              void *arg);
 extern dwarf_loc_t hppa_scratch_loc (struct cursor *c, unw_regnum_t reg);
 extern int setcontext (const ucontext_t *ucp);
 
diff --git a/src/ia64/Gapply_reg_state.c b/src/ia64/Gapply_reg_state.c
new file mode 100644
index 0000000..b45d1b5
--- /dev/null
+++ b/src/ia64/Gapply_reg_state.c
@@ -0,0 +1,39 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  // Needs dwarf support on ia64
+  // return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+  return -UNW_EINVAL;
+}
diff --git a/src/ia64/Gcreate_addr_space.c b/src/ia64/Gcreate_addr_space.c
index a3524a0..7ad29cb 100644
--- a/src/ia64/Gcreate_addr_space.c
+++ b/src/ia64/Gcreate_addr_space.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED unw_addr_space_t
+unw_addr_space_t
 unw_create_addr_space (unw_accessors_t *a, int byte_order)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/ia64/Gfind_unwind_table.c b/src/ia64/Gfind_unwind_table.c
index f7d3168..9fd2707 100644
--- a/src/ia64/Gfind_unwind_table.c
+++ b/src/ia64/Gfind_unwind_table.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -46,14 +46,14 @@ find_gp (struct elf_dyn_info *edi, Elf64_Phdr *pdyn, Elf64_Addr load_base)
   if (pdyn)
     {
       /* If we have a PT_DYNAMIC program header, fetch the gp-value
-	 from the DT_PLTGOT entry.  */
+         from the DT_PLTGOT entry.  */
       Elf64_Dyn *dyn = (Elf64_Dyn *) (pdyn->p_offset + (char *) edi->ei.image);
       for (; dyn->d_tag != DT_NULL; ++dyn)
-	if (dyn->d_tag == DT_PLTGOT)
-	  {
-	    gp = (Elf64_Addr) dyn->d_un.d_ptr + load_base;
-	    goto done;
-	  }
+        if (dyn->d_tag == DT_PLTGOT)
+          {
+            gp = (Elf64_Addr) dyn->d_un.d_ptr + load_base;
+            goto done;
+          }
     }
 
   /* Without a PT_DYAMIC header, lets try to look for a non-empty .opd
@@ -67,8 +67,8 @@ find_gp (struct elf_dyn_info *edi, Elf64_Phdr *pdyn, Elf64_Addr load_base)
   if (soff + ehdr->e_shnum * ehdr->e_shentsize > edi->ei.size)
     {
       Debug (1, "section table outside of image? (%lu > %lu)",
-	     soff + ehdr->e_shnum * ehdr->e_shentsize,
-	     edi->ei.size);
+             soff + ehdr->e_shnum * ehdr->e_shentsize,
+             edi->ei.size);
       goto done;
     }
 
@@ -78,11 +78,11 @@ find_gp (struct elf_dyn_info *edi, Elf64_Phdr *pdyn, Elf64_Addr load_base)
   for (i = 0; i < ehdr->e_shnum; ++i)
     {
       if (strcmp (strtab + shdr->sh_name, ".opd") == 0
-	  && shdr->sh_size >= 16)
-	{
-	  gp = ((Elf64_Addr *) ((char *) edi->ei.image + shdr->sh_offset))[1];
-	  goto done;
-	}
+          && shdr->sh_size >= 16)
+        {
+          gp = ((Elf64_Addr *) ((char *) edi->ei.image + shdr->sh_offset))[1];
+          goto done;
+        }
       shdr = (Elf64_Shdr *) (((char *) shdr) + ehdr->e_shentsize);
     }
 
@@ -93,8 +93,8 @@ find_gp (struct elf_dyn_info *edi, Elf64_Phdr *pdyn, Elf64_Addr load_base)
 
 int
 ia64_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
-			 char *path, unw_word_t segbase, unw_word_t mapoff,
-			 unw_word_t ip)
+                         char *path, unw_word_t segbase, unw_word_t mapoff,
+                         unw_word_t ip)
 {
   Elf64_Phdr *phdr, *ptxt = NULL, *punw = NULL, *pdyn = NULL;
   Elf64_Ehdr *ehdr;
@@ -109,23 +109,23 @@ ia64_find_unwind_table (struct elf_dyn_info *edi, unw_addr_space_t as,
   for (i = 0; i < ehdr->e_phnum; ++i)
     {
       switch (phdr[i].p_type)
-	{
-	case PT_LOAD:
-	  if (phdr[i].p_offset == mapoff)
-	    ptxt = phdr + i;
-	  break;
-
-	case PT_IA_64_UNWIND:
-	  punw = phdr + i;
-	  break;
-
-	case PT_DYNAMIC:
-	  pdyn = phdr + i;
-	  break;
-
-	default:
-	  break;
-	}
+        {
+        case PT_LOAD:
+          if (phdr[i].p_offset == mapoff)
+            ptxt = phdr + i;
+          break;
+
+        case PT_IA_64_UNWIND:
+          punw = phdr + i;
+          break;
+
+        case PT_DYNAMIC:
+          pdyn = phdr + i;
+          break;
+
+        default:
+          break;
+        }
     }
   if (!ptxt || !punw)
     return 0;
diff --git a/src/ia64/Gget_proc_info.c b/src/ia64/Gget_proc_info.c
index 21015d4..3ec82b9 100644
--- a/src/ia64/Gget_proc_info.c
+++ b/src/ia64/Gget_proc_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/ia64/Gget_save_loc.c b/src/ia64/Gget_save_loc.c
index 49bdaba..34efe99 100644
--- a/src/ia64/Gget_save_loc.c
+++ b/src/ia64/Gget_save_loc.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2003, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -30,7 +30,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "offsets.h"
 #include "regs.h"
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -38,7 +38,7 @@ unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
   uint8_t nat_bitnr;
   int ret;
 
-  loc = IA64_NULL_LOC;		/* default to "not saved" */
+  loc = IA64_NULL_LOC;          /* default to "not saved" */
 
   switch (reg)
     {
@@ -62,8 +62,8 @@ unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
       reg_loc = c->loc[IA64_REG_R4 + (reg - (UNW_IA64_NAT + 4))];
       nat_bitnr = c->nat_bitnr[reg - (UNW_IA64_NAT + 4)];
       if (IA64_IS_FP_LOC (reg_loc))
-	/* NaT bit saved as a NaTVal.  */
-	loc = reg_loc;
+        /* NaT bit saved as a NaTVal.  */
+        loc = reg_loc;
       break;
 
     case UNW_IA64_FR + 2: loc = c->loc[IA64_REG_F2]; break;
@@ -74,29 +74,29 @@ unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
       loc = c->loc[IA64_REG_F16 + (reg - (UNW_IA64_FR + 16))];
       break;
 
-    case UNW_IA64_AR_BSP:	loc = c->loc[IA64_REG_BSP]; break;
-    case UNW_IA64_AR_BSPSTORE:	loc = c->loc[IA64_REG_BSPSTORE]; break;
-    case UNW_IA64_AR_PFS:	loc = c->loc[IA64_REG_PFS]; break;
-    case UNW_IA64_AR_RNAT:	loc = c->loc[IA64_REG_RNAT]; break;
-    case UNW_IA64_AR_UNAT:	loc = c->loc[IA64_REG_UNAT]; break;
-    case UNW_IA64_AR_LC:	loc = c->loc[IA64_REG_LC]; break;
-    case UNW_IA64_AR_FPSR:	loc = c->loc[IA64_REG_FPSR]; break;
-    case UNW_IA64_BR + 1:	loc = c->loc[IA64_REG_B1]; break;
-    case UNW_IA64_BR + 2:	loc = c->loc[IA64_REG_B2]; break;
-    case UNW_IA64_BR + 3:	loc = c->loc[IA64_REG_B3]; break;
-    case UNW_IA64_BR + 4:	loc = c->loc[IA64_REG_B4]; break;
-    case UNW_IA64_BR + 5:	loc = c->loc[IA64_REG_B5]; break;
-    case UNW_IA64_CFM:		loc = c->cfm_loc; break;
-    case UNW_IA64_PR:		loc = c->loc[IA64_REG_PR]; break;
-
-    case UNW_IA64_GR + 32 ... UNW_IA64_GR + 127:	/* stacked reg */
+    case UNW_IA64_AR_BSP:       loc = c->loc[IA64_REG_BSP]; break;
+    case UNW_IA64_AR_BSPSTORE:  loc = c->loc[IA64_REG_BSPSTORE]; break;
+    case UNW_IA64_AR_PFS:       loc = c->loc[IA64_REG_PFS]; break;
+    case UNW_IA64_AR_RNAT:      loc = c->loc[IA64_REG_RNAT]; break;
+    case UNW_IA64_AR_UNAT:      loc = c->loc[IA64_REG_UNAT]; break;
+    case UNW_IA64_AR_LC:        loc = c->loc[IA64_REG_LC]; break;
+    case UNW_IA64_AR_FPSR:      loc = c->loc[IA64_REG_FPSR]; break;
+    case UNW_IA64_BR + 1:       loc = c->loc[IA64_REG_B1]; break;
+    case UNW_IA64_BR + 2:       loc = c->loc[IA64_REG_B2]; break;
+    case UNW_IA64_BR + 3:       loc = c->loc[IA64_REG_B3]; break;
+    case UNW_IA64_BR + 4:       loc = c->loc[IA64_REG_B4]; break;
+    case UNW_IA64_BR + 5:       loc = c->loc[IA64_REG_B5]; break;
+    case UNW_IA64_CFM:          loc = c->cfm_loc; break;
+    case UNW_IA64_PR:           loc = c->loc[IA64_REG_PR]; break;
+
+    case UNW_IA64_GR + 32 ... UNW_IA64_GR + 127:        /* stacked reg */
       reg = rotate_gr (c, reg - UNW_IA64_GR);
       ret = ia64_get_stacked (c, reg, &loc, NULL);
       if (ret < 0)
-	return ret;
+        return ret;
       break;
 
-    case UNW_IA64_NAT + 32 ... UNW_IA64_NAT + 127:	/* stacked reg */
+    case UNW_IA64_NAT + 32 ... UNW_IA64_NAT + 127:      /* stacked reg */
       reg = rotate_gr (c, reg - UNW_IA64_NAT);
       ret = ia64_get_stacked (c, reg, NULL, &loc);
       break;
@@ -108,9 +108,9 @@ unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
       /* scratch & special registers: */
 
     case UNW_IA64_GR + 0:
-    case UNW_IA64_GR + 1:				/* global pointer */
+    case UNW_IA64_GR + 1:                               /* global pointer */
     case UNW_IA64_NAT + 0:
-    case UNW_IA64_NAT + 1:				/* global pointer */
+    case UNW_IA64_NAT + 1:                              /* global pointer */
     case UNW_IA64_FR + 0:
     case UNW_IA64_FR + 1:
       break;
diff --git a/src/ia64/Gglobal.c b/src/ia64/Gglobal.c
index bdd9d44..5c6156f 100644
--- a/src/ia64/Gglobal.c
+++ b/src/ia64/Gglobal.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -80,7 +80,7 @@ tdep_init (void)
 
     mempool_init (&unw.reg_state_pool, sizeof (struct ia64_reg_state), 0);
     mempool_init (&unw.labeled_state_pool,
-		  sizeof (struct ia64_labeled_state), 0);
+                  sizeof (struct ia64_labeled_state), 0);
 
     unw.read_only.r0 = 0;
     unw.read_only.f0.raw.bits[0] = 0;
@@ -90,24 +90,24 @@ tdep_init (void)
     bep = (uint8_t *) &unw.read_only.f1_be;
     for (i = 0; i < 16; ++i)
       {
-	*--lep = f1_bytes[i];
-	*bep++ = f1_bytes[i];
+        *--lep = f1_bytes[i];
+        *bep++ = f1_bytes[i];
       }
 
     lep = (uint8_t *) &unw.nat_val_le + 16;
     bep = (uint8_t *) &unw.nat_val_be;
     for (i = 0; i < 16; ++i)
       {
-	*--lep = nat_val_bytes[i];
-	*bep++ = nat_val_bytes[i];
+        *--lep = nat_val_bytes[i];
+        *bep++ = nat_val_bytes[i];
       }
 
     lep = (uint8_t *) &unw.int_val_le + 16;
     bep = (uint8_t *) &unw.int_val_be;
     for (i = 0; i < 16; ++i)
       {
-	*--lep = int_val_bytes[i];
-	*bep++ = int_val_bytes[i];
+        *--lep = int_val_bytes[i];
+        *bep++ = int_val_bytes[i];
       }
 
     assert (8*sizeof(unw_hash_index_t) >= IA64_LOG_UNW_HASH_SIZE);
@@ -115,7 +115,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     ia64_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&unw.lock, saved_mask);
diff --git a/src/ia64/Ginit.c b/src/ia64/Ginit.c
index 5afa9ab..b09a2ad 100644
--- a/src/ia64/Ginit.c
+++ b/src/ia64/Ginit.c
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -33,13 +33,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 #ifdef HAVE_SYS_UC_ACCESS_H
 
@@ -61,7 +61,7 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
 #ifndef UNW_LOCAL_ONLY
 # pragma weak _U_dyn_info_list_addr
@@ -74,7 +74,7 @@ get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (write)
     {
@@ -91,12 +91,12 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 #ifdef HAVE_SYS_UC_ACCESS_H
 
-#define SYSCALL_CFM_SAVE_REG	11 /* on a syscall, ar.pfs is saved in r11 */
-#define REASON_SYSCALL		0
+#define SYSCALL_CFM_SAVE_REG    11 /* on a syscall, ar.pfs is saved in r11 */
+#define REASON_SYSCALL          0
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   ucontext_t *uc = arg;
   unsigned int nat, mask;
@@ -110,88 +110,88 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
     {
     case UNW_IA64_GR  ... UNW_IA64_GR + 31:
       if ((ret = __uc_get_grs (uc, (reg - UNW_IA64_GR), 1, &value, &nat)))
-	break;
+        break;
 
       if (write)
-	ret = __uc_set_grs (uc, (reg - UNW_IA64_GR), 1, val, nat);
+        ret = __uc_set_grs (uc, (reg - UNW_IA64_GR), 1, val, nat);
       else
-	*val = value;
+        *val = value;
       break;
 
     case UNW_IA64_NAT ... UNW_IA64_NAT + 31:
       if ((ret = __uc_get_grs (uc, (reg - UNW_IA64_GR), 1, &value, &nat)))
-	break;
+        break;
 
       mask = 1 << (reg - UNW_IA64_GR);
 
       if (write)
-	{
-	  if (*val)
-	    nat |= mask;
-	  else
-	    nat &= ~mask;
-	  ret = __uc_set_grs (uc, (reg - UNW_IA64_GR), 1, &value, nat);
-	}
+        {
+          if (*val)
+            nat |= mask;
+          else
+            nat &= ~mask;
+          ret = __uc_set_grs (uc, (reg - UNW_IA64_GR), 1, &value, nat);
+        }
       else
-	*val = (nat & mask) != 0;
+        *val = (nat & mask) != 0;
       break;
 
     case UNW_IA64_AR  ... UNW_IA64_AR + 127:
       if (reg == UNW_IA64_AR_BSP)
-	{
-  	  if (write)
-	    ret = __uc_set_ar (uc, (reg - UNW_IA64_AR), *val);
- 	  else
- 	    ret = __uc_get_ar (uc, (reg - UNW_IA64_AR), val);
-	}
+        {
+          if (write)
+            ret = __uc_set_ar (uc, (reg - UNW_IA64_AR), *val);
+          else
+            ret = __uc_get_ar (uc, (reg - UNW_IA64_AR), val);
+        }
       else if (reg == UNW_IA64_AR_PFS && reason == REASON_SYSCALL)
- 	{
-	  /* As of HP-UX 11.22, getcontext() does not have unwind info
-	     and because of that, we need to hack thins manually here.
-	     Hopefully, this is OK because the HP-UX kernel also needs
-	     to know where AR.PFS has been saved, so the use of
-	     register r11 for this purpose is pretty much nailed
-	     down.  */
- 	  if (write)
- 	    ret = __uc_set_grs (uc, SYSCALL_CFM_SAVE_REG, 1, val, 0);
- 	  else
- 	    ret = __uc_get_grs (uc, SYSCALL_CFM_SAVE_REG, 1, val, &nat);
- 	}
+        {
+          /* As of HP-UX 11.22, getcontext() does not have unwind info
+             and because of that, we need to hack thins manually here.
+             Hopefully, this is OK because the HP-UX kernel also needs
+             to know where AR.PFS has been saved, so the use of
+             register r11 for this purpose is pretty much nailed
+             down.  */
+          if (write)
+            ret = __uc_set_grs (uc, SYSCALL_CFM_SAVE_REG, 1, val, 0);
+          else
+            ret = __uc_get_grs (uc, SYSCALL_CFM_SAVE_REG, 1, val, &nat);
+        }
       else
-	{
-	  if (write)
-	    ret = __uc_set_ar (uc, (reg - UNW_IA64_AR), *val);
-	  else
-	    ret = __uc_get_ar (uc, (reg - UNW_IA64_AR), val);
-	}
+        {
+          if (write)
+            ret = __uc_set_ar (uc, (reg - UNW_IA64_AR), *val);
+          else
+            ret = __uc_get_ar (uc, (reg - UNW_IA64_AR), val);
+        }
       break;
 
     case UNW_IA64_BR  ... UNW_IA64_BR + 7:
       if (write)
-	ret = __uc_set_brs (uc, (reg - UNW_IA64_BR), 1, val);
+        ret = __uc_set_brs (uc, (reg - UNW_IA64_BR), 1, val);
       else
-	ret = __uc_get_brs (uc, (reg - UNW_IA64_BR), 1, val);
+        ret = __uc_get_brs (uc, (reg - UNW_IA64_BR), 1, val);
       break;
 
     case UNW_IA64_PR:
       if (write)
-	ret = __uc_set_prs (uc, *val);
+        ret = __uc_set_prs (uc, *val);
       else
-	ret = __uc_get_prs (uc, val);
+        ret = __uc_get_prs (uc, val);
       break;
 
     case UNW_IA64_IP:
       if (write)
-	ret = __uc_set_ip (uc, *val);
+        ret = __uc_set_ip (uc, *val);
       else
-	ret = __uc_get_ip (uc, val);
+        ret = __uc_get_ip (uc, val);
       break;
 
     case UNW_IA64_CFM:
       if (write)
-	ret = __uc_set_cfm (uc, *val);
+        ret = __uc_set_cfm (uc, *val);
       else
-	ret = __uc_get_cfm (uc, val);
+        ret = __uc_get_cfm (uc, val);
       break;
 
     case UNW_IA64_FR  ... UNW_IA64_FR + 127:
@@ -203,7 +203,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
   if (ret != 0)
     {
       Debug (1, "failed to %s %s (ret = %d)\n",
-	     write ? "write" : "read", unw_regname (reg), ret);
+             write ? "write" : "read", unw_regname (reg), ret);
       return -UNW_EBADREG;
     }
 
@@ -216,7 +216,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = arg;
   fp_regval_t fp_regval;
@@ -226,15 +226,15 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
     {
     case UNW_IA64_FR  ... UNW_IA64_FR + 127:
       if (write)
-	{
-	  memcpy (&fp_regval, val, sizeof (fp_regval));
-	  ret = __uc_set_frs (uc, (reg - UNW_IA64_FR), 1, &fp_regval);
-	}
+        {
+          memcpy (&fp_regval, val, sizeof (fp_regval));
+          ret = __uc_set_frs (uc, (reg - UNW_IA64_FR), 1, &fp_regval);
+        }
       else
-	{
-	  ret = __uc_get_frs (uc, (reg - UNW_IA64_FR), 1, &fp_regval);
-	  memcpy (val, &fp_regval, sizeof (*val));
-	}
+        {
+          ret = __uc_get_frs (uc, (reg - UNW_IA64_FR), 1, &fp_regval);
+          memcpy (val, &fp_regval, sizeof (*val));
+        }
       break;
 
     default:
@@ -251,7 +251,7 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   unw_word_t *addr, mask;
   ucontext_t *uc = arg;
@@ -260,19 +260,19 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
     {
       mask = ((unw_word_t) 1) << (reg - UNW_IA64_NAT);
       if (write)
-	{
-	  if (*val)
-	    uc->uc_mcontext.sc_nat |= mask;
-	  else
-	    uc->uc_mcontext.sc_nat &= ~mask;
-	}
+        {
+          if (*val)
+            uc->uc_mcontext.sc_nat |= mask;
+          else
+            uc->uc_mcontext.sc_nat &= ~mask;
+        }
       else
-	*val = (uc->uc_mcontext.sc_nat & mask) != 0;
+        *val = (uc->uc_mcontext.sc_nat & mask) != 0;
 
       if (write)
-	Debug (12, "%s <- %lx\n", unw_regname (reg), *val);
+        Debug (12, "%s <- %lx\n", unw_regname (reg), *val);
       else
-	Debug (12, "%s -> %lx\n", unw_regname (reg), *val);
+        Debug (12, "%s -> %lx\n", unw_regname (reg), *val);
       return 0;
     }
 
@@ -283,10 +283,10 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
   if (write)
     {
       if (ia64_read_only_reg (addr))
-	{
-	  Debug (16, "attempt to write read-only register\n");
-	  return -UNW_EREADONLYREG;
-	}
+        {
+          Debug (16, "attempt to write read-only register\n");
+          return -UNW_EREADONLYREG;
+        }
       *addr = *val;
       Debug (12, "%s <- %lx\n", unw_regname (reg), *val);
     }
@@ -304,7 +304,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = arg;
   unw_fpreg_t *addr;
@@ -319,19 +319,19 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   if (write)
     {
       if (ia64_read_only_reg (addr))
-	{
-	  Debug (16, "attempt to write read-only register\n");
-	  return -UNW_EREADONLYREG;
-	}
+        {
+          Debug (16, "attempt to write read-only register\n");
+          return -UNW_EREADONLYREG;
+        }
       *addr = *val;
       Debug (12, "%s <- %016lx.%016lx\n",
-	     unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
+             unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
     }
   else
     {
       *val = *(unw_fpreg_t *) addr;
       Debug (12, "%s -> %016lx.%016lx\n",
-	     unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
+             unw_regname (reg), val->raw.bits[1], val->raw.bits[0]);
     }
   return 0;
 
@@ -345,8 +345,8 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf64_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -361,7 +361,7 @@ ia64_local_addr_space_init (void)
 #elif defined(__hpux)
   local_addr_space.abi = ABI_HPUX;
 #endif
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = tdep_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
@@ -379,7 +379,7 @@ ia64_local_addr_space_init (void)
 
 HIDDEN int
 ia64_uc_access_reg (struct cursor *c, ia64_loc_t loc, unw_word_t *valp,
-		    int write)
+                    int write)
 {
 #ifdef HAVE_SYS_UC_ACCESS_H
   unw_word_t uc_addr = IA64_GET_AUX_ADDR (loc);
@@ -387,7 +387,7 @@ ia64_uc_access_reg (struct cursor *c, ia64_loc_t loc, unw_word_t *valp,
   int ret;
 
   Debug (16, "%s location %s\n",
-	 write ? "writing" : "reading", ia64_strloc (loc));
+         write ? "writing" : "reading", ia64_strloc (loc));
 
   if (c->as == unw_local_addr_space)
     ucp = (ucontext_t *) uc_addr;
@@ -398,7 +398,7 @@ ia64_uc_access_reg (struct cursor *c, ia64_loc_t loc, unw_word_t *valp,
       /* Need to copy-in ucontext_t first.  */
       ucp = alloca (sizeof (ucontext_t));
       if (!ucp)
-	return -UNW_ENOMEM;
+        return -UNW_ENOMEM;
 
       /* For now, there is no non-HP-UX implementation of the
          uc_access(3) interface.  Because of that, we cannot, e.g.,
@@ -410,25 +410,25 @@ ia64_uc_access_reg (struct cursor *c, ia64_loc_t loc, unw_word_t *valp,
 
       dst = (unw_word_t *) ucp;
       for (src = uc_addr; src < uc_addr + sizeof (ucontext_t); src += 8)
-	if ((ret = (*c->as->acc.access_mem) (c->as, src, dst++, 0, c->as_arg))
-	    < 0)
-	  return ret;
+        if ((ret = (*c->as->acc.access_mem) (c->as, src, dst++, 0, c->as_arg))
+            < 0)
+          return ret;
     }
 
   if (IA64_IS_REG_LOC (loc))
     ret = access_reg (unw_local_addr_space, IA64_GET_REG (loc), valp, write,
-		      ucp);
+                      ucp);
   else
     {
       /* Must be an access to the RSE backing store in ucontext_t.  */
       unw_word_t addr = IA64_GET_ADDR (loc);
 
       if (write)
-	ret = __uc_set_rsebs (ucp, (uint64_t *) addr, 1, valp);
+        ret = __uc_set_rsebs (ucp, (uint64_t *) addr, 1, valp);
       else
-	ret = __uc_get_rsebs (ucp, (uint64_t *) addr, 1, valp);
+        ret = __uc_get_rsebs (ucp, (uint64_t *) addr, 1, valp);
       if (ret != 0)
-	ret = -UNW_EBADREG;
+        ret = -UNW_EBADREG;
     }
   if (ret < 0)
     return ret;
@@ -438,9 +438,9 @@ ia64_uc_access_reg (struct cursor *c, ia64_loc_t loc, unw_word_t *valp,
       /* need to copy-out ucontext_t: */
       unw_word_t dst, *src = (unw_word_t *) ucp;
       for (dst = uc_addr; dst < uc_addr + sizeof (ucontext_t); dst += 8)
-	if ((ret = (*c->as->acc.access_mem) (c->as, dst, src++, 1, c->as_arg))
-	    < 0)
-	  return ret;
+        if ((ret = (*c->as->acc.access_mem) (c->as, dst, src++, 1, c->as_arg))
+            < 0)
+          return ret;
     }
   return 0;
 #else /* !HAVE_SYS_UC_ACCESS_H */
@@ -450,7 +450,7 @@ ia64_uc_access_reg (struct cursor *c, ia64_loc_t loc, unw_word_t *valp,
 
 HIDDEN int
 ia64_uc_access_fpreg (struct cursor *c, ia64_loc_t loc, unw_fpreg_t *valp,
-		      int write)
+                      int write)
 {
 #ifdef HAVE_SYS_UC_ACCESS_H
   unw_word_t uc_addr = IA64_GET_AUX_ADDR (loc);
@@ -466,7 +466,7 @@ ia64_uc_access_fpreg (struct cursor *c, ia64_loc_t loc, unw_fpreg_t *valp,
       /* Need to copy-in ucontext_t first.  */
       ucp = alloca (sizeof (ucontext_t));
       if (!ucp)
-	return -UNW_ENOMEM;
+        return -UNW_ENOMEM;
 
       /* For now, there is no non-HP-UX implementation of the
          uc_access(3) interface.  Because of that, we cannot, e.g.,
@@ -478,13 +478,13 @@ ia64_uc_access_fpreg (struct cursor *c, ia64_loc_t loc, unw_fpreg_t *valp,
 
       dst = (unw_word_t *) ucp;
       for (src = uc_addr; src < uc_addr + sizeof (ucontext_t); src += 8)
-	if ((ret = (*c->as->acc.access_mem) (c->as, src, dst++, 0, c->as_arg))
-	    < 0)
-	  return ret;
+        if ((ret = (*c->as->acc.access_mem) (c->as, src, dst++, 0, c->as_arg))
+            < 0)
+          return ret;
     }
 
   if ((ret = access_fpreg (unw_local_addr_space, IA64_GET_REG (loc), valp,
-			   write, ucp)) < 0)
+                           write, ucp)) < 0)
     return ret;
 
   if (write && c->as != unw_local_addr_space)
@@ -492,9 +492,9 @@ ia64_uc_access_fpreg (struct cursor *c, ia64_loc_t loc, unw_fpreg_t *valp,
       /* need to copy-out ucontext_t: */
       unw_word_t dst, *src = (unw_word_t *) ucp;
       for (dst = uc_addr; dst < uc_addr + sizeof (ucontext_t); dst += 8)
-	if ((ret = (*c->as->acc.access_mem) (c->as, dst, src++, 1, c->as_arg))
-	    < 0)
-	  return ret;
+        if ((ret = (*c->as->acc.access_mem) (c->as, dst, src++, 1, c->as_arg))
+            < 0)
+          return ret;
     }
   return 0;
 #else /* !HAVE_SYS_UC_ACCESS_H */
diff --git a/src/ia64/Ginit_local.c b/src/ia64/Ginit_local.c
index 5f82c01..8fe1c67 100644
--- a/src/ia64/Ginit_local.c
+++ b/src/ia64/Ginit_local.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2003, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
 {
   return -UNW_EINVAL;
@@ -49,7 +49,7 @@ set_as_arg (struct cursor *c, unw_context_t *uc)
 
 static inline int
 get_initial_stack_pointers (struct cursor *c, unw_context_t *uc,
-			    unw_word_t *sp, unw_word_t *bsp)
+                            unw_word_t *sp, unw_word_t *bsp)
 {
 #if defined(__linux)
   unw_word_t sol, bspstore;
@@ -76,7 +76,7 @@ get_initial_stack_pointers (struct cursor *c, unw_context_t *uc,
   return 0;
 }
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/ia64/Ginit_remote.c b/src/ia64/Ginit_remote.c
index 334d236..b570c7e 100644
--- a/src/ia64/Ginit_remote.c
+++ b/src/ia64/Ginit_remote.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "init.h"
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/ia64/Gis_signal_frame.c b/src/ia64/Gis_signal_frame.c
index cc69bd6..e268a06 100644
--- a/src/ia64/Gis_signal_frame.c
+++ b/src/ia64/Gis_signal_frame.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/ia64/Gparser.c b/src/ia64/Gparser.c
index ff36968..b1f0f4a 100644
--- a/src/ia64/Gparser.c
+++ b/src/ia64/Gparser.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,15 +27,15 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* forward declaration: */
 static int create_state_record_for (struct cursor *c,
-				    struct ia64_state_record *sr,
-				    unw_word_t ip);
+                                    struct ia64_state_record *sr,
+                                    unw_word_t ip);
 
 typedef unsigned long unw_word;
 
-#define alloc_reg_state()	(mempool_alloc (&unw.reg_state_pool))
-#define free_reg_state(rs)	(mempool_free (&unw.reg_state_pool, rs))
-#define alloc_labeled_state()	(mempool_alloc (&unw.labeled_state_pool))
-#define free_labeled_state(s)	(mempool_free (&unw.labeled_state_pool, s))
+#define alloc_reg_state()       (mempool_alloc (&unw.reg_state_pool))
+#define free_reg_state(rs)      (mempool_free (&unw.reg_state_pool, rs))
+#define alloc_labeled_state()   (mempool_alloc (&unw.labeled_state_pool))
+#define free_labeled_state(s)   (mempool_free (&unw.labeled_state_pool, s))
 
 /* Routines to manipulate the state stack.  */
 
@@ -78,15 +78,15 @@ dup_state_stack (struct ia64_reg_state *rs)
     {
       copy = alloc_reg_state ();
       if (!copy)
-	{
-	  print_error ("unwind.dup_state_stack: out of memory\n");
-	  return NULL;
-	}
+        {
+          print_error ("unwind.dup_state_stack: out of memory\n");
+          return NULL;
+        }
       memcpy (copy, rs, sizeof (*copy));
       if (first)
-	prev->next = copy;
+        prev->next = copy;
       else
-	first = copy;
+        first = copy;
       rs = rs->next;
       prev = copy;
     }
@@ -153,7 +153,7 @@ decode_abreg (unsigned char abreg, int memory)
 
 static void
 set_reg (struct ia64_reg_info *reg, enum ia64_where where, int when,
-	 unsigned long val)
+         unsigned long val)
 {
   reg->val = val;
   reg->where = where;
@@ -163,35 +163,35 @@ set_reg (struct ia64_reg_info *reg, enum ia64_where where, int when,
 
 static void
 alloc_spill_area (unsigned long *offp, unsigned long regsize,
-		  struct ia64_reg_info *lo, struct ia64_reg_info *hi)
+                  struct ia64_reg_info *lo, struct ia64_reg_info *hi)
 {
   struct ia64_reg_info *reg;
 
   for (reg = hi; reg >= lo; --reg)
     {
       if (reg->where == IA64_WHERE_SPILL_HOME)
-	{
-	  reg->where = IA64_WHERE_PSPREL;
-	  *offp -= regsize;
-	  reg->val = *offp;
-	}
+        {
+          reg->where = IA64_WHERE_PSPREL;
+          *offp -= regsize;
+          reg->val = *offp;
+        }
     }
 }
 
 static inline void
 spill_next_when (struct ia64_reg_info **regp, struct ia64_reg_info *lim,
-		 unw_word t)
+                 unw_word t)
 {
   struct ia64_reg_info *reg;
 
   for (reg = *regp; reg <= lim; ++reg)
     {
       if (reg->where == IA64_WHERE_SPILL_HOME)
-	{
-	  reg->when = t;
-	  *regp = reg + 1;
-	  return;
-	}
+        {
+          reg->when = t;
+          *regp = reg + 1;
+          return;
+        }
     }
   Dprintf ("libunwind: excess spill!\n");
 }
@@ -209,10 +209,10 @@ finish_prologue (struct ia64_state_record *sr)
     {
       reg = sr->curr.reg + unw.save_order[i];
       if (reg->where == IA64_WHERE_GR_SAVE)
-	{
-	  reg->where = IA64_WHERE_GR;
-	  reg->val = sr->gr_save_loc++;
-	}
+        {
+          reg->where = IA64_WHERE_GR;
+          reg->val = sr->gr_save_loc++;
+        }
     }
 
   /* Next, compute when the fp, general, and branch registers get
@@ -225,8 +225,8 @@ finish_prologue (struct ia64_state_record *sr)
       unsigned long t;
       static const unsigned char limit[3] =
         {
-	  IA64_REG_F31, IA64_REG_R7, IA64_REG_B5
-	};
+          IA64_REG_F31, IA64_REG_R7, IA64_REG_B5
+        };
       struct ia64_reg_info *(regs[3]);
 
       regs[0] = sr->curr.reg + IA64_REG_F2;
@@ -234,14 +234,14 @@ finish_prologue (struct ia64_state_record *sr)
       regs[2] = sr->curr.reg + IA64_REG_B1;
 
       for (t = 0; (int) t < sr->region_len; ++t)
-	{
-	  if ((t & 3) == 0)
-	    mask = *cp++;
-	  kind = (mask >> 2 * (3 - (t & 3))) & 3;
-	  if (kind > 0)
-	    spill_next_when (&regs[kind - 1], sr->curr.reg + limit[kind - 1],
-			     sr->region_start + t);
-	}
+        {
+          if ((t & 3) == 0)
+            mask = *cp++;
+          kind = (mask >> 2 * (3 - (t & 3))) & 3;
+          if (kind > 0)
+            spill_next_when (&regs[kind - 1], sr->curr.reg + limit[kind - 1],
+                             sr->region_start + t);
+        }
     }
 
   /* Next, lay out the memory stack spill area.  */
@@ -250,11 +250,11 @@ finish_prologue (struct ia64_state_record *sr)
     {
       off = sr->spill_offset;
       alloc_spill_area (&off, 16, sr->curr.reg + IA64_REG_F2,
-			sr->curr.reg + IA64_REG_F31);
+                        sr->curr.reg + IA64_REG_F31);
       alloc_spill_area (&off, 8, sr->curr.reg + IA64_REG_B1,
-			sr->curr.reg + IA64_REG_B5);
+                        sr->curr.reg + IA64_REG_B5);
       alloc_spill_area (&off, 8, sr->curr.reg + IA64_REG_R4,
-			sr->curr.reg + IA64_REG_R7);
+                        sr->curr.reg + IA64_REG_R7);
     }
 }
 
@@ -262,7 +262,7 @@ finish_prologue (struct ia64_state_record *sr)
 
 static void
 desc_prologue (int body, unw_word rlen, unsigned char mask,
-	       unsigned char grsave, struct ia64_state_record *sr)
+               unsigned char grsave, struct ia64_state_record *sr)
 {
   int i, region_start;
 
@@ -293,17 +293,17 @@ desc_prologue (int body, unw_word rlen, unsigned char mask,
       push (sr);
 
       if (mask)
-	for (i = 0; i < 4; ++i)
-	  {
-	    if (mask & 0x8)
-	      set_reg (sr->curr.reg + unw.save_order[i], IA64_WHERE_GR,
-		       sr->region_start + sr->region_len - 1, grsave++);
-	    mask <<= 1;
-	  }
+        for (i = 0; i < 4; ++i)
+          {
+            if (mask & 0x8)
+              set_reg (sr->curr.reg + unw.save_order[i], IA64_WHERE_GR,
+                       sr->region_start + sr->region_len - 1, grsave++);
+            mask <<= 1;
+          }
       sr->gr_save_loc = grsave;
       sr->any_spills = 0;
       sr->imask = 0;
-      sr->spill_offset = 0x10;	/* default to psp+16 */
+      sr->spill_offset = 0x10;  /* default to psp+16 */
     }
 }
 
@@ -311,22 +311,22 @@ desc_prologue (int body, unw_word rlen, unsigned char mask,
 
 static inline void
 desc_abi (unsigned char abi, unsigned char context,
-	  struct ia64_state_record *sr)
+          struct ia64_state_record *sr)
 {
   sr->abi_marker = (abi << 8) | context;
 }
 
 static inline void
 desc_br_gr (unsigned char brmask, unsigned char gr,
-	    struct ia64_state_record *sr)
+            struct ia64_state_record *sr)
 {
   int i;
 
   for (i = 0; i < 5; ++i)
     {
       if (brmask & 1)
-	set_reg (sr->curr.reg + IA64_REG_B1 + i, IA64_WHERE_GR,
-		 sr->region_start + sr->region_len - 1, gr++);
+        set_reg (sr->curr.reg + IA64_REG_B1 + i, IA64_WHERE_GR,
+                 sr->region_start + sr->region_len - 1, gr++);
       brmask >>= 1;
     }
 }
@@ -339,40 +339,40 @@ desc_br_mem (unsigned char brmask, struct ia64_state_record *sr)
   for (i = 0; i < 5; ++i)
     {
       if (brmask & 1)
-	{
-	  set_reg (sr->curr.reg + IA64_REG_B1 + i, IA64_WHERE_SPILL_HOME,
-		   sr->region_start + sr->region_len - 1, 0);
-	  sr->any_spills = 1;
-	}
+        {
+          set_reg (sr->curr.reg + IA64_REG_B1 + i, IA64_WHERE_SPILL_HOME,
+                   sr->region_start + sr->region_len - 1, 0);
+          sr->any_spills = 1;
+        }
       brmask >>= 1;
     }
 }
 
 static inline void
 desc_frgr_mem (unsigned char grmask, unw_word frmask,
-	       struct ia64_state_record *sr)
+               struct ia64_state_record *sr)
 {
   int i;
 
   for (i = 0; i < 4; ++i)
     {
       if ((grmask & 1) != 0)
-	{
-	  set_reg (sr->curr.reg + IA64_REG_R4 + i, IA64_WHERE_SPILL_HOME,
-		   sr->region_start + sr->region_len - 1, 0);
-	  sr->any_spills = 1;
-	}
+        {
+          set_reg (sr->curr.reg + IA64_REG_R4 + i, IA64_WHERE_SPILL_HOME,
+                   sr->region_start + sr->region_len - 1, 0);
+          sr->any_spills = 1;
+        }
       grmask >>= 1;
     }
   for (i = 0; i < 20; ++i)
     {
       if ((frmask & 1) != 0)
-	{
-	  int base = (i < 4) ? IA64_REG_F2 : IA64_REG_F16 - 4;
-	  set_reg (sr->curr.reg + base + i, IA64_WHERE_SPILL_HOME,
-		   sr->region_start + sr->region_len - 1, 0);
-	  sr->any_spills = 1;
-	}
+        {
+          int base = (i < 4) ? IA64_REG_F2 : IA64_REG_F16 - 4;
+          set_reg (sr->curr.reg + base + i, IA64_WHERE_SPILL_HOME,
+                   sr->region_start + sr->region_len - 1, 0);
+          sr->any_spills = 1;
+        }
       frmask >>= 1;
     }
 }
@@ -385,26 +385,26 @@ desc_fr_mem (unsigned char frmask, struct ia64_state_record *sr)
   for (i = 0; i < 4; ++i)
     {
       if ((frmask & 1) != 0)
-	{
-	  set_reg (sr->curr.reg + IA64_REG_F2 + i, IA64_WHERE_SPILL_HOME,
-		   sr->region_start + sr->region_len - 1, 0);
-	  sr->any_spills = 1;
-	}
+        {
+          set_reg (sr->curr.reg + IA64_REG_F2 + i, IA64_WHERE_SPILL_HOME,
+                   sr->region_start + sr->region_len - 1, 0);
+          sr->any_spills = 1;
+        }
       frmask >>= 1;
     }
 }
 
 static inline void
 desc_gr_gr (unsigned char grmask, unsigned char gr,
-	    struct ia64_state_record *sr)
+            struct ia64_state_record *sr)
 {
   int i;
 
   for (i = 0; i < 4; ++i)
     {
       if ((grmask & 1) != 0)
-	set_reg (sr->curr.reg + IA64_REG_R4 + i, IA64_WHERE_GR,
-		 sr->region_start + sr->region_len - 1, gr++);
+        set_reg (sr->curr.reg + IA64_REG_R4 + i, IA64_WHERE_GR,
+                 sr->region_start + sr->region_len - 1, gr++);
       grmask >>= 1;
     }
 }
@@ -417,11 +417,11 @@ desc_gr_mem (unsigned char grmask, struct ia64_state_record *sr)
   for (i = 0; i < 4; ++i)
     {
       if ((grmask & 1) != 0)
-	{
-	  set_reg (sr->curr.reg + IA64_REG_R4 + i, IA64_WHERE_SPILL_HOME,
-		   sr->region_start + sr->region_len - 1, 0);
-	  sr->any_spills = 1;
-	}
+        {
+          set_reg (sr->curr.reg + IA64_REG_R4 + i, IA64_WHERE_SPILL_HOME,
+                   sr->region_start + sr->region_len - 1, 0);
+          sr->any_spills = 1;
+        }
       grmask >>= 1;
     }
 }
@@ -430,7 +430,7 @@ static inline void
 desc_mem_stack_f (unw_word t, unw_word size, struct ia64_state_record *sr)
 {
   set_reg (sr->curr.reg + IA64_REG_PSP, IA64_WHERE_NONE,
-	   sr->region_start + MIN ((int) t, sr->region_len - 1), 16 * size);
+           sr->region_start + MIN ((int) t, sr->region_len - 1), 16 * size);
 }
 
 static inline void
@@ -442,26 +442,26 @@ desc_mem_stack_v (unw_word t, struct ia64_state_record *sr)
 
 static inline void
 desc_reg_gr (unsigned char reg, unsigned char dst,
-	     struct ia64_state_record *sr)
+             struct ia64_state_record *sr)
 {
   set_reg (sr->curr.reg + reg, IA64_WHERE_GR,
-	   sr->region_start + sr->region_len - 1, dst);
+           sr->region_start + sr->region_len - 1, dst);
 }
 
 static inline void
 desc_reg_psprel (unsigned char reg, unw_word pspoff,
-		 struct ia64_state_record *sr)
+                 struct ia64_state_record *sr)
 {
   set_reg (sr->curr.reg + reg, IA64_WHERE_PSPREL,
-	   sr->region_start + sr->region_len - 1, 0x10 - 4 * pspoff);
+           sr->region_start + sr->region_len - 1, 0x10 - 4 * pspoff);
 }
 
 static inline void
 desc_reg_sprel (unsigned char reg, unw_word spoff,
-		struct ia64_state_record *sr)
+                struct ia64_state_record *sr)
 {
   set_reg (sr->curr.reg + reg, IA64_WHERE_SPREL,
-	   sr->region_start + sr->region_len - 1, 4 * spoff);
+           sr->region_start + sr->region_len - 1, 4 * spoff);
 }
 
 static inline void
@@ -510,12 +510,12 @@ desc_copy_state (unw_word label, struct ia64_state_record *sr)
   for (ls = sr->labeled_states; ls; ls = ls->next)
     {
       if (ls->label == label)
-	{
-	  free_state_stack (&sr->curr);
-	  memcpy (&sr->curr, &ls->saved_state, sizeof (sr->curr));
-	  sr->curr.next = dup_state_stack (ls->saved_state.next);
-	  return;
-	}
+        {
+          free_state_stack (&sr->curr);
+          memcpy (&sr->curr, &ls->saved_state, sizeof (sr->curr));
+          sr->curr.next = dup_state_stack (ls->saved_state.next);
+          return;
+        }
     }
   print_error ("libunwind: failed to find labeled state\n");
 }
@@ -550,7 +550,7 @@ desc_is_active (unsigned char qp, unw_word t, struct ia64_state_record *sr)
   if (qp > 0)
     {
       if ((sr->pr_val & ((unw_word_t) 1 << qp)) == 0)
-	return 0;
+        return 0;
       sr->pr_mask |= ((unw_word_t) 1 << qp);
     }
   return 1;
@@ -558,7 +558,7 @@ desc_is_active (unsigned char qp, unw_word t, struct ia64_state_record *sr)
 
 static inline void
 desc_restore_p (unsigned char qp, unw_word t, unsigned char abreg,
-		struct ia64_state_record *sr)
+                struct ia64_state_record *sr)
 {
   struct ia64_reg_info *r;
 
@@ -573,8 +573,8 @@ desc_restore_p (unsigned char qp, unw_word t, unsigned char abreg,
 
 static inline void
 desc_spill_reg_p (unsigned char qp, unw_word t, unsigned char abreg,
-		  unsigned char x, unsigned char ytreg,
-		  struct ia64_state_record *sr)
+                  unsigned char x, unsigned char ytreg,
+                  struct ia64_state_record *sr)
 {
   enum ia64_where where = IA64_WHERE_GR;
   struct ia64_reg_info *r;
@@ -595,7 +595,7 @@ desc_spill_reg_p (unsigned char qp, unw_word t, unsigned char abreg,
 
 static inline void
 desc_spill_psprel_p (unsigned char qp, unw_word t, unsigned char abreg,
-		     unw_word pspoff, struct ia64_state_record *sr)
+                     unw_word pspoff, struct ia64_state_record *sr)
 {
   struct ia64_reg_info *r;
 
@@ -610,7 +610,7 @@ desc_spill_psprel_p (unsigned char qp, unw_word t, unsigned char abreg,
 
 static inline void
 desc_spill_sprel_p (unsigned char qp, unw_word t, unsigned char abreg,
-		    unw_word spoff, struct ia64_state_record *sr)
+                    unw_word spoff, struct ia64_state_record *sr)
 {
   struct ia64_reg_info *r;
 
@@ -623,69 +623,69 @@ desc_spill_sprel_p (unsigned char qp, unw_word t, unsigned char abreg,
   r->val = 4 * spoff;
 }
 
-#define UNW_DEC_BAD_CODE(code)						\
-	print_error ("libunwind: unknown code encountered\n")
+#define UNW_DEC_BAD_CODE(code)                                          \
+        print_error ("libunwind: unknown code encountered\n")
 
 /* Register names.  */
-#define UNW_REG_BSP		IA64_REG_BSP
-#define UNW_REG_BSPSTORE	IA64_REG_BSPSTORE
-#define UNW_REG_FPSR		IA64_REG_FPSR
-#define UNW_REG_LC		IA64_REG_LC
-#define UNW_REG_PFS		IA64_REG_PFS
-#define UNW_REG_PR		IA64_REG_PR
-#define UNW_REG_RNAT		IA64_REG_RNAT
-#define UNW_REG_PSP		IA64_REG_PSP
-#define UNW_REG_RP		IA64_REG_IP
-#define UNW_REG_UNAT		IA64_REG_UNAT
+#define UNW_REG_BSP             IA64_REG_BSP
+#define UNW_REG_BSPSTORE        IA64_REG_BSPSTORE
+#define UNW_REG_FPSR            IA64_REG_FPSR
+#define UNW_REG_LC              IA64_REG_LC
+#define UNW_REG_PFS             IA64_REG_PFS
+#define UNW_REG_PR              IA64_REG_PR
+#define UNW_REG_RNAT            IA64_REG_RNAT
+#define UNW_REG_PSP             IA64_REG_PSP
+#define UNW_REG_RP              IA64_REG_IP
+#define UNW_REG_UNAT            IA64_REG_UNAT
 
 /* Region headers.  */
-#define UNW_DEC_PROLOGUE_GR(fmt,r,m,gr,arg)	desc_prologue(0,r,m,gr,arg)
-#define UNW_DEC_PROLOGUE(fmt,b,r,arg)		desc_prologue(b,r,0,32,arg)
+#define UNW_DEC_PROLOGUE_GR(fmt,r,m,gr,arg)     desc_prologue(0,r,m,gr,arg)
+#define UNW_DEC_PROLOGUE(fmt,b,r,arg)           desc_prologue(b,r,0,32,arg)
 
 /* Prologue descriptors.  */
-#define UNW_DEC_ABI(fmt,a,c,arg)		desc_abi(a,c,arg)
-#define UNW_DEC_BR_GR(fmt,b,g,arg)		desc_br_gr(b,g,arg)
-#define UNW_DEC_BR_MEM(fmt,b,arg)		desc_br_mem(b,arg)
-#define UNW_DEC_FRGR_MEM(fmt,g,f,arg)		desc_frgr_mem(g,f,arg)
-#define UNW_DEC_FR_MEM(fmt,f,arg)		desc_fr_mem(f,arg)
-#define UNW_DEC_GR_GR(fmt,m,g,arg)		desc_gr_gr(m,g,arg)
-#define UNW_DEC_GR_MEM(fmt,m,arg)		desc_gr_mem(m,arg)
-#define UNW_DEC_MEM_STACK_F(fmt,t,s,arg)	desc_mem_stack_f(t,s,arg)
-#define UNW_DEC_MEM_STACK_V(fmt,t,arg)		desc_mem_stack_v(t,arg)
-#define UNW_DEC_REG_GR(fmt,r,d,arg)		desc_reg_gr(r,d,arg)
-#define UNW_DEC_REG_PSPREL(fmt,r,o,arg)		desc_reg_psprel(r,o,arg)
-#define UNW_DEC_REG_SPREL(fmt,r,o,arg)		desc_reg_sprel(r,o,arg)
-#define UNW_DEC_REG_WHEN(fmt,r,t,arg)		desc_reg_when(r,t,arg)
+#define UNW_DEC_ABI(fmt,a,c,arg)                desc_abi(a,c,arg)
+#define UNW_DEC_BR_GR(fmt,b,g,arg)              desc_br_gr(b,g,arg)
+#define UNW_DEC_BR_MEM(fmt,b,arg)               desc_br_mem(b,arg)
+#define UNW_DEC_FRGR_MEM(fmt,g,f,arg)           desc_frgr_mem(g,f,arg)
+#define UNW_DEC_FR_MEM(fmt,f,arg)               desc_fr_mem(f,arg)
+#define UNW_DEC_GR_GR(fmt,m,g,arg)              desc_gr_gr(m,g,arg)
+#define UNW_DEC_GR_MEM(fmt,m,arg)               desc_gr_mem(m,arg)
+#define UNW_DEC_MEM_STACK_F(fmt,t,s,arg)        desc_mem_stack_f(t,s,arg)
+#define UNW_DEC_MEM_STACK_V(fmt,t,arg)          desc_mem_stack_v(t,arg)
+#define UNW_DEC_REG_GR(fmt,r,d,arg)             desc_reg_gr(r,d,arg)
+#define UNW_DEC_REG_PSPREL(fmt,r,o,arg)         desc_reg_psprel(r,o,arg)
+#define UNW_DEC_REG_SPREL(fmt,r,o,arg)          desc_reg_sprel(r,o,arg)
+#define UNW_DEC_REG_WHEN(fmt,r,t,arg)           desc_reg_when(r,t,arg)
 #define UNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg) \
-	desc_reg_when(IA64_REG_PRI_UNAT_GR,t,arg)
+        desc_reg_when(IA64_REG_PRI_UNAT_GR,t,arg)
 #define UNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg) \
-	desc_reg_when(IA64_REG_PRI_UNAT_MEM,t,arg)
+        desc_reg_when(IA64_REG_PRI_UNAT_MEM,t,arg)
 #define UNW_DEC_PRIUNAT_GR(fmt,r,arg) \
-	desc_reg_gr(IA64_REG_PRI_UNAT_GR,r,arg)
+        desc_reg_gr(IA64_REG_PRI_UNAT_GR,r,arg)
 #define UNW_DEC_PRIUNAT_PSPREL(fmt,o,arg) \
-	desc_reg_psprel(IA64_REG_PRI_UNAT_MEM,o,arg)
+        desc_reg_psprel(IA64_REG_PRI_UNAT_MEM,o,arg)
 #define UNW_DEC_PRIUNAT_SPREL(fmt,o,arg) \
-	desc_reg_sprel(IA64_REG_PRI_UNAT_MEM,o,arg)
-#define UNW_DEC_RP_BR(fmt,d,arg)		desc_rp_br(d,arg)
-#define UNW_DEC_SPILL_BASE(fmt,o,arg)		desc_spill_base(o,arg)
-#define UNW_DEC_SPILL_MASK(fmt,m,arg)		(m = desc_spill_mask(m,arg))
+        desc_reg_sprel(IA64_REG_PRI_UNAT_MEM,o,arg)
+#define UNW_DEC_RP_BR(fmt,d,arg)                desc_rp_br(d,arg)
+#define UNW_DEC_SPILL_BASE(fmt,o,arg)           desc_spill_base(o,arg)
+#define UNW_DEC_SPILL_MASK(fmt,m,arg)           (m = desc_spill_mask(m,arg))
 
 /* Body descriptors.  */
-#define UNW_DEC_EPILOGUE(fmt,t,c,arg)		desc_epilogue(t,c,arg)
-#define UNW_DEC_COPY_STATE(fmt,l,arg)		desc_copy_state(l,arg)
-#define UNW_DEC_LABEL_STATE(fmt,l,arg)		desc_label_state(l,arg)
+#define UNW_DEC_EPILOGUE(fmt,t,c,arg)           desc_epilogue(t,c,arg)
+#define UNW_DEC_COPY_STATE(fmt,l,arg)           desc_copy_state(l,arg)
+#define UNW_DEC_LABEL_STATE(fmt,l,arg)          desc_label_state(l,arg)
 
 /* General unwind descriptors.  */
-#define UNW_DEC_SPILL_REG_P(f,p,t,a,x,y,arg)	desc_spill_reg_p(p,t,a,x,y,arg)
-#define UNW_DEC_SPILL_REG(f,t,a,x,y,arg)	desc_spill_reg_p(0,t,a,x,y,arg)
+#define UNW_DEC_SPILL_REG_P(f,p,t,a,x,y,arg)    desc_spill_reg_p(p,t,a,x,y,arg)
+#define UNW_DEC_SPILL_REG(f,t,a,x,y,arg)        desc_spill_reg_p(0,t,a,x,y,arg)
 #define UNW_DEC_SPILL_PSPREL_P(f,p,t,a,o,arg) \
-	desc_spill_psprel_p(p,t,a,o,arg)
+        desc_spill_psprel_p(p,t,a,o,arg)
 #define UNW_DEC_SPILL_PSPREL(f,t,a,o,arg) \
-	desc_spill_psprel_p(0,t,a,o,arg)
-#define UNW_DEC_SPILL_SPREL_P(f,p,t,a,o,arg)	desc_spill_sprel_p(p,t,a,o,arg)
-#define UNW_DEC_SPILL_SPREL(f,t,a,o,arg)	desc_spill_sprel_p(0,t,a,o,arg)
-#define UNW_DEC_RESTORE_P(f,p,t,a,arg)		desc_restore_p(p,t,a,arg)
-#define UNW_DEC_RESTORE(f,t,a,arg)		desc_restore_p(0,t,a,arg)
+        desc_spill_psprel_p(0,t,a,o,arg)
+#define UNW_DEC_SPILL_SPREL_P(f,p,t,a,o,arg)    desc_spill_sprel_p(p,t,a,o,arg)
+#define UNW_DEC_SPILL_SPREL(f,t,a,o,arg)        desc_spill_sprel_p(0,t,a,o,arg)
+#define UNW_DEC_RESTORE_P(f,p,t,a,arg)          desc_restore_p(p,t,a,arg)
+#define UNW_DEC_RESTORE(f,t,a,arg)              desc_restore_p(0,t,a,arg)
 
 #include "unwind_decoder.h"
 
@@ -700,22 +700,22 @@ lookup_preg (int regnum, int memory, struct ia64_state_record *sr)
 
   switch (regnum)
     {
-    case UNW_IA64_AR_BSP:		preg = IA64_REG_BSP; break;
-    case UNW_IA64_AR_BSPSTORE:		preg = IA64_REG_BSPSTORE; break;
-    case UNW_IA64_AR_FPSR:		preg = IA64_REG_FPSR; break;
-    case UNW_IA64_AR_LC:		preg = IA64_REG_LC; break;
-    case UNW_IA64_AR_PFS:		preg = IA64_REG_PFS; break;
-    case UNW_IA64_AR_RNAT:		preg = IA64_REG_RNAT; break;
-    case UNW_IA64_AR_UNAT:		preg = IA64_REG_UNAT; break;
-    case UNW_IA64_BR + 0:		preg = IA64_REG_IP; break;
-    case UNW_IA64_PR:			preg = IA64_REG_PR; break;
-    case UNW_IA64_SP:			preg = IA64_REG_PSP; break;
+    case UNW_IA64_AR_BSP:               preg = IA64_REG_BSP; break;
+    case UNW_IA64_AR_BSPSTORE:          preg = IA64_REG_BSPSTORE; break;
+    case UNW_IA64_AR_FPSR:              preg = IA64_REG_FPSR; break;
+    case UNW_IA64_AR_LC:                preg = IA64_REG_LC; break;
+    case UNW_IA64_AR_PFS:               preg = IA64_REG_PFS; break;
+    case UNW_IA64_AR_RNAT:              preg = IA64_REG_RNAT; break;
+    case UNW_IA64_AR_UNAT:              preg = IA64_REG_UNAT; break;
+    case UNW_IA64_BR + 0:               preg = IA64_REG_IP; break;
+    case UNW_IA64_PR:                   preg = IA64_REG_PR; break;
+    case UNW_IA64_SP:                   preg = IA64_REG_PSP; break;
 
     case UNW_IA64_NAT:
       if (memory)
-	preg = IA64_REG_PRI_UNAT_MEM;
+        preg = IA64_REG_PRI_UNAT_MEM;
       else
-	preg = IA64_REG_PRI_UNAT_GR;
+        preg = IA64_REG_PRI_UNAT_GR;
       break;
 
     case UNW_IA64_GR + 4 ... UNW_IA64_GR + 7:
@@ -802,119 +802,119 @@ parse_dynamic (struct cursor *c, struct ia64_state_record *sr)
     {
       len = r->insn_count;
       if (len < 0)
-	{
-	  if (r->next)
-	    {
-	      Debug (1, "negative region length allowed in last region only!");
-	      return -UNW_EINVAL;
-	    }
-	  len = -len;
-	  /* hack old region info to set the start where we need it: */
-	  sr->region_start = (di->end_ip - di->start_ip) / 0x10 * 3 - len;
-	  sr->region_len = 0;
-	}
+        {
+          if (r->next)
+            {
+              Debug (1, "negative region length allowed in last region only!");
+              return -UNW_EINVAL;
+            }
+          len = -len;
+          /* hack old region info to set the start where we need it: */
+          sr->region_start = (di->end_ip - di->start_ip) / 0x10 * 3 - len;
+          sr->region_len = 0;
+        }
       /* all regions are treated as prologue regions: */
       desc_prologue (0, len, 0, 0, sr);
 
       if (sr->done)
-	return 0;
+        return 0;
 
       for (op = r->op; op < r->op + r->op_count; ++op)
-	{
-	  when = op->when;
-	  val = op->val;
-	  qp = op->qp;
-
-	  if (!desc_is_active (qp, when, sr))
-	    continue;
-
-	  when = sr->region_start + MIN ((int) when, sr->region_len - 1);
-
-	  switch (op->tag)
-	    {
-	    case UNW_DYN_SAVE_REG:
-	      memory = 0;
-	      if ((unsigned) (val - UNW_IA64_GR) < 128)
-		where = IA64_WHERE_GR;
-	      else if ((unsigned) (val - UNW_IA64_FR) < 128)
-		where = IA64_WHERE_FR;
-	      else if ((unsigned) (val - UNW_IA64_BR) < 8)
-		where = IA64_WHERE_BR;
-	      else
-		{
-		  Dprintf ("%s: can't save to register number %d\n",
-			   __FUNCTION__, (int) op->reg);
-		  return -UNW_EBADREG;
-		}
-	      /* fall through */
-	    update_reg_info:
-	      ri = lookup_preg (op->reg, memory, sr);
-	      if (!ri)
-		return -UNW_EBADREG;
-	      ri->where = where;
-	      ri->when = when;
-	      ri->val = val;
-	      break;
-
-	    case UNW_DYN_SPILL_FP_REL:
-	      memory = 1;
-	      where = IA64_WHERE_PSPREL;
-	      val = 0x10 - val;
-	      goto update_reg_info;
-
-	    case UNW_DYN_SPILL_SP_REL:
-	      memory = 1;
-	      where = IA64_WHERE_SPREL;
-	      goto update_reg_info;
-
-	    case UNW_DYN_ADD:
-	      if (op->reg == UNW_IA64_SP)
-		{
-		  if (val & 0xf)
-		    {
-		      Dprintf ("%s: frame-size %ld not an integer "
-			       "multiple of 16\n",
-			       __FUNCTION__, (long) op->val);
-		      return -UNW_EINVAL;
-		    }
-		  desc_mem_stack_f (when, -((int64_t) val / 16), sr);
-		}
-	      else
-		{
-		  Dprintf ("%s: can only ADD to stack-pointer\n",
-			   __FUNCTION__);
-		  return -UNW_EBADREG;
-		}
-	      break;
-
-	    case UNW_DYN_POP_FRAMES:
-	      sr->when_sp_restored = when;
-	      sr->epilogue_count = op->val;
-	      break;
-
-	    case UNW_DYN_LABEL_STATE:
-	      desc_label_state (op->val, sr);
-	      break;
-
-	    case UNW_DYN_COPY_STATE:
-	      desc_copy_state (op->val, sr);
-	      break;
-
-	    case UNW_DYN_ALIAS:
-	      if ((ret = desc_alias (op, c, sr)) < 0)
-		return ret;
-
-	    case UNW_DYN_STOP:
-	      goto end_of_ops;
-	    }
-	}
+        {
+          when = op->when;
+          val = op->val;
+          qp = op->qp;
+
+          if (!desc_is_active (qp, when, sr))
+            continue;
+
+          when = sr->region_start + MIN ((int) when, sr->region_len - 1);
+
+          switch (op->tag)
+            {
+            case UNW_DYN_SAVE_REG:
+              memory = 0;
+              if ((unsigned) (val - UNW_IA64_GR) < 128)
+                where = IA64_WHERE_GR;
+              else if ((unsigned) (val - UNW_IA64_FR) < 128)
+                where = IA64_WHERE_FR;
+              else if ((unsigned) (val - UNW_IA64_BR) < 8)
+                where = IA64_WHERE_BR;
+              else
+                {
+                  Dprintf ("%s: can't save to register number %d\n",
+                           __FUNCTION__, (int) op->reg);
+                  return -UNW_EBADREG;
+                }
+              /* fall through */
+            update_reg_info:
+              ri = lookup_preg (op->reg, memory, sr);
+              if (!ri)
+                return -UNW_EBADREG;
+              ri->where = where;
+              ri->when = when;
+              ri->val = val;
+              break;
+
+            case UNW_DYN_SPILL_FP_REL:
+              memory = 1;
+              where = IA64_WHERE_PSPREL;
+              val = 0x10 - val;
+              goto update_reg_info;
+
+            case UNW_DYN_SPILL_SP_REL:
+              memory = 1;
+              where = IA64_WHERE_SPREL;
+              goto update_reg_info;
+
+            case UNW_DYN_ADD:
+              if (op->reg == UNW_IA64_SP)
+                {
+                  if (val & 0xf)
+                    {
+                      Dprintf ("%s: frame-size %ld not an integer "
+                               "multiple of 16\n",
+                               __FUNCTION__, (long) op->val);
+                      return -UNW_EINVAL;
+                    }
+                  desc_mem_stack_f (when, -((int64_t) val / 16), sr);
+                }
+              else
+                {
+                  Dprintf ("%s: can only ADD to stack-pointer\n",
+                           __FUNCTION__);
+                  return -UNW_EBADREG;
+                }
+              break;
+
+            case UNW_DYN_POP_FRAMES:
+              sr->when_sp_restored = when;
+              sr->epilogue_count = op->val;
+              break;
+
+            case UNW_DYN_LABEL_STATE:
+              desc_label_state (op->val, sr);
+              break;
+
+            case UNW_DYN_COPY_STATE:
+              desc_copy_state (op->val, sr);
+              break;
+
+            case UNW_DYN_ALIAS:
+              if ((ret = desc_alias (op, c, sr)) < 0)
+                return ret;
+
+            case UNW_DYN_STOP:
+              goto end_of_ops;
+            }
+        }
     end_of_ops:
       ;
     }
   return 0;
 }
 #else
-# define parse_dynamic(c,sr)	(-UNW_EINVAL)
+# define parse_dynamic(c,sr)    (-UNW_EINVAL)
 #endif /* _U_dyn_op */
 
 
@@ -928,7 +928,7 @@ ia64_fetch_proc_info (struct cursor *c, unw_word_t ip, int need_unwind_info)
 
   /* check dynamic info first --- it overrides everything else */
   ret = unwi_find_dynamic_proc_info (c->as, ip, &c->pi, need_unwind_info,
-				     c->as_arg);
+                                     c->as_arg);
   if (ret == -UNW_ENOINFO)
     {
       dynamic = 0;
@@ -954,7 +954,7 @@ put_unwind_info (struct cursor *c, unw_proc_info_t *pi)
 
 static int
 create_state_record_for (struct cursor *c, struct ia64_state_record *sr,
-			 unw_word_t ip)
+                         unw_word_t ip)
 {
   unw_word_t predicates = c->pr;
   struct ia64_reg_info *r;
@@ -975,7 +975,7 @@ create_state_record_for (struct cursor *c, struct ia64_state_record *sr,
       /* No info, return default unwinder (leaf proc, no mem stack, no
          saved regs), rp in b0, pfs in ar.pfs.  */
       Debug (1, "no unwind info for ip=0x%lx (gp=%lx)\n",
-	     (long) ip, (long) c->pi.gp);
+             (long) ip, (long) c->pi.gp);
       sr->curr.reg[IA64_REG_IP].where = IA64_WHERE_BR;
       sr->curr.reg[IA64_REG_IP].when = -1;
       sr->curr.reg[IA64_REG_IP].val = 0;
@@ -983,7 +983,7 @@ create_state_record_for (struct cursor *c, struct ia64_state_record *sr,
     }
 
   sr->when_target = (3 * ((ip & ~(unw_word_t) 0xf) - c->pi.start_ip) / 16
-		     + (ip & 0xf));
+                     + (ip & 0xf));
 
   switch (c->pi.format)
     {
@@ -992,7 +992,7 @@ create_state_record_for (struct cursor *c, struct ia64_state_record *sr,
       dp = c->pi.unwind_info;
       desc_end = dp + c->pi.unwind_info_size;
       while (!sr->done && dp < desc_end)
-	dp = unw_decode (dp, sr->in_body, sr);
+        dp = unw_decode (dp, sr->in_body, sr);
       ret = 0;
       break;
 
@@ -1012,18 +1012,18 @@ create_state_record_for (struct cursor *c, struct ia64_state_record *sr,
   if (sr->when_target > sr->when_sp_restored)
     {
       /* sp has been restored and all values on the memory stack below
-	 psp also have been restored.  */
+         psp also have been restored.  */
       sr->curr.reg[IA64_REG_PSP].val = 0;
       sr->curr.reg[IA64_REG_PSP].where = IA64_WHERE_NONE;
       sr->curr.reg[IA64_REG_PSP].when = IA64_WHEN_NEVER;
       for (r = sr->curr.reg; r < sr->curr.reg + IA64_NUM_PREGS; ++r)
-	if ((r->where == IA64_WHERE_PSPREL && r->val <= 0x10)
-	    || r->where == IA64_WHERE_SPREL)
-	  {
-	    r->val = 0;
-	    r->where = IA64_WHERE_NONE;
-	    r->when = IA64_WHEN_NEVER;
-	  }
+        if ((r->where == IA64_WHERE_PSPREL && r->val <= 0x10)
+            || r->where == IA64_WHERE_SPREL)
+          {
+            r->val = 0;
+            r->where = IA64_WHERE_NONE;
+            r->when = IA64_WHEN_NEVER;
+          }
     }
 
   /* If RP did't get saved, generate entry for the return link
@@ -1040,7 +1040,7 @@ create_state_record_for (struct cursor *c, struct ia64_state_record *sr,
       && sr->when_target > sr->curr.reg[IA64_REG_RNAT].when)
     {
       Debug (8, "func 0x%lx may switch the register-backing-store\n",
-	     c->pi.start_ip);
+             c->pi.start_ip);
       c->pi.flags |= UNW_PI_FLAG_IA64_RBS_SWITCH;
     }
  out:
@@ -1048,41 +1048,41 @@ create_state_record_for (struct cursor *c, struct ia64_state_record *sr,
   if (unwi_debug_level > 2)
     {
       Dprintf ("%s: state record for func 0x%lx, t=%u (flags=0x%lx):\n",
-	       __FUNCTION__,
-	       (long) c->pi.start_ip, sr->when_target, (long) c->pi.flags);
+               __FUNCTION__,
+               (long) c->pi.start_ip, sr->when_target, (long) c->pi.flags);
       for (r = sr->curr.reg; r < sr->curr.reg + IA64_NUM_PREGS; ++r)
-	{
-	  if (r->where != IA64_WHERE_NONE || r->when != IA64_WHEN_NEVER)
-	    {
-	      Dprintf ("  %s <- ", unw.preg_name[r - sr->curr.reg]);
-	      switch (r->where)
-		{
-		case IA64_WHERE_GR:
-		  Dprintf ("r%lu", (long) r->val);
-		  break;
-		case IA64_WHERE_FR:
-		  Dprintf ("f%lu", (long) r->val);
-		  break;
-		case IA64_WHERE_BR:
-		  Dprintf ("b%lu", (long) r->val);
-		  break;
-		case IA64_WHERE_SPREL:
-		  Dprintf ("[sp+0x%lx]", (long) r->val);
-		  break;
-		case IA64_WHERE_PSPREL:
-		  Dprintf ("[psp+0x%lx]", (long) r->val);
-		  break;
-		case IA64_WHERE_NONE:
-		  Dprintf ("%s+0x%lx",
-			   unw.preg_name[r - sr->curr.reg], (long) r->val);
-		  break;
-		default:
-		  Dprintf ("BADWHERE(%d)", r->where);
-		  break;
-		}
-	      Dprintf ("\t\t%d\n", r->when);
-	    }
-	}
+        {
+          if (r->where != IA64_WHERE_NONE || r->when != IA64_WHEN_NEVER)
+            {
+              Dprintf ("  %s <- ", unw.preg_name[r - sr->curr.reg]);
+              switch (r->where)
+                {
+                case IA64_WHERE_GR:
+                  Dprintf ("r%lu", (long) r->val);
+                  break;
+                case IA64_WHERE_FR:
+                  Dprintf ("f%lu", (long) r->val);
+                  break;
+                case IA64_WHERE_BR:
+                  Dprintf ("b%lu", (long) r->val);
+                  break;
+                case IA64_WHERE_SPREL:
+                  Dprintf ("[sp+0x%lx]", (long) r->val);
+                  break;
+                case IA64_WHERE_PSPREL:
+                  Dprintf ("[psp+0x%lx]", (long) r->val);
+                  break;
+                case IA64_WHERE_NONE:
+                  Dprintf ("%s+0x%lx",
+                           unw.preg_name[r - sr->curr.reg], (long) r->val);
+                  break;
+                default:
+                  Dprintf ("BADWHERE(%d)", r->where);
+                  break;
+                }
+              Dprintf ("\t\t%d\n", r->when);
+            }
+        }
     }
 #endif
   return 0;
@@ -1123,9 +1123,9 @@ ia64_make_proc_info (struct cursor *c)
     {
       /* Lookup it up the slow way... */
       if ((ret = ia64_fetch_proc_info (c, c->ip, 0)) < 0)
-	return ret;
+        return ret;
       if (caching)
-	ia64_cache_proc_info (c);
+        ia64_cache_proc_info (c);
     }
   return 0;
 }
diff --git a/src/ia64/Grbs.c b/src/ia64/Grbs.c
index 4230cf3..e7c01fe 100644
--- a/src/ia64/Grbs.c
+++ b/src/ia64/Grbs.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -62,7 +62,7 @@ ia64_strloc (ia64_loc_t loc)
     sprintf (buf + strlen (buf), "%s", unw_regname (IA64_GET_REG (loc)));
   else
     sprintf (buf + strlen (buf), "0x%llx",
-	     (unsigned long long) IA64_GET_ADDR (loc));
+             (unsigned long long) IA64_GET_ADDR (loc));
 
   if (IA64_IS_FP_LOC (loc))
     strcat (buf, ")");
@@ -78,8 +78,8 @@ ia64_strloc (ia64_loc_t loc)
 
 HIDDEN int
 rbs_switch (struct cursor *c,
-	    unw_word_t saved_bsp, unw_word_t saved_bspstore,
-	    ia64_loc_t saved_rnat_loc)
+            unw_word_t saved_bsp, unw_word_t saved_bspstore,
+            ia64_loc_t saved_rnat_loc)
 {
   struct rbs_area *rbs = &c->rbs_area[c->rbs_curr];
   unw_word_t lo, ndirty, rbs_base;
@@ -98,13 +98,13 @@ rbs_switch (struct cursor *c,
   if (rbs->size)
     {
       Debug (10, "inner=[0x%lx-0x%lx)\n",
-	     (long) (rbs->end - rbs->size), (long) rbs->end);
+             (long) (rbs->end - rbs->size), (long) rbs->end);
 
       c->rbs_curr = (c->rbs_curr + 1) % ARRAY_SIZE (c->rbs_area);
       rbs = c->rbs_area + c->rbs_curr;
 
       if (c->rbs_curr == c->rbs_left_edge)
-	c->rbs_left_edge = (c->rbs_left_edge + 1) % ARRAY_SIZE (c->rbs_area);
+        c->rbs_left_edge = (c->rbs_left_edge + 1) % ARRAY_SIZE (c->rbs_area);
     }
 
   if ((ret = rbs_get_base (c, saved_bspstore, &rbs_base)) < 0)
@@ -117,13 +117,13 @@ rbs_switch (struct cursor *c,
   c->bsp = saved_bsp;
 
   Debug (10, "outer=[0x%llx-0x%llx), rnat@%s\n", (long long) rbs_base,
-	 (long long) rbs->end, ia64_strloc (rbs->rnat_loc));
+         (long long) rbs->end, ia64_strloc (rbs->rnat_loc));
   return 0;
 }
 
 HIDDEN int
 rbs_find_stacked (struct cursor *c, unw_word_t regs_to_skip,
-		  ia64_loc_t *locp, ia64_loc_t *rnat_locp)
+                  ia64_loc_t *locp, ia64_loc_t *rnat_locp)
 {
   unw_word_t nregs, bsp = c->bsp, curr = c->rbs_curr, n;
   unw_word_t left_edge = c->rbs_left_edge;
@@ -134,10 +134,10 @@ rbs_find_stacked (struct cursor *c, unw_word_t regs_to_skip,
   while (!rbs_contains (&c->rbs_area[curr], bsp))
     {
       if (curr == left_edge)
-	{
-	  Debug (1, "could not find register r%d!\n", reg);
-	  return -UNW_EBADREG;
-	}
+        {
+          Debug (1, "could not find register r%d!\n", reg);
+          return -UNW_EBADREG;
+        }
 
       n = rse_num_regs (c->rbs_area[curr].end, bsp);
       curr = (curr + ARRAY_SIZE (c->rbs_area) - 1) % ARRAY_SIZE (c->rbs_area);
@@ -149,23 +149,23 @@ rbs_find_stacked (struct cursor *c, unw_word_t regs_to_skip,
       nregs = rse_num_regs (bsp, c->rbs_area[curr].end);
 
       if (regs_to_skip < nregs)
-	{
-	  /* found it: */
-	  unw_word_t addr;
-
-	  addr = rse_skip_regs (bsp, regs_to_skip);
-	  if (locp)
-	    *locp = rbs_loc (c->rbs_area + curr, addr);
-	  if (rnat_locp)
-	    *rnat_locp = rbs_get_rnat_loc (c->rbs_area + curr, addr);
-	  return 0;
-	}
+        {
+          /* found it: */
+          unw_word_t addr;
+
+          addr = rse_skip_regs (bsp, regs_to_skip);
+          if (locp)
+            *locp = rbs_loc (c->rbs_area + curr, addr);
+          if (rnat_locp)
+            *rnat_locp = rbs_get_rnat_loc (c->rbs_area + curr, addr);
+          return 0;
+        }
 
       if (curr == left_edge)
-	{
-	  Debug (1, "could not find register r%d!\n", reg);
-	  return -UNW_EBADREG;
-	}
+        {
+          Debug (1, "could not find register r%d!\n", reg);
+          return -UNW_EBADREG;
+        }
 
       regs_to_skip -= nregs;
 
@@ -178,7 +178,7 @@ rbs_find_stacked (struct cursor *c, unw_word_t regs_to_skip,
 
 static inline int
 get_rnat (struct cursor *c, struct rbs_area *rbs, unw_word_t bsp,
-	  unw_word_t *__restrict rnatp)
+          unw_word_t *__restrict rnatp)
 {
   ia64_loc_t rnat_locp = rbs_get_rnat_loc (rbs, bsp);
 
@@ -197,8 +197,8 @@ get_rnat (struct cursor *c, struct rbs_area *rbs, unw_word_t bsp,
    Note: This does not modify the rbs_area[] structure in any way.  */
 HIDDEN int
 rbs_cover_and_flush (struct cursor *c, unw_word_t nregs,
-		     unw_word_t *dirty_partition, unw_word_t *dirty_rnat,
-		     unw_word_t *bspstore)
+                     unw_word_t *dirty_partition, unw_word_t *dirty_rnat,
+                     unw_word_t *bspstore)
 {
   unw_word_t n, src_mask, dst_mask, bsp, *dst, src_rnat, dst_rnat = 0;
   unw_word_t curr = c->rbs_curr, left_edge = c->rbs_left_edge;
@@ -213,23 +213,23 @@ rbs_cover_and_flush (struct cursor *c, unw_word_t nregs,
       /* at least _some_ registers are on rbs... */
       n = rse_num_regs (bsp, rbs->end);
       if (likely (n >= nregs))
-	{
-	  /* common case #1: all registers are on current rbs... */
-	  /* got lucky: _all_ registers are on rbs... */
-	  ia64_loc_t rnat_loc = rbs_get_rnat_loc (rbs, c->bsp);
-
-	  *bspstore = c->bsp;
-
-	  if (IA64_IS_REG_LOC (rnat_loc))
-	    {
-	      unw_word_t rnat_addr = (unw_word_t)
-		tdep_uc_addr (c->as_arg, UNW_IA64_AR_RNAT, NULL);
-	      rnat_loc = IA64_LOC_ADDR (rnat_addr, 0);
-	    }
-	  c->loc[IA64_REG_RNAT] = rnat_loc;
-	  return 0;	/* all done */
-	}
-      nregs -= n;	/* account for registers already on the rbs */
+        {
+          /* common case #1: all registers are on current rbs... */
+          /* got lucky: _all_ registers are on rbs... */
+          ia64_loc_t rnat_loc = rbs_get_rnat_loc (rbs, c->bsp);
+
+          *bspstore = c->bsp;
+
+          if (IA64_IS_REG_LOC (rnat_loc))
+            {
+              unw_word_t rnat_addr = (unw_word_t)
+                tdep_uc_addr (c->as_arg, UNW_IA64_AR_RNAT, NULL);
+              rnat_loc = IA64_LOC_ADDR (rnat_addr, 0);
+            }
+          c->loc[IA64_REG_RNAT] = rnat_loc;
+          return 0;     /* all done */
+        }
+      nregs -= n;       /* account for registers already on the rbs */
 
       assert (rse_skip_regs (c->bsp, -nregs) == rse_skip_regs (rbs->end, 0));
     }
@@ -249,54 +249,54 @@ rbs_cover_and_flush (struct cursor *c, unw_word_t nregs,
   while (nregs > 0)
     {
       if (unlikely (!rbs_contains (rbs, bsp)))
-	{
-	  /* switch to next non-empty rbs-area: */
-	  do
-	    {
-	      if (curr == left_edge)
-		{
-		  Debug (0, "rbs-underflow while flushing %lu regs, "
-			 "bsp=0x%lx, dst=0x%p\n", (unsigned long) nregs,
-			 (unsigned long) bsp, dst);
-		  return -UNW_EBADREG;
-		}
-
-	      assert (rse_num_regs (rbs->end, bsp) == 0);
-
-	      curr = (curr + ARRAY_SIZE (c->rbs_area) - 1)
-		      % ARRAY_SIZE (c->rbs_area);
-	      rbs = c->rbs_area + curr;
-	      bsp = rbs->end - rbs->size;
-	    }
-	  while (rbs->size == 0);
-
-	  if ((ret = get_rnat (c, rbs, bsp, &src_rnat)) < 0)
-	    return ret;
-	}
+        {
+          /* switch to next non-empty rbs-area: */
+          do
+            {
+              if (curr == left_edge)
+                {
+                  Debug (0, "rbs-underflow while flushing %lu regs, "
+                         "bsp=0x%lx, dst=0x%p\n", (unsigned long) nregs,
+                         (unsigned long) bsp, dst);
+                  return -UNW_EBADREG;
+                }
+
+              assert (rse_num_regs (rbs->end, bsp) == 0);
+
+              curr = (curr + ARRAY_SIZE (c->rbs_area) - 1)
+                      % ARRAY_SIZE (c->rbs_area);
+              rbs = c->rbs_area + curr;
+              bsp = rbs->end - rbs->size;
+            }
+          while (rbs->size == 0);
+
+          if ((ret = get_rnat (c, rbs, bsp, &src_rnat)) < 0)
+            return ret;
+        }
 
       if (unlikely (rse_is_rnat_slot (bsp)))
-	{
-	  bsp += 8;
-	  if ((ret = get_rnat (c, rbs, bsp, &src_rnat)) < 0)
-	    return ret;
-	}
+        {
+          bsp += 8;
+          if ((ret = get_rnat (c, rbs, bsp, &src_rnat)) < 0)
+            return ret;
+        }
       if (unlikely (rse_is_rnat_slot ((unw_word_t) dst)))
-	{
-	  *dst++ = dst_rnat;
-	  dst_rnat = 0;
-	}
+        {
+          *dst++ = dst_rnat;
+          dst_rnat = 0;
+        }
 
       src_mask = ((unw_word_t) 1) << rse_slot_num (bsp);
       dst_mask = ((unw_word_t) 1) << rse_slot_num ((unw_word_t) dst);
 
       if (src_rnat & src_mask)
-	dst_rnat |= dst_mask;
+        dst_rnat |= dst_mask;
       else
-	dst_rnat &= ~dst_mask;
+        dst_rnat &= ~dst_mask;
 
       /* copy one slot: */
       if ((ret = ia64_get (c, rbs_loc (rbs, bsp), dst)) < 0)
-	return ret;
+        return ret;
 
       /* advance to next slot: */
       --nregs;
@@ -306,9 +306,9 @@ rbs_cover_and_flush (struct cursor *c, unw_word_t nregs,
   if (unlikely (rse_is_rnat_slot ((unw_word_t) dst)))
     {
       /* The LOADRS instruction loads "the N bytes below the current
-	 BSP" but BSP can never point to an RNaT slot so if the last
-	 destination word happens to be an RNaT slot, we need to write
-	 that slot now. */
+         BSP" but BSP can never point to an RNaT slot so if the last
+         destination word happens to be an RNaT slot, we need to write
+         that slot now. */
       *dst++ = dst_rnat;
       dst_rnat = 0;
     }
diff --git a/src/ia64/Greg_states_iterate.c b/src/ia64/Greg_states_iterate.c
new file mode 100644
index 0000000..3570740
--- /dev/null
+++ b/src/ia64/Greg_states_iterate.c
@@ -0,0 +1,39 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  // Needs dwarf support on ia64
+  // return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+  return -UNW_EINVAL;
+}
diff --git a/src/ia64/Gregs.c b/src/ia64/Gregs.c
index f3e4075..ac6f738 100644
--- a/src/ia64/Gregs.c
+++ b/src/ia64/Gregs.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -38,60 +38,60 @@ linux_scratch_loc (struct cursor *c, unw_regnum_t reg, uint8_t *nat_bitnr)
       || ia64_get_abi_marker (c) == ABI_MARKER_OLD_LINUX_SIGTRAMP)
     {
       switch (reg)
-	{
-	case UNW_IA64_NAT + 2 ... UNW_IA64_NAT + 3:
-	case UNW_IA64_NAT + 8 ... UNW_IA64_NAT + 31:
-	  /* Linux sigcontext contains the NaT bit of scratch register
-	     N in bit position N of the sc_nat member. */
-	  *nat_bitnr = (reg - UNW_IA64_NAT);
-	  addr += LINUX_SC_NAT_OFF;
-	  break;
-
-	case UNW_IA64_GR +  2 ... UNW_IA64_GR + 3:
-	case UNW_IA64_GR +  8 ... UNW_IA64_GR + 31:
-	  addr += LINUX_SC_GR_OFF + 8 * (reg - UNW_IA64_GR);
-	  break;
-
-	case UNW_IA64_FR + 6 ... UNW_IA64_FR + 15:
-	  addr += LINUX_SC_FR_OFF + 16 * (reg - UNW_IA64_FR);
-	  return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
-
-	case UNW_IA64_FR + 32 ... UNW_IA64_FR + 127:
-	  if (ia64_get (c, IA64_LOC_ADDR (addr + LINUX_SC_FLAGS_OFF, 0),
-			&flags) < 0)
-	    return IA64_NULL_LOC;
-
-	  if (!(flags & IA64_SC_FLAG_FPH_VALID))
-	    {
-	      /* initialize fph partition: */
-	      tmp_addr = addr + LINUX_SC_FR_OFF + 32*16;
-	      for (i = 32; i < 128; ++i, tmp_addr += 16)
-		if (ia64_putfp (c, IA64_LOC_ADDR (tmp_addr, 0),
-				unw.read_only.f0) < 0)
-		  return IA64_NULL_LOC;
-	      /* mark fph partition as valid: */
-	      if (ia64_put (c, IA64_LOC_ADDR (addr + LINUX_SC_FLAGS_OFF, 0),
-			    flags | IA64_SC_FLAG_FPH_VALID) < 0)
-		return IA64_NULL_LOC;
-	    }
-
-	  addr += LINUX_SC_FR_OFF + 16 * (reg - UNW_IA64_FR);
-	  return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
-
-	case UNW_IA64_BR + 0: addr += LINUX_SC_BR_OFF + 0; break;
-	case UNW_IA64_BR + 6: addr += LINUX_SC_BR_OFF + 6*8; break;
-	case UNW_IA64_BR + 7: addr += LINUX_SC_BR_OFF + 7*8; break;
-	case UNW_IA64_AR_RSC: addr += LINUX_SC_AR_RSC_OFF; break;
-	case UNW_IA64_AR_CSD: addr += LINUX_SC_AR_CSD_OFF; break;
-	case UNW_IA64_AR_SSD: addr += LINUX_SC_AR_SSD_OFF; break;
-	case UNW_IA64_AR_CCV: addr += LINUX_SC_AR_CCV; break;
-
-	default:
-	  if (unw_is_fpreg (reg))
-	    return IA64_FPREG_LOC (c, reg);
-	  else
-	    return IA64_REG_LOC (c, reg);
-	}
+        {
+        case UNW_IA64_NAT + 2 ... UNW_IA64_NAT + 3:
+        case UNW_IA64_NAT + 8 ... UNW_IA64_NAT + 31:
+          /* Linux sigcontext contains the NaT bit of scratch register
+             N in bit position N of the sc_nat member. */
+          *nat_bitnr = (reg - UNW_IA64_NAT);
+          addr += LINUX_SC_NAT_OFF;
+          break;
+
+        case UNW_IA64_GR +  2 ... UNW_IA64_GR + 3:
+        case UNW_IA64_GR +  8 ... UNW_IA64_GR + 31:
+          addr += LINUX_SC_GR_OFF + 8 * (reg - UNW_IA64_GR);
+          break;
+
+        case UNW_IA64_FR + 6 ... UNW_IA64_FR + 15:
+          addr += LINUX_SC_FR_OFF + 16 * (reg - UNW_IA64_FR);
+          return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
+
+        case UNW_IA64_FR + 32 ... UNW_IA64_FR + 127:
+          if (ia64_get (c, IA64_LOC_ADDR (addr + LINUX_SC_FLAGS_OFF, 0),
+                        &flags) < 0)
+            return IA64_NULL_LOC;
+
+          if (!(flags & IA64_SC_FLAG_FPH_VALID))
+            {
+              /* initialize fph partition: */
+              tmp_addr = addr + LINUX_SC_FR_OFF + 32*16;
+              for (i = 32; i < 128; ++i, tmp_addr += 16)
+                if (ia64_putfp (c, IA64_LOC_ADDR (tmp_addr, 0),
+                                unw.read_only.f0) < 0)
+                  return IA64_NULL_LOC;
+              /* mark fph partition as valid: */
+              if (ia64_put (c, IA64_LOC_ADDR (addr + LINUX_SC_FLAGS_OFF, 0),
+                            flags | IA64_SC_FLAG_FPH_VALID) < 0)
+                return IA64_NULL_LOC;
+            }
+
+          addr += LINUX_SC_FR_OFF + 16 * (reg - UNW_IA64_FR);
+          return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
+
+        case UNW_IA64_BR + 0: addr += LINUX_SC_BR_OFF + 0; break;
+        case UNW_IA64_BR + 6: addr += LINUX_SC_BR_OFF + 6*8; break;
+        case UNW_IA64_BR + 7: addr += LINUX_SC_BR_OFF + 7*8; break;
+        case UNW_IA64_AR_RSC: addr += LINUX_SC_AR_RSC_OFF; break;
+        case UNW_IA64_AR_CSD: addr += LINUX_SC_AR_CSD_OFF; break;
+        case UNW_IA64_AR_SSD: addr += LINUX_SC_AR_SSD_OFF; break;
+        case UNW_IA64_AR_CCV: addr += LINUX_SC_AR_CCV; break;
+
+        default:
+          if (unw_is_fpreg (reg))
+            return IA64_FPREG_LOC (c, reg);
+          else
+            return IA64_REG_LOC (c, reg);
+        }
       return IA64_LOC_ADDR (addr, 0);
     }
   else
@@ -99,120 +99,120 @@ linux_scratch_loc (struct cursor *c, unw_regnum_t reg, uint8_t *nat_bitnr)
       int is_nat = 0;
 
       if ((unsigned) (reg - UNW_IA64_NAT) < 128)
-	{
-	  is_nat = 1;
-	  reg -= (UNW_IA64_NAT - UNW_IA64_GR);
-	}
+        {
+          is_nat = 1;
+          reg -= (UNW_IA64_NAT - UNW_IA64_GR);
+        }
       if (ia64_get_abi_marker (c) == ABI_MARKER_LINUX_INTERRUPT)
-	{
-	  switch (reg)
-	    {
-	    case UNW_IA64_BR + 6 ... UNW_IA64_BR + 7:
-	      addr += LINUX_PT_B6_OFF + 8 * (reg - (UNW_IA64_BR + 6));
-	      break;
-
-	    case UNW_IA64_AR_CSD: addr += LINUX_PT_CSD_OFF; break;
-	    case UNW_IA64_AR_SSD: addr += LINUX_PT_SSD_OFF; break;
-
-	    case UNW_IA64_GR +  8 ... UNW_IA64_GR + 11:
-	      addr += LINUX_PT_R8_OFF + 8 * (reg - (UNW_IA64_GR + 8));
-	      break;
-
-	    case UNW_IA64_IP: addr += LINUX_PT_IIP_OFF; break;
-	    case UNW_IA64_CFM: addr += LINUX_PT_IFS_OFF; break;
-	    case UNW_IA64_AR_UNAT: addr += LINUX_PT_UNAT_OFF; break;
-	    case UNW_IA64_AR_PFS: addr += LINUX_PT_PFS_OFF; break;
-	    case UNW_IA64_AR_RSC: addr += LINUX_PT_RSC_OFF; break;
-	    case UNW_IA64_AR_RNAT: addr += LINUX_PT_RNAT_OFF; break;
-	    case UNW_IA64_AR_BSPSTORE: addr += LINUX_PT_BSPSTORE_OFF; break;
-	    case UNW_IA64_PR: addr += LINUX_PT_PR_OFF; break;
-	    case UNW_IA64_BR + 0: addr += LINUX_PT_B0_OFF; break;
-
-	    case UNW_IA64_GR + 1:
-	      /* The saved r1 value is valid only in the frame in which
-		 it was saved; for everything else we need to look up
-		 the appropriate gp value.  */
-	      if (c->sigcontext_addr != c->sp + 0x10)
-		return IA64_NULL_LOC;
-	      addr += LINUX_PT_R1_OFF;
-	      break;
-
-	    case UNW_IA64_GR + 12: addr += LINUX_PT_R12_OFF; break;
-	    case UNW_IA64_GR + 13: addr += LINUX_PT_R13_OFF; break;
-	    case UNW_IA64_AR_FPSR: addr += LINUX_PT_FPSR_OFF; break;
-	    case UNW_IA64_GR + 15: addr += LINUX_PT_R15_OFF; break;
-	    case UNW_IA64_GR + 14: addr += LINUX_PT_R14_OFF; break;
-	    case UNW_IA64_GR + 2: addr += LINUX_PT_R2_OFF; break;
-	    case UNW_IA64_GR + 3: addr += LINUX_PT_R3_OFF; break;
-
-	    case UNW_IA64_GR + 16 ... UNW_IA64_GR + 31:
-	      addr += LINUX_PT_R16_OFF + 8 * (reg - (UNW_IA64_GR + 16));
-	      break;
-
-	    case UNW_IA64_AR_CCV: addr += LINUX_PT_CCV_OFF; break;
-
-	    case UNW_IA64_FR + 6 ... UNW_IA64_FR + 11:
-	      addr += LINUX_PT_F6_OFF + 16 * (reg - (UNW_IA64_FR + 6));
-	      return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
-
-	    default:
-	      if (unw_is_fpreg (reg))
-		return IA64_FPREG_LOC (c, reg);
-	      else
-		return IA64_REG_LOC (c, reg);
-	    }
-	}
+        {
+          switch (reg)
+            {
+            case UNW_IA64_BR + 6 ... UNW_IA64_BR + 7:
+              addr += LINUX_PT_B6_OFF + 8 * (reg - (UNW_IA64_BR + 6));
+              break;
+
+            case UNW_IA64_AR_CSD: addr += LINUX_PT_CSD_OFF; break;
+            case UNW_IA64_AR_SSD: addr += LINUX_PT_SSD_OFF; break;
+
+            case UNW_IA64_GR +  8 ... UNW_IA64_GR + 11:
+              addr += LINUX_PT_R8_OFF + 8 * (reg - (UNW_IA64_GR + 8));
+              break;
+
+            case UNW_IA64_IP: addr += LINUX_PT_IIP_OFF; break;
+            case UNW_IA64_CFM: addr += LINUX_PT_IFS_OFF; break;
+            case UNW_IA64_AR_UNAT: addr += LINUX_PT_UNAT_OFF; break;
+            case UNW_IA64_AR_PFS: addr += LINUX_PT_PFS_OFF; break;
+            case UNW_IA64_AR_RSC: addr += LINUX_PT_RSC_OFF; break;
+            case UNW_IA64_AR_RNAT: addr += LINUX_PT_RNAT_OFF; break;
+            case UNW_IA64_AR_BSPSTORE: addr += LINUX_PT_BSPSTORE_OFF; break;
+            case UNW_IA64_PR: addr += LINUX_PT_PR_OFF; break;
+            case UNW_IA64_BR + 0: addr += LINUX_PT_B0_OFF; break;
+
+            case UNW_IA64_GR + 1:
+              /* The saved r1 value is valid only in the frame in which
+                 it was saved; for everything else we need to look up
+                 the appropriate gp value.  */
+              if (c->sigcontext_addr != c->sp + 0x10)
+                return IA64_NULL_LOC;
+              addr += LINUX_PT_R1_OFF;
+              break;
+
+            case UNW_IA64_GR + 12: addr += LINUX_PT_R12_OFF; break;
+            case UNW_IA64_GR + 13: addr += LINUX_PT_R13_OFF; break;
+            case UNW_IA64_AR_FPSR: addr += LINUX_PT_FPSR_OFF; break;
+            case UNW_IA64_GR + 15: addr += LINUX_PT_R15_OFF; break;
+            case UNW_IA64_GR + 14: addr += LINUX_PT_R14_OFF; break;
+            case UNW_IA64_GR + 2: addr += LINUX_PT_R2_OFF; break;
+            case UNW_IA64_GR + 3: addr += LINUX_PT_R3_OFF; break;
+
+            case UNW_IA64_GR + 16 ... UNW_IA64_GR + 31:
+              addr += LINUX_PT_R16_OFF + 8 * (reg - (UNW_IA64_GR + 16));
+              break;
+
+            case UNW_IA64_AR_CCV: addr += LINUX_PT_CCV_OFF; break;
+
+            case UNW_IA64_FR + 6 ... UNW_IA64_FR + 11:
+              addr += LINUX_PT_F6_OFF + 16 * (reg - (UNW_IA64_FR + 6));
+              return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
+
+            default:
+              if (unw_is_fpreg (reg))
+                return IA64_FPREG_LOC (c, reg);
+              else
+                return IA64_REG_LOC (c, reg);
+            }
+        }
       else if (ia64_get_abi_marker (c) == ABI_MARKER_OLD_LINUX_INTERRUPT)
-	{
-	  switch (reg)
-	    {
-	    case UNW_IA64_GR +  1:
-	      /* The saved r1 value is valid only in the frame in which
-		 it was saved; for everything else we need to look up
-		 the appropriate gp value.  */
-	      if (c->sigcontext_addr != c->sp + 0x10)
-		return IA64_NULL_LOC;
-	      addr += LINUX_OLD_PT_R1_OFF;
-	      break;
-
-	    case UNW_IA64_GR +  2 ... UNW_IA64_GR + 3:
-	      addr += LINUX_OLD_PT_R2_OFF + 8 * (reg - (UNW_IA64_GR + 2));
-	      break;
-
-	    case UNW_IA64_GR +  8 ... UNW_IA64_GR + 11:
-	      addr += LINUX_OLD_PT_R8_OFF + 8 * (reg - (UNW_IA64_GR + 8));
-	      break;
-
-	    case UNW_IA64_GR + 16 ... UNW_IA64_GR + 31:
-	      addr += LINUX_OLD_PT_R16_OFF + 8 * (reg - (UNW_IA64_GR + 16));
-	      break;
-
-	    case UNW_IA64_FR + 6 ... UNW_IA64_FR + 9:
-	      addr += LINUX_OLD_PT_F6_OFF + 16 * (reg - (UNW_IA64_FR + 6));
-	      return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
-
-	    case UNW_IA64_BR + 0: addr += LINUX_OLD_PT_B0_OFF; break;
-	    case UNW_IA64_BR + 6: addr += LINUX_OLD_PT_B6_OFF; break;
-	    case UNW_IA64_BR + 7: addr += LINUX_OLD_PT_B7_OFF; break;
-
-	    case UNW_IA64_AR_RSC: addr += LINUX_OLD_PT_RSC_OFF; break;
-	    case UNW_IA64_AR_CCV: addr += LINUX_OLD_PT_CCV_OFF; break;
-
-	    default:
-	      if (unw_is_fpreg (reg))
-		return IA64_FPREG_LOC (c, reg);
-	      else
-		return IA64_REG_LOC (c, reg);
-	    }
-	}
+        {
+          switch (reg)
+            {
+            case UNW_IA64_GR +  1:
+              /* The saved r1 value is valid only in the frame in which
+                 it was saved; for everything else we need to look up
+                 the appropriate gp value.  */
+              if (c->sigcontext_addr != c->sp + 0x10)
+                return IA64_NULL_LOC;
+              addr += LINUX_OLD_PT_R1_OFF;
+              break;
+
+            case UNW_IA64_GR +  2 ... UNW_IA64_GR + 3:
+              addr += LINUX_OLD_PT_R2_OFF + 8 * (reg - (UNW_IA64_GR + 2));
+              break;
+
+            case UNW_IA64_GR +  8 ... UNW_IA64_GR + 11:
+              addr += LINUX_OLD_PT_R8_OFF + 8 * (reg - (UNW_IA64_GR + 8));
+              break;
+
+            case UNW_IA64_GR + 16 ... UNW_IA64_GR + 31:
+              addr += LINUX_OLD_PT_R16_OFF + 8 * (reg - (UNW_IA64_GR + 16));
+              break;
+
+            case UNW_IA64_FR + 6 ... UNW_IA64_FR + 9:
+              addr += LINUX_OLD_PT_F6_OFF + 16 * (reg - (UNW_IA64_FR + 6));
+              return IA64_LOC_ADDR (addr, IA64_LOC_TYPE_FP);
+
+            case UNW_IA64_BR + 0: addr += LINUX_OLD_PT_B0_OFF; break;
+            case UNW_IA64_BR + 6: addr += LINUX_OLD_PT_B6_OFF; break;
+            case UNW_IA64_BR + 7: addr += LINUX_OLD_PT_B7_OFF; break;
+
+            case UNW_IA64_AR_RSC: addr += LINUX_OLD_PT_RSC_OFF; break;
+            case UNW_IA64_AR_CCV: addr += LINUX_OLD_PT_CCV_OFF; break;
+
+            default:
+              if (unw_is_fpreg (reg))
+                return IA64_FPREG_LOC (c, reg);
+              else
+                return IA64_REG_LOC (c, reg);
+            }
+        }
       if (is_nat)
-	{
-	  /* For Linux pt-regs structure, bit number is determined by
-	     the UNaT slot number (as determined by st8.spill) and the
-	     bits are saved wherever the (primary) UNaT was saved.  */
-	  *nat_bitnr = ia64_unat_slot_num (addr);
-	  return c->loc[IA64_REG_PRI_UNAT_MEM];
-	}
+        {
+          /* For Linux pt-regs structure, bit number is determined by
+             the UNaT slot number (as determined by st8.spill) and the
+             bits are saved wherever the (primary) UNaT was saved.  */
+          *nat_bitnr = ia64_unat_slot_num (addr);
+          return c->loc[IA64_REG_PRI_UNAT_MEM];
+        }
       return IA64_LOC_ADDR (addr, 0);
     }
 #endif
@@ -235,11 +235,11 @@ ia64_scratch_loc (struct cursor *c, unw_regnum_t reg, uint8_t *nat_bitnr)
   if (c->sigcontext_addr)
     {
       if (ia64_get_abi (c) == ABI_LINUX)
-	return linux_scratch_loc (c, reg, nat_bitnr);
+        return linux_scratch_loc (c, reg, nat_bitnr);
       else if (ia64_get_abi (c) ==  ABI_HPUX)
-	return hpux_scratch_loc (c, reg, nat_bitnr);
+        return hpux_scratch_loc (c, reg, nat_bitnr);
       else
-	return IA64_NULL_LOC;
+        return IA64_NULL_LOC;
     }
   else
     return IA64_REG_LOC (c, reg);
@@ -247,7 +247,7 @@ ia64_scratch_loc (struct cursor *c, unw_regnum_t reg, uint8_t *nat_bitnr)
 
 static inline int
 update_nat (struct cursor *c, ia64_loc_t nat_loc, unw_word_t mask,
-	    unw_word_t *valp, int write)
+            unw_word_t *valp, int write)
 {
   unw_word_t nat_word;
   int ret;
@@ -259,9 +259,9 @@ update_nat (struct cursor *c, ia64_loc_t nat_loc, unw_word_t mask,
   if (write)
     {
       if (*valp)
-	nat_word |= mask;
+        nat_word |= mask;
       else
-	nat_word &= ~mask;
+        nat_word &= ~mask;
       ret = ia64_put (c, nat_loc, nat_word);
     }
   else
@@ -271,8 +271,8 @@ update_nat (struct cursor *c, ia64_loc_t nat_loc, unw_word_t mask,
 
 static int
 access_nat (struct cursor *c,
-	    ia64_loc_t nat_loc, ia64_loc_t reg_loc, uint8_t nat_bitnr,
-	    unw_word_t *valp, int write)
+            ia64_loc_t nat_loc, ia64_loc_t reg_loc, uint8_t nat_bitnr,
+            unw_word_t *valp, int write)
 {
   unw_word_t mask = 0;
   unw_fpreg_t tmp;
@@ -281,47 +281,47 @@ access_nat (struct cursor *c,
   if (IA64_IS_FP_LOC (reg_loc))
     {
       /* NaT bit is saved as a NaTVal.  This happens when a general
-	 register is saved to a floating-point register.  */
+         register is saved to a floating-point register.  */
       if (write)
-	{
-	  if (*valp)
-	    {
-	      if (ia64_is_big_endian (c))
-		ret = ia64_putfp (c, reg_loc, unw.nat_val_be);
-	      else
-		ret = ia64_putfp (c, reg_loc, unw.nat_val_le);
-	    }
-	  else
-	    {
-	      unw_word_t *src, *dst;
-	      unw_fpreg_t tmp;
-
-	      ret = ia64_getfp (c, reg_loc, &tmp);
-	      if (ret < 0)
-		return ret;
-
-	      /* Reset the exponent to 0x1003e so that the significand
-		 will be interpreted as an integer value.  */
-	      src = (unw_word_t *) &unw.int_val_be;
-	      dst = (unw_word_t *) &tmp;
-	      if (!ia64_is_big_endian (c))
-		++src, ++dst;
-	      *dst = *src;
-
-	      ret = ia64_putfp (c, reg_loc, tmp);
-	    }
-	}
+        {
+          if (*valp)
+            {
+              if (ia64_is_big_endian (c))
+                ret = ia64_putfp (c, reg_loc, unw.nat_val_be);
+              else
+                ret = ia64_putfp (c, reg_loc, unw.nat_val_le);
+            }
+          else
+            {
+              unw_word_t *src, *dst;
+              unw_fpreg_t tmp;
+
+              ret = ia64_getfp (c, reg_loc, &tmp);
+              if (ret < 0)
+                return ret;
+
+              /* Reset the exponent to 0x1003e so that the significand
+                 will be interpreted as an integer value.  */
+              src = (unw_word_t *) &unw.int_val_be;
+              dst = (unw_word_t *) &tmp;
+              if (!ia64_is_big_endian (c))
+                ++src, ++dst;
+              *dst = *src;
+
+              ret = ia64_putfp (c, reg_loc, tmp);
+            }
+        }
       else
-	{
-	  ret = ia64_getfp (c, reg_loc, &tmp);
-	  if (ret < 0)
-	    return ret;
-
-	  if (ia64_is_big_endian (c))
-	    *valp = (memcmp (&tmp, &unw.nat_val_be, sizeof (tmp)) == 0);
-	  else
-	    *valp = (memcmp (&tmp, &unw.nat_val_le, sizeof (tmp)) == 0);
-	}
+        {
+          ret = ia64_getfp (c, reg_loc, &tmp);
+          if (ret < 0)
+            return ret;
+
+          if (ia64_is_big_endian (c))
+            *valp = (memcmp (&tmp, &unw.nat_val_be, sizeof (tmp)) == 0);
+          else
+            *valp = (memcmp (&tmp, &unw.nat_val_le, sizeof (tmp)) == 0);
+        }
       return ret;
     }
 
@@ -330,25 +330,25 @@ access_nat (struct cursor *c,
       || IA64_IS_UC_LOC (reg_loc))
     {
       if (write)
-	return ia64_put (c, nat_loc, *valp);
+        return ia64_put (c, nat_loc, *valp);
       else
-	return ia64_get (c, nat_loc, valp);
+        return ia64_get (c, nat_loc, valp);
     }
 
   if (IA64_IS_NULL_LOC (nat_loc))
     {
       /* NaT bit is not saved. This happens if a general register is
-	 saved to a branch register.  Since the NaT bit gets lost, we
-	 need to drop it here, too.  Note that if the NaT bit had been
-	 set when the save occurred, it would have caused a NaT
-	 consumption fault.  */
+         saved to a branch register.  Since the NaT bit gets lost, we
+         need to drop it here, too.  Note that if the NaT bit had been
+         set when the save occurred, it would have caused a NaT
+         consumption fault.  */
       if (write)
-	{
-	  if (*valp)
-	    return -UNW_EBADREG;	/* can't set NaT bit */
-	}
+        {
+          if (*valp)
+            return -UNW_EBADREG;        /* can't set NaT bit */
+        }
       else
-	*valp = 0;
+        *valp = 0;
       return 0;
     }
 
@@ -358,7 +358,7 @@ access_nat (struct cursor *c,
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   ia64_loc_t loc, reg_loc, nat_loc;
   unw_word_t mask, val;
@@ -371,25 +371,25 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
     case UNW_IA64_BSP:
       if (write)
-	c->bsp = *valp;
+        c->bsp = *valp;
       else
-	*valp = c->bsp;
+        *valp = c->bsp;
       return 0;
 
     case UNW_REG_SP:
       if (write)
-	c->sp = *valp;
+        c->sp = *valp;
       else
-	*valp = c->sp;
+        *valp = c->sp;
       return 0;
 
     case UNW_REG_IP:
       if (write)
-	{
-	  c->ip = *valp;	/* also update the IP cache */
-	  if (c->pi_valid && (*valp < c->pi.start_ip || *valp >= c->pi.end_ip))
-	    c->pi_valid = 0;	/* new IP outside of current proc */
-	}
+        {
+          c->ip = *valp;        /* also update the IP cache */
+          if (c->pi_valid && (*valp < c->pi.start_ip || *valp >= c->pi.end_ip))
+            c->pi_valid = 0;    /* new IP outside of current proc */
+        }
       loc = c->loc[IA64_REG_IP];
       break;
 
@@ -405,22 +405,22 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
       nat_bitnr = c->nat_bitnr[reg - (UNW_IA64_NAT + 4)];
       return access_nat (c, loc, reg_loc, nat_bitnr, valp, write);
 
-    case UNW_IA64_AR_BSP:	loc = c->loc[IA64_REG_BSP]; break;
-    case UNW_IA64_AR_BSPSTORE:	loc = c->loc[IA64_REG_BSPSTORE]; break;
-    case UNW_IA64_AR_PFS:	loc = c->loc[IA64_REG_PFS]; break;
-    case UNW_IA64_AR_RNAT:	loc = c->loc[IA64_REG_RNAT]; break;
-    case UNW_IA64_AR_UNAT:	loc = c->loc[IA64_REG_UNAT]; break;
-    case UNW_IA64_AR_LC:	loc = c->loc[IA64_REG_LC]; break;
-    case UNW_IA64_AR_FPSR:	loc = c->loc[IA64_REG_FPSR]; break;
-    case UNW_IA64_BR + 1:	loc = c->loc[IA64_REG_B1]; break;
-    case UNW_IA64_BR + 2:	loc = c->loc[IA64_REG_B2]; break;
-    case UNW_IA64_BR + 3:	loc = c->loc[IA64_REG_B3]; break;
-    case UNW_IA64_BR + 4:	loc = c->loc[IA64_REG_B4]; break;
-    case UNW_IA64_BR + 5:	loc = c->loc[IA64_REG_B5]; break;
+    case UNW_IA64_AR_BSP:       loc = c->loc[IA64_REG_BSP]; break;
+    case UNW_IA64_AR_BSPSTORE:  loc = c->loc[IA64_REG_BSPSTORE]; break;
+    case UNW_IA64_AR_PFS:       loc = c->loc[IA64_REG_PFS]; break;
+    case UNW_IA64_AR_RNAT:      loc = c->loc[IA64_REG_RNAT]; break;
+    case UNW_IA64_AR_UNAT:      loc = c->loc[IA64_REG_UNAT]; break;
+    case UNW_IA64_AR_LC:        loc = c->loc[IA64_REG_LC]; break;
+    case UNW_IA64_AR_FPSR:      loc = c->loc[IA64_REG_FPSR]; break;
+    case UNW_IA64_BR + 1:       loc = c->loc[IA64_REG_B1]; break;
+    case UNW_IA64_BR + 2:       loc = c->loc[IA64_REG_B2]; break;
+    case UNW_IA64_BR + 3:       loc = c->loc[IA64_REG_B3]; break;
+    case UNW_IA64_BR + 4:       loc = c->loc[IA64_REG_B4]; break;
+    case UNW_IA64_BR + 5:       loc = c->loc[IA64_REG_B5]; break;
 
     case UNW_IA64_CFM:
       if (write)
-	c->cfm = *valp;	/* also update the CFM cache */
+        c->cfm = *valp; /* also update the CFM cache */
       loc = c->cfm_loc;
       break;
 
@@ -430,59 +430,59 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
        * (i.e., it is done as if CFM.rrb.pr == 0.
        */
       if (write)
-	{
-	  c->pr = *valp;		/* update the predicate cache */
-	  return ia64_put (c, c->loc[IA64_REG_PR], *valp);
-	}
+        {
+          c->pr = *valp;                /* update the predicate cache */
+          return ia64_put (c, c->loc[IA64_REG_PR], *valp);
+        }
       else
-	return ia64_get (c, c->loc[IA64_REG_PR], valp);
+        return ia64_get (c, c->loc[IA64_REG_PR], valp);
 
-    case UNW_IA64_GR + 32 ... UNW_IA64_GR + 127:	/* stacked reg */
+    case UNW_IA64_GR + 32 ... UNW_IA64_GR + 127:        /* stacked reg */
       reg = rotate_gr (c, reg - UNW_IA64_GR);
       if (reg < 0)
-	return -UNW_EBADREG;
+        return -UNW_EBADREG;
       ret = ia64_get_stacked (c, reg, &loc, NULL);
       if (ret < 0)
-	return ret;
+        return ret;
       break;
 
-    case UNW_IA64_NAT + 32 ... UNW_IA64_NAT + 127:	/* stacked reg */
+    case UNW_IA64_NAT + 32 ... UNW_IA64_NAT + 127:      /* stacked reg */
       reg = rotate_gr (c, reg - UNW_IA64_NAT);
       if (reg < 0)
-	return -UNW_EBADREG;
+        return -UNW_EBADREG;
       ret = ia64_get_stacked (c, reg, &loc, &nat_loc);
       if (ret < 0)
-	return ret;
+        return ret;
       assert (!IA64_IS_REG_LOC (loc));
       mask = (unw_word_t) 1 << rse_slot_num (IA64_GET_ADDR (loc));
       return update_nat (c, nat_loc, mask, valp, write);
 
     case UNW_IA64_AR_EC:
       if ((ret = ia64_get (c, c->ec_loc, &val)) < 0)
-	return ret;
+        return ret;
 
       if (write)
-	{
-	  val = ((val & ~((unw_word_t) 0x3f << 52)) | ((*valp & 0x3f) << 52));
-	  return ia64_put (c, c->ec_loc, val);
-	}
+        {
+          val = ((val & ~((unw_word_t) 0x3f << 52)) | ((*valp & 0x3f) << 52));
+          return ia64_put (c, c->ec_loc, val);
+        }
       else
-	{
-	  *valp = (val >> 52) & 0x3f;
-	  return 0;
-	}
+        {
+          *valp = (val >> 52) & 0x3f;
+          return 0;
+        }
 
       /* scratch & special registers: */
 
     case UNW_IA64_GR + 0:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = 0;
       return 0;
 
     case UNW_IA64_NAT + 0:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = 0;
       return 0;
 
@@ -491,37 +491,37 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     case UNW_IA64_NAT + 8 ... UNW_IA64_NAT + 31:
       loc = ia64_scratch_loc (c, reg, &nat_bitnr);
       if (IA64_IS_NULL_LOC (loc) && reg == UNW_IA64_NAT + 1)
-	{
-	  /* access to GP */
-	  if (write)
-	    return -UNW_EREADONLYREG;
-	  *valp = 0;
-	  return 0;
-	}
+        {
+          /* access to GP */
+          if (write)
+            return -UNW_EREADONLYREG;
+          *valp = 0;
+          return 0;
+        }
       if (!(IA64_IS_REG_LOC (loc) || IA64_IS_UC_LOC (loc)
-	    || IA64_IS_FP_LOC (loc)))
-	/* We're dealing with a NaT bit stored in memory.  */
-	return update_nat(c, loc, (unw_word_t) 1 << nat_bitnr, valp, write);
+            || IA64_IS_FP_LOC (loc)))
+        /* We're dealing with a NaT bit stored in memory.  */
+        return update_nat(c, loc, (unw_word_t) 1 << nat_bitnr, valp, write);
       break;
 
     case UNW_IA64_GR + 15 ... UNW_IA64_GR + 18:
       mask = 1 << (reg - (UNW_IA64_GR + 15));
       if (write)
-	{
-	  c->eh_args[reg - (UNW_IA64_GR + 15)] = *valp;
-	  c->eh_valid_mask |= mask;
-	  return 0;
-	}
+        {
+          c->eh_args[reg - (UNW_IA64_GR + 15)] = *valp;
+          c->eh_valid_mask |= mask;
+          return 0;
+        }
       else if ((c->eh_valid_mask & mask) != 0)
-	{
-	  *valp = c->eh_args[reg - (UNW_IA64_GR + 15)];
-	  return 0;
-	}
+        {
+          *valp = c->eh_args[reg - (UNW_IA64_GR + 15)];
+          return 0;
+        }
       else
-	loc = ia64_scratch_loc (c, reg, NULL);
+        loc = ia64_scratch_loc (c, reg, NULL);
       break;
 
-    case UNW_IA64_GR +  1:				/* global pointer */
+    case UNW_IA64_GR +  1:                              /* global pointer */
     case UNW_IA64_GR +  2 ... UNW_IA64_GR + 3:
     case UNW_IA64_GR +  8 ... UNW_IA64_GR + 14:
     case UNW_IA64_GR + 19 ... UNW_IA64_GR + 31:
@@ -534,17 +534,17 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     case UNW_IA64_AR_CCV:
       loc = ia64_scratch_loc (c, reg, NULL);
       if (IA64_IS_NULL_LOC (loc) && reg == UNW_IA64_GR + 1)
-	{
-	  /* access to GP */
-	  if (write)
-	    return -UNW_EREADONLYREG;
-
-	  /* ensure c->pi is up-to-date: */
-	  if ((ret = ia64_make_proc_info (c)) < 0)
-	    return ret;
-	  *valp = c->pi.gp;
-	  return 0;
-	}
+        {
+          /* access to GP */
+          if (write)
+            return -UNW_EREADONLYREG;
+
+          /* ensure c->pi is up-to-date: */
+          if ((ret = ia64_make_proc_info (c)) < 0)
+            return ret;
+          *valp = c->pi.gp;
+          return 0;
+        }
       break;
 
     default:
@@ -560,7 +560,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, int reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   ia64_loc_t loc;
 
@@ -568,18 +568,18 @@ tdep_access_fpreg (struct cursor *c, int reg, unw_fpreg_t *valp,
     {
     case UNW_IA64_FR + 0:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = unw.read_only.f0;
       return 0;
 
     case UNW_IA64_FR + 1:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
 
       if (ia64_is_big_endian (c))
-	*valp = unw.read_only.f1_be;
+        *valp = unw.read_only.f1_be;
       else
-	*valp = unw.read_only.f1_le;
+        *valp = unw.read_only.f1_le;
       return 0;
 
     case UNW_IA64_FR + 2: loc = c->loc[IA64_REG_F2]; break;
diff --git a/src/ia64/Gresume.c b/src/ia64/Gresume.c
index fe23f76..68fe8a6 100644
--- a/src/ia64/Gresume.c
+++ b/src/ia64/Gresume.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -51,15 +51,15 @@ local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
     }
   extra;
   int ret, dirty_size;
-# define GET_NAT(n)						\
-  do								\
-    {								\
-      ret = tdep_access_reg (c, UNW_IA64_NAT + (n), &val, 0);	\
-      if (ret < 0)						\
-	return ret;						\
-      if (val)							\
-	pri_unat |= (unw_word_t) 1 << n;			\
-    }								\
+# define GET_NAT(n)                                             \
+  do                                                            \
+    {                                                           \
+      ret = tdep_access_reg (c, UNW_IA64_NAT + (n), &val, 0);   \
+      if (ret < 0)                                              \
+        return ret;                                             \
+      if (val)                                                  \
+        pri_unat |= (unw_word_t) 1 << n;                        \
+    }                                                           \
   while (0)
 
   /* ensure c->pi is up-to-date: */
@@ -84,43 +84,43 @@ local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
   if (unlikely (c->sigcontext_addr))
     {
       struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
-#     define PR_SCRATCH		0xffc0	/* p6-p15 are scratch */
-#     define PR_PRESERVED	(~(PR_SCRATCH | 1))
+#     define PR_SCRATCH         0xffc0  /* p6-p15 are scratch */
+#     define PR_PRESERVED       (~(PR_SCRATCH | 1))
 
       /* We're returning to a frame that was (either directly or
-	 indirectly) interrupted by a signal.  We have to restore
-	 _both_ "preserved" and "scratch" registers.  That doesn't
-	 leave us any registers to work with, and the only way we can
-	 achieve this is by doing a sigreturn().
+         indirectly) interrupted by a signal.  We have to restore
+         _both_ "preserved" and "scratch" registers.  That doesn't
+         leave us any registers to work with, and the only way we can
+         achieve this is by doing a sigreturn().
 
-	 Note: it might be tempting to think that we don't have to
-	 restore the scratch registers when returning to a frame that
-	 was indirectly interrupted by a signal.  However, that is not
-	 safe because that frame and its descendants could have been
-	 using a special convention that stores "preserved" state in
-	 scratch registers.  For example, the Linux fsyscall
-	 convention does this with r11 (to save ar.pfs) and b6 (to
-	 save "rp"). */
+         Note: it might be tempting to think that we don't have to
+         restore the scratch registers when returning to a frame that
+         was indirectly interrupted by a signal.  However, that is not
+         safe because that frame and its descendants could have been
+         using a special convention that stores "preserved" state in
+         scratch registers.  For example, the Linux fsyscall
+         convention does this with r11 (to save ar.pfs) and b6 (to
+         save "rp"). */
 
       sc->sc_gr[12] = c->psp;
       c->psp = c->sigcontext_addr - c->sigcontext_off;
 
       sof = (c->cfm & 0x7f);
       if ((dirty_size = rbs_cover_and_flush (c, sof, dirty_partition,
-					     &dirty_rnat, &bspstore)) < 0)
-	return dirty_size;
+                                             &dirty_rnat, &bspstore)) < 0)
+        return dirty_size;
 
       /* Clear the "in-syscall" flag, because in general we won't be
-	 returning to the interruption-point and we need all registers
-	 restored.  */
+         returning to the interruption-point and we need all registers
+         restored.  */
       sc->sc_flags &= ~IA64_SC_FLAG_IN_SYSCALL;
       sc->sc_ip = c->ip;
       sc->sc_cfm = c->cfm & (((unw_word_t) 1 << 38) - 1);
       sc->sc_pr = (c->pr & ~PR_SCRATCH) | (sc->sc_pr & ~PR_PRESERVED);
       if ((ret = ia64_get (c, c->loc[IA64_REG_PFS], &sc->sc_ar_pfs)) < 0
-	  || (ret = ia64_get (c, c->loc[IA64_REG_FPSR], &sc->sc_ar_fpsr)) < 0
-	  || (ret = ia64_get (c, c->loc[IA64_REG_UNAT], &sc->sc_ar_unat)) < 0)
-	return ret;
+          || (ret = ia64_get (c, c->loc[IA64_REG_FPSR], &sc->sc_ar_fpsr)) < 0
+          || (ret = ia64_get (c, c->loc[IA64_REG_UNAT], &sc->sc_ar_unat)) < 0)
+        return ret;
 
       sc->sc_gr[1] = c->pi.gp;
       if (c->eh_valid_mask & 0x1) sc->sc_gr[15] = c->eh_args[0];
@@ -128,19 +128,19 @@ local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
       if (c->eh_valid_mask & 0x4) sc->sc_gr[17] = c->eh_args[2];
       if (c->eh_valid_mask & 0x8) sc->sc_gr[18] = c->eh_args[3];
       Debug (9, "sc: r15=%lx,r16=%lx,r17=%lx,r18=%lx\n",
-	     (long) sc->sc_gr[15], (long) sc->sc_gr[16],
-	     (long) sc->sc_gr[17], (long) sc->sc_gr[18]);
+             (long) sc->sc_gr[15], (long) sc->sc_gr[16],
+             (long) sc->sc_gr[17], (long) sc->sc_gr[18]);
     }
   else
     {
       /* Account for the fact that _Uia64_install_context() will
-	 return via br.ret, which will decrement bsp by size-of-locals.  */
+         return via br.ret, which will decrement bsp by size-of-locals.  */
       if ((ret = ia64_get (c, c->loc[IA64_REG_PFS], &pfs)) < 0)
-	return ret;
+        return ret;
       sol = (pfs >> 7) & 0x7f;
       if ((dirty_size = rbs_cover_and_flush (c, sol, dirty_partition,
-					     &dirty_rnat, &bspstore)) < 0)
-	return dirty_size;
+                                             &dirty_rnat, &bspstore)) < 0)
+        return dirty_size;
 
       extra.r1 = c->pi.gp;
       extra.r15 = c->eh_args[0];
@@ -148,17 +148,17 @@ local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
       extra.r17 = c->eh_args[2];
       extra.r18 = c->eh_args[3];
       Debug (9, "extra: r15=%lx,r16=%lx,r17=%lx,r18=%lx\n",
-	     (long) extra.r15, (long) extra.r16,
-	     (long) extra.r17, (long) extra.r18);
+             (long) extra.r15, (long) extra.r16,
+             (long) extra.r17, (long) extra.r18);
     }
   Debug (8, "resuming at ip=%lx\n", (long) c->ip);
   ia64_install_cursor (c, pri_unat, (unw_word_t *) &extra,
-		       bspstore, dirty_size, dirty_partition + dirty_size/8,
-		       dirty_rnat);
+                       bspstore, dirty_size, dirty_partition + dirty_size/8,
+                       dirty_rnat);
 #elif defined(__hpux)
   struct cursor *c = (struct cursor *) cursor;
 
-  setcontext (c->as_arg);	/* should not return */
+  setcontext (c->as_arg);       /* should not return */
 #endif
   return -UNW_EINVAL;
 }
@@ -177,9 +177,9 @@ static inline int
 remote_install_cursor (struct cursor *c)
 {
   int (*access_reg) (unw_addr_space_t, unw_regnum_t, unw_word_t *,
-		     int write, void *);
+                     int write, void *);
   int (*access_fpreg) (unw_addr_space_t, unw_regnum_t, unw_fpreg_t *,
-		       int write, void *);
+                       int write, void *);
   unw_fpreg_t fpval;
   unw_word_t val;
   int reg;
@@ -188,49 +188,49 @@ remote_install_cursor (struct cursor *c)
   if (c->as == unw_local_addr_space)
     {
       /* Take a short-cut: we directly resume out of the cursor and
-	 all we need to do is make sure that all locations point to
-	 memory, not registers.  Furthermore, R4-R7 and NAT4-NAT7 are
-	 taken care of by ia64_local_resume() so they don't need to be
-	 handled here.  */
-#     define MEMIFY(preg, reg)						 \
-      do {								 \
-	if (IA64_IS_REG_LOC (c->loc[(preg)]))				 \
-	  c->loc[(preg)] = IA64_LOC_ADDR ((unw_word_t)			 \
-					  tdep_uc_addr(c->as_arg, (reg), \
-						       NULL), 0);	 \
+         all we need to do is make sure that all locations point to
+         memory, not registers.  Furthermore, R4-R7 and NAT4-NAT7 are
+         taken care of by ia64_local_resume() so they don't need to be
+         handled here.  */
+#     define MEMIFY(preg, reg)                                           \
+      do {                                                               \
+        if (IA64_IS_REG_LOC (c->loc[(preg)]))                            \
+          c->loc[(preg)] = IA64_LOC_ADDR ((unw_word_t)                   \
+                                          tdep_uc_addr(c->as_arg, (reg), \
+                                                       NULL), 0);        \
       } while (0)
-      MEMIFY (IA64_REG_PR,	UNW_IA64_PR);
-      MEMIFY (IA64_REG_PFS,	UNW_IA64_AR_PFS);
-      MEMIFY (IA64_REG_RNAT,	UNW_IA64_AR_RNAT);
-      MEMIFY (IA64_REG_UNAT,	UNW_IA64_AR_UNAT);
-      MEMIFY (IA64_REG_LC,	UNW_IA64_AR_LC);
-      MEMIFY (IA64_REG_FPSR,	UNW_IA64_AR_FPSR);
-      MEMIFY (IA64_REG_IP,	UNW_IA64_BR + 0);
-      MEMIFY (IA64_REG_B1,	UNW_IA64_BR + 1);
-      MEMIFY (IA64_REG_B2,	UNW_IA64_BR + 2);
-      MEMIFY (IA64_REG_B3,	UNW_IA64_BR + 3);
-      MEMIFY (IA64_REG_B4,	UNW_IA64_BR + 4);
-      MEMIFY (IA64_REG_B5,	UNW_IA64_BR + 5);
-      MEMIFY (IA64_REG_F2,	UNW_IA64_FR + 2);
-      MEMIFY (IA64_REG_F3,	UNW_IA64_FR + 3);
-      MEMIFY (IA64_REG_F4,	UNW_IA64_FR + 4);
-      MEMIFY (IA64_REG_F5,	UNW_IA64_FR + 5);
-      MEMIFY (IA64_REG_F16,	UNW_IA64_FR + 16);
-      MEMIFY (IA64_REG_F17,	UNW_IA64_FR + 17);
-      MEMIFY (IA64_REG_F18,	UNW_IA64_FR + 18);
-      MEMIFY (IA64_REG_F19,	UNW_IA64_FR + 19);
-      MEMIFY (IA64_REG_F20,	UNW_IA64_FR + 20);
-      MEMIFY (IA64_REG_F21,	UNW_IA64_FR + 21);
-      MEMIFY (IA64_REG_F22,	UNW_IA64_FR + 22);
-      MEMIFY (IA64_REG_F23,	UNW_IA64_FR + 23);
-      MEMIFY (IA64_REG_F24,	UNW_IA64_FR + 24);
-      MEMIFY (IA64_REG_F25,	UNW_IA64_FR + 25);
-      MEMIFY (IA64_REG_F26,	UNW_IA64_FR + 26);
-      MEMIFY (IA64_REG_F27,	UNW_IA64_FR + 27);
-      MEMIFY (IA64_REG_F28,	UNW_IA64_FR + 28);
-      MEMIFY (IA64_REG_F29,	UNW_IA64_FR + 29);
-      MEMIFY (IA64_REG_F30,	UNW_IA64_FR + 30);
-      MEMIFY (IA64_REG_F31,	UNW_IA64_FR + 31);
+      MEMIFY (IA64_REG_PR,      UNW_IA64_PR);
+      MEMIFY (IA64_REG_PFS,     UNW_IA64_AR_PFS);
+      MEMIFY (IA64_REG_RNAT,    UNW_IA64_AR_RNAT);
+      MEMIFY (IA64_REG_UNAT,    UNW_IA64_AR_UNAT);
+      MEMIFY (IA64_REG_LC,      UNW_IA64_AR_LC);
+      MEMIFY (IA64_REG_FPSR,    UNW_IA64_AR_FPSR);
+      MEMIFY (IA64_REG_IP,      UNW_IA64_BR + 0);
+      MEMIFY (IA64_REG_B1,      UNW_IA64_BR + 1);
+      MEMIFY (IA64_REG_B2,      UNW_IA64_BR + 2);
+      MEMIFY (IA64_REG_B3,      UNW_IA64_BR + 3);
+      MEMIFY (IA64_REG_B4,      UNW_IA64_BR + 4);
+      MEMIFY (IA64_REG_B5,      UNW_IA64_BR + 5);
+      MEMIFY (IA64_REG_F2,      UNW_IA64_FR + 2);
+      MEMIFY (IA64_REG_F3,      UNW_IA64_FR + 3);
+      MEMIFY (IA64_REG_F4,      UNW_IA64_FR + 4);
+      MEMIFY (IA64_REG_F5,      UNW_IA64_FR + 5);
+      MEMIFY (IA64_REG_F16,     UNW_IA64_FR + 16);
+      MEMIFY (IA64_REG_F17,     UNW_IA64_FR + 17);
+      MEMIFY (IA64_REG_F18,     UNW_IA64_FR + 18);
+      MEMIFY (IA64_REG_F19,     UNW_IA64_FR + 19);
+      MEMIFY (IA64_REG_F20,     UNW_IA64_FR + 20);
+      MEMIFY (IA64_REG_F21,     UNW_IA64_FR + 21);
+      MEMIFY (IA64_REG_F22,     UNW_IA64_FR + 22);
+      MEMIFY (IA64_REG_F23,     UNW_IA64_FR + 23);
+      MEMIFY (IA64_REG_F24,     UNW_IA64_FR + 24);
+      MEMIFY (IA64_REG_F25,     UNW_IA64_FR + 25);
+      MEMIFY (IA64_REG_F26,     UNW_IA64_FR + 26);
+      MEMIFY (IA64_REG_F27,     UNW_IA64_FR + 27);
+      MEMIFY (IA64_REG_F28,     UNW_IA64_FR + 28);
+      MEMIFY (IA64_REG_F29,     UNW_IA64_FR + 29);
+      MEMIFY (IA64_REG_F30,     UNW_IA64_FR + 30);
+      MEMIFY (IA64_REG_F31,     UNW_IA64_FR + 31);
     }
   else
 #endif /* __linux && !UNW_REMOTE_ONLY */
@@ -241,25 +241,25 @@ remote_install_cursor (struct cursor *c)
       Debug (8, "copying out cursor state\n");
 
       for (reg = 0; reg <= UNW_REG_LAST; ++reg)
-	{
-	  if (unw_is_fpreg (reg))
-	    {
-	      if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
-		(*access_fpreg) (c->as, reg, &fpval, 1, c->as_arg);
-	    }
-	  else
-	    {
-	      if (tdep_access_reg (c, reg, &val, 0) >= 0)
-		(*access_reg) (c->as, reg, &val, 1, c->as_arg);
-	    }
-	}
+        {
+          if (unw_is_fpreg (reg))
+            {
+              if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+                (*access_fpreg) (c->as, reg, &fpval, 1, c->as_arg);
+            }
+          else
+            {
+              if (tdep_access_reg (c, reg, &val, 0) >= 0)
+                (*access_reg) (c->as, reg, &val, 1, c->as_arg);
+            }
+        }
     }
   return (*c->as->acc.resume) (c->as, (unw_cursor_t *) c, c->as_arg);
 }
 
 #endif /* !UNW_LOCAL_ONLY */
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/ia64/Gscript.c b/src/ia64/Gscript.c
index 5d8f2e1..526aeaf 100644
--- a/src/ia64/Gscript.c
+++ b/src/ia64/Gscript.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -29,23 +29,23 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 enum ia64_script_insn_opcode
   {
-    IA64_INSN_INC_PSP,		/* psp += val */
-    IA64_INSN_LOAD_PSP,		/* psp = *psp_loc */
-    IA64_INSN_ADD_PSP,		/* s[dst] = (s.psp + val) */
-    IA64_INSN_ADD_PSP_NAT,	/* like above, but with NaT info */
-    IA64_INSN_ADD_SP,		/* s[dst] = (s.sp + val) */
-    IA64_INSN_ADD_SP_NAT,	/* like above, but with NaT info */
-    IA64_INSN_MOVE,		/* s[dst] = s[val] */
-    IA64_INSN_MOVE_NAT,		/* like above, but with NaT info */
-    IA64_INSN_MOVE_NO_NAT,	/* like above, but clear NaT info */
-    IA64_INSN_MOVE_STACKED,	/* s[dst] = rse_skip(*s.bsp_loc, val) */
-    IA64_INSN_MOVE_STACKED_NAT,	/* like above, but with NaT info */
-    IA64_INSN_MOVE_SCRATCH,	/* s[dst] = scratch reg "val" */
-    IA64_INSN_MOVE_SCRATCH_NAT,	/* like above, but with NaT info */
+    IA64_INSN_INC_PSP,          /* psp += val */
+    IA64_INSN_LOAD_PSP,         /* psp = *psp_loc */
+    IA64_INSN_ADD_PSP,          /* s[dst] = (s.psp + val) */
+    IA64_INSN_ADD_PSP_NAT,      /* like above, but with NaT info */
+    IA64_INSN_ADD_SP,           /* s[dst] = (s.sp + val) */
+    IA64_INSN_ADD_SP_NAT,       /* like above, but with NaT info */
+    IA64_INSN_MOVE,             /* s[dst] = s[val] */
+    IA64_INSN_MOVE_NAT,         /* like above, but with NaT info */
+    IA64_INSN_MOVE_NO_NAT,      /* like above, but clear NaT info */
+    IA64_INSN_MOVE_STACKED,     /* s[dst] = rse_skip(*s.bsp_loc, val) */
+    IA64_INSN_MOVE_STACKED_NAT, /* like above, but with NaT info */
+    IA64_INSN_MOVE_SCRATCH,     /* s[dst] = scratch reg "val" */
+    IA64_INSN_MOVE_SCRATCH_NAT, /* like above, but with NaT info */
     IA64_INSN_MOVE_SCRATCH_NO_NAT /* like above, but clear NaT info */
   };
 
-#ifdef HAVE___THREAD
+#if defined(HAVE___THREAD) && HAVE___THREAD
 static __thread struct ia64_script_cache ia64_per_thread_cache =
   {
 #ifdef HAVE_ATOMIC_OPS_H
@@ -60,7 +60,7 @@ static inline unw_hash_index_t CONST_ATTR
 hash (unw_word_t ip)
 {
   /* based on (sqrt(5)/2-1)*2^64 */
-# define magic	((unw_word_t) 0x9e3779b97f4a7c16ULL)
+# define magic  ((unw_word_t) 0x9e3779b97f4a7c16ULL)
 
   return (ip >> 4) * magic >> (64 - IA64_LOG_UNW_HASH_SIZE);
 }
@@ -84,7 +84,7 @@ flush_script_cache (struct ia64_script_cache *cache)
   for (i = 0; i < IA64_UNW_CACHE_SIZE; ++i)
     {
       if (i > 0)
-	cache->buckets[i].lru_chain = (i - 1);
+        cache->buckets[i].lru_chain = (i - 1);
       cache->buckets[i].coll_chain = -1;
       cache->buckets[i].ip = 0;
     }
@@ -105,7 +105,7 @@ get_script_cache (unw_addr_space_t as, intrmask_t *saved_maskp)
   if (!spin_trylock_irqsave (&cache->busy, *saved_maskp))
     return NULL;
 #else
-# ifdef HAVE___THREAD
+# if defined(HAVE___THREAD) && HAVE___THREAD
   if (as->caching_policy == UNW_CACHE_PER_THREAD)
     cache = &ia64_per_thread_cache;
 # endif
@@ -131,7 +131,7 @@ get_script_cache (unw_addr_space_t as, intrmask_t *saved_maskp)
 
 static inline void
 put_script_cache (unw_addr_space_t as, struct ia64_script_cache *cache,
-		  intrmask_t *saved_maskp)
+                  intrmask_t *saved_maskp)
 {
   assert (as->caching_policy != UNW_CACHE_NONE);
 
@@ -169,14 +169,14 @@ script_lookup (struct ia64_script_cache *cache, struct cursor *c)
   while (1)
     {
       if (cache_match (script, ip, pr))
-	{
-	  /* update hint; no locking needed: single-word writes are atomic */
-	  c->hint = cache->buckets[c->prev_script].hint =
-	    (script - cache->buckets);
-	  return script;
-	}
+        {
+          /* update hint; no locking needed: single-word writes are atomic */
+          c->hint = cache->buckets[c->prev_script].hint =
+            (script - cache->buckets);
+          return script;
+        }
       if (script->coll_chain >= IA64_UNW_HASH_SIZE)
-	return 0;
+        return 0;
       script = cache->buckets + script->coll_chain;
     }
 }
@@ -212,22 +212,22 @@ script_new (struct ia64_script_cache *cache, unw_word_t ip)
       tmp = cache->buckets + cache->hash[index];
       prev = 0;
       while (1)
-	{
-	  if (tmp == script)
-	    {
-	      if (prev)
-		prev->coll_chain = tmp->coll_chain;
-	      else
-		cache->hash[index] = tmp->coll_chain;
-	      break;
-	    }
-	  else
-	    prev = tmp;
-	  if (tmp->coll_chain >= IA64_UNW_CACHE_SIZE)
-	    /* old script wasn't in the hash-table */
-	    break;
-	  tmp = cache->buckets + tmp->coll_chain;
-	}
+        {
+          if (tmp == script)
+            {
+              if (prev)
+                prev->coll_chain = tmp->coll_chain;
+              else
+                cache->hash[index] = tmp->coll_chain;
+              break;
+            }
+          else
+            prev = tmp;
+          if (tmp->coll_chain >= IA64_UNW_CACHE_SIZE)
+            /* old script wasn't in the hash-table */
+            break;
+          tmp = cache->buckets + tmp->coll_chain;
+        }
     }
 
   /* enter new script in the hash table */
@@ -241,7 +241,7 @@ script_new (struct ia64_script_cache *cache, unw_word_t ip)
 
 static inline void
 script_finalize (struct ia64_script *script, struct cursor *c,
-		 struct ia64_state_record *sr)
+                 struct ia64_state_record *sr)
 {
   script->pr_mask = sr->pr_mask;
   script->pr_val = sr->pr_val;
@@ -254,7 +254,7 @@ script_emit (struct ia64_script *script, struct ia64_script_insn insn)
   if (script->count >= IA64_MAX_SCRIPT_LEN)
     {
       Dprintf ("%s: script exceeds maximum size of %u instructions!\n",
-	       __FUNCTION__, IA64_MAX_SCRIPT_LEN);
+               __FUNCTION__, IA64_MAX_SCRIPT_LEN);
       return;
     }
   script->insn[script->count++] = insn;
@@ -262,7 +262,7 @@ script_emit (struct ia64_script *script, struct ia64_script_insn insn)
 
 static void
 compile_reg (struct ia64_state_record *sr, int i, struct ia64_reg_info *r,
-	     struct ia64_script *script)
+             struct ia64_script *script)
 {
   enum ia64_script_insn_opcode opc;
   unsigned long val, rval;
@@ -280,94 +280,94 @@ compile_reg (struct ia64_state_record *sr, int i, struct ia64_reg_info *r,
     {
       /* Handle most common case first... */
       if (rval >= 32)
-	{
-	  /* register got spilled to a stacked register */
-	  if (is_preserved_gr)
-	    opc = IA64_INSN_MOVE_STACKED_NAT;
-	  else
-	    opc = IA64_INSN_MOVE_STACKED;
-	  val = rval;
-	}
+        {
+          /* register got spilled to a stacked register */
+          if (is_preserved_gr)
+            opc = IA64_INSN_MOVE_STACKED_NAT;
+          else
+            opc = IA64_INSN_MOVE_STACKED;
+          val = rval;
+        }
       else if (rval >= 4 && rval <= 7)
-	{
-	  /* register got spilled to a preserved register */
-	  val = IA64_REG_R4 + (rval - 4);
-	  if (is_preserved_gr)
-	    opc = IA64_INSN_MOVE_NAT;
-	}
+        {
+          /* register got spilled to a preserved register */
+          val = IA64_REG_R4 + (rval - 4);
+          if (is_preserved_gr)
+            opc = IA64_INSN_MOVE_NAT;
+        }
       else
-	{
-	  /* register got spilled to a scratch register */
-	  if (is_preserved_gr)
-	    opc = IA64_INSN_MOVE_SCRATCH_NAT;
-	  else
-	    opc = IA64_INSN_MOVE_SCRATCH;
-	  val = UNW_IA64_GR + rval;
-	}
+        {
+          /* register got spilled to a scratch register */
+          if (is_preserved_gr)
+            opc = IA64_INSN_MOVE_SCRATCH_NAT;
+          else
+            opc = IA64_INSN_MOVE_SCRATCH;
+          val = UNW_IA64_GR + rval;
+        }
     }
   else
     {
       switch (r->where)
-	{
-	case IA64_WHERE_FR:
-	  /* Note: There is no need to handle NaT-bit info here
-	     (indepent of is_preserved_gr), because for floating-point
-	     NaTs are represented as NaTVal, so the NaT-info never
-	     needs to be consulated.  */
-	  if (rval >= 2 && rval <= 5)
-	    val = IA64_REG_F2 + (rval - 2);
-	  else if (rval >= 16 && rval <= 31)
-	    val = IA64_REG_F16 + (rval - 16);
-	  else
-	    {
-	      opc = IA64_INSN_MOVE_SCRATCH;
-	      val = UNW_IA64_FR + rval;
-	    }
-	  break;
-
-	case IA64_WHERE_BR:
-	  if (rval >= 1 && rval <= 5)
-	    {
-	      val = IA64_REG_B1 + (rval - 1);
-	      if (is_preserved_gr)
-		opc = IA64_INSN_MOVE_NO_NAT;
-	    }
-	  else
-	    {
-	      opc = IA64_INSN_MOVE_SCRATCH;
-	      if (is_preserved_gr)
-		opc = IA64_INSN_MOVE_SCRATCH_NO_NAT;
-	      val = UNW_IA64_BR + rval;
-	    }
-	  break;
-
-	case IA64_WHERE_SPREL:
-	  if (is_preserved_gr)
-	    opc = IA64_INSN_ADD_SP_NAT;
-	  else
-	    {
-	      opc = IA64_INSN_ADD_SP;
-	      if (i >= IA64_REG_F2 && i <= IA64_REG_F31)
-		val |= IA64_LOC_TYPE_FP;
-	    }
-	  break;
-
-	case IA64_WHERE_PSPREL:
-	  if (is_preserved_gr)
-	    opc = IA64_INSN_ADD_PSP_NAT;
-	  else
-	    {
-	      opc = IA64_INSN_ADD_PSP;
-	      if (i >= IA64_REG_F2 && i <= IA64_REG_F31)
-		val |= IA64_LOC_TYPE_FP;
-	    }
-	  break;
-
-	default:
-	  Dprintf ("%s: register %u has unexpected `where' value of %u\n",
-		   __FUNCTION__, i, r->where);
-	  break;
-	}
+        {
+        case IA64_WHERE_FR:
+          /* Note: There is no need to handle NaT-bit info here
+             (indepent of is_preserved_gr), because for floating-point
+             NaTs are represented as NaTVal, so the NaT-info never
+             needs to be consulated.  */
+          if (rval >= 2 && rval <= 5)
+            val = IA64_REG_F2 + (rval - 2);
+          else if (rval >= 16 && rval <= 31)
+            val = IA64_REG_F16 + (rval - 16);
+          else
+            {
+              opc = IA64_INSN_MOVE_SCRATCH;
+              val = UNW_IA64_FR + rval;
+            }
+          break;
+
+        case IA64_WHERE_BR:
+          if (rval >= 1 && rval <= 5)
+            {
+              val = IA64_REG_B1 + (rval - 1);
+              if (is_preserved_gr)
+                opc = IA64_INSN_MOVE_NO_NAT;
+            }
+          else
+            {
+              opc = IA64_INSN_MOVE_SCRATCH;
+              if (is_preserved_gr)
+                opc = IA64_INSN_MOVE_SCRATCH_NO_NAT;
+              val = UNW_IA64_BR + rval;
+            }
+          break;
+
+        case IA64_WHERE_SPREL:
+          if (is_preserved_gr)
+            opc = IA64_INSN_ADD_SP_NAT;
+          else
+            {
+              opc = IA64_INSN_ADD_SP;
+              if (i >= IA64_REG_F2 && i <= IA64_REG_F31)
+                val |= IA64_LOC_TYPE_FP;
+            }
+          break;
+
+        case IA64_WHERE_PSPREL:
+          if (is_preserved_gr)
+            opc = IA64_INSN_ADD_PSP_NAT;
+          else
+            {
+              opc = IA64_INSN_ADD_PSP;
+              if (i >= IA64_REG_F2 && i <= IA64_REG_F31)
+                val |= IA64_LOC_TYPE_FP;
+            }
+          break;
+
+        default:
+          Dprintf ("%s: register %u has unexpected `where' value of %u\n",
+                   __FUNCTION__, i, r->where);
+          break;
+        }
     }
   insn.opc = opc;
   insn.dst = i;
@@ -377,8 +377,8 @@ compile_reg (struct ia64_state_record *sr, int i, struct ia64_reg_info *r,
   if (i == IA64_REG_PSP)
     {
       /* c->psp must contain the _value_ of the previous sp, not it's
-	 save-location.  We get this by dereferencing the value we
-	 just stored in loc[IA64_REG_PSP]: */
+         save-location.  We get this by dereferencing the value we
+         just stored in loc[IA64_REG_PSP]: */
       insn.opc = IA64_INSN_LOAD_PSP;
       script_emit (script, insn);
     }
@@ -400,8 +400,8 @@ sort_regs (struct ia64_state_record *sr, int regorder[])
   for (r = IA64_REG_BSP; r < IA64_NUM_PREGS; ++r)
     {
       if (sr->curr.reg[r].where == IA64_WHERE_NONE
-	  || sr->curr.reg[r].when >= sr->when_target)
-	continue;
+          || sr->curr.reg[r].when >= sr->when_target)
+        continue;
 
       regorder[num_regs++] = r;
     }
@@ -416,17 +416,17 @@ sort_regs (struct ia64_state_record *sr, int regorder[])
       max_when = sr->curr.reg[max_reg].when;
 
       for (j = i + 1; j < num_regs; ++j)
-	if (sr->curr.reg[regorder[j]].when > max_when)
-	  {
-	    max = j;
-	    max_reg = regorder[j];
-	    max_when = sr->curr.reg[max_reg].when;
-	  }
+        if (sr->curr.reg[regorder[j]].when > max_when)
+          {
+            max = j;
+            max_reg = regorder[j];
+            max_when = sr->curr.reg[max_reg].when;
+          }
       if (i != max)
-	{
-	  regorder[max] = regorder[i];
-	  regorder[i] = max_reg;
-	}
+        {
+          regorder[max] = regorder[i];
+          regorder[i] = max_reg;
+        }
     }
   return num_regs;
 }
@@ -457,7 +457,7 @@ build_script (struct cursor *c, struct ia64_script *script)
     {
       /* new psp is psp plus frame size */
       insn.opc = IA64_INSN_INC_PSP;
-      insn.val = sr.curr.reg[IA64_REG_PSP].val;	/* frame size */
+      insn.val = sr.curr.reg[IA64_REG_PSP].val; /* frame size */
       script_emit (script, insn);
     }
   else
@@ -469,18 +469,18 @@ build_script (struct cursor *c, struct ia64_script *script)
       || sr.when_target >= sr.curr.reg[IA64_REG_PRI_UNAT_MEM].when)
     {
       if (sr.when_target < sr.curr.reg[IA64_REG_PRI_UNAT_GR].when)
-	/* (primary) NaT bits were saved to memory only */
-	pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_MEM;
+        /* (primary) NaT bits were saved to memory only */
+        pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_MEM;
       else if (sr.when_target < sr.curr.reg[IA64_REG_PRI_UNAT_MEM].when)
-	/* (primary) NaT bits were saved to a register only */
-	pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_GR;
+        /* (primary) NaT bits were saved to a register only */
+        pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_GR;
       else if (sr.curr.reg[IA64_REG_PRI_UNAT_MEM].when >
-	       sr.curr.reg[IA64_REG_PRI_UNAT_GR].when)
-	/* (primary) NaT bits were last saved to memory */
-	pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_MEM;
+               sr.curr.reg[IA64_REG_PRI_UNAT_GR].when)
+        /* (primary) NaT bits were last saved to memory */
+        pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_MEM;
       else
-	/* (primary) NaT bits were last saved to a register */
-	pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_GR;
+        /* (primary) NaT bits were last saved to a register */
+        pri_unat = sr.curr.reg + IA64_REG_PRI_UNAT_GR;
 
       /* Note: we always store the final primary-UNaT location in UNAT_MEM.  */
       compile_reg (&sr, IA64_REG_PRI_UNAT_MEM, pri_unat, script);
@@ -501,7 +501,7 @@ build_script (struct cursor *c, struct ia64_script *script)
 
 static inline void
 set_nat_info (struct cursor *c, unsigned long dst,
-	      ia64_loc_t nat_loc, uint8_t bitnr)
+              ia64_loc_t nat_loc, uint8_t bitnr)
 {
   assert (dst >= IA64_REG_R4 && dst <= IA64_REG_R7);
 
@@ -538,79 +538,79 @@ run_script (struct ia64_script *script, struct cursor *c)
 
       /* This is by far the most common operation: */
       if (likely (opc == IA64_INSN_MOVE_STACKED))
-	{
-	  if ((ret = ia64_get_stacked (c, val, &loc, NULL)) < 0)
-	    return ret;
-	}
+        {
+          if ((ret = ia64_get_stacked (c, val, &loc, NULL)) < 0)
+            return ret;
+        }
       else
-	switch (opc)
-	  {
-	  case IA64_INSN_INC_PSP:
-	    c->psp += val;
-	    continue;
-
-	  case IA64_INSN_LOAD_PSP:
-	    if ((ret = ia64_get (c, c->loc[IA64_REG_PSP], &c->psp)) < 0)
-	      return ret;
-	    continue;
-
-	  case IA64_INSN_ADD_PSP:
-	    loc = IA64_LOC_ADDR (c->psp + val, (val & IA64_LOC_TYPE_FP));
-	    break;
-
-	  case IA64_INSN_ADD_SP:
-	    loc = IA64_LOC_ADDR (c->sp + val, (val & IA64_LOC_TYPE_FP));
-	    break;
-
-	  case IA64_INSN_MOVE_NO_NAT:
-	    set_nat_info (c, dst, IA64_NULL_LOC, 0);
-	  case IA64_INSN_MOVE:
-	    loc = c->loc[val];
-	    break;
-
-	  case IA64_INSN_MOVE_SCRATCH_NO_NAT:
-	    set_nat_info (c, dst, IA64_NULL_LOC, 0);
-	  case IA64_INSN_MOVE_SCRATCH:
-	    loc = ia64_scratch_loc (c, val, NULL);
-	    break;
-
-	  case IA64_INSN_ADD_PSP_NAT:
-	    loc = IA64_LOC_ADDR (c->psp + val, 0);
-	    assert (!IA64_IS_REG_LOC (loc));
-	    set_nat_info (c, dst,
-			  c->loc[IA64_REG_PRI_UNAT_MEM],
-			  ia64_unat_slot_num (IA64_GET_ADDR (loc)));
-	    break;
-
-	  case IA64_INSN_ADD_SP_NAT:
-	    loc = IA64_LOC_ADDR (c->sp + val, 0);
-	    assert (!IA64_IS_REG_LOC (loc));
-	    set_nat_info (c, dst,
-			  c->loc[IA64_REG_PRI_UNAT_MEM],
-			  ia64_unat_slot_num (IA64_GET_ADDR (loc)));
-	    break;
-
-	  case IA64_INSN_MOVE_NAT:
-	    loc = c->loc[val];
-	    set_nat_info (c, dst,
-			  c->loc[val - IA64_REG_R4 + IA64_REG_NAT4],
-			  c->nat_bitnr[val - IA64_REG_R4]);
-	    break;
-
-	  case IA64_INSN_MOVE_STACKED_NAT:
-	    if ((ret = ia64_get_stacked (c, val, &loc, &nat_loc)) < 0)
-	      return ret;
-	    assert (!IA64_IS_REG_LOC (loc));
-	    set_nat_info (c, dst, nat_loc, rse_slot_num (IA64_GET_ADDR (loc)));
-	    break;
-
-	  case IA64_INSN_MOVE_SCRATCH_NAT:
-	    loc = ia64_scratch_loc (c, val, NULL);
-	    nat_loc = ia64_scratch_loc (c, val + (UNW_IA64_NAT - UNW_IA64_GR),
-					&nat_bitnr);
-	    set_nat_info (c, dst, nat_loc, nat_bitnr);
-	    break;
-	  }
+        switch (opc)
+          {
+          case IA64_INSN_INC_PSP:
+            c->psp += val;
+            continue;
+
+          case IA64_INSN_LOAD_PSP:
+            if ((ret = ia64_get (c, c->loc[IA64_REG_PSP], &c->psp)) < 0)
+              return ret;
+            continue;
+
+          case IA64_INSN_ADD_PSP:
+            loc = IA64_LOC_ADDR (c->psp + val, (val & IA64_LOC_TYPE_FP));
+            break;
+
+          case IA64_INSN_ADD_SP:
+            loc = IA64_LOC_ADDR (c->sp + val, (val & IA64_LOC_TYPE_FP));
+            break;
+
+          case IA64_INSN_MOVE_NO_NAT:
+            set_nat_info (c, dst, IA64_NULL_LOC, 0);
+          case IA64_INSN_MOVE:
+            loc = c->loc[val];
+            break;
+
+          case IA64_INSN_MOVE_SCRATCH_NO_NAT:
+            set_nat_info (c, dst, IA64_NULL_LOC, 0);
+          case IA64_INSN_MOVE_SCRATCH:
+            loc = ia64_scratch_loc (c, val, NULL);
+            break;
+
+          case IA64_INSN_ADD_PSP_NAT:
+            loc = IA64_LOC_ADDR (c->psp + val, 0);
+            assert (!IA64_IS_REG_LOC (loc));
+            set_nat_info (c, dst,
+                          c->loc[IA64_REG_PRI_UNAT_MEM],
+                          ia64_unat_slot_num (IA64_GET_ADDR (loc)));
+            break;
+
+          case IA64_INSN_ADD_SP_NAT:
+            loc = IA64_LOC_ADDR (c->sp + val, 0);
+            assert (!IA64_IS_REG_LOC (loc));
+            set_nat_info (c, dst,
+                          c->loc[IA64_REG_PRI_UNAT_MEM],
+                          ia64_unat_slot_num (IA64_GET_ADDR (loc)));
+            break;
+
+          case IA64_INSN_MOVE_NAT:
+            loc = c->loc[val];
+            set_nat_info (c, dst,
+                          c->loc[val - IA64_REG_R4 + IA64_REG_NAT4],
+                          c->nat_bitnr[val - IA64_REG_R4]);
+            break;
+
+          case IA64_INSN_MOVE_STACKED_NAT:
+            if ((ret = ia64_get_stacked (c, val, &loc, &nat_loc)) < 0)
+              return ret;
+            assert (!IA64_IS_REG_LOC (loc));
+            set_nat_info (c, dst, nat_loc, rse_slot_num (IA64_GET_ADDR (loc)));
+            break;
+
+          case IA64_INSN_MOVE_SCRATCH_NAT:
+            loc = ia64_scratch_loc (c, val, NULL);
+            nat_loc = ia64_scratch_loc (c, val + (UNW_IA64_NAT - UNW_IA64_GR),
+                                        &nat_bitnr);
+            set_nat_info (c, dst, nat_loc, nat_bitnr);
+            break;
+          }
       c->loc[dst] = loc;
     }
   return 0;
@@ -629,8 +629,8 @@ uncached_find_save_locs (struct cursor *c)
   if ((ret = build_script (c, &script)) < 0)
     {
       if (ret != -UNW_ESTOPUNWIND)
-	Dprintf ("%s: failed to build unwind script for ip %lx\n",
-		 __FUNCTION__, (long) c->ip);
+        Dprintf ("%s: failed to build unwind script for ip %lx\n",
+                 __FUNCTION__, (long) c->ip);
       return ret;
     }
   return run_script (&script, c);
@@ -656,23 +656,23 @@ ia64_find_save_locs (struct cursor *c)
   {
     script = script_lookup (cache, c);
     Debug (8, "ip %lx %s in script cache\n", (long) c->ip,
-	   script ? "hit" : "missed");
+           script ? "hit" : "missed");
 
     if (!script || (script->count == 0 && !script->pi.unwind_info))
       {
-	if ((ret = ia64_fetch_proc_info (c, c->ip, 1)) < 0)
-	  goto out;
+        if ((ret = ia64_fetch_proc_info (c, c->ip, 1)) < 0)
+          goto out;
       }
 
     if (!script)
       {
-	script = script_new (cache, c->ip);
-	if (!script)
-	  {
-	    Dprintf ("%s: failed to create unwind script\n", __FUNCTION__);
-	    ret = -UNW_EUNSPEC;
-	    goto out;
-	  }
+        script = script_new (cache, c->ip);
+        if (!script)
+          {
+            Dprintf ("%s: failed to create unwind script\n", __FUNCTION__);
+            ret = -UNW_EUNSPEC;
+            goto out;
+          }
       }
     cache->buckets[c->prev_script].hint = script - cache->buckets;
 
@@ -686,10 +686,10 @@ ia64_find_save_locs (struct cursor *c)
 
     if (ret < 0)
       {
-	if (ret != -UNW_ESTOPUNWIND)
-	  Dprintf ("%s: failed to locate/build unwind script for ip %lx\n",
-		   __FUNCTION__, (long) c->ip);
-	goto out;
+        if (ret != -UNW_ESTOPUNWIND)
+          Dprintf ("%s: failed to locate/build unwind script for ip %lx\n",
+                   __FUNCTION__, (long) c->ip);
+        goto out;
       }
 
     ret = run_script (script, c);
@@ -723,7 +723,7 @@ ia64_cache_proc_info (struct cursor *c)
 
   cache = get_script_cache (c->as, &saved_mask);
   if (!cache)
-    return ret;	/* cache is busy */
+    return ret; /* cache is busy */
 
   /* Re-check to see if a cache entry has been added in the meantime: */
   script = script_lookup (cache, c);
@@ -754,7 +754,7 @@ ia64_get_cached_proc_info (struct cursor *c)
 
   cache = get_script_cache (c->as, &saved_mask);
   if (!cache)
-    return -UNW_ENOINFO;	/* cache is busy */
+    return -UNW_ENOINFO;        /* cache is busy */
   {
     script = script_lookup (cache, c);
     if (script)
diff --git a/src/ia64/Gstep.c b/src/ia64/Gstep.c
index e632910..df4ecb8 100644
--- a/src/ia64/Gstep.c
+++ b/src/ia64/Gstep.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 static inline int
 linux_sigtramp (struct cursor *c, ia64_loc_t prev_cfm_loc,
-		unw_word_t *num_regsp)
+                unw_word_t *num_regsp)
 {
 #if defined(UNW_LOCAL_ONLY) && !defined(__linux)
   return -UNW_EINVAL;
@@ -37,8 +37,8 @@ linux_sigtramp (struct cursor *c, ia64_loc_t prev_cfm_loc,
   int ret;
 
   if ((ret = ia64_get (c, IA64_LOC_ADDR (c->sp + 0x10
-					 + LINUX_SIGFRAME_ARG2_OFF, 0),
-		       &sc_addr)) < 0)
+                                         + LINUX_SIGFRAME_ARG2_OFF, 0),
+                       &sc_addr)) < 0)
     return ret;
 
   c->sigcontext_addr = sc_addr;
@@ -47,7 +47,7 @@ linux_sigtramp (struct cursor *c, ia64_loc_t prev_cfm_loc,
       && IA64_GET_ADDR (c->loc[IA64_REG_IP]) == sc_addr + LINUX_SC_BR_OFF + 8)
     {
       /* Linux kernels before 2.4.19 and 2.5.10 had buggy
-	 unwind info for sigtramp.  Fix it up here.  */
+         unwind info for sigtramp.  Fix it up here.  */
       c->loc[IA64_REG_IP]  = IA64_LOC_ADDR (sc_addr + LINUX_SC_IP_OFF, 0);
       c->cfm_loc = IA64_LOC_ADDR (sc_addr + LINUX_SC_CFM_OFF, 0);
     }
@@ -55,14 +55,14 @@ linux_sigtramp (struct cursor *c, ia64_loc_t prev_cfm_loc,
   /* do what can't be described by unwind directives: */
   c->loc[IA64_REG_PFS] = IA64_LOC_ADDR (sc_addr + LINUX_SC_AR_PFS_OFF, 0);
   c->ec_loc = prev_cfm_loc;
-  *num_regsp = c->cfm & 0x7f;		/* size of frame */
+  *num_regsp = c->cfm & 0x7f;           /* size of frame */
   return 0;
 #endif
 }
 
 static inline int
 linux_interrupt (struct cursor *c, ia64_loc_t prev_cfm_loc,
-		 unw_word_t *num_regsp, int marker)
+                 unw_word_t *num_regsp, int marker)
 {
 #if defined(UNW_LOCAL_ONLY) && !(defined(__linux) && defined(__KERNEL__))
   return -UNW_EINVAL;
@@ -79,19 +79,19 @@ linux_interrupt (struct cursor *c, ia64_loc_t prev_cfm_loc,
 
   /* do what can't be described by unwind directives: */
   if (marker == ABI_MARKER_OLD_LINUX_INTERRUPT)
-	  pfs_loc = IA64_LOC_ADDR (sc_addr + LINUX_OLD_PT_PFS_OFF, 0);
+          pfs_loc = IA64_LOC_ADDR (sc_addr + LINUX_OLD_PT_PFS_OFF, 0);
   else
-	  pfs_loc = IA64_LOC_ADDR (sc_addr + LINUX_PT_PFS_OFF, 0);
+          pfs_loc = IA64_LOC_ADDR (sc_addr + LINUX_PT_PFS_OFF, 0);
   c->loc[IA64_REG_PFS] = pfs_loc;
   c->ec_loc = prev_cfm_loc;
-  *num_regsp = num_regs;		/* size of frame */
+  *num_regsp = num_regs;                /* size of frame */
   return 0;
 #endif
 }
 
 static inline int
 hpux_sigtramp (struct cursor *c, ia64_loc_t prev_cfm_loc,
-	       unw_word_t *num_regsp)
+               unw_word_t *num_regsp)
 {
 #if defined(UNW_LOCAL_ONLY) && !defined(__hpux)
   return -UNW_EINVAL;
@@ -177,36 +177,36 @@ check_rbs_switch (struct cursor *c)
   if (c->pi.flags & UNW_PI_FLAG_IA64_RBS_SWITCH)
     {
       /* Got ourselves a frame that has saved ar.bspstore, ar.bsp,
-	 and ar.rnat, so we're all set for rbs-switching:  */
+         and ar.rnat, so we're all set for rbs-switching:  */
       if ((ret = ia64_get (c, c->loc[IA64_REG_BSP], &saved_bsp)) < 0
-	  || (ret = ia64_get (c, c->loc[IA64_REG_BSPSTORE], &saved_bspstore)))
-	return ret;
+          || (ret = ia64_get (c, c->loc[IA64_REG_BSPSTORE], &saved_bspstore)))
+        return ret;
     }
   else if ((c->abi_marker == ABI_MARKER_LINUX_SIGTRAMP
-	    || c->abi_marker == ABI_MARKER_OLD_LINUX_SIGTRAMP)
-	   && !IA64_IS_REG_LOC (c->loc[IA64_REG_BSP])
-	   && (IA64_GET_ADDR (c->loc[IA64_REG_BSP])
-	       == c->sigcontext_addr + LINUX_SC_AR_BSP_OFF))
+            || c->abi_marker == ABI_MARKER_OLD_LINUX_SIGTRAMP)
+           && !IA64_IS_REG_LOC (c->loc[IA64_REG_BSP])
+           && (IA64_GET_ADDR (c->loc[IA64_REG_BSP])
+               == c->sigcontext_addr + LINUX_SC_AR_BSP_OFF))
     {
       /* When Linux delivers a signal on an alternate stack, it
-	 does things a bit differently from what the unwind
-	 conventions allow us to describe: instead of saving
-	 ar.rnat, ar.bsp, and ar.bspstore, it saves the former two
-	 plus the "loadrs" value.  Because of this, we need to
-	 detect & record a potential rbs-area switch
-	 manually... */
+         does things a bit differently from what the unwind
+         conventions allow us to describe: instead of saving
+         ar.rnat, ar.bsp, and ar.bspstore, it saves the former two
+         plus the "loadrs" value.  Because of this, we need to
+         detect & record a potential rbs-area switch
+         manually... */
 
       /* If ar.bsp has been saved already AND the current bsp is
-	 not equal to the saved value, then we know for sure that
-	 we're past the point where the backing store has been
-	 switched (and before the point where it's restored).  */
+         not equal to the saved value, then we know for sure that
+         we're past the point where the backing store has been
+         switched (and before the point where it's restored).  */
       if ((ret = ia64_get (c, IA64_LOC_ADDR (c->sigcontext_addr
-					     + LINUX_SC_AR_BSP_OFF, 0),
-			   &saved_bsp) < 0)
-	  || (ret = ia64_get (c, IA64_LOC_ADDR (c->sigcontext_addr
-						+ LINUX_SC_LOADRS_OFF, 0),
-			      &loadrs) < 0))
-	return ret;
+                                             + LINUX_SC_AR_BSP_OFF, 0),
+                           &saved_bsp) < 0)
+          || (ret = ia64_get (c, IA64_LOC_ADDR (c->sigcontext_addr
+                                                + LINUX_SC_LOADRS_OFF, 0),
+                              &loadrs) < 0))
+        return ret;
       loadrs >>= 16;
       ndirty = rse_num_regs (c->bsp - loadrs, c->bsp);
       saved_bspstore = rse_skip_regs (saved_bsp, -ndirty);
@@ -267,54 +267,54 @@ update_frame_state (struct cursor *c)
     {
       c->last_abi_marker = c->abi_marker;
       switch (ia64_get_abi_marker (c))
-	{
-	case ABI_MARKER_LINUX_SIGTRAMP:
-	case ABI_MARKER_OLD_LINUX_SIGTRAMP:
-	  ia64_set_abi (c, ABI_LINUX);
-	  if ((ret = linux_sigtramp (c, prev_cfm_loc, &num_regs)) < 0)
-	    return ret;
-	  break;
-
-	case ABI_MARKER_OLD_LINUX_INTERRUPT:
-	case ABI_MARKER_LINUX_INTERRUPT:
-	  ia64_set_abi (c, ABI_LINUX);
-	  if ((ret = linux_interrupt (c, prev_cfm_loc, &num_regs,
-				      c->abi_marker)) < 0)
-	    return ret;
-	  break;
-
-	case ABI_MARKER_HP_UX_SIGTRAMP:
-	  ia64_set_abi (c, ABI_HPUX);
-	  if ((ret = hpux_sigtramp (c, prev_cfm_loc, &num_regs)) < 0)
-	    return ret;
-	  break;
-
-	default:
-	  Debug (1, "unknown ABI marker: ABI=%u, context=%u\n",
-		 c->abi_marker >> 8, c->abi_marker & 0xff);
-	  return -UNW_EINVAL;
-	}
+        {
+        case ABI_MARKER_LINUX_SIGTRAMP:
+        case ABI_MARKER_OLD_LINUX_SIGTRAMP:
+          ia64_set_abi (c, ABI_LINUX);
+          if ((ret = linux_sigtramp (c, prev_cfm_loc, &num_regs)) < 0)
+            return ret;
+          break;
+
+        case ABI_MARKER_OLD_LINUX_INTERRUPT:
+        case ABI_MARKER_LINUX_INTERRUPT:
+          ia64_set_abi (c, ABI_LINUX);
+          if ((ret = linux_interrupt (c, prev_cfm_loc, &num_regs,
+                                      c->abi_marker)) < 0)
+            return ret;
+          break;
+
+        case ABI_MARKER_HP_UX_SIGTRAMP:
+          ia64_set_abi (c, ABI_HPUX);
+          if ((ret = hpux_sigtramp (c, prev_cfm_loc, &num_regs)) < 0)
+            return ret;
+          break;
+
+        default:
+          Debug (1, "unknown ABI marker: ABI=%u, context=%u\n",
+                 c->abi_marker >> 8, c->abi_marker & 0xff);
+          return -UNW_EINVAL;
+        }
       Debug (12, "sigcontext_addr=%lx (ret=%d)\n",
-	     (unsigned long) c->sigcontext_addr, ret);
+             (unsigned long) c->sigcontext_addr, ret);
 
       c->sigcontext_off = c->sigcontext_addr - c->sp;
 
       /* update the IP cache: */
       if ((ret = ia64_get (c, c->loc[IA64_REG_IP], &ip)) < 0)
- 	return ret;
+        return ret;
       c->ip = ip;
       if (ip == 0)
-	/* end of frame-chain reached */
-	return 0;
+        /* end of frame-chain reached */
+        return 0;
     }
   else
-    num_regs = (c->cfm >> 7) & 0x7f;	/* size of locals */
+    num_regs = (c->cfm >> 7) & 0x7f;    /* size of locals */
 
   if (!IA64_IS_NULL_LOC (c->loc[IA64_REG_BSP]))
     {
       ret = check_rbs_switch (c);
       if (ret < 0)
-	return ret;
+        return ret;
     }
 
   c->bsp = rse_skip_regs (c->bsp, -num_regs);
@@ -325,7 +325,7 @@ update_frame_state (struct cursor *c)
   if (c->ip == prev_ip && c->sp == prev_sp && c->bsp == prev_bsp)
     {
       Dprintf ("%s: ip, sp, and bsp unchanged; stopping here (ip=0x%lx)\n",
-	       __FUNCTION__, (long) ip);
+               __FUNCTION__, (long) ip);
       return -UNW_EBADFRAME;
     }
 
@@ -342,7 +342,7 @@ update_frame_state (struct cursor *c)
 }
 
 
-PROTECTED int
+int
 unw_step (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/ia64/Gtables.c b/src/ia64/Gtables.c
index de9e86f..f5e8f2d 100644
--- a/src/ia64/Gtables.c
+++ b/src/ia64/Gtables.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2001-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -68,26 +68,26 @@ is_local_addr_space (unw_addr_space_t as)
 static inline int
 read_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *valp, void *arg)
 {
-  unw_accessors_t *a = unw_get_accessors (as);
+  unw_accessors_t *a = unw_get_accessors_int (as);
 
   return (*a->access_mem) (as, addr, valp, 0, arg);
 }
 
 /* Helper macro for reading an ia64_table_entry from remote memory.  */
-#define remote_read(addr, member)					     \
-	(*a->access_mem) (as, (addr) + offsetof (struct ia64_table_entry,    \
-						 member), &member, 0, arg)
+#define remote_read(addr, member)                                            \
+        (*a->access_mem) (as, (addr) + offsetof (struct ia64_table_entry,    \
+                                                 member), &member, 0, arg)
 
 /* Lookup an unwind-table entry in remote memory.  Returns 1 if an
    entry is found, 0 if no entry is found, negative if an error
    occurred reading remote memory.  */
 static int
 remote_lookup (unw_addr_space_t as,
-	       unw_word_t table, size_t table_size, unw_word_t rel_ip,
-	       struct ia64_table_entry *e, void *arg)
+               unw_word_t table, size_t table_size, unw_word_t rel_ip,
+               struct ia64_table_entry *e, void *arg)
 {
   unw_word_t e_addr = 0, start_offset, end_offset, info_offset;
-  unw_accessors_t *a = unw_get_accessors (as);
+  unw_accessors_t *a = unw_get_accessors_int (as);
   unsigned long lo, hi, mid;
   int ret;
 
@@ -97,20 +97,20 @@ remote_lookup (unw_addr_space_t as,
       mid = (lo + hi) / 2;
       e_addr = table + mid * sizeof (struct ia64_table_entry);
       if ((ret = remote_read (e_addr, start_offset)) < 0)
-	return ret;
+        return ret;
 
       if (rel_ip < start_offset)
-	hi = mid;
+        hi = mid;
       else
-	{
-	  if ((ret = remote_read (e_addr, end_offset)) < 0)
-	    return ret;
-
-	  if (rel_ip >= end_offset)
-	    lo = mid + 1;
-	  else
-	    break;
-	}
+        {
+          if ((ret = remote_read (e_addr, end_offset)) < 0)
+            return ret;
+
+          if (rel_ip >= end_offset)
+            lo = mid + 1;
+          else
+            break;
+        }
     }
   if (rel_ip < start_offset || rel_ip >= end_offset)
     return 0;
@@ -136,7 +136,7 @@ tdep_put_unwind_info (unw_addr_space_t as, unw_proc_info_t *pi, void *arg)
     }
 }
 
-PROTECTED unw_word_t
+unw_word_t
 _Uia64_find_dyn_list (unw_addr_space_t as, unw_dyn_info_t *di, void *arg)
 {
   unw_word_t hdr_addr, info_addr, hdr, directives, pers, cookie, off;
@@ -157,7 +157,7 @@ _Uia64_find_dyn_list (unw_addr_space_t as, unw_dyn_info_t *di, void *arg)
       table_size = di->u.ti.table_len * sizeof (di->u.ti.table_data[0]);
       segbase = di->u.ti.segbase;
       if (table_size < sizeof (struct ia64_table_entry))
-	return 0;
+        return 0;
       start_offset = e[0].start_offset;
       end_offset = e[0].end_offset;
       info_offset = e[0].info_offset;
@@ -165,18 +165,18 @@ _Uia64_find_dyn_list (unw_addr_space_t as, unw_dyn_info_t *di, void *arg)
 
     case UNW_INFO_FORMAT_REMOTE_TABLE:
       {
-	unw_accessors_t *a = unw_get_accessors (as);
-	unw_word_t e_addr = di->u.rti.table_data;
-
-	table_size = di->u.rti.table_len * sizeof (unw_word_t);
-	segbase = di->u.rti.segbase;
-	if (table_size < sizeof (struct ia64_table_entry))
-	  return 0;
-
-	if (   (ret = remote_read (e_addr, start_offset) < 0)
-	    || (ret = remote_read (e_addr, end_offset) < 0)
-	    || (ret = remote_read (e_addr, info_offset) < 0))
-	  return ret;
+        unw_accessors_t *a = unw_get_accessors_int (as);
+        unw_word_t e_addr = di->u.rti.table_data;
+
+        table_size = di->u.rti.table_len * sizeof (unw_word_t);
+        segbase = di->u.rti.segbase;
+        if (table_size < sizeof (struct ia64_table_entry))
+          return 0;
+
+        if (   (ret = remote_read (e_addr, start_offset) < 0)
+            || (ret = remote_read (e_addr, end_offset) < 0)
+            || (ret = remote_read (e_addr, info_offset) < 0))
+          return ret;
       }
       break;
     }
@@ -236,21 +236,21 @@ lookup (struct ia64_table_entry *table, size_t table_size, unw_word_t rel_ip)
       mid = (lo + hi) / 2;
       e = table + mid;
       if (rel_ip < e->start_offset)
-	hi = mid;
+        hi = mid;
       else if (rel_ip >= e->end_offset)
-	lo = mid + 1;
+        lo = mid + 1;
       else
-	break;
+        break;
     }
   if (rel_ip < e->start_offset || rel_ip >= e->end_offset)
     return NULL;
   return e;
 }
 
-PROTECTED int
+int
 unw_search_ia64_unwind_table (unw_addr_space_t as, unw_word_t ip,
-			      unw_dyn_info_t *di, unw_proc_info_t *pi,
-			      int need_unwind_info, void *arg)
+                              unw_dyn_info_t *di, unw_proc_info_t *pi,
+                              int need_unwind_info, void *arg)
 {
   unw_word_t addr, hdr_addr, info_addr, info_end_addr, hdr, *wp;
   const struct ia64_table_entry *e = NULL;
@@ -261,8 +261,8 @@ unw_search_ia64_unwind_table (unw_addr_space_t as, unw_word_t ip,
 #endif
 
   assert ((di->format == UNW_INFO_FORMAT_TABLE
-	   || di->format == UNW_INFO_FORMAT_REMOTE_TABLE)
-	  && (ip >= di->start_ip && ip < di->end_ip));
+           || di->format == UNW_INFO_FORMAT_REMOTE_TABLE)
+          && (ip >= di->start_ip && ip < di->end_ip));
 
   pi->flags = 0;
   pi->unwind_info = 0;
@@ -272,26 +272,26 @@ unw_search_ia64_unwind_table (unw_addr_space_t as, unw_word_t ip,
     {
       segbase = di->u.ti.segbase;
       e = lookup ((struct ia64_table_entry *) di->u.ti.table_data,
-		  di->u.ti.table_len * sizeof (unw_word_t),
-		  ip - segbase);
+                  di->u.ti.table_len * sizeof (unw_word_t),
+                  ip - segbase);
     }
 #ifndef UNW_LOCAL_ONLY
   else
     {
       segbase = di->u.rti.segbase;
       if ((ret = remote_lookup (as, di->u.rti.table_data,
-				di->u.rti.table_len * sizeof (unw_word_t),
-				ip - segbase, &ent, arg)) < 0)
-	return ret;
+                                di->u.rti.table_len * sizeof (unw_word_t),
+                                ip - segbase, &ent, arg)) < 0)
+        return ret;
       if (ret)
-	e = &ent;
+        e = &ent;
     }
 #endif
   if (!e)
     {
       /* IP is inside this table's range, but there is no explicit
-	 unwind info => use default conventions (i.e., this is NOT an
-	 error).  */
+         unwind info => use default conventions (i.e., this is NOT an
+         error).  */
       memset (pi, 0, sizeof (*pi));
       pi->start_ip = 0;
       pi->end_ip = 0;
@@ -316,8 +316,8 @@ unw_search_ia64_unwind_table (unw_addr_space_t as, unw_word_t ip,
   if (IA64_UNW_VER (hdr) != 1)
     {
       Debug (1, "Unknown header version %ld (hdr word=0x%lx @ 0x%lx)\n",
-	     IA64_UNW_VER (hdr), (unsigned long) hdr,
-	     (unsigned long) hdr_addr);
+             IA64_UNW_VER (hdr), (unsigned long) hdr,
+             (unsigned long) hdr_addr);
       return -UNW_EBADVERSION;
     }
 
@@ -333,36 +333,36 @@ unw_search_ia64_unwind_table (unw_addr_space_t as, unw_word_t ip,
       pi->unwind_info_size = 8 * IA64_UNW_LENGTH (hdr);
 
       if (is_local)
-	pi->unwind_info = (void *) (uintptr_t) info_addr;
+        pi->unwind_info = (void *) (uintptr_t) info_addr;
       else
-	{
-	  /* Internalize unwind info.  Note: since we're doing this
-	     only for non-local address spaces, there is no
-	     signal-safety issue and it is OK to use malloc()/free().  */
-	  pi->unwind_info = malloc (8 * IA64_UNW_LENGTH (hdr));
-	  if (!pi->unwind_info)
-	    return -UNW_ENOMEM;
-
-	  wp = (unw_word_t *) pi->unwind_info;
-	  for (addr = info_addr; addr < info_end_addr; addr += 8, ++wp)
-	    {
-	      if ((ret = read_mem (as, addr, wp, arg)) < 0)
-		{
-		  free (pi->unwind_info);
-		  return ret;
-		}
-	    }
-	}
+        {
+          /* Internalize unwind info.  Note: since we're doing this
+             only for non-local address spaces, there is no
+             signal-safety issue and it is OK to use malloc()/free().  */
+          pi->unwind_info = malloc (8 * IA64_UNW_LENGTH (hdr));
+          if (!pi->unwind_info)
+            return -UNW_ENOMEM;
+
+          wp = (unw_word_t *) pi->unwind_info;
+          for (addr = info_addr; addr < info_end_addr; addr += 8, ++wp)
+            {
+              if ((ret = read_mem (as, addr, wp, arg)) < 0)
+                {
+                  free (pi->unwind_info);
+                  return ret;
+                }
+            }
+        }
     }
 
   if (IA64_UNW_FLAG_EHANDLER (hdr) || IA64_UNW_FLAG_UHANDLER (hdr))
     {
       /* read the personality routine address (address is gp-relative): */
       if ((ret = read_mem (as, info_end_addr, &handler_offset, arg)) < 0)
-	return ret;
+        return ret;
       Debug (4, "handler ptr @ offset=%lx, gp=%lx\n", handler_offset, di->gp);
       if ((read_mem (as, handler_offset + di->gp, &pi->handler, arg)) < 0)
-	return ret;
+        return ret;
     }
   pi->lsda = info_end_addr + 8;
   pi->gp = di->gp;
@@ -387,7 +387,7 @@ unw_search_ia64_unwind_table (unw_addr_space_t as, unw_word_t ip,
 #   include <unistd.h>
 #   include <sys/syscall.h>
 #   ifndef __NR_getunwind
-#     define __NR_getunwind	1215
+#     define __NR_getunwind     1215
 #   endif
 
 static unsigned long
@@ -413,7 +413,7 @@ get_kernel_table (unw_dyn_info_t *di)
   if (!ktab)
     {
       Dprintf (__FILE__".%s: failed to allocate %zu bytes",
-	       __FUNCTION__, size);
+               __FUNCTION__, size);
       return -UNW_ENOMEM;
     }
   getunwind (ktab, size);
@@ -432,15 +432,15 @@ get_kernel_table (unw_dyn_info_t *di)
   di->u.ti.table_data = (unw_word_t *) ktab;
 
   Debug (16, "found table `%s': [%lx-%lx) segbase=%lx len=%lu\n",
-	 (char *) di->u.ti.name_ptr, di->start_ip, di->end_ip,
-	 di->u.ti.segbase, di->u.ti.table_len);
+         (char *) di->u.ti.name_ptr, di->start_ip, di->end_ip,
+         di->u.ti.segbase, di->u.ti.table_len);
   return 0;
 }
 
 #  ifndef UNW_LOCAL_ONLY
 
 /* This is exported for the benefit of libunwind-ptrace.a.  */
-PROTECTED int
+int
 _Uia64_get_kernel_table (unw_dyn_info_t *di)
 {
   int ret;
@@ -478,11 +478,11 @@ callback (struct dl_phdr_info *info, size_t size, void *ptr)
 
   /* Make sure struct dl_phdr_info is at least as big as we need.  */
   if (size < offsetof (struct dl_phdr_info, dlpi_phnum)
-	     + sizeof (info->dlpi_phnum))
+             + sizeof (info->dlpi_phnum))
     return -1;
 
   Debug (16, "checking `%s' (load_base=%lx)\n",
-	 info->dlpi_name, info->dlpi_addr);
+         info->dlpi_name, info->dlpi_addr);
 
   phdr = info->dlpi_phdr;
   load_base = info->dlpi_addr;
@@ -495,52 +495,52 @@ callback (struct dl_phdr_info *info, size_t size, void *ptr)
   for (n = info->dlpi_phnum; --n >= 0; phdr++)
     {
       if (phdr->p_type == PT_LOAD)
-	{
-	  Elf64_Addr vaddr = phdr->p_vaddr + load_base;
-	  if (di->u.ti.segbase >= vaddr
-	      && di->u.ti.segbase < vaddr + phdr->p_memsz)
-	    p_text = phdr;
-	}
+        {
+          Elf64_Addr vaddr = phdr->p_vaddr + load_base;
+          if (di->u.ti.segbase >= vaddr
+              && di->u.ti.segbase < vaddr + phdr->p_memsz)
+            p_text = phdr;
+        }
       else if (phdr->p_type == PT_IA_64_UNWIND)
-	p_unwind = phdr;
+        p_unwind = phdr;
       else if (phdr->p_type == PT_DYNAMIC)
-	p_dynamic = phdr;
+        p_dynamic = phdr;
     }
   if (!p_text || !p_unwind)
     return 0;
 
   if (likely (p_unwind->p_vaddr >= p_text->p_vaddr
-	      && p_unwind->p_vaddr < p_text->p_vaddr + p_text->p_memsz))
+              && p_unwind->p_vaddr < p_text->p_vaddr + p_text->p_memsz))
     /* normal case: unwind table is inside text segment */
     segbase = p_text->p_vaddr + load_base;
   else
     {
       /* Special case: unwind table is in some other segment; this
-	 happens for the Linux kernel's gate DSO, for example.  */
+         happens for the Linux kernel's gate DSO, for example.  */
       phdr = info->dlpi_phdr;
       for (n = info->dlpi_phnum; --n >= 0; phdr++)
-	{
-	  if (phdr->p_type == PT_LOAD && p_unwind->p_vaddr >= phdr->p_vaddr
-	      && p_unwind->p_vaddr < phdr->p_vaddr + phdr->p_memsz)
-	    {
-	      segbase = phdr->p_vaddr + load_base;
-	      break;
-	    }
-	}
+        {
+          if (phdr->p_type == PT_LOAD && p_unwind->p_vaddr >= phdr->p_vaddr
+              && p_unwind->p_vaddr < phdr->p_vaddr + phdr->p_memsz)
+            {
+              segbase = phdr->p_vaddr + load_base;
+              break;
+            }
+        }
     }
 
   if (p_dynamic)
     {
       /* For dynamicly linked executables and shared libraries,
-	 DT_PLTGOT is the gp value for that object.  */
+         DT_PLTGOT is the gp value for that object.  */
       Elf64_Dyn *dyn = (Elf64_Dyn *)(p_dynamic->p_vaddr + load_base);
       for (; dyn->d_tag != DT_NULL; ++dyn)
-	if (dyn->d_tag == DT_PLTGOT)
-	  {
-	    /* On IA-64, _DYNAMIC is writable and GLIBC has relocated it.  */
-	    di->gp = dyn->d_un.d_ptr;
-	    break;
-	  }
+        if (dyn->d_tag == DT_PLTGOT)
+          {
+            /* On IA-64, _DYNAMIC is writable and GLIBC has relocated it.  */
+            di->gp = dyn->d_un.d_ptr;
+            break;
+          }
     }
   else
     /* Otherwise this is a static executable with no _DYNAMIC.
@@ -555,8 +555,8 @@ callback (struct dl_phdr_info *info, size_t size, void *ptr)
   di->u.ti.segbase = segbase;
 
   Debug (16, "found table `%s': segbase=%lx, len=%lu, gp=%lx, "
-	 "table_data=%p\n", (char *) di->u.ti.name_ptr, di->u.ti.segbase,
-	 di->u.ti.table_len, di->gp, di->u.ti.table_data);
+         "table_data=%p\n", (char *) di->u.ti.name_ptr, di->u.ti.segbase,
+         di->u.ti.table_len, di->gp, di->u.ti.table_data);
   return 1;
 }
 
@@ -611,7 +611,7 @@ check_callback (struct dl_phdr_info *info, size_t size, void *ptr)
 
   as->shared_object_removals = info->dlpi_subs;
   unw_flush_cache (as, 0, 0);
-  return -1;		/* indicate that there were removals */
+  return -1;            /* indicate that there were removals */
 #   else
   return 1;
 #   endif
@@ -645,14 +645,14 @@ validate_cache (unw_addr_space_t as)
 
 HIDDEN int
 tdep_find_proc_info (unw_addr_space_t as, unw_word_t ip,
-		     unw_proc_info_t *pi, int need_unwind_info, void *arg)
+                     unw_proc_info_t *pi, int need_unwind_info, void *arg)
 {
 # if defined(HAVE_DL_ITERATE_PHDR)
   unw_dyn_info_t di, *dip = &di;
   intrmask_t saved_mask;
   int ret;
 
-  di.u.ti.segbase = ip;	/* this is cheap... */
+  di.u.ti.segbase = ip; /* this is cheap... */
 
   SIGPROCMASK (SIG_SETMASK, &unwi_full_mask, &saved_mask);
   ret = dl_iterate_phdr (callback, &di);
@@ -661,16 +661,16 @@ tdep_find_proc_info (unw_addr_space_t as, unw_word_t ip,
   if (ret <= 0)
     {
       if (!kernel_table.u.ti.table_data)
-	{
-	  if ((ret = get_kernel_table (&kernel_table)) < 0)
-	    return ret;
-	}
+        {
+          if ((ret = get_kernel_table (&kernel_table)) < 0)
+            return ret;
+        }
       if (ip < kernel_table.start_ip || ip >= kernel_table.end_ip)
-	return -UNW_ENOINFO;
+        return -UNW_ENOINFO;
       dip = &kernel_table;
     }
 # elif defined(HAVE_DLMODINFO)
-# define UNWIND_TBL_32BIT	0x8000000000000000
+# define UNWIND_TBL_32BIT       0x8000000000000000
   struct load_module_desc lmd;
   unw_dyn_info_t di, *dip = &di;
   struct unwind_header
@@ -688,7 +688,7 @@ tdep_find_proc_info (unw_addr_space_t as, unw_word_t ip,
   di.start_ip = lmd.text_base;
   di.end_ip = lmd.text_base + lmd.text_size;
   di.gp = lmd.linkage_ptr;
-  di.u.ti.name_ptr = 0;	/* no obvious table-name available */
+  di.u.ti.name_ptr = 0; /* no obvious table-name available */
   di.u.ti.segbase = lmd.text_base;
 
   uhdr = (struct unwind_header *) lmd.unwind_base;
@@ -697,7 +697,7 @@ tdep_find_proc_info (unw_addr_space_t as, unw_word_t ip,
       && (uhdr->header_version & ~UNWIND_TBL_32BIT) != 2)
     {
       Debug (1, "encountered unknown unwind header version %ld\n",
- 	     (long) (uhdr->header_version & ~UNWIND_TBL_32BIT));
+             (long) (uhdr->header_version & ~UNWIND_TBL_32BIT));
       return -UNW_EBADVERSION;
     }
   if (uhdr->header_version & UNWIND_TBL_32BIT)
@@ -708,11 +708,11 @@ tdep_find_proc_info (unw_addr_space_t as, unw_word_t ip,
 
   di.u.ti.table_data = (unw_word_t *) (di.u.ti.segbase + uhdr->start_offset);
   di.u.ti.table_len = ((uhdr->end_offset - uhdr->start_offset)
-		       / sizeof (unw_word_t));
+                       / sizeof (unw_word_t));
 
   Debug (16, "found table `%s': segbase=%lx, len=%lu, gp=%lx, "
- 	 "table_data=%p\n", (char *) di.u.ti.name_ptr, di.u.ti.segbase,
- 	 di.u.ti.table_len, di.gp, di.u.ti.table_data);
+         "table_data=%p\n", (char *) di.u.ti.name_ptr, di.u.ti.segbase,
+         di.u.ti.table_len, di.gp, di.u.ti.table_data);
 # endif
 
   /* now search the table: */
diff --git a/src/ia64/Lapply_reg_state.c b/src/ia64/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/ia64/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/ia64/Lreg_states_iterate.c b/src/ia64/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/ia64/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/ia64/init.h b/src/ia64/init.h
index 1f3f956..6628a1d 100644
--- a/src/ia64/init.h
+++ b/src/ia64/init.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -35,17 +35,17 @@ common_init (struct cursor *c, unw_word_t sp, unw_word_t bsp)
     /* ensure cache doesn't have any stale contents: */
     ia64_validate_cache (c->as, c->as_arg);
 
-  c->cfm_loc =			IA64_REG_LOC (c, UNW_IA64_CFM);
-  c->loc[IA64_REG_BSP] =	IA64_NULL_LOC;
-  c->loc[IA64_REG_BSPSTORE] =	IA64_REG_LOC (c, UNW_IA64_AR_BSPSTORE);
-  c->loc[IA64_REG_PFS] =	IA64_REG_LOC (c, UNW_IA64_AR_PFS);
-  c->loc[IA64_REG_RNAT] =	IA64_REG_LOC (c, UNW_IA64_AR_RNAT);
-  c->loc[IA64_REG_IP] =		IA64_REG_LOC (c, UNW_IA64_IP);
+  c->cfm_loc =                  IA64_REG_LOC (c, UNW_IA64_CFM);
+  c->loc[IA64_REG_BSP] =        IA64_NULL_LOC;
+  c->loc[IA64_REG_BSPSTORE] =   IA64_REG_LOC (c, UNW_IA64_AR_BSPSTORE);
+  c->loc[IA64_REG_PFS] =        IA64_REG_LOC (c, UNW_IA64_AR_PFS);
+  c->loc[IA64_REG_RNAT] =       IA64_REG_LOC (c, UNW_IA64_AR_RNAT);
+  c->loc[IA64_REG_IP] =         IA64_REG_LOC (c, UNW_IA64_IP);
   c->loc[IA64_REG_PRI_UNAT_MEM] = IA64_NULL_LOC; /* no primary UNaT location */
-  c->loc[IA64_REG_UNAT] =	IA64_REG_LOC (c, UNW_IA64_AR_UNAT);
-  c->loc[IA64_REG_PR] =		IA64_REG_LOC (c, UNW_IA64_PR);
-  c->loc[IA64_REG_LC] =		IA64_REG_LOC (c, UNW_IA64_AR_LC);
-  c->loc[IA64_REG_FPSR] =	IA64_REG_LOC (c, UNW_IA64_AR_FPSR);
+  c->loc[IA64_REG_UNAT] =       IA64_REG_LOC (c, UNW_IA64_AR_UNAT);
+  c->loc[IA64_REG_PR] =         IA64_REG_LOC (c, UNW_IA64_PR);
+  c->loc[IA64_REG_LC] =         IA64_REG_LOC (c, UNW_IA64_AR_LC);
+  c->loc[IA64_REG_FPSR] =       IA64_REG_LOC (c, UNW_IA64_AR_FPSR);
 
   c->loc[IA64_REG_R4] = IA64_REG_LOC (c, UNW_IA64_GR + 4);
   c->loc[IA64_REG_R5] = IA64_REG_LOC (c, UNW_IA64_GR + 5);
@@ -115,8 +115,8 @@ common_init (struct cursor *c, unw_word_t sp, unw_word_t bsp)
   c->rbs_area[0].size = bspstore - rbs_base;
   c->rbs_area[0].rnat_loc = IA64_REG_LOC (c, UNW_IA64_AR_RNAT);
   Debug (10, "initial rbs-area: [0x%llx-0x%llx), rnat@%s\n",
-	 (long long) rbs_base, (long long) c->rbs_area[0].end,
-	 ia64_strloc (c->rbs_area[0].rnat_loc));
+         (long long) rbs_base, (long long) c->rbs_area[0].end,
+         ia64_strloc (c->rbs_area[0].rnat_loc));
 
   c->pi.flags = 0;
 
diff --git a/src/ia64/offsets.h b/src/ia64/offsets.h
index b169933..5ab7f8b 100644
--- a/src/ia64/offsets.h
+++ b/src/ia64/offsets.h
@@ -6,132 +6,132 @@
    number, siginfo pointer, and sigcontext pointer passed to the
    signal handler.  We use this to locate the sigcontext pointer.  */
 
-#define LINUX_SIGFRAME_ARG2_OFF	0x10
+#define LINUX_SIGFRAME_ARG2_OFF 0x10
 
-#define LINUX_SC_FLAGS_OFF	0x000
-#define LINUX_SC_NAT_OFF	0x008
-#define LINUX_SC_STACK_OFF	0x010
-#define LINUX_SC_IP_OFF		0x028
-#define LINUX_SC_CFM_OFF	0x030
-#define LINUX_SC_UM_OFF		0x038
-#define LINUX_SC_AR_RSC_OFF	0x040
-#define LINUX_SC_AR_BSP_OFF	0x048
-#define LINUX_SC_AR_RNAT_OFF	0x050
-#define LINUX_SC_AR_CCV		0x058
-#define LINUX_SC_AR_UNAT_OFF	0x060
-#define LINUX_SC_AR_FPSR_OFF	0x068
-#define LINUX_SC_AR_PFS_OFF	0x070
-#define LINUX_SC_AR_LC_OFF	0x078
-#define LINUX_SC_PR_OFF		0x080
-#define LINUX_SC_BR_OFF		0x088
-#define LINUX_SC_GR_OFF		0x0c8
-#define LINUX_SC_FR_OFF		0x1d0
-#define LINUX_SC_RBS_BASE_OFF	0x9d0
-#define LINUX_SC_LOADRS_OFF	0x9d8
-#define LINUX_SC_AR_CSD_OFF	0x9e0
-#define LINUX_SC_AR_SSD_OFF	0x9e8
-#define LINUX_SC_MASK		0xa50
+#define LINUX_SC_FLAGS_OFF      0x000
+#define LINUX_SC_NAT_OFF        0x008
+#define LINUX_SC_STACK_OFF      0x010
+#define LINUX_SC_IP_OFF         0x028
+#define LINUX_SC_CFM_OFF        0x030
+#define LINUX_SC_UM_OFF         0x038
+#define LINUX_SC_AR_RSC_OFF     0x040
+#define LINUX_SC_AR_BSP_OFF     0x048
+#define LINUX_SC_AR_RNAT_OFF    0x050
+#define LINUX_SC_AR_CCV         0x058
+#define LINUX_SC_AR_UNAT_OFF    0x060
+#define LINUX_SC_AR_FPSR_OFF    0x068
+#define LINUX_SC_AR_PFS_OFF     0x070
+#define LINUX_SC_AR_LC_OFF      0x078
+#define LINUX_SC_PR_OFF         0x080
+#define LINUX_SC_BR_OFF         0x088
+#define LINUX_SC_GR_OFF         0x0c8
+#define LINUX_SC_FR_OFF         0x1d0
+#define LINUX_SC_RBS_BASE_OFF   0x9d0
+#define LINUX_SC_LOADRS_OFF     0x9d8
+#define LINUX_SC_AR_CSD_OFF     0x9e0
+#define LINUX_SC_AR_SSD_OFF     0x9e8
+#define LINUX_SC_MASK           0xa50
 
 /* Layout of old Linux kernel interrupt frame (struct pt_regs).  */
 
-#define LINUX_OLD_PT_IPSR_OFF	0x000
-#define LINUX_OLD_PT_IIP_OFF	0x008
-#define LINUX_OLD_PT_IFS_OFF	0x010
-#define LINUX_OLD_PT_UNAT_OFF	0x018
-#define LINUX_OLD_PT_PFS_OFF	0x020
-#define LINUX_OLD_PT_RSC_OFF	0x028
-#define LINUX_OLD_PT_RNAT_OFF	0x030
+#define LINUX_OLD_PT_IPSR_OFF   0x000
+#define LINUX_OLD_PT_IIP_OFF    0x008
+#define LINUX_OLD_PT_IFS_OFF    0x010
+#define LINUX_OLD_PT_UNAT_OFF   0x018
+#define LINUX_OLD_PT_PFS_OFF    0x020
+#define LINUX_OLD_PT_RSC_OFF    0x028
+#define LINUX_OLD_PT_RNAT_OFF   0x030
 #define LINUX_OLD_PT_BSPSTORE_OFF 0x038
-#define LINUX_OLD_PT_PR_OFF	0x040
-#define LINUX_OLD_PT_B6_OFF	0x048
-#define LINUX_OLD_PT_LOADRS_OFF	0x050
-#define LINUX_OLD_PT_R1_OFF	0x058
-#define LINUX_OLD_PT_R2_OFF	0x060
-#define LINUX_OLD_PT_R3_OFF	0x068
-#define LINUX_OLD_PT_R12_OFF	0x070
-#define LINUX_OLD_PT_R13_OFF	0x078
-#define LINUX_OLD_PT_R14_OFF	0x080
-#define LINUX_OLD_PT_R15_OFF	0x088
-#define LINUX_OLD_PT_R8_OFF	0x090
-#define LINUX_OLD_PT_R9_OFF	0x098
-#define LINUX_OLD_PT_R10_OFF	0x0a0
-#define LINUX_OLD_PT_R11_OFF	0x0a8
-#define LINUX_OLD_PT_R16_OFF	0x0b0
-#define LINUX_OLD_PT_R17_OFF	0x0b8
-#define LINUX_OLD_PT_R18_OFF	0x0c0
-#define LINUX_OLD_PT_R19_OFF	0x0c8
-#define LINUX_OLD_PT_R20_OFF	0x0d0
-#define LINUX_OLD_PT_R21_OFF	0x0d8
-#define LINUX_OLD_PT_R22_OFF	0x0e0
-#define LINUX_OLD_PT_R23_OFF	0x0e8
-#define LINUX_OLD_PT_R24_OFF	0x0f0
-#define LINUX_OLD_PT_R25_OFF	0x0f8
-#define LINUX_OLD_PT_R26_OFF	0x100
-#define LINUX_OLD_PT_R27_OFF	0x108
-#define LINUX_OLD_PT_R28_OFF	0x110
-#define LINUX_OLD_PT_R29_OFF	0x118
-#define LINUX_OLD_PT_R30_OFF	0x120
-#define LINUX_OLD_PT_R31_OFF	0x128
-#define LINUX_OLD_PT_CCV_OFF	0x130
-#define LINUX_OLD_PT_FPSR_OFF	0x138
-#define LINUX_OLD_PT_B0_OFF	0x140
-#define LINUX_OLD_PT_B7_OFF	0x148
-#define LINUX_OLD_PT_F6_OFF	0x150
-#define LINUX_OLD_PT_F7_OFF	0x160
-#define LINUX_OLD_PT_F8_OFF	0x170
-#define LINUX_OLD_PT_F9_OFF	0x180
+#define LINUX_OLD_PT_PR_OFF     0x040
+#define LINUX_OLD_PT_B6_OFF     0x048
+#define LINUX_OLD_PT_LOADRS_OFF 0x050
+#define LINUX_OLD_PT_R1_OFF     0x058
+#define LINUX_OLD_PT_R2_OFF     0x060
+#define LINUX_OLD_PT_R3_OFF     0x068
+#define LINUX_OLD_PT_R12_OFF    0x070
+#define LINUX_OLD_PT_R13_OFF    0x078
+#define LINUX_OLD_PT_R14_OFF    0x080
+#define LINUX_OLD_PT_R15_OFF    0x088
+#define LINUX_OLD_PT_R8_OFF     0x090
+#define LINUX_OLD_PT_R9_OFF     0x098
+#define LINUX_OLD_PT_R10_OFF    0x0a0
+#define LINUX_OLD_PT_R11_OFF    0x0a8
+#define LINUX_OLD_PT_R16_OFF    0x0b0
+#define LINUX_OLD_PT_R17_OFF    0x0b8
+#define LINUX_OLD_PT_R18_OFF    0x0c0
+#define LINUX_OLD_PT_R19_OFF    0x0c8
+#define LINUX_OLD_PT_R20_OFF    0x0d0
+#define LINUX_OLD_PT_R21_OFF    0x0d8
+#define LINUX_OLD_PT_R22_OFF    0x0e0
+#define LINUX_OLD_PT_R23_OFF    0x0e8
+#define LINUX_OLD_PT_R24_OFF    0x0f0
+#define LINUX_OLD_PT_R25_OFF    0x0f8
+#define LINUX_OLD_PT_R26_OFF    0x100
+#define LINUX_OLD_PT_R27_OFF    0x108
+#define LINUX_OLD_PT_R28_OFF    0x110
+#define LINUX_OLD_PT_R29_OFF    0x118
+#define LINUX_OLD_PT_R30_OFF    0x120
+#define LINUX_OLD_PT_R31_OFF    0x128
+#define LINUX_OLD_PT_CCV_OFF    0x130
+#define LINUX_OLD_PT_FPSR_OFF   0x138
+#define LINUX_OLD_PT_B0_OFF     0x140
+#define LINUX_OLD_PT_B7_OFF     0x148
+#define LINUX_OLD_PT_F6_OFF     0x150
+#define LINUX_OLD_PT_F7_OFF     0x160
+#define LINUX_OLD_PT_F8_OFF     0x170
+#define LINUX_OLD_PT_F9_OFF     0x180
 
 /* Layout of new Linux kernel interrupt frame (struct pt_regs).  */
 
-#define LINUX_PT_B6_OFF		0
-#define LINUX_PT_B7_OFF		8
-#define LINUX_PT_CSD_OFF	16
-#define LINUX_PT_SSD_OFF	24
-#define LINUX_PT_R8_OFF		32
-#define LINUX_PT_R9_OFF		40
-#define LINUX_PT_R10_OFF	48
-#define LINUX_PT_R11_OFF	56
-#define LINUX_PT_IPSR_OFF	64
-#define LINUX_PT_IIP_OFF	72
-#define LINUX_PT_IFS_OFF	80
-#define LINUX_PT_UNAT_OFF	88
-#define LINUX_PT_PFS_OFF	96
-#define LINUX_PT_RSC_OFF	104
-#define LINUX_PT_RNAT_OFF	112
-#define LINUX_PT_BSPSTORE_OFF	120
-#define LINUX_PT_PR_OFF		128
-#define LINUX_PT_B0_OFF		136
-#define LINUX_PT_LOADRS_OFF	144
-#define LINUX_PT_R1_OFF		152
-#define LINUX_PT_R12_OFF	160
-#define LINUX_PT_R13_OFF	168
-#define LINUX_PT_FPSR_OFF	176
-#define LINUX_PT_R15_OFF	184
-#define LINUX_PT_R14_OFF	192
-#define LINUX_PT_R2_OFF		200
-#define LINUX_PT_R3_OFF		208
-#define LINUX_PT_R16_OFF	216
-#define LINUX_PT_R17_OFF	224
-#define LINUX_PT_R18_OFF	232
-#define LINUX_PT_R19_OFF	240
-#define LINUX_PT_R20_OFF	248
-#define LINUX_PT_R21_OFF	256
-#define LINUX_PT_R22_OFF	264
-#define LINUX_PT_R23_OFF	272
-#define LINUX_PT_R24_OFF	280
-#define LINUX_PT_R25_OFF	288
-#define LINUX_PT_R26_OFF	296
-#define LINUX_PT_R27_OFF	304
-#define LINUX_PT_R28_OFF	312
-#define LINUX_PT_R29_OFF	320
-#define LINUX_PT_R30_OFF	328
-#define LINUX_PT_R31_OFF	336
-#define LINUX_PT_CCV_OFF	344
-#define LINUX_PT_F6_OFF		352
-#define LINUX_PT_F7_OFF		368
-#define LINUX_PT_F8_OFF		384
-#define LINUX_PT_F9_OFF		400
-#define LINUX_PT_F10_OFF	416
-#define LINUX_PT_F11_OFF	432
+#define LINUX_PT_B6_OFF         0
+#define LINUX_PT_B7_OFF         8
+#define LINUX_PT_CSD_OFF        16
+#define LINUX_PT_SSD_OFF        24
+#define LINUX_PT_R8_OFF         32
+#define LINUX_PT_R9_OFF         40
+#define LINUX_PT_R10_OFF        48
+#define LINUX_PT_R11_OFF        56
+#define LINUX_PT_IPSR_OFF       64
+#define LINUX_PT_IIP_OFF        72
+#define LINUX_PT_IFS_OFF        80
+#define LINUX_PT_UNAT_OFF       88
+#define LINUX_PT_PFS_OFF        96
+#define LINUX_PT_RSC_OFF        104
+#define LINUX_PT_RNAT_OFF       112
+#define LINUX_PT_BSPSTORE_OFF   120
+#define LINUX_PT_PR_OFF         128
+#define LINUX_PT_B0_OFF         136
+#define LINUX_PT_LOADRS_OFF     144
+#define LINUX_PT_R1_OFF         152
+#define LINUX_PT_R12_OFF        160
+#define LINUX_PT_R13_OFF        168
+#define LINUX_PT_FPSR_OFF       176
+#define LINUX_PT_R15_OFF        184
+#define LINUX_PT_R14_OFF        192
+#define LINUX_PT_R2_OFF         200
+#define LINUX_PT_R3_OFF         208
+#define LINUX_PT_R16_OFF        216
+#define LINUX_PT_R17_OFF        224
+#define LINUX_PT_R18_OFF        232
+#define LINUX_PT_R19_OFF        240
+#define LINUX_PT_R20_OFF        248
+#define LINUX_PT_R21_OFF        256
+#define LINUX_PT_R22_OFF        264
+#define LINUX_PT_R23_OFF        272
+#define LINUX_PT_R24_OFF        280
+#define LINUX_PT_R25_OFF        288
+#define LINUX_PT_R26_OFF        296
+#define LINUX_PT_R27_OFF        304
+#define LINUX_PT_R28_OFF        312
+#define LINUX_PT_R29_OFF        320
+#define LINUX_PT_R30_OFF        328
+#define LINUX_PT_R31_OFF        336
+#define LINUX_PT_CCV_OFF        344
+#define LINUX_PT_F6_OFF         352
+#define LINUX_PT_F7_OFF         368
+#define LINUX_PT_F8_OFF         384
+#define LINUX_PT_F9_OFF         400
+#define LINUX_PT_F10_OFF        416
+#define LINUX_PT_F11_OFF        432
 
-#define LINUX_PT_P_NONSYS	5	/* must match pNonSys in entry.h */
+#define LINUX_PT_P_NONSYS       5       /* must match pNonSys in entry.h */
diff --git a/src/ia64/regname.c b/src/ia64/regname.c
index 4936a3d..3636df8 100644
--- a/src/ia64/regname.c
+++ b/src/ia64/regname.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -42,144 +42,144 @@ purpose.  */
 /* Maintain the register names as a single string to keep the number
    of dynamic relocations in the shared object to a minimum.  */
 
-#define regname_len	9
-#define regname_str							\
-  "r0\0\0\0\0\0\0\0r1\0\0\0\0\0\0\0r2\0\0\0\0\0\0\0r3\0\0\0\0\0\0\0"	\
-  "r4\0\0\0\0\0\0\0r5\0\0\0\0\0\0\0r6\0\0\0\0\0\0\0r7\0\0\0\0\0\0\0"	\
-  "r8\0\0\0\0\0\0\0r9\0\0\0\0\0\0\0r10\0\0\0\0\0\0r11\0\0\0\0\0\0"	\
-  "r12\0\0\0\0\0\0r13\0\0\0\0\0\0r14\0\0\0\0\0\0r15\0\0\0\0\0\0"	\
-  "r16\0\0\0\0\0\0r17\0\0\0\0\0\0r18\0\0\0\0\0\0r19\0\0\0\0\0\0"	\
-  "r20\0\0\0\0\0\0r21\0\0\0\0\0\0r22\0\0\0\0\0\0r23\0\0\0\0\0\0"	\
-  "r24\0\0\0\0\0\0r25\0\0\0\0\0\0r26\0\0\0\0\0\0r27\0\0\0\0\0\0"	\
-  "r28\0\0\0\0\0\0r29\0\0\0\0\0\0r30\0\0\0\0\0\0r31\0\0\0\0\0\0"	\
-  "r32\0\0\0\0\0\0r33\0\0\0\0\0\0r34\0\0\0\0\0\0r35\0\0\0\0\0\0"	\
-  "r36\0\0\0\0\0\0r37\0\0\0\0\0\0r38\0\0\0\0\0\0r39\0\0\0\0\0\0"	\
-  "r40\0\0\0\0\0\0r41\0\0\0\0\0\0r42\0\0\0\0\0\0r43\0\0\0\0\0\0"	\
-  "r44\0\0\0\0\0\0r45\0\0\0\0\0\0r46\0\0\0\0\0\0r47\0\0\0\0\0\0"	\
-  "r48\0\0\0\0\0\0r49\0\0\0\0\0\0r50\0\0\0\0\0\0r51\0\0\0\0\0\0"	\
-  "r52\0\0\0\0\0\0r53\0\0\0\0\0\0r54\0\0\0\0\0\0r55\0\0\0\0\0\0"	\
-  "r56\0\0\0\0\0\0r57\0\0\0\0\0\0r58\0\0\0\0\0\0r59\0\0\0\0\0\0"	\
-  "r60\0\0\0\0\0\0r61\0\0\0\0\0\0r62\0\0\0\0\0\0r63\0\0\0\0\0\0"	\
-  "r64\0\0\0\0\0\0r65\0\0\0\0\0\0r66\0\0\0\0\0\0r67\0\0\0\0\0\0"	\
-  "r68\0\0\0\0\0\0r69\0\0\0\0\0\0r70\0\0\0\0\0\0r71\0\0\0\0\0\0"	\
-  "r72\0\0\0\0\0\0r73\0\0\0\0\0\0r74\0\0\0\0\0\0r75\0\0\0\0\0\0"	\
-  "r76\0\0\0\0\0\0r77\0\0\0\0\0\0r78\0\0\0\0\0\0r79\0\0\0\0\0\0"	\
-  "r80\0\0\0\0\0\0r81\0\0\0\0\0\0r82\0\0\0\0\0\0r83\0\0\0\0\0\0"	\
-  "r84\0\0\0\0\0\0r85\0\0\0\0\0\0r86\0\0\0\0\0\0r87\0\0\0\0\0\0"	\
-  "r88\0\0\0\0\0\0r89\0\0\0\0\0\0r90\0\0\0\0\0\0r91\0\0\0\0\0\0"	\
-  "r92\0\0\0\0\0\0r93\0\0\0\0\0\0r94\0\0\0\0\0\0r95\0\0\0\0\0\0"	\
-  "r96\0\0\0\0\0\0r97\0\0\0\0\0\0r98\0\0\0\0\0\0r99\0\0\0\0\0\0"	\
-  "r100\0\0\0\0\0r101\0\0\0\0\0r102\0\0\0\0\0r103\0\0\0\0\0"		\
-  "r104\0\0\0\0\0r105\0\0\0\0\0r106\0\0\0\0\0r107\0\0\0\0\0"		\
-  "r108\0\0\0\0\0r109\0\0\0\0\0r110\0\0\0\0\0r111\0\0\0\0\0"		\
-  "r112\0\0\0\0\0r113\0\0\0\0\0r114\0\0\0\0\0r115\0\0\0\0\0"		\
-  "r116\0\0\0\0\0r117\0\0\0\0\0r118\0\0\0\0\0r119\0\0\0\0\0"		\
-  "r120\0\0\0\0\0r121\0\0\0\0\0r122\0\0\0\0\0r123\0\0\0\0\0"		\
-  "r124\0\0\0\0\0r125\0\0\0\0\0r126\0\0\0\0\0r127\0\0\0\0\0"		\
-  "nat0\0\0\0\0\0nat1\0\0\0\0\0nat2\0\0\0\0\0nat3\0\0\0\0\0"		\
-  "nat4\0\0\0\0\0nat5\0\0\0\0\0nat6\0\0\0\0\0nat7\0\0\0\0\0"		\
-  "nat8\0\0\0\0\0nat9\0\0\0\0\0nat10\0\0\0\0nat11\0\0\0\0"		\
-  "nat12\0\0\0\0nat13\0\0\0\0nat14\0\0\0\0nat15\0\0\0\0"		\
-  "nat16\0\0\0\0nat17\0\0\0\0nat18\0\0\0\0nat19\0\0\0\0"		\
-  "nat20\0\0\0\0nat21\0\0\0\0nat22\0\0\0\0nat23\0\0\0\0"		\
-  "nat24\0\0\0\0nat25\0\0\0\0nat26\0\0\0\0nat27\0\0\0\0"		\
-  "nat28\0\0\0\0nat29\0\0\0\0nat30\0\0\0\0nat31\0\0\0\0"		\
-  "nat32\0\0\0\0nat33\0\0\0\0nat34\0\0\0\0nat35\0\0\0\0"		\
-  "nat36\0\0\0\0nat37\0\0\0\0nat38\0\0\0\0nat39\0\0\0\0"		\
-  "nat40\0\0\0\0nat41\0\0\0\0nat42\0\0\0\0nat43\0\0\0\0"		\
-  "nat44\0\0\0\0nat45\0\0\0\0nat46\0\0\0\0nat47\0\0\0\0"		\
-  "nat48\0\0\0\0nat49\0\0\0\0nat50\0\0\0\0nat51\0\0\0\0"		\
-  "nat52\0\0\0\0nat53\0\0\0\0nat54\0\0\0\0nat55\0\0\0\0"		\
-  "nat56\0\0\0\0nat57\0\0\0\0nat58\0\0\0\0nat59\0\0\0\0"		\
-  "nat60\0\0\0\0nat61\0\0\0\0nat62\0\0\0\0nat63\0\0\0\0"		\
-  "nat64\0\0\0\0nat65\0\0\0\0nat66\0\0\0\0nat67\0\0\0\0"		\
-  "nat68\0\0\0\0nat69\0\0\0\0nat70\0\0\0\0nat71\0\0\0\0"		\
-  "nat72\0\0\0\0nat73\0\0\0\0nat74\0\0\0\0nat75\0\0\0\0"		\
-  "nat76\0\0\0\0nat77\0\0\0\0nat78\0\0\0\0nat79\0\0\0\0"		\
-  "nat80\0\0\0\0nat81\0\0\0\0nat82\0\0\0\0nat83\0\0\0\0"		\
-  "nat84\0\0\0\0nat85\0\0\0\0nat86\0\0\0\0nat87\0\0\0\0"		\
-  "nat88\0\0\0\0nat89\0\0\0\0nat90\0\0\0\0nat91\0\0\0\0"		\
-  "nat92\0\0\0\0nat93\0\0\0\0nat94\0\0\0\0nat95\0\0\0\0"		\
-  "nat96\0\0\0\0nat97\0\0\0\0nat98\0\0\0\0nat99\0\0\0\0"		\
-  "nat100\0\0\0nat101\0\0\0nat102\0\0\0nat103\0\0\0"			\
-  "nat104\0\0\0nat105\0\0\0nat106\0\0\0nat107\0\0\0"			\
-  "nat108\0\0\0nat109\0\0\0nat110\0\0\0nat111\0\0\0"			\
-  "nat112\0\0\0nat113\0\0\0nat114\0\0\0nat115\0\0\0"			\
-  "nat116\0\0\0nat117\0\0\0nat118\0\0\0nat119\0\0\0"			\
-  "nat120\0\0\0nat121\0\0\0nat122\0\0\0nat123\0\0\0"			\
-  "nat124\0\0\0nat125\0\0\0nat126\0\0\0nat127\0\0\0"			\
-  "f0\0\0\0\0\0\0\0f1\0\0\0\0\0\0\0f2\0\0\0\0\0\0\0f3\0\0\0\0\0\0\0"	\
-  "f4\0\0\0\0\0\0\0f5\0\0\0\0\0\0\0f6\0\0\0\0\0\0\0f7\0\0\0\0\0\0\0"	\
-  "f8\0\0\0\0\0\0\0f9\0\0\0\0\0\0\0f10\0\0\0\0\0\0f11\0\0\0\0\0\0"	\
-  "f12\0\0\0\0\0\0f13\0\0\0\0\0\0f14\0\0\0\0\0\0f15\0\0\0\0\0\0"	\
-  "f16\0\0\0\0\0\0f17\0\0\0\0\0\0f18\0\0\0\0\0\0f19\0\0\0\0\0\0"	\
-  "f20\0\0\0\0\0\0f21\0\0\0\0\0\0f22\0\0\0\0\0\0f23\0\0\0\0\0\0"	\
-  "f24\0\0\0\0\0\0f25\0\0\0\0\0\0f26\0\0\0\0\0\0f27\0\0\0\0\0\0"	\
-  "f28\0\0\0\0\0\0f29\0\0\0\0\0\0f30\0\0\0\0\0\0f31\0\0\0\0\0\0"	\
-  "f32\0\0\0\0\0\0f33\0\0\0\0\0\0f34\0\0\0\0\0\0f35\0\0\0\0\0\0"	\
-  "f36\0\0\0\0\0\0f37\0\0\0\0\0\0f38\0\0\0\0\0\0f39\0\0\0\0\0\0"	\
-  "f40\0\0\0\0\0\0f41\0\0\0\0\0\0f42\0\0\0\0\0\0f43\0\0\0\0\0\0"	\
-  "f44\0\0\0\0\0\0f45\0\0\0\0\0\0f46\0\0\0\0\0\0f47\0\0\0\0\0\0"	\
-  "f48\0\0\0\0\0\0f49\0\0\0\0\0\0f50\0\0\0\0\0\0f51\0\0\0\0\0\0"	\
-  "f52\0\0\0\0\0\0f53\0\0\0\0\0\0f54\0\0\0\0\0\0f55\0\0\0\0\0\0"	\
-  "f56\0\0\0\0\0\0f57\0\0\0\0\0\0f58\0\0\0\0\0\0f59\0\0\0\0\0\0"	\
-  "f60\0\0\0\0\0\0f61\0\0\0\0\0\0f62\0\0\0\0\0\0f63\0\0\0\0\0\0"	\
-  "f64\0\0\0\0\0\0f65\0\0\0\0\0\0f66\0\0\0\0\0\0f67\0\0\0\0\0\0"	\
-  "f68\0\0\0\0\0\0f69\0\0\0\0\0\0f70\0\0\0\0\0\0f71\0\0\0\0\0\0"	\
-  "f72\0\0\0\0\0\0f73\0\0\0\0\0\0f74\0\0\0\0\0\0f75\0\0\0\0\0\0"	\
-  "f76\0\0\0\0\0\0f77\0\0\0\0\0\0f78\0\0\0\0\0\0f79\0\0\0\0\0\0"	\
-  "f80\0\0\0\0\0\0f81\0\0\0\0\0\0f82\0\0\0\0\0\0f83\0\0\0\0\0\0"	\
-  "f84\0\0\0\0\0\0f85\0\0\0\0\0\0f86\0\0\0\0\0\0f87\0\0\0\0\0\0"	\
-  "f88\0\0\0\0\0\0f89\0\0\0\0\0\0f90\0\0\0\0\0\0f91\0\0\0\0\0\0"	\
-  "f92\0\0\0\0\0\0f93\0\0\0\0\0\0f94\0\0\0\0\0\0f95\0\0\0\0\0\0"	\
-  "f96\0\0\0\0\0\0f97\0\0\0\0\0\0f98\0\0\0\0\0\0f99\0\0\0\0\0\0"	\
-  "f100\0\0\0\0\0f101\0\0\0\0\0f102\0\0\0\0\0f103\0\0\0\0\0"		\
-  "f104\0\0\0\0\0f105\0\0\0\0\0f106\0\0\0\0\0f107\0\0\0\0\0"		\
-  "f108\0\0\0\0\0f109\0\0\0\0\0f110\0\0\0\0\0f111\0\0\0\0\0"		\
-  "f112\0\0\0\0\0f113\0\0\0\0\0f114\0\0\0\0\0f115\0\0\0\0\0"		\
-  "f116\0\0\0\0\0f117\0\0\0\0\0f118\0\0\0\0\0f119\0\0\0\0\0"		\
-  "f120\0\0\0\0\0f121\0\0\0\0\0f122\0\0\0\0\0f123\0\0\0\0\0"		\
-  "f124\0\0\0\0\0f125\0\0\0\0\0f126\0\0\0\0\0f127\0\0\0\0\0"		\
-  "ar0\0\0\0\0\0\0ar1\0\0\0\0\0\0ar2\0\0\0\0\0\0ar3\0\0\0\0\0\0"	\
-  "ar4\0\0\0\0\0\0ar5\0\0\0\0\0\0ar6\0\0\0\0\0\0ar7\0\0\0\0\0\0"	\
-  "ar8\0\0\0\0\0\0ar9\0\0\0\0\0\0ar10\0\0\0\0\0ar11\0\0\0\0\0"		\
-  "ar12\0\0\0\0\0ar13\0\0\0\0\0ar14\0\0\0\0\0ar15\0\0\0\0\0"		\
-  "rsc\0\0\0\0\0\0bsp\0\0\0\0\0\0bspstore\0rnat\0\0\0\0\0"		\
-  "ar20\0\0\0\0\0ar21\0\0\0\0\0ar22\0\0\0\0\0ar23\0\0\0\0\0"		\
-  "ar24\0\0\0\0\0ar25\0\0\0\0\0ar26\0\0\0\0\0ar27\0\0\0\0\0"		\
-  "ar28\0\0\0\0\0ar29\0\0\0\0\0ar30\0\0\0\0\0ar31\0\0\0\0\0"		\
-  "ccv\0\0\0\0\0\0ar33\0\0\0\0\0ar34\0\0\0\0\0ar35\0\0\0\0\0"		\
-  "unat\0\0\0\0\0ar37\0\0\0\0\0ar38\0\0\0\0\0ar39\0\0\0\0\0"		\
-  "fpsr\0\0\0\0\0ar41\0\0\0\0\0ar42\0\0\0\0\0ar43\0\0\0\0\0"		\
-  "ar44\0\0\0\0\0ar45\0\0\0\0\0ar46\0\0\0\0\0ar47\0\0\0\0\0"		\
-  "ar48\0\0\0\0\0ar49\0\0\0\0\0ar50\0\0\0\0\0ar51\0\0\0\0\0"		\
-  "ar52\0\0\0\0\0ar53\0\0\0\0\0ar54\0\0\0\0\0ar55\0\0\0\0\0"		\
-  "ar56\0\0\0\0\0ar57\0\0\0\0\0ar58\0\0\0\0\0ar59\0\0\0\0\0"		\
-  "ar60\0\0\0\0\0ar61\0\0\0\0\0ar62\0\0\0\0\0ar63\0\0\0\0\0"		\
-  "pfs\0\0\0\0\0\0lc\0\0\0\0\0\0\0ec\0\0\0\0\0\0\0ar67\0\0\0\0\0"	\
-  "ar68\0\0\0\0\0ar69\0\0\0\0\0ar70\0\0\0\0\0ar71\0\0\0\0\0"		\
-  "ar72\0\0\0\0\0ar73\0\0\0\0\0ar74\0\0\0\0\0ar75\0\0\0\0\0"		\
-  "ar76\0\0\0\0\0ar77\0\0\0\0\0ar78\0\0\0\0\0ar79\0\0\0\0\0"		\
-  "ar80\0\0\0\0\0ar81\0\0\0\0\0ar82\0\0\0\0\0ar83\0\0\0\0\0"		\
-  "ar84\0\0\0\0\0ar85\0\0\0\0\0ar86\0\0\0\0\0ar87\0\0\0\0\0"		\
-  "ar88\0\0\0\0\0ar89\0\0\0\0\0ar90\0\0\0\0\0ar91\0\0\0\0\0"		\
-  "ar92\0\0\0\0\0ar93\0\0\0\0\0ar94\0\0\0\0\0ar95\0\0\0\0\0"		\
-  "ar96\0\0\0\0\0ar97\0\0\0\0\0ar98\0\0\0\0\0ar99\0\0\0\0\0"		\
-  "ar100\0\0\0\0ar101\0\0\0\0ar102\0\0\0\0ar103\0\0\0\0"		\
-  "ar104\0\0\0\0ar105\0\0\0\0ar106\0\0\0\0ar107\0\0\0\0"		\
-  "ar108\0\0\0\0ar109\0\0\0\0ar110\0\0\0\0ar111\0\0\0\0"		\
-  "ar112\0\0\0\0ar113\0\0\0\0ar114\0\0\0\0ar115\0\0\0\0"		\
-  "ar116\0\0\0\0ar117\0\0\0\0ar118\0\0\0\0ar119\0\0\0\0"		\
-  "ar120\0\0\0\0ar121\0\0\0\0ar122\0\0\0\0ar123\0\0\0\0"		\
-  "ar124\0\0\0\0ar125\0\0\0\0ar126\0\0\0\0ar127\0\0\0\0"		\
-  "rp\0\0\0\0\0\0\0b1\0\0\0\0\0\0\0b2\0\0\0\0\0\0\0b3\0\0\0\0\0\0\0"	\
-  "b4\0\0\0\0\0\0\0b5\0\0\0\0\0\0\0b6\0\0\0\0\0\0\0b7\0\0\0\0\0\0\0"	\
-  "pr\0\0\0\0\0\0\0cfm\0\0\0\0\0\0bsp\0\0\0\0\0\0ip\0\0\0\0\0\0\0"	\
+#define regname_len     9
+#define regname_str                                                     \
+  "r0\0\0\0\0\0\0\0r1\0\0\0\0\0\0\0r2\0\0\0\0\0\0\0r3\0\0\0\0\0\0\0"    \
+  "r4\0\0\0\0\0\0\0r5\0\0\0\0\0\0\0r6\0\0\0\0\0\0\0r7\0\0\0\0\0\0\0"    \
+  "r8\0\0\0\0\0\0\0r9\0\0\0\0\0\0\0r10\0\0\0\0\0\0r11\0\0\0\0\0\0"      \
+  "r12\0\0\0\0\0\0r13\0\0\0\0\0\0r14\0\0\0\0\0\0r15\0\0\0\0\0\0"        \
+  "r16\0\0\0\0\0\0r17\0\0\0\0\0\0r18\0\0\0\0\0\0r19\0\0\0\0\0\0"        \
+  "r20\0\0\0\0\0\0r21\0\0\0\0\0\0r22\0\0\0\0\0\0r23\0\0\0\0\0\0"        \
+  "r24\0\0\0\0\0\0r25\0\0\0\0\0\0r26\0\0\0\0\0\0r27\0\0\0\0\0\0"        \
+  "r28\0\0\0\0\0\0r29\0\0\0\0\0\0r30\0\0\0\0\0\0r31\0\0\0\0\0\0"        \
+  "r32\0\0\0\0\0\0r33\0\0\0\0\0\0r34\0\0\0\0\0\0r35\0\0\0\0\0\0"        \
+  "r36\0\0\0\0\0\0r37\0\0\0\0\0\0r38\0\0\0\0\0\0r39\0\0\0\0\0\0"        \
+  "r40\0\0\0\0\0\0r41\0\0\0\0\0\0r42\0\0\0\0\0\0r43\0\0\0\0\0\0"        \
+  "r44\0\0\0\0\0\0r45\0\0\0\0\0\0r46\0\0\0\0\0\0r47\0\0\0\0\0\0"        \
+  "r48\0\0\0\0\0\0r49\0\0\0\0\0\0r50\0\0\0\0\0\0r51\0\0\0\0\0\0"        \
+  "r52\0\0\0\0\0\0r53\0\0\0\0\0\0r54\0\0\0\0\0\0r55\0\0\0\0\0\0"        \
+  "r56\0\0\0\0\0\0r57\0\0\0\0\0\0r58\0\0\0\0\0\0r59\0\0\0\0\0\0"        \
+  "r60\0\0\0\0\0\0r61\0\0\0\0\0\0r62\0\0\0\0\0\0r63\0\0\0\0\0\0"        \
+  "r64\0\0\0\0\0\0r65\0\0\0\0\0\0r66\0\0\0\0\0\0r67\0\0\0\0\0\0"        \
+  "r68\0\0\0\0\0\0r69\0\0\0\0\0\0r70\0\0\0\0\0\0r71\0\0\0\0\0\0"        \
+  "r72\0\0\0\0\0\0r73\0\0\0\0\0\0r74\0\0\0\0\0\0r75\0\0\0\0\0\0"        \
+  "r76\0\0\0\0\0\0r77\0\0\0\0\0\0r78\0\0\0\0\0\0r79\0\0\0\0\0\0"        \
+  "r80\0\0\0\0\0\0r81\0\0\0\0\0\0r82\0\0\0\0\0\0r83\0\0\0\0\0\0"        \
+  "r84\0\0\0\0\0\0r85\0\0\0\0\0\0r86\0\0\0\0\0\0r87\0\0\0\0\0\0"        \
+  "r88\0\0\0\0\0\0r89\0\0\0\0\0\0r90\0\0\0\0\0\0r91\0\0\0\0\0\0"        \
+  "r92\0\0\0\0\0\0r93\0\0\0\0\0\0r94\0\0\0\0\0\0r95\0\0\0\0\0\0"        \
+  "r96\0\0\0\0\0\0r97\0\0\0\0\0\0r98\0\0\0\0\0\0r99\0\0\0\0\0\0"        \
+  "r100\0\0\0\0\0r101\0\0\0\0\0r102\0\0\0\0\0r103\0\0\0\0\0"            \
+  "r104\0\0\0\0\0r105\0\0\0\0\0r106\0\0\0\0\0r107\0\0\0\0\0"            \
+  "r108\0\0\0\0\0r109\0\0\0\0\0r110\0\0\0\0\0r111\0\0\0\0\0"            \
+  "r112\0\0\0\0\0r113\0\0\0\0\0r114\0\0\0\0\0r115\0\0\0\0\0"            \
+  "r116\0\0\0\0\0r117\0\0\0\0\0r118\0\0\0\0\0r119\0\0\0\0\0"            \
+  "r120\0\0\0\0\0r121\0\0\0\0\0r122\0\0\0\0\0r123\0\0\0\0\0"            \
+  "r124\0\0\0\0\0r125\0\0\0\0\0r126\0\0\0\0\0r127\0\0\0\0\0"            \
+  "nat0\0\0\0\0\0nat1\0\0\0\0\0nat2\0\0\0\0\0nat3\0\0\0\0\0"            \
+  "nat4\0\0\0\0\0nat5\0\0\0\0\0nat6\0\0\0\0\0nat7\0\0\0\0\0"            \
+  "nat8\0\0\0\0\0nat9\0\0\0\0\0nat10\0\0\0\0nat11\0\0\0\0"              \
+  "nat12\0\0\0\0nat13\0\0\0\0nat14\0\0\0\0nat15\0\0\0\0"                \
+  "nat16\0\0\0\0nat17\0\0\0\0nat18\0\0\0\0nat19\0\0\0\0"                \
+  "nat20\0\0\0\0nat21\0\0\0\0nat22\0\0\0\0nat23\0\0\0\0"                \
+  "nat24\0\0\0\0nat25\0\0\0\0nat26\0\0\0\0nat27\0\0\0\0"                \
+  "nat28\0\0\0\0nat29\0\0\0\0nat30\0\0\0\0nat31\0\0\0\0"                \
+  "nat32\0\0\0\0nat33\0\0\0\0nat34\0\0\0\0nat35\0\0\0\0"                \
+  "nat36\0\0\0\0nat37\0\0\0\0nat38\0\0\0\0nat39\0\0\0\0"                \
+  "nat40\0\0\0\0nat41\0\0\0\0nat42\0\0\0\0nat43\0\0\0\0"                \
+  "nat44\0\0\0\0nat45\0\0\0\0nat46\0\0\0\0nat47\0\0\0\0"                \
+  "nat48\0\0\0\0nat49\0\0\0\0nat50\0\0\0\0nat51\0\0\0\0"                \
+  "nat52\0\0\0\0nat53\0\0\0\0nat54\0\0\0\0nat55\0\0\0\0"                \
+  "nat56\0\0\0\0nat57\0\0\0\0nat58\0\0\0\0nat59\0\0\0\0"                \
+  "nat60\0\0\0\0nat61\0\0\0\0nat62\0\0\0\0nat63\0\0\0\0"                \
+  "nat64\0\0\0\0nat65\0\0\0\0nat66\0\0\0\0nat67\0\0\0\0"                \
+  "nat68\0\0\0\0nat69\0\0\0\0nat70\0\0\0\0nat71\0\0\0\0"                \
+  "nat72\0\0\0\0nat73\0\0\0\0nat74\0\0\0\0nat75\0\0\0\0"                \
+  "nat76\0\0\0\0nat77\0\0\0\0nat78\0\0\0\0nat79\0\0\0\0"                \
+  "nat80\0\0\0\0nat81\0\0\0\0nat82\0\0\0\0nat83\0\0\0\0"                \
+  "nat84\0\0\0\0nat85\0\0\0\0nat86\0\0\0\0nat87\0\0\0\0"                \
+  "nat88\0\0\0\0nat89\0\0\0\0nat90\0\0\0\0nat91\0\0\0\0"                \
+  "nat92\0\0\0\0nat93\0\0\0\0nat94\0\0\0\0nat95\0\0\0\0"                \
+  "nat96\0\0\0\0nat97\0\0\0\0nat98\0\0\0\0nat99\0\0\0\0"                \
+  "nat100\0\0\0nat101\0\0\0nat102\0\0\0nat103\0\0\0"                    \
+  "nat104\0\0\0nat105\0\0\0nat106\0\0\0nat107\0\0\0"                    \
+  "nat108\0\0\0nat109\0\0\0nat110\0\0\0nat111\0\0\0"                    \
+  "nat112\0\0\0nat113\0\0\0nat114\0\0\0nat115\0\0\0"                    \
+  "nat116\0\0\0nat117\0\0\0nat118\0\0\0nat119\0\0\0"                    \
+  "nat120\0\0\0nat121\0\0\0nat122\0\0\0nat123\0\0\0"                    \
+  "nat124\0\0\0nat125\0\0\0nat126\0\0\0nat127\0\0\0"                    \
+  "f0\0\0\0\0\0\0\0f1\0\0\0\0\0\0\0f2\0\0\0\0\0\0\0f3\0\0\0\0\0\0\0"    \
+  "f4\0\0\0\0\0\0\0f5\0\0\0\0\0\0\0f6\0\0\0\0\0\0\0f7\0\0\0\0\0\0\0"    \
+  "f8\0\0\0\0\0\0\0f9\0\0\0\0\0\0\0f10\0\0\0\0\0\0f11\0\0\0\0\0\0"      \
+  "f12\0\0\0\0\0\0f13\0\0\0\0\0\0f14\0\0\0\0\0\0f15\0\0\0\0\0\0"        \
+  "f16\0\0\0\0\0\0f17\0\0\0\0\0\0f18\0\0\0\0\0\0f19\0\0\0\0\0\0"        \
+  "f20\0\0\0\0\0\0f21\0\0\0\0\0\0f22\0\0\0\0\0\0f23\0\0\0\0\0\0"        \
+  "f24\0\0\0\0\0\0f25\0\0\0\0\0\0f26\0\0\0\0\0\0f27\0\0\0\0\0\0"        \
+  "f28\0\0\0\0\0\0f29\0\0\0\0\0\0f30\0\0\0\0\0\0f31\0\0\0\0\0\0"        \
+  "f32\0\0\0\0\0\0f33\0\0\0\0\0\0f34\0\0\0\0\0\0f35\0\0\0\0\0\0"        \
+  "f36\0\0\0\0\0\0f37\0\0\0\0\0\0f38\0\0\0\0\0\0f39\0\0\0\0\0\0"        \
+  "f40\0\0\0\0\0\0f41\0\0\0\0\0\0f42\0\0\0\0\0\0f43\0\0\0\0\0\0"        \
+  "f44\0\0\0\0\0\0f45\0\0\0\0\0\0f46\0\0\0\0\0\0f47\0\0\0\0\0\0"        \
+  "f48\0\0\0\0\0\0f49\0\0\0\0\0\0f50\0\0\0\0\0\0f51\0\0\0\0\0\0"        \
+  "f52\0\0\0\0\0\0f53\0\0\0\0\0\0f54\0\0\0\0\0\0f55\0\0\0\0\0\0"        \
+  "f56\0\0\0\0\0\0f57\0\0\0\0\0\0f58\0\0\0\0\0\0f59\0\0\0\0\0\0"        \
+  "f60\0\0\0\0\0\0f61\0\0\0\0\0\0f62\0\0\0\0\0\0f63\0\0\0\0\0\0"        \
+  "f64\0\0\0\0\0\0f65\0\0\0\0\0\0f66\0\0\0\0\0\0f67\0\0\0\0\0\0"        \
+  "f68\0\0\0\0\0\0f69\0\0\0\0\0\0f70\0\0\0\0\0\0f71\0\0\0\0\0\0"        \
+  "f72\0\0\0\0\0\0f73\0\0\0\0\0\0f74\0\0\0\0\0\0f75\0\0\0\0\0\0"        \
+  "f76\0\0\0\0\0\0f77\0\0\0\0\0\0f78\0\0\0\0\0\0f79\0\0\0\0\0\0"        \
+  "f80\0\0\0\0\0\0f81\0\0\0\0\0\0f82\0\0\0\0\0\0f83\0\0\0\0\0\0"        \
+  "f84\0\0\0\0\0\0f85\0\0\0\0\0\0f86\0\0\0\0\0\0f87\0\0\0\0\0\0"        \
+  "f88\0\0\0\0\0\0f89\0\0\0\0\0\0f90\0\0\0\0\0\0f91\0\0\0\0\0\0"        \
+  "f92\0\0\0\0\0\0f93\0\0\0\0\0\0f94\0\0\0\0\0\0f95\0\0\0\0\0\0"        \
+  "f96\0\0\0\0\0\0f97\0\0\0\0\0\0f98\0\0\0\0\0\0f99\0\0\0\0\0\0"        \
+  "f100\0\0\0\0\0f101\0\0\0\0\0f102\0\0\0\0\0f103\0\0\0\0\0"            \
+  "f104\0\0\0\0\0f105\0\0\0\0\0f106\0\0\0\0\0f107\0\0\0\0\0"            \
+  "f108\0\0\0\0\0f109\0\0\0\0\0f110\0\0\0\0\0f111\0\0\0\0\0"            \
+  "f112\0\0\0\0\0f113\0\0\0\0\0f114\0\0\0\0\0f115\0\0\0\0\0"            \
+  "f116\0\0\0\0\0f117\0\0\0\0\0f118\0\0\0\0\0f119\0\0\0\0\0"            \
+  "f120\0\0\0\0\0f121\0\0\0\0\0f122\0\0\0\0\0f123\0\0\0\0\0"            \
+  "f124\0\0\0\0\0f125\0\0\0\0\0f126\0\0\0\0\0f127\0\0\0\0\0"            \
+  "ar0\0\0\0\0\0\0ar1\0\0\0\0\0\0ar2\0\0\0\0\0\0ar3\0\0\0\0\0\0"        \
+  "ar4\0\0\0\0\0\0ar5\0\0\0\0\0\0ar6\0\0\0\0\0\0ar7\0\0\0\0\0\0"        \
+  "ar8\0\0\0\0\0\0ar9\0\0\0\0\0\0ar10\0\0\0\0\0ar11\0\0\0\0\0"          \
+  "ar12\0\0\0\0\0ar13\0\0\0\0\0ar14\0\0\0\0\0ar15\0\0\0\0\0"            \
+  "rsc\0\0\0\0\0\0bsp\0\0\0\0\0\0bspstore\0rnat\0\0\0\0\0"              \
+  "ar20\0\0\0\0\0ar21\0\0\0\0\0ar22\0\0\0\0\0ar23\0\0\0\0\0"            \
+  "ar24\0\0\0\0\0ar25\0\0\0\0\0ar26\0\0\0\0\0ar27\0\0\0\0\0"            \
+  "ar28\0\0\0\0\0ar29\0\0\0\0\0ar30\0\0\0\0\0ar31\0\0\0\0\0"            \
+  "ccv\0\0\0\0\0\0ar33\0\0\0\0\0ar34\0\0\0\0\0ar35\0\0\0\0\0"           \
+  "unat\0\0\0\0\0ar37\0\0\0\0\0ar38\0\0\0\0\0ar39\0\0\0\0\0"            \
+  "fpsr\0\0\0\0\0ar41\0\0\0\0\0ar42\0\0\0\0\0ar43\0\0\0\0\0"            \
+  "ar44\0\0\0\0\0ar45\0\0\0\0\0ar46\0\0\0\0\0ar47\0\0\0\0\0"            \
+  "ar48\0\0\0\0\0ar49\0\0\0\0\0ar50\0\0\0\0\0ar51\0\0\0\0\0"            \
+  "ar52\0\0\0\0\0ar53\0\0\0\0\0ar54\0\0\0\0\0ar55\0\0\0\0\0"            \
+  "ar56\0\0\0\0\0ar57\0\0\0\0\0ar58\0\0\0\0\0ar59\0\0\0\0\0"            \
+  "ar60\0\0\0\0\0ar61\0\0\0\0\0ar62\0\0\0\0\0ar63\0\0\0\0\0"            \
+  "pfs\0\0\0\0\0\0lc\0\0\0\0\0\0\0ec\0\0\0\0\0\0\0ar67\0\0\0\0\0"       \
+  "ar68\0\0\0\0\0ar69\0\0\0\0\0ar70\0\0\0\0\0ar71\0\0\0\0\0"            \
+  "ar72\0\0\0\0\0ar73\0\0\0\0\0ar74\0\0\0\0\0ar75\0\0\0\0\0"            \
+  "ar76\0\0\0\0\0ar77\0\0\0\0\0ar78\0\0\0\0\0ar79\0\0\0\0\0"            \
+  "ar80\0\0\0\0\0ar81\0\0\0\0\0ar82\0\0\0\0\0ar83\0\0\0\0\0"            \
+  "ar84\0\0\0\0\0ar85\0\0\0\0\0ar86\0\0\0\0\0ar87\0\0\0\0\0"            \
+  "ar88\0\0\0\0\0ar89\0\0\0\0\0ar90\0\0\0\0\0ar91\0\0\0\0\0"            \
+  "ar92\0\0\0\0\0ar93\0\0\0\0\0ar94\0\0\0\0\0ar95\0\0\0\0\0"            \
+  "ar96\0\0\0\0\0ar97\0\0\0\0\0ar98\0\0\0\0\0ar99\0\0\0\0\0"            \
+  "ar100\0\0\0\0ar101\0\0\0\0ar102\0\0\0\0ar103\0\0\0\0"                \
+  "ar104\0\0\0\0ar105\0\0\0\0ar106\0\0\0\0ar107\0\0\0\0"                \
+  "ar108\0\0\0\0ar109\0\0\0\0ar110\0\0\0\0ar111\0\0\0\0"                \
+  "ar112\0\0\0\0ar113\0\0\0\0ar114\0\0\0\0ar115\0\0\0\0"                \
+  "ar116\0\0\0\0ar117\0\0\0\0ar118\0\0\0\0ar119\0\0\0\0"                \
+  "ar120\0\0\0\0ar121\0\0\0\0ar122\0\0\0\0ar123\0\0\0\0"                \
+  "ar124\0\0\0\0ar125\0\0\0\0ar126\0\0\0\0ar127\0\0\0\0"                \
+  "rp\0\0\0\0\0\0\0b1\0\0\0\0\0\0\0b2\0\0\0\0\0\0\0b3\0\0\0\0\0\0\0"    \
+  "b4\0\0\0\0\0\0\0b5\0\0\0\0\0\0\0b6\0\0\0\0\0\0\0b7\0\0\0\0\0\0\0"    \
+  "pr\0\0\0\0\0\0\0cfm\0\0\0\0\0\0bsp\0\0\0\0\0\0ip\0\0\0\0\0\0\0"      \
   "sp\0\0\0\0\0\0\0"
 
-#define NREGS	((int) (sizeof (regname_str) - 1) / regname_len)
+#define NREGS   ((int) (sizeof (regname_str) - 1) / regname_len)
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < NREGS)
diff --git a/src/ia64/regs.h b/src/ia64/regs.h
index 1e748bb..a22a818 100644
--- a/src/ia64/regs.h
+++ b/src/ia64/regs.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -40,9 +40,9 @@ rotate_gr (struct cursor *c, int reg)
     preg = reg;
   else
     {
-      preg = reg + rrb_gr;	/* apply rotation */
+      preg = reg + rrb_gr;      /* apply rotation */
       if ((unsigned) (preg - 32) >= sor)
-	preg -= sor;		/* wrap around */
+        preg -= sor;            /* wrap around */
     }
   if (sor)
     Debug (15, "sor=%u rrb.gr=%u, r%d -> r%d\n", sor, rrb_gr, reg, preg);
@@ -60,12 +60,12 @@ rotate_fr (struct cursor *c, int reg)
 
   rrb_fr = (c->cfm >> 25) & 0x7f;
   if (reg < 32)
-    preg = reg;		/* register not part of the rotating partition */
+    preg = reg;         /* register not part of the rotating partition */
   else
     {
-      preg = reg + rrb_fr;	/* apply rotation */
+      preg = reg + rrb_fr;      /* apply rotation */
       if (preg > 127)
-	preg -= 96;		/* wrap around */
+        preg -= 96;             /* wrap around */
     }
   if (rrb_fr)
     Debug (15, "rrb.fr=%u, f%d -> f%d\n", rrb_fr, reg, preg);
diff --git a/src/ia64/ucontext_i.h b/src/ia64/ucontext_i.h
index 34171fd..ea32c8a 100644
--- a/src/ia64/ucontext_i.h
+++ b/src/ia64/ucontext_i.h
@@ -25,44 +25,44 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 /* Constants shared between setcontext() and getcontext().  Don't
    install this header file.  */
 
-#define SIG_BLOCK	0
-#define SIG_UNBLOCK	1
-#define SIG_SETMASK	2
+#define SIG_BLOCK       0
+#define SIG_UNBLOCK     1
+#define SIG_SETMASK     2
 
-#define IA64_SC_FLAG_SYNCHRONOUS_BIT	63
+#define IA64_SC_FLAG_SYNCHRONOUS_BIT    63
 
 #define SC_FLAGS 0x000
-#define SC_NAT	0x008
-#define SC_BSP	0x048
-#define SC_RNAT	0x050
-#define SC_UNAT	0x060
-#define SC_FPSR	0x068
-#define SC_PFS	0x070
-#define SC_LC	0x078
-#define SC_PR	0x080
-#define SC_BR	0x088
-#define SC_GR	0x0c8
-#define SC_FR	0x1d0
-#define SC_MASK	0x9d0
+#define SC_NAT  0x008
+#define SC_BSP  0x048
+#define SC_RNAT 0x050
+#define SC_UNAT 0x060
+#define SC_FPSR 0x068
+#define SC_PFS  0x070
+#define SC_LC   0x078
+#define SC_PR   0x080
+#define SC_BR   0x088
+#define SC_GR   0x0c8
+#define SC_FR   0x1d0
+#define SC_MASK 0x9d0
 
 
-#define rTMP	r10
-#define rPOS	r11
-#define rCPOS	r14
-#define rNAT	r15
-#define rFLAGS	r16
+#define rTMP    r10
+#define rPOS    r11
+#define rCPOS   r14
+#define rNAT    r15
+#define rFLAGS  r16
 
-#define rB5	r18
-#define rB4	r19
-#define rB3	r20
-#define rB2	r21
-#define rB1	r22
-#define rB0	r23
-#define rRSC	r24
-#define rBSP	r25
-#define rRNAT	r26
-#define rUNAT	r27
-#define rFPSR	r28
-#define rPFS	r29
-#define rLC	r30
-#define rPR	r31
+#define rB5     r18
+#define rB4     r19
+#define rB3     r20
+#define rB2     r21
+#define rB1     r22
+#define rB0     r23
+#define rRSC    r24
+#define rBSP    r25
+#define rRNAT   r26
+#define rUNAT   r27
+#define rFPSR   r28
+#define rPFS    r29
+#define rLC     r30
+#define rPR     r31
diff --git a/src/ia64/unwind_decoder.h b/src/ia64/unwind_decoder.h
index f12c21d..7fd4174 100644
--- a/src/ia64/unwind_decoder.h
+++ b/src/ia64/unwind_decoder.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -33,55 +33,55 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
  * macros/constants before including this file:
  *
  *  Types:
- *	unw_word	Unsigned integer type with at least 64 bits
+ *      unw_word        Unsigned integer type with at least 64 bits
  *
  *  Register names:
- *	UNW_REG_BSP
- *	UNW_REG_BSPSTORE
- *	UNW_REG_FPSR
- *	UNW_REG_LC
- *	UNW_REG_PFS
- *	UNW_REG_PR
- *	UNW_REG_RNAT
- *	UNW_REG_PSP
- *	UNW_REG_RP
- *	UNW_REG_UNAT
+ *      UNW_REG_BSP
+ *      UNW_REG_BSPSTORE
+ *      UNW_REG_FPSR
+ *      UNW_REG_LC
+ *      UNW_REG_PFS
+ *      UNW_REG_PR
+ *      UNW_REG_RNAT
+ *      UNW_REG_PSP
+ *      UNW_REG_RP
+ *      UNW_REG_UNAT
  *
  *  Decoder action macros:
- *	UNW_DEC_BAD_CODE(code)
- *	UNW_DEC_ABI(fmt,abi,context,arg)
- *	UNW_DEC_BR_GR(fmt,brmask,gr,arg)
- *	UNW_DEC_BR_MEM(fmt,brmask,arg)
- *	UNW_DEC_COPY_STATE(fmt,label,arg)
- *	UNW_DEC_EPILOGUE(fmt,t,ecount,arg)
- *	UNW_DEC_FRGR_MEM(fmt,grmask,frmask,arg)
- *	UNW_DEC_FR_MEM(fmt,frmask,arg)
- *	UNW_DEC_GR_GR(fmt,grmask,gr,arg)
- *	UNW_DEC_GR_MEM(fmt,grmask,arg)
- *	UNW_DEC_LABEL_STATE(fmt,label,arg)
- *	UNW_DEC_MEM_STACK_F(fmt,t,size,arg)
- *	UNW_DEC_MEM_STACK_V(fmt,t,arg)
- *	UNW_DEC_PRIUNAT_GR(fmt,r,arg)
- *	UNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg)
- *	UNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg)
- *	UNW_DEC_PRIUNAT_WHEN_PSPREL(fmt,pspoff,arg)
- *	UNW_DEC_PRIUNAT_WHEN_SPREL(fmt,spoff,arg)
- *	UNW_DEC_PROLOGUE(fmt,body,rlen,arg)
- *	UNW_DEC_PROLOGUE_GR(fmt,rlen,mask,grsave,arg)
- *	UNW_DEC_REG_PSPREL(fmt,reg,pspoff,arg)
- *	UNW_DEC_REG_REG(fmt,src,dst,arg)
- *	UNW_DEC_REG_SPREL(fmt,reg,spoff,arg)
- *	UNW_DEC_REG_WHEN(fmt,reg,t,arg)
- *	UNW_DEC_RESTORE(fmt,t,abreg,arg)
- *	UNW_DEC_RESTORE_P(fmt,qp,t,abreg,arg)
- *	UNW_DEC_SPILL_BASE(fmt,pspoff,arg)
- *	UNW_DEC_SPILL_MASK(fmt,imaskp,arg)
- *	UNW_DEC_SPILL_PSPREL(fmt,t,abreg,pspoff,arg)
- *	UNW_DEC_SPILL_PSPREL_P(fmt,qp,t,abreg,pspoff,arg)
- *	UNW_DEC_SPILL_REG(fmt,t,abreg,x,ytreg,arg)
- *	UNW_DEC_SPILL_REG_P(fmt,qp,t,abreg,x,ytreg,arg)
- *	UNW_DEC_SPILL_SPREL(fmt,t,abreg,spoff,arg)
- *	UNW_DEC_SPILL_SPREL_P(fmt,qp,t,abreg,pspoff,arg)
+ *      UNW_DEC_BAD_CODE(code)
+ *      UNW_DEC_ABI(fmt,abi,context,arg)
+ *      UNW_DEC_BR_GR(fmt,brmask,gr,arg)
+ *      UNW_DEC_BR_MEM(fmt,brmask,arg)
+ *      UNW_DEC_COPY_STATE(fmt,label,arg)
+ *      UNW_DEC_EPILOGUE(fmt,t,ecount,arg)
+ *      UNW_DEC_FRGR_MEM(fmt,grmask,frmask,arg)
+ *      UNW_DEC_FR_MEM(fmt,frmask,arg)
+ *      UNW_DEC_GR_GR(fmt,grmask,gr,arg)
+ *      UNW_DEC_GR_MEM(fmt,grmask,arg)
+ *      UNW_DEC_LABEL_STATE(fmt,label,arg)
+ *      UNW_DEC_MEM_STACK_F(fmt,t,size,arg)
+ *      UNW_DEC_MEM_STACK_V(fmt,t,arg)
+ *      UNW_DEC_PRIUNAT_GR(fmt,r,arg)
+ *      UNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg)
+ *      UNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg)
+ *      UNW_DEC_PRIUNAT_WHEN_PSPREL(fmt,pspoff,arg)
+ *      UNW_DEC_PRIUNAT_WHEN_SPREL(fmt,spoff,arg)
+ *      UNW_DEC_PROLOGUE(fmt,body,rlen,arg)
+ *      UNW_DEC_PROLOGUE_GR(fmt,rlen,mask,grsave,arg)
+ *      UNW_DEC_REG_PSPREL(fmt,reg,pspoff,arg)
+ *      UNW_DEC_REG_REG(fmt,src,dst,arg)
+ *      UNW_DEC_REG_SPREL(fmt,reg,spoff,arg)
+ *      UNW_DEC_REG_WHEN(fmt,reg,t,arg)
+ *      UNW_DEC_RESTORE(fmt,t,abreg,arg)
+ *      UNW_DEC_RESTORE_P(fmt,qp,t,abreg,arg)
+ *      UNW_DEC_SPILL_BASE(fmt,pspoff,arg)
+ *      UNW_DEC_SPILL_MASK(fmt,imaskp,arg)
+ *      UNW_DEC_SPILL_PSPREL(fmt,t,abreg,pspoff,arg)
+ *      UNW_DEC_SPILL_PSPREL_P(fmt,qp,t,abreg,pspoff,arg)
+ *      UNW_DEC_SPILL_REG(fmt,t,abreg,x,ytreg,arg)
+ *      UNW_DEC_SPILL_REG_P(fmt,qp,t,abreg,x,ytreg,arg)
+ *      UNW_DEC_SPILL_SPREL(fmt,t,abreg,spoff,arg)
+ *      UNW_DEC_SPILL_SPREL_P(fmt,qp,t,abreg,pspoff,arg)
  */
 
 static unw_word
@@ -96,7 +96,7 @@ unw_decode_uleb128 (unsigned char **dpp)
       byte = *bp++;
       result |= (byte & 0x7f) << shift;
       if ((byte & 0x80) == 0)
-	break;
+        break;
       shift += 7;
     }
   *dpp = bp;
@@ -114,9 +114,9 @@ unw_decode_x1 (unsigned char *dp, unsigned char code, void *arg)
   off = unw_decode_uleb128 (&dp);
   abreg = (byte1 & 0x7f);
   if (byte1 & 0x80)
-	  UNW_DEC_SPILL_SPREL(X1, t, abreg, off, arg);
+          UNW_DEC_SPILL_SPREL(X1, t, abreg, off, arg);
   else
-	  UNW_DEC_SPILL_PSPREL(X1, t, abreg, off, arg);
+          UNW_DEC_SPILL_PSPREL(X1, t, abreg, off, arg);
   return dp;
 }
 
@@ -232,7 +232,7 @@ unw_decode_p2_p5 (unsigned char *dp, unsigned char code, void *arg)
       unsigned char byte1 = *dp++;
 
       UNW_DEC_BR_GR(P2, ((code & 0xf) << 1) | ((byte1 >> 7) & 1),
-		    (byte1 & 0x7f), arg);
+                    (byte1 & 0x7f), arg);
     }
   else if ((code & 0x08) == 0)
     {
@@ -241,21 +241,21 @@ unw_decode_p2_p5 (unsigned char *dp, unsigned char code, void *arg)
       r = ((code & 0x7) << 1) | ((byte1 >> 7) & 1);
       dst = (byte1 & 0x7f);
       switch (r)
-	{
-	case 0: UNW_DEC_REG_GR(P3, UNW_REG_PSP, dst, arg); break;
-	case 1: UNW_DEC_REG_GR(P3, UNW_REG_RP, dst, arg); break;
-	case 2: UNW_DEC_REG_GR(P3, UNW_REG_PFS, dst, arg); break;
-	case 3: UNW_DEC_REG_GR(P3, UNW_REG_PR, dst, arg); break;
-	case 4: UNW_DEC_REG_GR(P3, UNW_REG_UNAT, dst, arg); break;
-	case 5: UNW_DEC_REG_GR(P3, UNW_REG_LC, dst, arg); break;
-	case 6: UNW_DEC_RP_BR(P3, dst, arg); break;
-	case 7: UNW_DEC_REG_GR(P3, UNW_REG_RNAT, dst, arg); break;
-	case 8: UNW_DEC_REG_GR(P3, UNW_REG_BSP, dst, arg); break;
-	case 9: UNW_DEC_REG_GR(P3, UNW_REG_BSPSTORE, dst, arg); break;
-	case 10: UNW_DEC_REG_GR(P3, UNW_REG_FPSR, dst, arg); break;
-	case 11: UNW_DEC_PRIUNAT_GR(P3, dst, arg); break;
-	default: UNW_DEC_BAD_CODE(r); break;
-	}
+        {
+        case 0: UNW_DEC_REG_GR(P3, UNW_REG_PSP, dst, arg); break;
+        case 1: UNW_DEC_REG_GR(P3, UNW_REG_RP, dst, arg); break;
+        case 2: UNW_DEC_REG_GR(P3, UNW_REG_PFS, dst, arg); break;
+        case 3: UNW_DEC_REG_GR(P3, UNW_REG_PR, dst, arg); break;
+        case 4: UNW_DEC_REG_GR(P3, UNW_REG_UNAT, dst, arg); break;
+        case 5: UNW_DEC_REG_GR(P3, UNW_REG_LC, dst, arg); break;
+        case 6: UNW_DEC_RP_BR(P3, dst, arg); break;
+        case 7: UNW_DEC_REG_GR(P3, UNW_REG_RNAT, dst, arg); break;
+        case 8: UNW_DEC_REG_GR(P3, UNW_REG_BSP, dst, arg); break;
+        case 9: UNW_DEC_REG_GR(P3, UNW_REG_BSPSTORE, dst, arg); break;
+        case 10: UNW_DEC_REG_GR(P3, UNW_REG_FPSR, dst, arg); break;
+        case 11: UNW_DEC_PRIUNAT_GR(P3, dst, arg); break;
+        default: UNW_DEC_BAD_CODE(r); break;
+        }
     }
   else if ((code & 0x7) == 0)
     UNW_DEC_SPILL_MASK(P4, dp, arg);
@@ -297,90 +297,90 @@ unw_decode_p7_p10 (unsigned char *dp, unsigned char code, void *arg)
       r = (code & 0xf);
       t = unw_decode_uleb128 (&dp);
       switch (r)
-	{
-	case 0:
-	  size = unw_decode_uleb128 (&dp);
-	  UNW_DEC_MEM_STACK_F(P7, t, size, arg);
-	  break;
-
-	case 1: UNW_DEC_MEM_STACK_V(P7, t, arg); break;
-	case 2: UNW_DEC_SPILL_BASE(P7, t, arg); break;
-	case 3: UNW_DEC_REG_SPREL(P7, UNW_REG_PSP, t, arg); break;
-	case 4: UNW_DEC_REG_WHEN(P7, UNW_REG_RP, t, arg); break;
-	case 5: UNW_DEC_REG_PSPREL(P7, UNW_REG_RP, t, arg); break;
-	case 6: UNW_DEC_REG_WHEN(P7, UNW_REG_PFS, t, arg); break;
-	case 7: UNW_DEC_REG_PSPREL(P7, UNW_REG_PFS, t, arg); break;
-	case 8: UNW_DEC_REG_WHEN(P7, UNW_REG_PR, t, arg); break;
-	case 9: UNW_DEC_REG_PSPREL(P7, UNW_REG_PR, t, arg); break;
-	case 10: UNW_DEC_REG_WHEN(P7, UNW_REG_LC, t, arg); break;
-	case 11: UNW_DEC_REG_PSPREL(P7, UNW_REG_LC, t, arg); break;
-	case 12: UNW_DEC_REG_WHEN(P7, UNW_REG_UNAT, t, arg); break;
-	case 13: UNW_DEC_REG_PSPREL(P7, UNW_REG_UNAT, t, arg); break;
-	case 14: UNW_DEC_REG_WHEN(P7, UNW_REG_FPSR, t, arg); break;
-	case 15: UNW_DEC_REG_PSPREL(P7, UNW_REG_FPSR, t, arg); break;
-	default: UNW_DEC_BAD_CODE(r); break;
-	}
+        {
+        case 0:
+          size = unw_decode_uleb128 (&dp);
+          UNW_DEC_MEM_STACK_F(P7, t, size, arg);
+          break;
+
+        case 1: UNW_DEC_MEM_STACK_V(P7, t, arg); break;
+        case 2: UNW_DEC_SPILL_BASE(P7, t, arg); break;
+        case 3: UNW_DEC_REG_SPREL(P7, UNW_REG_PSP, t, arg); break;
+        case 4: UNW_DEC_REG_WHEN(P7, UNW_REG_RP, t, arg); break;
+        case 5: UNW_DEC_REG_PSPREL(P7, UNW_REG_RP, t, arg); break;
+        case 6: UNW_DEC_REG_WHEN(P7, UNW_REG_PFS, t, arg); break;
+        case 7: UNW_DEC_REG_PSPREL(P7, UNW_REG_PFS, t, arg); break;
+        case 8: UNW_DEC_REG_WHEN(P7, UNW_REG_PR, t, arg); break;
+        case 9: UNW_DEC_REG_PSPREL(P7, UNW_REG_PR, t, arg); break;
+        case 10: UNW_DEC_REG_WHEN(P7, UNW_REG_LC, t, arg); break;
+        case 11: UNW_DEC_REG_PSPREL(P7, UNW_REG_LC, t, arg); break;
+        case 12: UNW_DEC_REG_WHEN(P7, UNW_REG_UNAT, t, arg); break;
+        case 13: UNW_DEC_REG_PSPREL(P7, UNW_REG_UNAT, t, arg); break;
+        case 14: UNW_DEC_REG_WHEN(P7, UNW_REG_FPSR, t, arg); break;
+        case 15: UNW_DEC_REG_PSPREL(P7, UNW_REG_FPSR, t, arg); break;
+        default: UNW_DEC_BAD_CODE(r); break;
+        }
     }
   else
     {
       switch (code & 0xf)
-	{
-	case 0x0: /* p8 */
-	  {
-	    r = *dp++;
-	    t = unw_decode_uleb128 (&dp);
-	    switch (r)
-	      {
-	      case  1: UNW_DEC_REG_SPREL(P8, UNW_REG_RP, t, arg); break;
-	      case  2: UNW_DEC_REG_SPREL(P8, UNW_REG_PFS, t, arg); break;
-	      case  3: UNW_DEC_REG_SPREL(P8, UNW_REG_PR, t, arg); break;
-	      case  4: UNW_DEC_REG_SPREL(P8, UNW_REG_LC, t, arg); break;
-	      case  5: UNW_DEC_REG_SPREL(P8, UNW_REG_UNAT, t, arg); break;
-	      case  6: UNW_DEC_REG_SPREL(P8, UNW_REG_FPSR, t, arg); break;
-	      case  7: UNW_DEC_REG_WHEN(P8, UNW_REG_BSP, t, arg); break;
-	      case  8: UNW_DEC_REG_PSPREL(P8, UNW_REG_BSP, t, arg); break;
-	      case  9: UNW_DEC_REG_SPREL(P8, UNW_REG_BSP, t, arg); break;
-	      case 10: UNW_DEC_REG_WHEN(P8, UNW_REG_BSPSTORE, t, arg); break;
-	      case 11: UNW_DEC_REG_PSPREL(P8, UNW_REG_BSPSTORE, t, arg); break;
-	      case 12: UNW_DEC_REG_SPREL(P8, UNW_REG_BSPSTORE, t, arg); break;
-	      case 13: UNW_DEC_REG_WHEN(P8, UNW_REG_RNAT, t, arg); break;
-	      case 14: UNW_DEC_REG_PSPREL(P8, UNW_REG_RNAT, t, arg); break;
-	      case 15: UNW_DEC_REG_SPREL(P8, UNW_REG_RNAT, t, arg); break;
-	      case 16: UNW_DEC_PRIUNAT_WHEN_GR(P8, t, arg); break;
-	      case 17: UNW_DEC_PRIUNAT_PSPREL(P8, t, arg); break;
-	      case 18: UNW_DEC_PRIUNAT_SPREL(P8, t, arg); break;
-	      case 19: UNW_DEC_PRIUNAT_WHEN_MEM(P8, t, arg); break;
-	      default: UNW_DEC_BAD_CODE(r); break;
-	    }
-	  }
-	  break;
-
-	case 0x1:
-	  byte1 = *dp++; byte2 = *dp++;
-	  UNW_DEC_GR_GR(P9, (byte1 & 0xf), (byte2 & 0x7f), arg);
-	  break;
-
-	case 0xf: /* p10 */
-	  byte1 = *dp++; byte2 = *dp++;
-	  UNW_DEC_ABI(P10, byte1, byte2, arg);
-	  break;
-
-	case 0x9:
-	  return unw_decode_x1 (dp, code, arg);
-
-	case 0xa:
-	  return unw_decode_x2 (dp, code, arg);
-
-	case 0xb:
-	  return unw_decode_x3 (dp, code, arg);
-
-	case 0xc:
-	  return unw_decode_x4 (dp, code, arg);
-
-	default:
-	  UNW_DEC_BAD_CODE(code);
-	  break;
-	}
+        {
+        case 0x0: /* p8 */
+          {
+            r = *dp++;
+            t = unw_decode_uleb128 (&dp);
+            switch (r)
+              {
+              case  1: UNW_DEC_REG_SPREL(P8, UNW_REG_RP, t, arg); break;
+              case  2: UNW_DEC_REG_SPREL(P8, UNW_REG_PFS, t, arg); break;
+              case  3: UNW_DEC_REG_SPREL(P8, UNW_REG_PR, t, arg); break;
+              case  4: UNW_DEC_REG_SPREL(P8, UNW_REG_LC, t, arg); break;
+              case  5: UNW_DEC_REG_SPREL(P8, UNW_REG_UNAT, t, arg); break;
+              case  6: UNW_DEC_REG_SPREL(P8, UNW_REG_FPSR, t, arg); break;
+              case  7: UNW_DEC_REG_WHEN(P8, UNW_REG_BSP, t, arg); break;
+              case  8: UNW_DEC_REG_PSPREL(P8, UNW_REG_BSP, t, arg); break;
+              case  9: UNW_DEC_REG_SPREL(P8, UNW_REG_BSP, t, arg); break;
+              case 10: UNW_DEC_REG_WHEN(P8, UNW_REG_BSPSTORE, t, arg); break;
+              case 11: UNW_DEC_REG_PSPREL(P8, UNW_REG_BSPSTORE, t, arg); break;
+              case 12: UNW_DEC_REG_SPREL(P8, UNW_REG_BSPSTORE, t, arg); break;
+              case 13: UNW_DEC_REG_WHEN(P8, UNW_REG_RNAT, t, arg); break;
+              case 14: UNW_DEC_REG_PSPREL(P8, UNW_REG_RNAT, t, arg); break;
+              case 15: UNW_DEC_REG_SPREL(P8, UNW_REG_RNAT, t, arg); break;
+              case 16: UNW_DEC_PRIUNAT_WHEN_GR(P8, t, arg); break;
+              case 17: UNW_DEC_PRIUNAT_PSPREL(P8, t, arg); break;
+              case 18: UNW_DEC_PRIUNAT_SPREL(P8, t, arg); break;
+              case 19: UNW_DEC_PRIUNAT_WHEN_MEM(P8, t, arg); break;
+              default: UNW_DEC_BAD_CODE(r); break;
+            }
+          }
+          break;
+
+        case 0x1:
+          byte1 = *dp++; byte2 = *dp++;
+          UNW_DEC_GR_GR(P9, (byte1 & 0xf), (byte2 & 0x7f), arg);
+          break;
+
+        case 0xf: /* p10 */
+          byte1 = *dp++; byte2 = *dp++;
+          UNW_DEC_ABI(P10, byte1, byte2, arg);
+          break;
+
+        case 0x9:
+          return unw_decode_x1 (dp, code, arg);
+
+        case 0xa:
+          return unw_decode_x2 (dp, code, arg);
+
+        case 0xb:
+          return unw_decode_x3 (dp, code, arg);
+
+        case 0xc:
+          return unw_decode_x4 (dp, code, arg);
+
+        default:
+          UNW_DEC_BAD_CODE(code);
+          break;
+        }
     }
   return dp;
 }
@@ -422,9 +422,9 @@ unw_decode_b3_x4 (unsigned char *dp, unsigned char code, void *arg)
     {
       label = unw_decode_uleb128 (&dp);
       if ((code & 0x08) != 0)
-	UNW_DEC_COPY_STATE(B4, label, arg);
+        UNW_DEC_COPY_STATE(B4, label, arg);
       else
-	UNW_DEC_LABEL_STATE(B4, label, arg);
+        UNW_DEC_LABEL_STATE(B4, label, arg);
     }
   else
     switch (code & 0x7)
diff --git a/src/ia64/unwind_i.h b/src/ia64/unwind_i.h
index c8cc52d..8ccbb46 100644
--- a/src/ia64/unwind_i.h
+++ b/src/ia64/unwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -35,17 +35,17 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-#define IA64_UNW_VER(x)		    ((x) >> 48)
-#define IA64_UNW_FLAG_MASK	    ((unw_word_t) 0x0000ffff00000000ULL)
-#define IA64_UNW_FLAG_OSMASK	    ((unw_word_t) 0x0000f00000000000ULL)
+#define IA64_UNW_VER(x)             ((x) >> 48)
+#define IA64_UNW_FLAG_MASK          ((unw_word_t) 0x0000ffff00000000ULL)
+#define IA64_UNW_FLAG_OSMASK        ((unw_word_t) 0x0000f00000000000ULL)
 #define IA64_UNW_FLAG_EHANDLER(x)   ((x) & (unw_word_t) 0x0000000100000000ULL)
 #define IA64_UNW_FLAG_UHANDLER(x)   ((x) & (unw_word_t) 0x0000000200000000ULL)
-#define IA64_UNW_LENGTH(x)	    ((x) & (unw_word_t) 0x00000000ffffffffULL)
+#define IA64_UNW_LENGTH(x)          ((x) & (unw_word_t) 0x00000000ffffffffULL)
 
 #ifdef MIN
 # undef MIN
 #endif
-#define MIN(a,b)	((a) < (b) ? (a) : (b))
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
 
 #if !defined(HAVE_SYS_UC_ACCESS_H) && !defined(UNW_REMOTE_ONLY)
 
@@ -57,23 +57,23 @@ inlined_uc_addr (ucontext_t *uc, int reg, uint8_t *nat_bitnr)
 
   switch (reg)
     {
-    case UNW_IA64_GR + 0:	addr = &unw.read_only.r0; break;
-    case UNW_IA64_NAT + 0:	addr = &unw.read_only.r0; break;
-    case UNW_IA64_FR + 0:	addr = &unw.read_only.f0; break;
+    case UNW_IA64_GR + 0:       addr = &unw.read_only.r0; break;
+    case UNW_IA64_NAT + 0:      addr = &unw.read_only.r0; break;
+    case UNW_IA64_FR + 0:       addr = &unw.read_only.f0; break;
     case UNW_IA64_FR + 1:
       if (__BYTE_ORDER == __BIG_ENDIAN)
-	addr = &unw.read_only.f1_be;
+        addr = &unw.read_only.f1_be;
       else
-	addr = &unw.read_only.f1_le;
+        addr = &unw.read_only.f1_le;
       break;
-    case UNW_IA64_IP:		addr = &uc->uc_mcontext.sc_br[0]; break;
-    case UNW_IA64_CFM:		addr = &uc->uc_mcontext.sc_ar_pfs; break;
-    case UNW_IA64_AR_RNAT:	addr = &uc->uc_mcontext.sc_ar_rnat; break;
-    case UNW_IA64_AR_UNAT:	addr = &uc->uc_mcontext.sc_ar_unat; break;
-    case UNW_IA64_AR_LC:	addr = &uc->uc_mcontext.sc_ar_lc; break;
-    case UNW_IA64_AR_FPSR:	addr = &uc->uc_mcontext.sc_ar_fpsr; break;
-    case UNW_IA64_PR:		addr = &uc->uc_mcontext.sc_pr; break;
-    case UNW_IA64_AR_BSPSTORE:	addr = &uc->uc_mcontext.sc_ar_bsp; break;
+    case UNW_IA64_IP:           addr = &uc->uc_mcontext.sc_br[0]; break;
+    case UNW_IA64_CFM:          addr = &uc->uc_mcontext.sc_ar_pfs; break;
+    case UNW_IA64_AR_RNAT:      addr = &uc->uc_mcontext.sc_ar_rnat; break;
+    case UNW_IA64_AR_UNAT:      addr = &uc->uc_mcontext.sc_ar_unat; break;
+    case UNW_IA64_AR_LC:        addr = &uc->uc_mcontext.sc_ar_lc; break;
+    case UNW_IA64_AR_FPSR:      addr = &uc->uc_mcontext.sc_ar_fpsr; break;
+    case UNW_IA64_PR:           addr = &uc->uc_mcontext.sc_pr; break;
+    case UNW_IA64_AR_BSPSTORE:  addr = &uc->uc_mcontext.sc_ar_bsp; break;
 
     case UNW_IA64_GR + 4 ... UNW_IA64_GR + 7:
     case UNW_IA64_GR + 12:
@@ -117,41 +117,41 @@ static inline long
 ia64_read_only_reg (void *addr)
 {
   return ((unsigned long) ((char *) addr - (char *) &unw.read_only)
-	  < sizeof (unw.read_only));
+          < sizeof (unw.read_only));
 }
 
 #endif /* !defined(HAVE_SYS_UC_ACCESS_H) && !defined(UNW_REMOTE_ONLY) */
 
 /* Bits 0 and 1 of a location are used to encode its type:
-	bit 0: set if location uses floating-point format.
-	bit 1: set if location is a NaT bit on memory stack.  */
+        bit 0: set if location uses floating-point format.
+        bit 1: set if location is a NaT bit on memory stack.  */
 
-#define IA64_LOC_TYPE_FP		(1 << 0)
-#define IA64_LOC_TYPE_MEMSTK_NAT	(1 << 1)
+#define IA64_LOC_TYPE_FP                (1 << 0)
+#define IA64_LOC_TYPE_MEMSTK_NAT        (1 << 1)
 
 #ifdef UNW_LOCAL_ONLY
-#define IA64_LOC_REG(r,t)	(((r) << 2) | (t))
-#define IA64_LOC_ADDR(a,t)	(((a) & ~0x3) | (t))
-#define IA64_LOC_UC_ADDR(a,t)	IA64_LOC_ADDR(a, t)
-#define IA64_NULL_LOC		(0)
-
-#define IA64_GET_REG(l)		((l) >> 2)
-#define IA64_GET_ADDR(l)	((l) & ~0x3)
-#define IA64_IS_NULL_LOC(l)	((l) == 0)
-#define IA64_IS_FP_LOC(l)	(((l) & IA64_LOC_TYPE_FP) != 0)
-#define IA64_IS_MEMSTK_NAT(l)	(((l) & IA64_LOC_TYPE_MEMSTK_NAT) != 0)
-#define IA64_IS_REG_LOC(l)	0
-#define IA64_IS_UC_LOC(l)	0
-
-#define IA64_REG_LOC(c,r)	((unw_word_t) uc_addr((c)->as_arg, r, NULL))
-#define IA64_REG_NAT_LOC(c,r,n)	((unw_word_t) uc_addr((c)->as_arg, r, n))
-#define IA64_FPREG_LOC(c,r)						 \
-	((unw_word_t) uc_addr((c)->as_arg, (r), NULL) | IA64_LOC_TYPE_FP)
-
-# define ia64_find_proc_info(c,ip,n)					\
-	tdep_find_proc_info(unw_local_addr_space, (ip), &(c)->pi, (n),	\
-			    (c)->as_arg)
-# define ia64_put_unwind_info(c, pi)	do { ; } while (0)
+#define IA64_LOC_REG(r,t)       (((r) << 2) | (t))
+#define IA64_LOC_ADDR(a,t)      (((a) & ~0x3) | (t))
+#define IA64_LOC_UC_ADDR(a,t)   IA64_LOC_ADDR(a, t)
+#define IA64_NULL_LOC           (0)
+
+#define IA64_GET_REG(l)         ((l) >> 2)
+#define IA64_GET_ADDR(l)        ((l) & ~0x3)
+#define IA64_IS_NULL_LOC(l)     ((l) == 0)
+#define IA64_IS_FP_LOC(l)       (((l) & IA64_LOC_TYPE_FP) != 0)
+#define IA64_IS_MEMSTK_NAT(l)   (((l) & IA64_LOC_TYPE_MEMSTK_NAT) != 0)
+#define IA64_IS_REG_LOC(l)      0
+#define IA64_IS_UC_LOC(l)       0
+
+#define IA64_REG_LOC(c,r)       ((unw_word_t) uc_addr((c)->as_arg, r, NULL))
+#define IA64_REG_NAT_LOC(c,r,n) ((unw_word_t) uc_addr((c)->as_arg, r, n))
+#define IA64_FPREG_LOC(c,r)                                              \
+        ((unw_word_t) uc_addr((c)->as_arg, (r), NULL) | IA64_LOC_TYPE_FP)
+
+# define ia64_find_proc_info(c,ip,n)                                    \
+        tdep_find_proc_info(unw_local_addr_space, (ip), &(c)->pi, (n),  \
+                            (c)->as_arg)
+# define ia64_put_unwind_info(c, pi)    do { ; } while (0)
 
 /* Note: the register accessors (ia64_{get,set}{,fp}()) must check for
    NULL locations because uc_addr() returns NULL for unsaved
@@ -224,47 +224,47 @@ ia64_put (struct cursor *c, unw_word_t loc, unw_word_t val)
 /* Bits 0 and 1 of the second word (w1) of a location are used
    to further distinguish what location we're dealing with:
 
-   	bit 0: set if the location is a register
-	bit 1: set of the location is accessed via uc_access(3)  */
-#define IA64_LOC_TYPE_REG	(1 << 0)
-#define IA64_LOC_TYPE_UC	(1 << 1)
-
-#define IA64_LOC_REG(r,t)	((ia64_loc_t) { ((r) << 2) | (t),	\
-						IA64_LOC_TYPE_REG })
-#define IA64_LOC_ADDR(a,t)	((ia64_loc_t) { ((a) & ~0x3) | (t), 0 })
-#define IA64_LOC_UC_ADDR(a,t)	((ia64_loc_t) { ((a) & ~0x3) | (t),	\
-						IA64_LOC_TYPE_UC })
-#define IA64_LOC_UC_REG(r,a)	((ia64_loc_t) { ((r) << 2),		 \
-						((a) | IA64_LOC_TYPE_REG \
-					         | IA64_LOC_TYPE_UC) })
-#define IA64_NULL_LOC		((ia64_loc_t) { 0, 0 })
-
-#define IA64_GET_REG(l)		((l).w0 >> 2)
-#define IA64_GET_ADDR(l)	((l).w0 & ~0x3)
-#define IA64_GET_AUX_ADDR(l)	((l).w1 & ~0x3)
-#define IA64_IS_NULL_LOC(l)	(((l).w0 | (l).w1) == 0)
-#define IA64_IS_FP_LOC(l)	(((l).w0 & IA64_LOC_TYPE_FP) != 0)
-#define IA64_IS_MEMSTK_NAT(l)	(((l).w0 & IA64_LOC_TYPE_MEMSTK_NAT) != 0)
-#define IA64_IS_REG_LOC(l)	(((l).w1 & IA64_LOC_TYPE_REG) != 0)
-#define IA64_IS_UC_LOC(l)	(((l).w1 & IA64_LOC_TYPE_UC) != 0)
-
-#define IA64_REG_LOC(c,r)	IA64_LOC_REG ((r), 0)
-#define IA64_REG_NAT_LOC(c,r,n)	IA64_LOC_REG ((r), 0)
-#define IA64_FPREG_LOC(c,r)	IA64_LOC_REG ((r), IA64_LOC_TYPE_FP)
-
-# define ia64_find_proc_info(c,ip,n)					\
-	(*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),	\
-				       (c)->as_arg)
-# define ia64_put_unwind_info(c,pi)					\
-	(*(c)->as->acc.put_unwind_info)((c)->as, (pi), (c)->as_arg)
-
-#define ia64_uc_access_reg	UNW_OBJ(uc_access_reg)
-#define ia64_uc_access_fpreg	UNW_OBJ(uc_access_fpreg)
+        bit 0: set if the location is a register
+        bit 1: set of the location is accessed via uc_access(3)  */
+#define IA64_LOC_TYPE_REG       (1 << 0)
+#define IA64_LOC_TYPE_UC        (1 << 1)
+
+#define IA64_LOC_REG(r,t)       ((ia64_loc_t) { ((r) << 2) | (t),       \
+                                                IA64_LOC_TYPE_REG })
+#define IA64_LOC_ADDR(a,t)      ((ia64_loc_t) { ((a) & ~0x3) | (t), 0 })
+#define IA64_LOC_UC_ADDR(a,t)   ((ia64_loc_t) { ((a) & ~0x3) | (t),     \
+                                                IA64_LOC_TYPE_UC })
+#define IA64_LOC_UC_REG(r,a)    ((ia64_loc_t) { ((r) << 2),              \
+                                                ((a) | IA64_LOC_TYPE_REG \
+                                                 | IA64_LOC_TYPE_UC) })
+#define IA64_NULL_LOC           ((ia64_loc_t) { 0, 0 })
+
+#define IA64_GET_REG(l)         ((l).w0 >> 2)
+#define IA64_GET_ADDR(l)        ((l).w0 & ~0x3)
+#define IA64_GET_AUX_ADDR(l)    ((l).w1 & ~0x3)
+#define IA64_IS_NULL_LOC(l)     (((l).w0 | (l).w1) == 0)
+#define IA64_IS_FP_LOC(l)       (((l).w0 & IA64_LOC_TYPE_FP) != 0)
+#define IA64_IS_MEMSTK_NAT(l)   (((l).w0 & IA64_LOC_TYPE_MEMSTK_NAT) != 0)
+#define IA64_IS_REG_LOC(l)      (((l).w1 & IA64_LOC_TYPE_REG) != 0)
+#define IA64_IS_UC_LOC(l)       (((l).w1 & IA64_LOC_TYPE_UC) != 0)
+
+#define IA64_REG_LOC(c,r)       IA64_LOC_REG ((r), 0)
+#define IA64_REG_NAT_LOC(c,r,n) IA64_LOC_REG ((r), 0)
+#define IA64_FPREG_LOC(c,r)     IA64_LOC_REG ((r), IA64_LOC_TYPE_FP)
+
+# define ia64_find_proc_info(c,ip,n)                                    \
+        (*(c)->as->acc.find_proc_info)((c)->as, (ip), &(c)->pi, (n),    \
+                                       (c)->as_arg)
+# define ia64_put_unwind_info(c,pi)                                     \
+        (*(c)->as->acc.put_unwind_info)((c)->as, (pi), (c)->as_arg)
+
+#define ia64_uc_access_reg      UNW_OBJ(uc_access_reg)
+#define ia64_uc_access_fpreg    UNW_OBJ(uc_access_fpreg)
 
 extern int ia64_uc_access_reg (struct cursor *c, ia64_loc_t loc,
-			       unw_word_t *valp, int write);
+                               unw_word_t *valp, int write);
 extern int ia64_uc_access_fpreg (struct cursor *c, ia64_loc_t loc,
-				 unw_fpreg_t *valp, int write);
+                                 unw_fpreg_t *valp, int write);
 
 static inline int
 ia64_getfp (struct cursor *c, ia64_loc_t loc, unw_fpreg_t *val)
@@ -283,16 +283,16 @@ ia64_getfp (struct cursor *c, ia64_loc_t loc, unw_fpreg_t *val)
 
   if (IA64_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, IA64_GET_REG (loc),
-				       val, 0, c->as_arg);
+                                       val, 0, c->as_arg);
 
   addr = IA64_GET_ADDR (loc);
   ret = (*c->as->acc.access_mem) (c->as, addr + 0, &val->raw.bits[0], 0,
-				  c->as_arg);
+                                  c->as_arg);
   if (ret < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 8, &val->raw.bits[1], 0,
-				   c->as_arg);
+                                   c->as_arg);
 }
 
 static inline int
@@ -312,16 +312,16 @@ ia64_putfp (struct cursor *c, ia64_loc_t loc, unw_fpreg_t val)
 
   if (IA64_IS_REG_LOC (loc))
     return (*c->as->acc.access_fpreg) (c->as, IA64_GET_REG (loc), &val, 1,
-				       c->as_arg);
+                                       c->as_arg);
 
   addr = IA64_GET_ADDR (loc);
   ret = (*c->as->acc.access_mem) (c->as, addr + 0, &val.raw.bits[0], 1,
-				  c->as_arg);
+                                  c->as_arg);
   if (ret < 0)
     return ret;
 
   return (*c->as->acc.access_mem) (c->as, addr + 8, &val.raw.bits[1], 1,
-				   c->as_arg);
+                                   c->as_arg);
 }
 
 /* Get the 64 data bits from location LOC.  If bit 0 is cleared, LOC
@@ -345,12 +345,12 @@ ia64_get (struct cursor *c, ia64_loc_t loc, unw_word_t *val)
 
       ret = ia64_getfp (c, loc, &tmp);
       if (ret < 0)
-	return ret;
+        return ret;
 
       if (c->as->big_endian)
-	*val = tmp.raw.bits[1];
+        *val = tmp.raw.bits[1];
       else
-	*val = tmp.raw.bits[0];
+        *val = tmp.raw.bits[0];
       return 0;
     }
 
@@ -359,10 +359,10 @@ ia64_get (struct cursor *c, ia64_loc_t loc, unw_word_t *val)
 
   if (IA64_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg)(c->as, IA64_GET_REG (loc), val, 0,
-				    c->as_arg);
+                                    c->as_arg);
   else
     return (*c->as->acc.access_mem)(c->as, IA64_GET_ADDR (loc), val, 0,
-				    c->as_arg);
+                                    c->as_arg);
 }
 
 static inline int
@@ -380,9 +380,9 @@ ia64_put (struct cursor *c, ia64_loc_t loc, unw_word_t val)
 
       memset (&tmp, 0, sizeof (tmp));
       if (c->as->big_endian)
-	tmp.raw.bits[1] = val;
+        tmp.raw.bits[1] = val;
       else
-	tmp.raw.bits[0] = val;
+        tmp.raw.bits[0] = val;
       return ia64_putfp (c, loc, tmp);
     }
 
@@ -391,10 +391,10 @@ ia64_put (struct cursor *c, ia64_loc_t loc, unw_word_t val)
 
   if (IA64_IS_REG_LOC (loc))
     return (*c->as->acc.access_reg)(c->as, IA64_GET_REG (loc), &val, 1,
-				    c->as_arg);
+                                    c->as_arg);
   else
     return (*c->as->acc.access_mem)(c->as, IA64_GET_ADDR (loc), &val, 1,
-				    c->as_arg);
+                                    c->as_arg);
 }
 
 #endif /* !UNW_LOCAL_ONLY */
@@ -402,7 +402,7 @@ ia64_put (struct cursor *c, ia64_loc_t loc, unw_word_t val)
 struct ia64_unwind_block
   {
     unw_word_t header;
-    unw_word_t desc[0];			/* unwind descriptors */
+    unw_word_t desc[0];                 /* unwind descriptors */
 
     /* Personality routine and language-specific data follow behind
        descriptors.  */
@@ -410,58 +410,58 @@ struct ia64_unwind_block
 
 enum ia64_where
   {
-    IA64_WHERE_NONE,	/* register isn't saved at all */
-    IA64_WHERE_GR,	/* register is saved in a general register */
-    IA64_WHERE_FR,	/* register is saved in a floating-point register */
-    IA64_WHERE_BR,	/* register is saved in a branch register */
-    IA64_WHERE_SPREL,	/* register is saved on memstack (sp-relative) */
-    IA64_WHERE_PSPREL,	/* register is saved on memstack (psp-relative) */
+    IA64_WHERE_NONE,    /* register isn't saved at all */
+    IA64_WHERE_GR,      /* register is saved in a general register */
+    IA64_WHERE_FR,      /* register is saved in a floating-point register */
+    IA64_WHERE_BR,      /* register is saved in a branch register */
+    IA64_WHERE_SPREL,   /* register is saved on memstack (sp-relative) */
+    IA64_WHERE_PSPREL,  /* register is saved on memstack (psp-relative) */
 
     /* At the end of each prologue these locations get resolved to
        IA64_WHERE_PSPREL and IA64_WHERE_GR, respectively:  */
 
     IA64_WHERE_SPILL_HOME, /* register is saved in its spill home */
-    IA64_WHERE_GR_SAVE	/* register is saved in next general register */
+    IA64_WHERE_GR_SAVE  /* register is saved in next general register */
   };
 
-#define IA64_WHEN_NEVER	0x7fffffff
+#define IA64_WHEN_NEVER 0x7fffffff
 
 struct ia64_reg_info
   {
-    unw_word_t val;		/* save location: register number or offset */
-    enum ia64_where where;	/* where the register gets saved */
-    int when;			/* when the register gets saved */
+    unw_word_t val;             /* save location: register number or offset */
+    enum ia64_where where;      /* where the register gets saved */
+    int when;                   /* when the register gets saved */
   };
 
-struct ia64_labeled_state;	/* opaque structure */
+struct ia64_labeled_state;      /* opaque structure */
 
 struct ia64_reg_state
   {
     struct ia64_reg_state *next;    /* next (outer) element on state stack */
-    struct ia64_reg_info reg[IA64_NUM_PREGS];	/* register save locations */
+    struct ia64_reg_info reg[IA64_NUM_PREGS];   /* register save locations */
   };
 
 struct ia64_state_record
   {
-    unsigned int first_region : 1;	/* is this the first region? */
-    unsigned int done : 1;		/* are we done scanning descriptors? */
-    unsigned int any_spills : 1;	/* got any register spills? */
-    unsigned int in_body : 1;		/* are we inside prologue or body? */
-    uint8_t *imask;		/* imask of spill_mask record or NULL */
+    unsigned int first_region : 1;      /* is this the first region? */
+    unsigned int done : 1;              /* are we done scanning descriptors? */
+    unsigned int any_spills : 1;        /* got any register spills? */
+    unsigned int in_body : 1;           /* are we inside prologue or body? */
+    uint8_t *imask;             /* imask of spill_mask record or NULL */
     uint16_t abi_marker;
 
-    unw_word_t pr_val;		/* predicate values */
-    unw_word_t pr_mask;		/* predicate mask */
+    unw_word_t pr_val;          /* predicate values */
+    unw_word_t pr_mask;         /* predicate mask */
 
-    long spill_offset;		/* psp-relative offset for spill base */
+    long spill_offset;          /* psp-relative offset for spill base */
     int region_start;
     int region_len;
     int when_sp_restored;
     int epilogue_count;
     int when_target;
 
-    uint8_t gr_save_loc;	/* next save register */
-    uint8_t return_link_reg;	/* branch register used as return pointer */
+    uint8_t gr_save_loc;        /* next save register */
+    uint8_t return_link_reg;    /* branch register used as return pointer */
 
     struct ia64_labeled_state *labeled_states;
     struct ia64_reg_state curr;
@@ -469,65 +469,65 @@ struct ia64_state_record
 
 struct ia64_labeled_state
   {
-    struct ia64_labeled_state *next;	/* next label (or NULL) */
-    unsigned long label;			/* label for this state */
+    struct ia64_labeled_state *next;    /* next label (or NULL) */
+    unsigned long label;                        /* label for this state */
     struct ia64_reg_state saved_state;
   };
 
 /* Convenience macros: */
-#define ia64_make_proc_info		UNW_OBJ(make_proc_info)
-#define ia64_fetch_proc_info		UNW_OBJ(fetch_proc_info)
-#define ia64_create_state_record	UNW_OBJ(create_state_record)
-#define ia64_free_state_record		UNW_OBJ(free_state_record)
-#define ia64_find_save_locs		UNW_OBJ(find_save_locs)
-#define ia64_validate_cache		UNW_OBJ(ia64_validate_cache)
-#define ia64_local_validate_cache	UNW_OBJ(ia64_local_validate_cache)
-#define ia64_per_thread_cache		UNW_OBJ(per_thread_cache)
-#define ia64_scratch_loc		UNW_OBJ(scratch_loc)
-#define ia64_local_resume		UNW_OBJ(local_resume)
-#define ia64_local_addr_space_init	UNW_OBJ(local_addr_space_init)
-#define ia64_strloc			UNW_OBJ(strloc)
-#define ia64_install_cursor		UNW_OBJ(install_cursor)
-#define rbs_switch			UNW_OBJ(rbs_switch)
-#define rbs_find_stacked		UNW_OBJ(rbs_find_stacked)
+#define ia64_make_proc_info             UNW_OBJ(make_proc_info)
+#define ia64_fetch_proc_info            UNW_OBJ(fetch_proc_info)
+#define ia64_create_state_record        UNW_OBJ(create_state_record)
+#define ia64_free_state_record          UNW_OBJ(free_state_record)
+#define ia64_find_save_locs             UNW_OBJ(find_save_locs)
+#define ia64_validate_cache             UNW_OBJ(ia64_validate_cache)
+#define ia64_local_validate_cache       UNW_OBJ(ia64_local_validate_cache)
+#define ia64_per_thread_cache           UNW_OBJ(per_thread_cache)
+#define ia64_scratch_loc                UNW_OBJ(scratch_loc)
+#define ia64_local_resume               UNW_OBJ(local_resume)
+#define ia64_local_addr_space_init      UNW_OBJ(local_addr_space_init)
+#define ia64_strloc                     UNW_OBJ(strloc)
+#define ia64_install_cursor             UNW_OBJ(install_cursor)
+#define rbs_switch                      UNW_OBJ(rbs_switch)
+#define rbs_find_stacked                UNW_OBJ(rbs_find_stacked)
 
 extern int ia64_make_proc_info (struct cursor *c);
 extern int ia64_fetch_proc_info (struct cursor *c, unw_word_t ip,
-				 int need_unwind_info);
+                                 int need_unwind_info);
 /* The proc-info must be valid for IP before this routine can be
    called:  */
 extern int ia64_create_state_record (struct cursor *c,
-				     struct ia64_state_record *sr);
+                                     struct ia64_state_record *sr);
 extern int ia64_free_state_record (struct ia64_state_record *sr);
 extern int ia64_find_save_locs (struct cursor *c);
 extern void ia64_validate_cache (unw_addr_space_t as, void *arg);
 extern int ia64_local_validate_cache (unw_addr_space_t as, void *arg);
 extern void ia64_local_addr_space_init (void);
 extern ia64_loc_t ia64_scratch_loc (struct cursor *c, unw_regnum_t reg,
-				    uint8_t *nat_bitnr);
+                                    uint8_t *nat_bitnr);
 
 extern NORETURN void ia64_install_cursor (struct cursor *c,
-					  unw_word_t pri_unat,
-					  unw_word_t *extra,
-					  unw_word_t bspstore,
-					  unw_word_t dirty_size,
-					  unw_word_t *dirty_partition,
-					  unw_word_t dirty_rnat);
+                                          unw_word_t pri_unat,
+                                          unw_word_t *extra,
+                                          unw_word_t bspstore,
+                                          unw_word_t dirty_size,
+                                          unw_word_t *dirty_partition,
+                                          unw_word_t dirty_rnat);
 extern int ia64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			      void *arg);
+                              void *arg);
 extern int rbs_switch (struct cursor *c,
-		       unw_word_t saved_bsp, unw_word_t saved_bspstore,
-		       ia64_loc_t saved_rnat_loc);
+                       unw_word_t saved_bsp, unw_word_t saved_bspstore,
+                       ia64_loc_t saved_rnat_loc);
 extern int rbs_find_stacked (struct cursor *c, unw_word_t regs_to_skip,
-			     ia64_loc_t *locp, ia64_loc_t *rnat_locp);
+                             ia64_loc_t *locp, ia64_loc_t *rnat_locp);
 
 #ifndef UNW_REMOTE_ONLY
 # define NEED_RBS_COVER_AND_FLUSH
-# define rbs_cover_and_flush	UNW_OBJ(rbs_cover_and_flush)
+# define rbs_cover_and_flush    UNW_OBJ(rbs_cover_and_flush)
   extern int rbs_cover_and_flush (struct cursor *c, unw_word_t nregs,
-				  unw_word_t *dirty_partition,
-				  unw_word_t *dirty_rnat,
-				  unw_word_t *bspstore);
+                                  unw_word_t *dirty_partition,
+                                  unw_word_t *dirty_rnat,
+                                  unw_word_t *bspstore);
 #endif
 
 /* Warning: ia64_strloc() is for debugging only and it is NOT re-entrant! */
@@ -554,7 +554,7 @@ rbs_contains (struct rbs_area *rbs, unw_word_t bsp)
      take advantage of the fact that -n == ~n + 1.  */
   result = bsp - rbs->end > ~rbs->size;
   Debug (16, "0x%lx in [0x%lx-0x%lx) => %d\n",
-	 (long) bsp, (long) (rbs->end - rbs->size), (long) rbs->end, result);
+         (long) bsp, (long) (rbs->end - rbs->size), (long) rbs->end, result);
   return result;
 }
 
@@ -567,9 +567,9 @@ rbs_get_rnat_loc (struct rbs_area *rbs, unw_word_t bsp)
   if (rbs_contains (rbs, rnat_addr))
     {
       if (rbs_on_uc (rbs))
-	rnat_loc = IA64_LOC_UC_ADDR (rnat_addr, 0);
+        rnat_loc = IA64_LOC_UC_ADDR (rnat_addr, 0);
       else
-	rnat_loc = IA64_LOC_ADDR (rnat_addr, 0);
+        rnat_loc = IA64_LOC_ADDR (rnat_addr, 0);
     }
   else
     rnat_loc = rbs->rnat_loc;
@@ -587,7 +587,7 @@ rbs_loc (struct rbs_area *rbs, unw_word_t bsp)
 
 static inline int
 ia64_get_stacked (struct cursor *c, unw_word_t reg,
-		  ia64_loc_t *locp, ia64_loc_t *rnat_locp)
+                  ia64_loc_t *locp, ia64_loc_t *rnat_locp)
 {
   struct rbs_area *rbs = c->rbs_area + c->rbs_curr;
   unw_word_t addr, regs_to_skip = reg - 32;
@@ -609,15 +609,15 @@ ia64_get_stacked (struct cursor *c, unw_word_t reg,
 /* The UNaT slot # calculation is identical to the one for RNaT slots,
    but for readability/clarity, we don't want to use
    ia64_rnat_slot_num() directly.  */
-#define ia64_unat_slot_num(addr)	rse_slot_num(addr)
+#define ia64_unat_slot_num(addr)        rse_slot_num(addr)
 
 /* The following are helper macros which makes it easier for libunwind
    to be used in the kernel.  They allow the kernel to optimize away
    any unused code without littering everything with #ifdefs.  */
-#define ia64_is_big_endian(c)	((c)->as->big_endian)
-#define ia64_get_abi(c)		((c)->as->abi)
-#define ia64_set_abi(c, v)	((c)->as->abi = (v))
-#define ia64_get_abi_marker(c)	((c)->last_abi_marker)
+#define ia64_is_big_endian(c)   ((c)->as->big_endian)
+#define ia64_get_abi(c)         ((c)->as->abi)
+#define ia64_set_abi(c, v)      ((c)->as->abi = (v))
+#define ia64_get_abi_marker(c)  ((c)->last_abi_marker)
 
 /* XXX should be in glibc: */
 #ifndef IA64_SC_FLAG_ONSTACK
@@ -625,9 +625,9 @@ ia64_get_stacked (struct cursor *c, unw_word_t reg,
 # define IA64_SC_FLAG_IN_SYSCALL_BIT 1 /* did signal interrupt a syscall? */
 # define IA64_SC_FLAG_FPH_VALID_BIT  2 /* is state in f[32]-f[127] valid? */
 
-# define IA64_SC_FLAG_ONSTACK		(1 << IA64_SC_FLAG_ONSTACK_BIT)
-# define IA64_SC_FLAG_IN_SYSCALL	(1 << IA64_SC_FLAG_IN_SYSCALL_BIT)
-# define IA64_SC_FLAG_FPH_VALID		(1 << IA64_SC_FLAG_FPH_VALID_BIT)
+# define IA64_SC_FLAG_ONSTACK           (1 << IA64_SC_FLAG_ONSTACK_BIT)
+# define IA64_SC_FLAG_IN_SYSCALL        (1 << IA64_SC_FLAG_IN_SYSCALL_BIT)
+# define IA64_SC_FLAG_FPH_VALID         (1 << IA64_SC_FLAG_FPH_VALID_BIT)
 #endif
 
 #endif /* unwind_i_h */
diff --git a/src/libunwind-generic.pc.in b/src/libunwind-generic.pc.in
index 89e9814..1f3baff 100644
--- a/src/libunwind-generic.pc.in
+++ b/src/libunwind-generic.pc.in
@@ -8,3 +8,4 @@ Description: libunwind generic library
 Version: @VERSION@
 Requires: libunwind
 Libs: -L${libdir} -lunwind-generic
+Cflags: -I${includedir}
diff --git a/src/mi/Gdestroy_addr_space.c b/src/mi/Gdestroy_addr_space.c
index 83a01b9..504558e 100644
--- a/src/mi/Gdestroy_addr_space.c
+++ b/src/mi/Gdestroy_addr_space.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED void
+void
 unw_destroy_addr_space (unw_addr_space_t as)
 {
 #ifndef UNW_LOCAL_ONLY
diff --git a/src/mi/Gdyn-extract.c b/src/mi/Gdyn-extract.c
index 5258839..5f7682e 100644
--- a/src/mi/Gdyn-extract.c
+++ b/src/mi/Gdyn-extract.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,8 +27,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 unwi_extract_dynamic_proc_info (unw_addr_space_t as, unw_word_t ip,
-				unw_proc_info_t *pi, unw_dyn_info_t *di,
-				int need_unwind_info, void *arg)
+                                unw_proc_info_t *pi, unw_dyn_info_t *di,
+                                int need_unwind_info, void *arg)
 {
   pi->start_ip = di->start_ip;
   pi->end_ip = di->end_ip;
@@ -42,13 +42,15 @@ unwi_extract_dynamic_proc_info (unw_addr_space_t as, unw_word_t ip,
       pi->flags = di->u.pi.flags;
       pi->unwind_info_size = 0;
       if (need_unwind_info)
-	pi->unwind_info = di;
+        pi->unwind_info = di;
       else
-	pi->unwind_info = NULL;
+        pi->unwind_info = NULL;
       return 0;
 
     case UNW_INFO_FORMAT_TABLE:
     case UNW_INFO_FORMAT_REMOTE_TABLE:
+    case UNW_INFO_FORMAT_ARM_EXIDX:
+    case UNW_INFO_FORMAT_IP_OFFSET:
 #ifdef tdep_search_unwind_table
       /* call platform-specific search routine: */
       return tdep_search_unwind_table (as, ip, di, pi, need_unwind_info, arg);
diff --git a/src/mi/Gdyn-remote.c b/src/mi/Gdyn-remote.c
index 917a11d..40a5ad8 100644
--- a/src/mi/Gdyn-remote.c
+++ b/src/mi/Gdyn-remote.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -38,7 +38,7 @@ free_regions (unw_dyn_region_info_t *region)
 
 static int
 intern_op (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
-	   unw_dyn_op_t *op, void *arg)
+           unw_dyn_op_t *op, void *arg)
 {
   int ret;
 
@@ -53,7 +53,7 @@ intern_op (unw_addr_space_t as, unw_accessors_t *a, unw_word_t *addr,
 
 static int
 intern_regions (unw_addr_space_t as, unw_accessors_t *a,
-		unw_word_t *addr, unw_dyn_region_info_t **regionp, void *arg)
+                unw_word_t *addr, unw_dyn_region_info_t **regionp, void *arg)
 {
   uint32_t insn_count, op_count, i;
   unw_dyn_region_info_t *region;
@@ -63,7 +63,7 @@ intern_regions (unw_addr_space_t as, unw_accessors_t *a,
   *regionp = NULL;
 
   if (!*addr)
-    return 0;	/* NULL region-list */
+    return 0;   /* NULL region-list */
 
   if ((ret = fetchw (as, a, addr, &next_addr, arg)) < 0
       || (ret = fetch32 (as, a, addr, (int32_t *) &insn_count, arg)) < 0
@@ -98,8 +98,8 @@ intern_regions (unw_addr_space_t as, unw_accessors_t *a,
 
 static int
 intern_array (unw_addr_space_t as, unw_accessors_t *a,
-	      unw_word_t *addr, unw_word_t table_len, unw_word_t **table_data,
-	      void *arg)
+              unw_word_t *addr, unw_word_t table_len, unw_word_t **table_data,
+              void *arg)
 {
   unw_word_t i, *data = calloc (table_len, WSIZE);
   int ret = 0;
@@ -130,18 +130,18 @@ free_dyn_info (unw_dyn_info_t *di)
     {
     case UNW_INFO_FORMAT_DYNAMIC:
       if (di->u.pi.regions)
-	{
-	  free_regions (di->u.pi.regions);
-	  di->u.pi.regions = NULL;
-	}
+        {
+          free_regions (di->u.pi.regions);
+          di->u.pi.regions = NULL;
+        }
       break;
 
     case UNW_INFO_FORMAT_TABLE:
       if (di->u.ti.table_data)
-	{
-	  free (di->u.ti.table_data);
-	  di->u.ti.table_data = NULL;
-	}
+        {
+          free (di->u.ti.table_data);
+          di->u.ti.table_data = NULL;
+        }
       break;
 
     case UNW_INFO_FORMAT_REMOTE_TABLE:
@@ -152,7 +152,7 @@ free_dyn_info (unw_dyn_info_t *di)
 
 static int
 intern_dyn_info (unw_addr_space_t as, unw_accessors_t *a,
-		 unw_word_t *addr, unw_dyn_info_t *di, void *arg)
+                 unw_word_t *addr, unw_dyn_info_t *di, void *arg)
 {
   unw_word_t first_region;
   int ret;
@@ -161,32 +161,32 @@ intern_dyn_info (unw_addr_space_t as, unw_accessors_t *a,
     {
     case UNW_INFO_FORMAT_DYNAMIC:
       if ((ret = fetchw (as, a, addr, &di->u.pi.name_ptr, arg)) < 0
-	  || (ret = fetchw (as, a, addr, &di->u.pi.handler, arg)) < 0
-	  || (ret = fetch32 (as, a, addr,
-			     (int32_t *) &di->u.pi.flags, arg)) < 0)
-	goto out;
-      *addr += 4;	/* skip over pad0 */
+          || (ret = fetchw (as, a, addr, &di->u.pi.handler, arg)) < 0
+          || (ret = fetch32 (as, a, addr,
+                             (int32_t *) &di->u.pi.flags, arg)) < 0)
+        goto out;
+      *addr += 4;       /* skip over pad0 */
       if ((ret = fetchw (as, a, addr, &first_region, arg)) < 0
-	  || (ret = intern_regions (as, a, &first_region, &di->u.pi.regions,
-				    arg)) < 0)
-	goto out;
+          || (ret = intern_regions (as, a, &first_region, &di->u.pi.regions,
+                                    arg)) < 0)
+        goto out;
       break;
 
     case UNW_INFO_FORMAT_TABLE:
       if ((ret = fetchw (as, a, addr, &di->u.ti.name_ptr, arg)) < 0
-	  || (ret = fetchw (as, a, addr, &di->u.ti.segbase, arg)) < 0
-	  || (ret = fetchw (as, a, addr, &di->u.ti.table_len, arg)) < 0
-	  || (ret = intern_array (as, a, addr, di->u.ti.table_len,
-				  &di->u.ti.table_data, arg)) < 0)
-	goto out;
+          || (ret = fetchw (as, a, addr, &di->u.ti.segbase, arg)) < 0
+          || (ret = fetchw (as, a, addr, &di->u.ti.table_len, arg)) < 0
+          || (ret = intern_array (as, a, addr, di->u.ti.table_len,
+                                  &di->u.ti.table_data, arg)) < 0)
+        goto out;
       break;
 
     case UNW_INFO_FORMAT_REMOTE_TABLE:
       if ((ret = fetchw (as, a, addr, &di->u.rti.name_ptr, arg)) < 0
-	  || (ret = fetchw (as, a, addr, &di->u.rti.segbase, arg)) < 0
-	  || (ret = fetchw (as, a, addr, &di->u.rti.table_len, arg)) < 0
-	  || (ret = fetchw (as, a, addr, &di->u.rti.table_data, arg)) < 0)
-	goto out;
+          || (ret = fetchw (as, a, addr, &di->u.rti.segbase, arg)) < 0
+          || (ret = fetchw (as, a, addr, &di->u.rti.table_len, arg)) < 0
+          || (ret = fetchw (as, a, addr, &di->u.rti.table_data, arg)) < 0)
+        goto out;
       break;
 
     default:
@@ -202,10 +202,10 @@ intern_dyn_info (unw_addr_space_t as, unw_accessors_t *a,
 
 HIDDEN int
 unwi_dyn_remote_find_proc_info (unw_addr_space_t as, unw_word_t ip,
-				unw_proc_info_t *pi,
-				int need_unwind_info, void *arg)
+                                unw_proc_info_t *pi,
+                                int need_unwind_info, void *arg)
 {
-  unw_accessors_t *a = unw_get_accessors (as);
+  unw_accessors_t *a = unw_get_accessors_int (as);
   unw_word_t dyn_list_addr, addr, next_addr, gen1, gen2, start_ip, end_ip;
   unw_dyn_info_t *di = NULL;
   int ret;
@@ -215,9 +215,9 @@ unwi_dyn_remote_find_proc_info (unw_addr_space_t as, unw_word_t ip,
   else
     {
       if ((*a->get_dyn_info_list_addr) (as, &dyn_list_addr, arg) < 0)
-	return -UNW_ENOINFO;
+        return -UNW_ENOINFO;
       if (as->caching_policy != UNW_CACHE_NONE)
-	as->dyn_info_list_addr = dyn_list_addr;
+        as->dyn_info_list_addr = dyn_list_addr;
     }
 
   do
@@ -227,55 +227,55 @@ unwi_dyn_remote_find_proc_info (unw_addr_space_t as, unw_word_t ip,
       ret = -UNW_ENOINFO;
 
       if (fetchw (as, a, &addr, &gen1, arg) < 0
-	  || fetchw (as, a, &addr, &next_addr, arg) < 0)
-	return ret;
+          || fetchw (as, a, &addr, &next_addr, arg) < 0)
+        return ret;
 
       for (addr = next_addr; addr != 0; addr = next_addr)
-	{
-	  if (fetchw (as, a, &addr, &next_addr, arg) < 0)
-	    goto recheck;	/* only fail if generation # didn't change */
+        {
+          if (fetchw (as, a, &addr, &next_addr, arg) < 0)
+            goto recheck;       /* only fail if generation # didn't change */
 
-	  addr += WSIZE;	/* skip over prev_addr */
+          addr += WSIZE;        /* skip over prev_addr */
 
-	  if (fetchw (as, a, &addr, &start_ip, arg) < 0
-	      || fetchw (as, a, &addr, &end_ip, arg) < 0)
-	    goto recheck;	/* only fail if generation # didn't change */
+          if (fetchw (as, a, &addr, &start_ip, arg) < 0
+              || fetchw (as, a, &addr, &end_ip, arg) < 0)
+            goto recheck;       /* only fail if generation # didn't change */
 
-	  if (ip >= start_ip && ip < end_ip)
-	    {
-	      if (!di)
-		di = calloc (1, sizeof (*di));
+          if (ip >= start_ip && ip < end_ip)
+            {
+              if (!di)
+                di = calloc (1, sizeof (*di));
 
-	      di->start_ip = start_ip;
-	      di->end_ip = end_ip;
+              di->start_ip = start_ip;
+              di->end_ip = end_ip;
 
-	      if (fetchw (as, a, &addr, &di->gp, arg) < 0
-		  || fetch32 (as, a, &addr, &di->format, arg) < 0)
-		goto recheck;	/* only fail if generation # didn't change */
+              if (fetchw (as, a, &addr, &di->gp, arg) < 0
+                  || fetch32 (as, a, &addr, &di->format, arg) < 0)
+                goto recheck;   /* only fail if generation # didn't change */
 
-	      addr += 4;	/* skip over padding */
+              addr += 4;        /* skip over padding */
 
-	      if (need_unwind_info
-		  && intern_dyn_info (as, a, &addr, di, arg) < 0)
-		goto recheck;	/* only fail if generation # didn't change */
+              if (need_unwind_info
+                  && intern_dyn_info (as, a, &addr, di, arg) < 0)
+                goto recheck;   /* only fail if generation # didn't change */
 
-	      if (unwi_extract_dynamic_proc_info (as, ip, pi, di,
-						  need_unwind_info, arg) < 0)
-		{
-		  free_dyn_info (di);
-		  goto recheck;	/* only fail if generation # didn't change */
-		}
-	      ret = 0;	/* OK, found it */
-	      break;
-	    }
-	}
+              if (unwi_extract_dynamic_proc_info (as, ip, pi, di,
+                                                  need_unwind_info, arg) < 0)
+                {
+                  free_dyn_info (di);
+                  goto recheck; /* only fail if generation # didn't change */
+                }
+              ret = 0;  /* OK, found it */
+              break;
+            }
+        }
 
       /* Re-check generation number to ensure the data we have is
-	 consistent.  */
+         consistent.  */
     recheck:
       addr = dyn_list_addr;
       if (fetchw (as, a, &addr, &gen2, arg) < 0)
-	return ret;
+        return ret;
     }
   while (gen1 != gen2);
 
@@ -287,7 +287,7 @@ unwi_dyn_remote_find_proc_info (unw_addr_space_t as, unw_word_t ip,
 
 HIDDEN void
 unwi_dyn_remote_put_unwind_info (unw_addr_space_t as, unw_proc_info_t *pi,
-				 void *arg)
+                                 void *arg)
 {
   if (!pi->unwind_info)
     return;
@@ -311,7 +311,7 @@ unwi_dyn_validate_cache (unw_addr_space_t as, void *arg)
        in the cache.  */
     return 0;
 
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   addr = as->dyn_info_list_addr;
 
   if (fetchw (as, a, &addr, &gen, arg) < 0)
diff --git a/src/mi/Gfind_dynamic_proc_info.c b/src/mi/Gfind_dynamic_proc_info.c
index 6cf3b42..98d3501 100644
--- a/src/mi/Gfind_dynamic_proc_info.c
+++ b/src/mi/Gfind_dynamic_proc_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -29,7 +29,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 static inline int
 local_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
-		      int need_unwind_info, void *arg)
+                      int need_unwind_info, void *arg)
 {
   return -UNW_ENOINFO;
 }
@@ -38,7 +38,7 @@ local_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
 
 static inline int
 local_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
-		      int need_unwind_info, void *arg)
+                      int need_unwind_info, void *arg)
 {
   unw_dyn_info_list_t *list;
   unw_dyn_info_t *di;
@@ -53,7 +53,7 @@ local_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
   for (di = list->first; di; di = di->next)
     if (ip >= di->start_ip && ip < di->end_ip)
       return unwi_extract_dynamic_proc_info (as, ip, pi, di, need_unwind_info,
-					     arg);
+                                             arg);
   return -UNW_ENOINFO;
 }
 
@@ -63,7 +63,7 @@ local_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
 
 static inline int
 remote_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
-		       int need_unwind_info, void *arg)
+                       int need_unwind_info, void *arg)
 {
   return -UNW_ENOINFO;
 }
@@ -72,7 +72,7 @@ remote_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
 
 static inline int
 remote_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
-		       int need_unwind_info, void *arg)
+                       int need_unwind_info, void *arg)
 {
   return unwi_dyn_remote_find_proc_info (as, ip, pi, need_unwind_info, arg);
 }
@@ -81,8 +81,8 @@ remote_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
 
 HIDDEN int
 unwi_find_dynamic_proc_info (unw_addr_space_t as, unw_word_t ip,
-			     unw_proc_info_t *pi, int need_unwind_info,
-			     void *arg)
+                             unw_proc_info_t *pi, int need_unwind_info,
+                             void *arg)
 {
   if (as == unw_local_addr_space)
     return local_find_proc_info (as, ip, pi, need_unwind_info, arg);
diff --git a/src/mi/Gget_accessors.c b/src/mi/Gget_accessors.c
index 0e3606c..31a6fba 100644
--- a/src/mi/Gget_accessors.c
+++ b/src/mi/Gget_accessors.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002, 2004-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,10 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED unw_accessors_t *
+HIDDEN ALIAS(unw_get_accessors) unw_accessors_t *
+unw_get_accessors_int (unw_addr_space_t as);
+
+unw_accessors_t *
 unw_get_accessors (unw_addr_space_t as)
 {
   if (!tdep_init_done)
diff --git a/src/mi/Gget_fpreg.c b/src/mi/Gget_fpreg.c
index a9ae9bf..f32b128 100644
--- a/src/mi/Gget_fpreg.c
+++ b/src/mi/Gget_fpreg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_get_fpreg (unw_cursor_t *cursor, int regnum, unw_fpreg_t *valp)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/mi/Gget_proc_info_by_ip.c b/src/mi/Gget_proc_info_by_ip.c
index 4c9de77..2697ff8 100644
--- a/src/mi/Gget_proc_info_by_ip.c
+++ b/src/mi/Gget_proc_info_by_ip.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,11 +25,11 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info_by_ip (unw_addr_space_t as, unw_word_t ip,
-			 unw_proc_info_t *pi, void *as_arg)
+                         unw_proc_info_t *pi, void *as_arg)
 {
-  unw_accessors_t *a = unw_get_accessors (as);
+  unw_accessors_t *a = unw_get_accessors_int (as);
   int ret;
 
   ret = unwi_find_dynamic_proc_info (as, ip, pi, 0, as_arg);
diff --git a/src/mi/Gget_proc_name.c b/src/mi/Gget_proc_name.c
index 7251c59..840d900 100644
--- a/src/mi/Gget_proc_name.c
+++ b/src/mi/Gget_proc_name.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 static inline int
 intern_string (unw_addr_space_t as, unw_accessors_t *a,
-	       unw_word_t addr, char *buf, size_t buf_len, void *arg)
+               unw_word_t addr, char *buf, size_t buf_len, void *arg)
 {
   size_t i;
   int ret;
@@ -36,24 +36,24 @@ intern_string (unw_addr_space_t as, unw_accessors_t *a,
   for (i = 0; i < buf_len; ++i)
     {
       if ((ret = fetch8 (as, a, &addr, (int8_t *) buf + i, arg)) < 0)
-	return ret;
+        return ret;
 
       if (buf[i] == '\0')
-	return 0;		/* copied full string; return success */
+        return 0;               /* copied full string; return success */
     }
-  buf[buf_len - 1] = '\0';	/* ensure string is NUL terminated */
+  buf[buf_len - 1] = '\0';      /* ensure string is NUL terminated */
   return -UNW_ENOMEM;
 }
 
 static inline int
 get_proc_name (unw_addr_space_t as, unw_word_t ip,
-	       char *buf, size_t buf_len, unw_word_t *offp, void *arg)
+               char *buf, size_t buf_len, unw_word_t *offp, void *arg)
 {
-  unw_accessors_t *a = unw_get_accessors (as);
+  unw_accessors_t *a = unw_get_accessors_int (as);
   unw_proc_info_t pi;
   int ret;
 
-  buf[0] = '\0';	/* always return a valid string, even if it's empty */
+  buf[0] = '\0';        /* always return a valid string, even if it's empty */
 
   ret = unwi_find_dynamic_proc_info (as, ip, &pi, 1, arg);
   if (ret == 0)
@@ -61,25 +61,25 @@ get_proc_name (unw_addr_space_t as, unw_word_t ip,
       unw_dyn_info_t *di = pi.unwind_info;
 
       if (offp)
-	*offp = ip - pi.start_ip;
+        *offp = ip - pi.start_ip;
 
       switch (di->format)
-	{
-	case UNW_INFO_FORMAT_DYNAMIC:
-	  ret = intern_string (as, a, di->u.pi.name_ptr, buf, buf_len, arg);
-	  break;
-
-	case UNW_INFO_FORMAT_TABLE:
-	case UNW_INFO_FORMAT_REMOTE_TABLE:
-	  /* XXX should we create a fake name, e.g.: "tablenameN",
-	     where N is the index of the function in the table??? */
-	  ret = -UNW_ENOINFO;
-	  break;
-
-	default:
-	  ret = -UNW_EINVAL;
-	  break;
-	}
+        {
+        case UNW_INFO_FORMAT_DYNAMIC:
+          ret = intern_string (as, a, di->u.pi.name_ptr, buf, buf_len, arg);
+          break;
+
+        case UNW_INFO_FORMAT_TABLE:
+        case UNW_INFO_FORMAT_REMOTE_TABLE:
+          /* XXX should we create a fake name, e.g.: "tablenameN",
+             where N is the index of the function in the table??? */
+          ret = -UNW_ENOINFO;
+          break;
+
+        default:
+          ret = -UNW_EINVAL;
+          break;
+        }
       unwi_put_dynamic_unwind_info (as, &pi, arg);
       return ret;
     }
@@ -95,12 +95,24 @@ get_proc_name (unw_addr_space_t as, unw_word_t ip,
   return -UNW_ENOINFO;
 }
 
-PROTECTED int
+int
 unw_get_proc_name (unw_cursor_t *cursor, char *buf, size_t buf_len,
-		   unw_word_t *offp)
+                   unw_word_t *offp)
 {
   struct cursor *c = (struct cursor *) cursor;
-
-  return get_proc_name (tdep_get_as (c), tdep_get_ip (c), buf, buf_len, offp,
-			tdep_get_as_arg (c));
+  unw_word_t ip;
+  int error;
+
+  ip = tdep_get_ip (c);
+#if !defined(__ia64__)
+  if (c->dwarf.use_prev_instr)
+    --ip;
+#endif
+  error = get_proc_name (tdep_get_as (c), ip, buf, buf_len, offp,
+                         tdep_get_as_arg (c));
+#if !defined(__ia64__)
+  if (c->dwarf.use_prev_instr && offp != NULL && error == 0)
+    *offp += 1;
+#endif
+  return error;
 }
diff --git a/src/mi/Gget_reg.c b/src/mi/Gget_reg.c
index 021d913..9fc725c 100644
--- a/src/mi/Gget_reg.c
+++ b/src/mi/Gget_reg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_get_reg (unw_cursor_t *cursor, int regnum, unw_word_t *valp)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/mi/Gput_dynamic_unwind_info.c b/src/mi/Gput_dynamic_unwind_info.c
index 13a9c1a..ca377c9 100644
--- a/src/mi/Gput_dynamic_unwind_info.c
+++ b/src/mi/Gput_dynamic_unwind_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN void
 unwi_put_dynamic_unwind_info (unw_addr_space_t as, unw_proc_info_t *pi,
-			      void *arg)
+                              void *arg)
 {
   switch (pi->format)
     {
@@ -37,7 +37,7 @@ unwi_put_dynamic_unwind_info (unw_addr_space_t as, unw_proc_info_t *pi,
       unwi_dyn_remote_put_unwind_info (as, pi, arg);
 # else
       if (as != unw_local_addr_space)
-	unwi_dyn_remote_put_unwind_info (as, pi, arg);
+        unwi_dyn_remote_put_unwind_info (as, pi, arg);
 # endif
 #endif
       break;
diff --git a/src/mi/Gset_cache_size.c b/src/mi/Gset_cache_size.c
new file mode 100644
index 0000000..07b282e
--- /dev/null
+++ b/src/mi/Gset_cache_size.c
@@ -0,0 +1,72 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2014
+        Contributed by Milian Wolff <address@hidden>
+                   and Dave Watson <dade.watson@gmail.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "libunwind_i.h"
+
+int
+unw_set_cache_size (unw_addr_space_t as, size_t size, int flag)
+{
+  size_t power = 1;
+  unsigned short log_size = 0;
+
+  if (!tdep_init_done)
+    tdep_init ();
+
+  if (flag != 0)
+    return -1;
+
+  /* Currently not supported for per-thread cache due to memory leak */
+  /* A pthread-key destructor would work, but is not signal safe */
+#if defined(HAVE___THREAD) && HAVE___THREAD
+  return -1;
+#endif
+
+  /* Round up to next power of two, slowly but portably */
+  while(power < size)
+    {
+      power *= 2;
+      log_size++;
+      /* Largest size currently supported by rs_cache */
+      if (log_size >= 15)
+        break;
+    }
+
+#if !defined(__ia64__)
+  if (log_size == as->global_cache.log_size)
+    return 0;   /* no change */
+
+  as->global_cache.log_size = log_size;
+#endif
+
+  /* Ensure caches are empty (and initialized).  */
+  unw_flush_cache (as, 0, 0);
+#ifdef __ia64__
+  return 0;
+#else
+  /* Synchronously purge cache, to ensure memory is allocated */
+  return dwarf_flush_rs_cache(&as->global_cache);
+#endif
+}
diff --git a/src/mi/Gset_caching_policy.c b/src/mi/Gset_caching_policy.c
index 421c435..aa3d237 100644
--- a/src/mi/Gset_caching_policy.c
+++ b/src/mi/Gset_caching_policy.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,19 +25,19 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_set_caching_policy (unw_addr_space_t as, unw_caching_policy_t policy)
 {
   if (!tdep_init_done)
     tdep_init ();
 
-#ifndef HAVE___THREAD
+#if !(defined(HAVE___THREAD) && HAVE___THREAD)
   if (policy == UNW_CACHE_PER_THREAD)
     policy = UNW_CACHE_GLOBAL;
 #endif
 
   if (policy == as->caching_policy)
-    return 0;	/* no change */
+    return 0;   /* no change */
 
   as->caching_policy = policy;
   /* Ensure caches are empty (and initialized).  */
diff --git a/src/mi/Gset_fpreg.c b/src/mi/Gset_fpreg.c
index d3b202d..8c37afd 100644
--- a/src/mi/Gset_fpreg.c
+++ b/src/mi/Gset_fpreg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_set_fpreg (unw_cursor_t *cursor, int regnum, unw_fpreg_t val)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/mi/Gset_reg.c b/src/mi/Gset_reg.c
index 09fa09a..b1b1770 100644
--- a/src/mi/Gset_reg.c
+++ b/src/mi/Gset_reg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_set_reg (unw_cursor_t *cursor, int regnum, unw_word_t valp)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/mi/Lset_cache_size.c b/src/mi/Lset_cache_size.c
new file mode 100644
index 0000000..670f64d
--- /dev/null
+++ b/src/mi/Lset_cache_size.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gset_cache_size.c"
+#endif
diff --git a/src/mi/_ReadSLEB.c b/src/mi/_ReadSLEB.c
index ce08f33..c041e37 100644
--- a/src/mi/_ReadSLEB.c
+++ b/src/mi/_ReadSLEB.c
@@ -13,7 +13,7 @@ _ReadSLEB (unsigned char **dpp)
       result |= (byte & 0x7f) << shift;
       shift += 7;
       if ((byte & 0x80) == 0)
-	break;
+        break;
     }
 
   if (shift < 8 * sizeof (unw_word_t) && (byte & 0x40) != 0)
diff --git a/src/mi/_ReadULEB.c b/src/mi/_ReadULEB.c
index 8952e63..116f3e1 100644
--- a/src/mi/_ReadULEB.c
+++ b/src/mi/_ReadULEB.c
@@ -12,7 +12,7 @@ _ReadULEB (unsigned char **dpp)
       byte = *bp++;
       result |= (byte & 0x7f) << shift;
       if ((byte & 0x80) == 0)
-	break;
+        break;
       shift += 7;
     }
   *dpp = bp;
diff --git a/src/mi/backtrace.c b/src/mi/backtrace.c
index 91d6597..c7aa2bd 100644
--- a/src/mi/backtrace.c
+++ b/src/mi/backtrace.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -45,10 +45,10 @@ slow_backtrace (void **buffer, int size, unw_context_t *uc)
   while (unw_step (&cursor) > 0)
     {
       if (n >= size)
-	return n;
+        return n;
 
       if (unw_get_reg (&cursor, UNW_REG_IP, &ip) < 0)
-	return n;
+        return n;
       buffer[n++] = (void *) (uintptr_t) ip;
     }
   return n;
diff --git a/src/mi/dyn-cancel.c b/src/mi/dyn-cancel.c
index e784317..9d7472d 100644
--- a/src/mi/dyn-cancel.c
+++ b/src/mi/dyn-cancel.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
diff --git a/src/mi/dyn-info-list.c b/src/mi/dyn-info-list.c
index 5a5e30e..1c7c550 100644
--- a/src/mi/dyn-info-list.c
+++ b/src/mi/dyn-info-list.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
 
-PROTECTED unw_word_t
+unw_word_t
 _U_dyn_info_list_addr (void)
 {
   return (unw_word_t) (uintptr_t) &_U_dyn_info_list;
diff --git a/src/mi/dyn-register.c b/src/mi/dyn-register.c
index c28954a..efdad3d 100644
--- a/src/mi/dyn-register.c
+++ b/src/mi/dyn-register.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2001-2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -37,7 +37,7 @@ _U_dyn_register (unw_dyn_info_t *di)
     di->next = _U_dyn_info_list.first;
     di->prev = NULL;
     if (di->next)
-	    di->next->prev = di;
+            di->next->prev = di;
     _U_dyn_info_list.first = di;
   }
   mutex_unlock (&_U_dyn_info_list_lock);
diff --git a/src/mi/flush_cache.c b/src/mi/flush_cache.c
index 2e88fa8..f2b0115 100644
--- a/src/mi/flush_cache.c
+++ b/src/mi/flush_cache.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,26 +25,29 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED void
+void
 unw_flush_cache (unw_addr_space_t as, unw_word_t lo, unw_word_t hi)
 {
 #if !UNW_TARGET_IA64
   struct unw_debug_frame_list *w = as->debug_frames;
-#endif
 
-  /* clear dyn_info_list_addr cache: */
-  as->dyn_info_list_addr = 0;
-
-#if !UNW_TARGET_IA64
-  for (; w; w = w->next)
+  while (w)
     {
+      struct unw_debug_frame_list *n = w->next;
+
       if (w->index)
-        free (w->index);
-      free (w->debug_frame);
+        munmap (w->index, w->index_size);
+
+      munmap (w->debug_frame, w->debug_frame_size);
+      munmap (w, sizeof (*w));
+      w = n;
     }
   as->debug_frames = NULL;
 #endif
 
+  /* clear dyn_info_list_addr cache: */
+  as->dyn_info_list_addr = 0;
+
   /* This lets us flush caches lazily.  The implementation currently
      ignores the flush range arguments (lo-hi).  This is OK because
      unw_flush_cache() is allowed to flush more than the requested
diff --git a/src/mi/init.c b/src/mi/init.c
index 4bf97c4..60a48c5 100644
--- a/src/mi/init.c
+++ b/src/mi/init.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -32,7 +32,7 @@ static const char rcsid[] UNUSED =
 
 #if UNW_DEBUG
 
-/* Must not be declared HIDDEN/PROTECTED because libunwind.so and
+/* Must not be declared HIDDEN because libunwind.so and
    libunwind-PLATFORM.so will both define their own copies of this
    variable and we want to use only one or the other when both
    libraries are loaded.  */
diff --git a/src/mi/mempool.c b/src/mi/mempool.c
index dbc183f..536b64e 100644
--- a/src/mi/mempool.c
+++ b/src/mi/mempool.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2003, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
    Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
 
 This file is part of libunwind.
@@ -30,13 +30,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
  * __BIGGEST_ALIGNMENT__, which is the largest alignment ever used for any data
  * type on the target machine you are compiling for.'' */
 #ifdef __BIGGEST_ALIGNMENT__
-# define MAX_ALIGN	__BIGGEST_ALIGNMENT__
+# define MAX_ALIGN      __BIGGEST_ALIGNMENT__
 #else
 /* Crude hack to check that MAX_ALIGN is power-of-two.
  * sizeof(long double) = 12 on i386. */
-# define MAX_ALIGN_(n)	(n < 8 ? 8 : \
-			 n < 16 ? 16 : n)
-# define MAX_ALIGN	MAX_ALIGN_(sizeof (long double))
+# define MAX_ALIGN_(n)  (n < 8 ? 8 : \
+                         n < 16 ? 16 : n)
+# define MAX_ALIGN      MAX_ALIGN_(sizeof (long double))
 #endif
 
 static char sos_memory[SOS_MEMORY_SIZE] ALIGNED(MAX_ALIGN);
@@ -64,9 +64,9 @@ sos_alloc (size_t size)
     /* No assumptions about `sos_memory' alignment. */
     if (sos_memory_freepos == 0)
       {
-	unsigned align = UNW_ALIGN((uintptr_t) &sos_memory[0], MAX_ALIGN)
-				- (uintptr_t) &sos_memory[0];
-	sos_memory_freepos = align;
+        unsigned align = UNW_ALIGN((uintptr_t) &sos_memory[0], MAX_ALIGN)
+                                - (uintptr_t) &sos_memory[0];
+        sos_memory_freepos = align;
       }
     pos = sos_memory_freepos;
     sos_memory_freepos += size;
@@ -114,11 +114,11 @@ expand (struct mempool *pool)
       size = UNW_ALIGN(pool->obj_size, pg_size);
       GET_MEMORY (mem, size);
       if (!mem)
-	{
-	  /* last chance: try to allocate one object from the SOS memory */
-	  size = pool->obj_size;
-	  mem = sos_alloc (size);
-	}
+        {
+          /* last chance: try to allocate one object from the SOS memory */
+          size = pool->obj_size;
+          mem = sos_alloc (size);
+        }
     }
   add_memory (pool, mem, size, pool->obj_size);
 }
@@ -140,7 +140,7 @@ mempool_init (struct mempool *pool, size_t obj_size, size_t reserve)
     {
       reserve = pg_size / obj_size / 4;
       if (!reserve)
-	reserve = 16;
+        reserve = 16;
     }
 
   pool->obj_size = obj_size;
diff --git a/src/mi/strerror.c b/src/mi/strerror.c
index ef64716..2cec73d 100644
--- a/src/mi/strerror.c
+++ b/src/mi/strerror.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 BEA Systems
-	Contributed by Thomas Hallgren <thallgre@bea.com>
+        Contributed by Thomas Hallgren <thallgre@bea.com>
 
 This file is part of libunwind.
 
@@ -34,18 +34,18 @@ unw_strerror (int err_code)
   unw_error_t error = (unw_error_t)-err_code;
   switch (error)
     {
-    case UNW_ESUCCESS:	   cp = "no error"; break;
-    case UNW_EUNSPEC:	   cp = "unspecified (general) error"; break;
-    case UNW_ENOMEM:	   cp = "out of memory"; break;
-    case UNW_EBADREG:	   cp = "bad register number"; break;
+    case UNW_ESUCCESS:     cp = "no error"; break;
+    case UNW_EUNSPEC:      cp = "unspecified (general) error"; break;
+    case UNW_ENOMEM:       cp = "out of memory"; break;
+    case UNW_EBADREG:      cp = "bad register number"; break;
     case UNW_EREADONLYREG: cp = "attempt to write read-only register"; break;
     case UNW_ESTOPUNWIND:  cp = "stop unwinding"; break;
     case UNW_EINVALIDIP:   cp = "invalid IP"; break;
-    case UNW_EBADFRAME:	   cp = "bad frame"; break;
-    case UNW_EINVAL:	   cp = "unsupported operation or bad value"; break;
+    case UNW_EBADFRAME:    cp = "bad frame"; break;
+    case UNW_EINVAL:       cp = "unsupported operation or bad value"; break;
     case UNW_EBADVERSION:  cp = "unwind info has unsupported version"; break;
-    case UNW_ENOINFO:	   cp = "no unwind info found"; break;
-    default:		   cp = "invalid error code";
+    case UNW_ENOINFO:      cp = "no unwind info found"; break;
+    default:               cp = "invalid error code";
     }
   return cp;
 }
diff --git a/src/mips/Gapply_reg_state.c b/src/mips/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/mips/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/mips/Gcreate_addr_space.c b/src/mips/Gcreate_addr_space.c
index 371841d..c2408b9 100644
--- a/src/mips/Gcreate_addr_space.c
+++ b/src/mips/Gcreate_addr_space.c
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED unw_addr_space_t
+unw_addr_space_t
 unw_create_addr_space (unw_accessors_t *a, int byte_order)
 {
 #ifdef UNW_LOCAL_ONLY
@@ -58,7 +58,15 @@ unw_create_addr_space (unw_accessors_t *a, int byte_order)
     as->big_endian = (byte_order == __BIG_ENDIAN);
 
   /* FIXME!  There is no way to specify the ABI.  */
+#if _MIPS_SIM == _ABIO32
   as->abi = UNW_MIPS_ABI_O32;
+#elif _MIPS_SIM == _ABIN32
+  as->abi = UNW_MIPS_ABI_N32;
+#elif _MIPS_SIM == _ABI64
+  as->abi = UNW_MIPS_ABI_N64;
+#else
+# error Unsupported ABI
+#endif
   as->addr_size = 4;
 
   return as;
diff --git a/src/mips/Gget_proc_info.c b/src/mips/Gget_proc_info.c
index 973ddd9..04c4326 100644
--- a/src/mips/Gget_proc_info.c
+++ b/src/mips/Gget_proc_info.c
@@ -24,17 +24,20 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
   struct cursor *c = (struct cursor *) cursor;
   int ret;
 
-  /* We can only unwind using Dwarf into on MIPS: return failure code
-     if it's not present.  */
   ret = dwarf_make_proc_info (&c->dwarf);
-  if (ret < 0)
-    return ret;
+  if (ret < 0) {
+    /* Construct a dummy proc info if Dwarf failed */
+    memset (pi, 0, sizeof (*pi));
+    pi->start_ip = c->dwarf.ip;
+    pi->end_ip = c->dwarf.ip + 4;
+    return 0;
+  }
 
   *pi = c->dwarf.pi;
   return 0;
diff --git a/src/mips/Gget_save_loc.c b/src/mips/Gget_save_loc.c
index 0f90847..c21f9b0 100644
--- a/src/mips/Gget_save_loc.c
+++ b/src/mips/Gget_save_loc.c
@@ -26,13 +26,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 /* FIXME for MIPS.  */
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   struct cursor *c = (struct cursor *) cursor;
   dwarf_loc_t loc;
 
-  loc = DWARF_NULL_LOC;		/* default to "not saved" */
+  loc = DWARF_NULL_LOC;         /* default to "not saved" */
 
   switch (reg)
     {
diff --git a/src/mips/Gglobal.c b/src/mips/Gglobal.c
index f223157..fa9478e 100644
--- a/src/mips/Gglobal.c
+++ b/src/mips/Gglobal.c
@@ -48,7 +48,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     mips_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&mips_lock, saved_mask);
diff --git a/src/mips/Ginit.c b/src/mips/Ginit.c
index dc9c125..3df170c 100644
--- a/src/mips/Ginit.c
+++ b/src/mips/Ginit.c
@@ -30,13 +30,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 /* Return the address of the 64-bit slot in UC for REG (even for o32,
    where registers are 32-bit, the slots are still 64-bit).  */
@@ -59,7 +59,7 @@ tdep_uc_addr (ucontext_t *uc, int reg)
 {
   char *addr = uc_addr (uc, reg);
 
-  if (reg >= UNW_MIPS_R0 && reg <= UNW_MIPS_R31
+  if (((reg >= UNW_MIPS_R0 && reg <= UNW_MIPS_R31) || reg == UNW_MIPS_PC)
       && tdep_big_endian (unw_local_addr_space)
       && unw_local_addr_space->abi == UNW_MIPS_ABI_O32)
     addr += 4;
@@ -84,7 +84,7 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) (intptr_t) &_U_dyn_info_list;
   return 0;
@@ -92,7 +92,7 @@ get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (write)
     {
@@ -109,7 +109,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   unw_word_t *addr;
   ucontext_t *uc = arg;
@@ -140,7 +140,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = arg;
   unw_fpreg_t *addr;
@@ -154,14 +154,14 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   if (write)
     {
       Debug (12, "%s <- %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
       *(unw_fpreg_t *) (intptr_t) addr = *val;
     }
   else
     {
       *val = *(unw_fpreg_t *) (intptr_t) addr;
       Debug (12, "%s -> %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
     }
   return 0;
 
@@ -173,8 +173,8 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
 
   return elf_w (get_proc_name) (as, getpid (), ip, buf, buf_len, offp);
@@ -195,7 +195,7 @@ mips_local_addr_space_init (void)
 # error Unsupported ABI
 #endif
   local_addr_space.addr_size = sizeof (void *);
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
diff --git a/src/mips/Ginit_local.c b/src/mips/Ginit_local.c
index e5e1c5a..f3153b5 100644
--- a/src/mips/Ginit_local.c
+++ b/src/mips/Ginit_local.c
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 {
   return -UNW_EINVAL;
@@ -35,8 +35,8 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 
 #else /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
-unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+static int
+unw_init_local_common(unw_cursor_t *cursor, ucontext_t *uc, unsigned use_prev_instr)
 {
   struct cursor *c = (struct cursor *) cursor;
 
@@ -47,7 +47,30 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 
   c->dwarf.as = unw_local_addr_space;
   c->dwarf.as_arg = uc;
-  return common_init (c, 1);
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local(unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
 }
 
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/mips/Ginit_remote.c b/src/mips/Ginit_remote.c
index f284e99..9b8ba5b 100644
--- a/src/mips/Ginit_remote.c
+++ b/src/mips/Ginit_remote.c
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "init.h"
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/mips/Gis_signal_frame.c b/src/mips/Gis_signal_frame.c
index fef542b..c0e3b98 100644
--- a/src/mips/Gis_signal_frame.c
+++ b/src/mips/Gis_signal_frame.c
@@ -1,4 +1,5 @@
 /* libunwind - a platform-independent unwind library
+   Copyright (C) 2015 Imagination Technologies Limited
    Copyright (C) 2008 CodeSourcery
 
 This file is part of libunwind.
@@ -25,11 +26,53 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include <stdio.h>
 
-/* FIXME for MIPS.  */
-
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
-  printf ("%s: implement me\n", __FUNCTION__);
-  return -UNW_ENOINFO;
+  struct cursor *c = (struct cursor *) cursor;
+  unw_word_t w0, w1, ip;
+  unw_addr_space_t as;
+  unw_accessors_t *a;
+  void *arg;
+  int ret;
+
+  as = c->dwarf.as;
+  a = unw_get_accessors_int (as);
+  arg = c->dwarf.as_arg;
+
+  ip = c->dwarf.ip;
+
+  /* syscall */
+  if ((ret = (*a->access_mem) (as, ip + 4, &w1, 0, arg)) < 0)
+    return 0;
+  if ((w1 & 0xffffffff) != 0x0c)
+    return 0;
+
+  /* li v0, 0x1061 (rt) or li v0, 0x1017 */
+  if ((ret = (*a->access_mem) (as, ip, &w0, 0, arg)) < 0)
+    return 0;
+
+  switch (c->dwarf.as->abi)
+    {
+    case UNW_MIPS_ABI_O32:
+      switch (w0 & 0xffffffff)
+        {
+        case 0x24021061:
+          return 1;
+        case 0x24021017:
+          return 2;
+        default:
+          return 0;
+        }
+    case UNW_MIPS_ABI_N64:
+      switch (w0 & 0xffffffff)
+        {
+        case 0x2402145b:
+          return 1;
+        default:
+          return 0;
+        }
+    default:
+      return 0;
+    }
 }
diff --git a/src/mips/Greg_states_iterate.c b/src/mips/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/mips/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/mips/Gregs.c b/src/mips/Gregs.c
index 0dfc4a9..e967324 100644
--- a/src/mips/Gregs.c
+++ b/src/mips/Gregs.c
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   dwarf_loc_t loc = DWARF_NULL_LOC;
   
@@ -63,16 +63,19 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     case UNW_MIPS_R26:
     case UNW_MIPS_R27:
     case UNW_MIPS_R28:
-    case UNW_MIPS_R29:
+
     case UNW_MIPS_R30:
     case UNW_MIPS_R31:
       loc = c->dwarf.loc[reg - UNW_MIPS_R0];
       break;
 
     case UNW_MIPS_PC:
+      if (write)
+	c->dwarf.ip = *valp;            /* update the IP cache */
       loc = c->dwarf.loc[reg];
       break;
 
+    case UNW_MIPS_R29:
     case UNW_MIPS_CFA:
       if (write)
         return -UNW_EREADONLYREG;
@@ -96,7 +99,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   Debug (1, "bad register number %u\n", reg);
   return -UNW_EBADREG;
diff --git a/src/mips/Gresume.c b/src/mips/Gresume.c
index b822e24..cb70abc 100644
--- a/src/mips/Gresume.c
+++ b/src/mips/Gresume.c
@@ -38,7 +38,7 @@ mips_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
 
 #endif /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   return -UNW_EINVAL;
diff --git a/src/mips/Gstep.c b/src/mips/Gstep.c
index bafeef1..f5a742e 100644
--- a/src/mips/Gstep.c
+++ b/src/mips/Gstep.c
@@ -1,4 +1,5 @@
 /* libunwind - a platform-independent unwind library
+   Copyright (C) 2015 Imagination Technologies Limited
    Copyright (C) 2008 CodeSourcery
 
 This file is part of libunwind.
@@ -25,24 +26,193 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include "offsets.h"
 
-PROTECTED int
-unw_step (unw_cursor_t *cursor)
+static int
+mips_handle_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
+  unw_word_t sc_addr, sp_addr = c->dwarf.cfa;
+  unw_word_t ra, fp;
+  int ret;
+
+  switch (unw_is_signal_frame (cursor)) {
+  case 1:
+    sc_addr = sp_addr + LINUX_SF_TRAMP_SIZE + sizeof (siginfo_t) +
+              LINUX_UC_MCONTEXT_OFF;
+    break;
+  case 2:
+    sc_addr = sp_addr + LINUX_UC_MCONTEXT_OFF;
+    break;
+  default:
+    return -UNW_EUNSPEC;
+  }
+
+  if (tdep_big_endian(c->dwarf.as))
+    sc_addr += 4;
+
+  c->sigcontext_addr = sc_addr;
+
+  /* Update the dwarf cursor. */
+  c->dwarf.loc[UNW_MIPS_R0]  = DWARF_LOC (sc_addr + LINUX_SC_R0_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R1]  = DWARF_LOC (sc_addr + LINUX_SC_R1_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R2]  = DWARF_LOC (sc_addr + LINUX_SC_R2_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R3]  = DWARF_LOC (sc_addr + LINUX_SC_R3_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R4]  = DWARF_LOC (sc_addr + LINUX_SC_R4_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R5]  = DWARF_LOC (sc_addr + LINUX_SC_R5_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R6]  = DWARF_LOC (sc_addr + LINUX_SC_R6_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R7]  = DWARF_LOC (sc_addr + LINUX_SC_R7_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R8]  = DWARF_LOC (sc_addr + LINUX_SC_R8_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R9]  = DWARF_LOC (sc_addr + LINUX_SC_R9_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R10] = DWARF_LOC (sc_addr + LINUX_SC_R10_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R11] = DWARF_LOC (sc_addr + LINUX_SC_R11_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R12] = DWARF_LOC (sc_addr + LINUX_SC_R12_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R13] = DWARF_LOC (sc_addr + LINUX_SC_R13_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R14] = DWARF_LOC (sc_addr + LINUX_SC_R14_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R15] = DWARF_LOC (sc_addr + LINUX_SC_R15_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R16] = DWARF_LOC (sc_addr + LINUX_SC_R16_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R17] = DWARF_LOC (sc_addr + LINUX_SC_R17_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R18] = DWARF_LOC (sc_addr + LINUX_SC_R18_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R19] = DWARF_LOC (sc_addr + LINUX_SC_R19_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R20] = DWARF_LOC (sc_addr + LINUX_SC_R20_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R21] = DWARF_LOC (sc_addr + LINUX_SC_R21_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R22] = DWARF_LOC (sc_addr + LINUX_SC_R22_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R23] = DWARF_LOC (sc_addr + LINUX_SC_R23_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R24] = DWARF_LOC (sc_addr + LINUX_SC_R24_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R25] = DWARF_LOC (sc_addr + LINUX_SC_R25_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R26] = DWARF_LOC (sc_addr + LINUX_SC_R26_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R27] = DWARF_LOC (sc_addr + LINUX_SC_R27_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R28] = DWARF_LOC (sc_addr + LINUX_SC_R28_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R29] = DWARF_LOC (sc_addr + LINUX_SC_R29_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R30] = DWARF_LOC (sc_addr + LINUX_SC_R30_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_R31] = DWARF_LOC (sc_addr + LINUX_SC_R31_OFF, 0);
+  c->dwarf.loc[UNW_MIPS_PC] = DWARF_LOC (sc_addr + LINUX_SC_PC_OFF, 0);
+
+  /* Set SP/CFA and PC/IP. */
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_MIPS_R29], &c->dwarf.cfa);
+
+  if ((ret = dwarf_get(&c->dwarf, DWARF_LOC(sc_addr + LINUX_SC_PC_OFF, 0),
+                       &c->dwarf.ip)) < 0)
+    return ret;
+
+  if ((ret = dwarf_get(&c->dwarf, DWARF_LOC(sc_addr + LINUX_SC_R31_OFF, 0),
+                       &ra)) < 0)
+    return ret;
+  if ((ret = dwarf_get(&c->dwarf, DWARF_LOC(sc_addr + LINUX_SC_R30_OFF, 0),
+                       &fp)) < 0)
+    return ret;
+
+  Debug (2, "SH (ip=0x%016llx, ra=0x%016llx, sp=0x%016llx, fp=0x%016llx)\n",
+         (unsigned long long)c->dwarf.ip, (unsigned long long)ra,
+         (unsigned long long)c->dwarf.cfa, (unsigned long long)fp);
+
+  c->dwarf.pi_valid = 0;
+  c->dwarf.use_prev_instr = 0;
+
+  return 1;
+}
+
+
+int _step_n64(struct cursor *c)
+{
+  //TODO:handle plt entry
+  struct dwarf_loc fp_loc, pc_loc;
   int ret;
+  unw_word_t fp = 0;
+  unw_word_t ra = 0;
+
+  ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_MIPS_R30], &fp);
+  if (ret < 0)
+    {
+      Debug (2, "returning %d [FP=0x%lx]\n", ret,
+             DWARF_GET_LOC (c->dwarf.loc[UNW_MIPS_R30]));
+      return ret;
+    }
+  ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_MIPS_R31], &ra);
+  if (ret < 0)
+    {
+      Debug (2, "returning %d [RA=0x%lx]\n", ret,
+             DWARF_GET_LOC (c->dwarf.loc[UNW_MIPS_R31]));
+      return ret;
+    }
+
+  if (!fp) {
+    fp_loc = DWARF_NULL_LOC;
+    pc_loc = DWARF_NULL_LOC;
+  } else {
+    fp_loc = DWARF_LOC(fp+16, 0);
+    pc_loc = DWARF_LOC (fp+24, 0);
+#if UNW_DEBUG
+    unw_word_t fp1 = 0;
+    ret = dwarf_get (&c->dwarf, fp_loc, &fp1);
+    Debug (1, "RET:%d [FP=0x%lx] = 0x%lx (cfa = 0x%lx) -> 0x%lx. SAVED PC:0x%lx\n",
+           ret,
+           (unsigned long) DWARF_GET_LOC (c->dwarf.loc[UNW_MIPS_R30]),
+           fp, c->dwarf.cfa, fp1, ra);
+#endif
+    /* Heuristic to determine incorrect guess.  For FP to be a
+       valid frame it needs to be above current CFA, but don't
+       let it go more than a little.  Note that we can't deduce
+       anything about new FP (fp1) since it may not be a frame
+       pointer in the frame above.  Just check we get the value. */
+    if (ret < 0
+        || fp < c->dwarf.cfa
+        || (fp - c->dwarf.cfa) > 0x4000)
+      {
+        pc_loc = DWARF_NULL_LOC;
+        fp_loc = DWARF_NULL_LOC;
+      }
+  }
+
+  c->dwarf.loc[UNW_MIPS_R30] = fp_loc;
+
+  c->dwarf.loc[UNW_MIPS_PC] = c->dwarf.loc[UNW_MIPS_R31];
+  c->dwarf.loc[UNW_MIPS_R31] = pc_loc;
+  c->dwarf.use_prev_instr = 1;
+
+  if (DWARF_IS_NULL_LOC (c->dwarf.loc[UNW_MIPS_R30]))
+    {
+      ret = 0;
+      Debug (2, "NULL %%fp loc, returning %d\n", ret);
+      return ret;
+    }
 
-  Debug (1, "(cursor=%p)\n", c);
+  if (!DWARF_IS_NULL_LOC (c->dwarf.loc[UNW_MIPS_PC]))
+    {
+      ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_MIPS_PC], &c->dwarf.ip);
+      Debug (1, "Frame Chain [IP=0x%Lx] = 0x%Lx\n",
+             (unsigned long long) DWARF_GET_LOC (c->dwarf.loc[UNW_MIPS_PC]),
+             (unsigned long long) c->dwarf.ip);
+      if (ret < 0)
+        {
+          Debug (2, "returning %d\n", ret);
+          return ret;
+        }
+      ret = 1;
+    }
+  else {
+    c->dwarf.ip = 0;
+  }
+  return (c->dwarf.ip == 0) ? 0 : 1;
+}
+
+int
+unw_step (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
 
-  /* Try DWARF-based unwinding...  this is the only method likely to work for
-     MIPS.  */
-  ret = dwarf_step (&c->dwarf);
+  ret = mips_handle_signal_frame (cursor);
+  if (ret < 0)
+    /* Not a signal frame, try DWARF-based unwinding. */
+    ret = dwarf_step (&c->dwarf);
 
   if (unlikely (ret == -UNW_ESTOPUNWIND))
     return ret;
 
-  /* Dwarf unwinding didn't work, stop.  */
+#if _MIPS_SIM == _ABI64
   if (unlikely (ret < 0))
-    return 0;
-
+    {
+      return _step_n64(c);
+    }
+#endif
   return (c->dwarf.ip == 0) ? 0 : 1;
 }
diff --git a/src/mips/Lapply_reg_state.c b/src/mips/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/mips/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/mips/Lreg_states_iterate.c b/src/mips/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/mips/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/mips/init.h b/src/mips/init.h
index 95322c6..30c193a 100644
--- a/src/mips/init.h
+++ b/src/mips/init.h
@@ -41,14 +41,13 @@ common_init (struct cursor *c, unsigned use_prev_instr)
     return ret;
 
   ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_MIPS_R29),
-		   &c->dwarf.cfa);
+                   &c->dwarf.cfa);
   if (ret < 0)
     return ret;
 
   /* FIXME: Initialisation for other registers.  */
 
   c->dwarf.args_size = 0;
-  c->dwarf.ret_addr_column = 0;
   c->dwarf.stash_frames = 0;
   c->dwarf.use_prev_instr = use_prev_instr;
   c->dwarf.pi_valid = 0;
diff --git a/src/mips/is_fpreg.c b/src/mips/is_fpreg.c
index 3acc696..a92dd5e 100644
--- a/src/mips/is_fpreg.c
+++ b/src/mips/is_fpreg.c
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 /* FIXME: I'm not sure if libunwind's GP/FP register distinction is very useful
    on MIPS.  */
 
-PROTECTED int
+int
 unw_is_fpreg (int regnum)
 {
   /* FIXME: Support FP.  */
diff --git a/src/mips/offsets.h b/src/mips/offsets.h
index 49af970..b506051 100644
--- a/src/mips/offsets.h
+++ b/src/mips/offsets.h
@@ -9,34 +9,78 @@
 
 /* Offsets for MIPS Linux "ucontext_t":  */
 
+/* First 24 bytes in sigframe are argument save space and padding for
+what used to be signal trampolines. Ref: arch/mips/kernel/signal.c */
+#define LINUX_SF_TRAMP_SIZE 0x18
+
 #if _MIPS_SIM == _ABIO32
 
-# define LINUX_UC_FLAGS_OFF	0x0
-# define LINUX_UC_LINK_OFF	0x4
-# define LINUX_UC_STACK_OFF	0x8
-# define LINUX_UC_MCONTEXT_OFF	0x18
-# define LINUX_UC_SIGMASK_OFF	0x268
-# define LINUX_UC_MCONTEXT_PC	0x20
-# define LINUX_UC_MCONTEXT_GREGS	0x28
+# define LINUX_UC_FLAGS_OFF     0x0
+# define LINUX_UC_LINK_OFF      0x4
+# define LINUX_UC_STACK_OFF     0x8
+# define LINUX_UC_MCONTEXT_OFF  0x18
+# define LINUX_UC_SIGMASK_OFF   0x268
+# define LINUX_UC_MCONTEXT_PC   0x20
+# define LINUX_UC_MCONTEXT_GREGS        0x28
 
 #elif _MIPS_SIM == _ABIN32
 
-# define LINUX_UC_FLAGS_OFF	0x0
-# define LINUX_UC_LINK_OFF	0x4
-# define LINUX_UC_STACK_OFF	0x8
-# define LINUX_UC_MCONTEXT_OFF	0x18
-# define LINUX_UC_SIGMASK_OFF	0x270
-# define LINUX_UC_MCONTEXT_PC	0x258
-# define LINUX_UC_MCONTEXT_GREGS	0x18
+# define LINUX_UC_FLAGS_OFF     0x0
+# define LINUX_UC_LINK_OFF      0x4
+# define LINUX_UC_STACK_OFF     0x8
+# define LINUX_UC_MCONTEXT_OFF  0x18
+# define LINUX_UC_SIGMASK_OFF   0x270
+# define LINUX_UC_MCONTEXT_PC   0x258
+# define LINUX_UC_MCONTEXT_GREGS        0x18
 
 #elif _MIPS_SIM == _ABI64
 
-# define LINUX_UC_FLAGS_OFF	0x0
-# define LINUX_UC_LINK_OFF	0x8
-# define LINUX_UC_STACK_OFF	0x10
-# define LINUX_UC_MCONTEXT_OFF	0x28
-# define LINUX_UC_SIGMASK_OFF	0x280
-# define LINUX_UC_MCONTEXT_PC	0x268
-# define LINUX_UC_MCONTEXT_GREGS	0x28
+# define LINUX_UC_FLAGS_OFF     0x0
+# define LINUX_UC_LINK_OFF      0x8
+# define LINUX_UC_STACK_OFF     0x10
+# define LINUX_UC_MCONTEXT_OFF  0x28
+# define LINUX_UC_SIGMASK_OFF   0x280
+# define LINUX_UC_MCONTEXT_PC   0x268
+# define LINUX_UC_MCONTEXT_GREGS        0x28
+
+#else
+
+#error Unsupported ABI
 
 #endif
+
+#define LINUX_SC_R0_OFF   (LINUX_UC_MCONTEXT_GREGS - LINUX_UC_MCONTEXT_OFF)
+#define LINUX_SC_R1_OFF   (LINUX_SC_R0_OFF + 1*8)
+#define LINUX_SC_R2_OFF   (LINUX_SC_R0_OFF + 2*8)
+#define LINUX_SC_R3_OFF   (LINUX_SC_R0_OFF + 3*8)
+#define LINUX_SC_R4_OFF   (LINUX_SC_R0_OFF + 4*8)
+#define LINUX_SC_R5_OFF   (LINUX_SC_R0_OFF + 5*8)
+#define LINUX_SC_R6_OFF   (LINUX_SC_R0_OFF + 6*8)
+#define LINUX_SC_R7_OFF   (LINUX_SC_R0_OFF + 7*8)
+#define LINUX_SC_R8_OFF   (LINUX_SC_R0_OFF + 8*8)
+#define LINUX_SC_R9_OFF   (LINUX_SC_R0_OFF + 9*8)
+#define LINUX_SC_R10_OFF  (LINUX_SC_R0_OFF + 10*8)
+#define LINUX_SC_R11_OFF  (LINUX_SC_R0_OFF + 11*8)
+#define LINUX_SC_R12_OFF  (LINUX_SC_R0_OFF + 12*8)
+#define LINUX_SC_R13_OFF  (LINUX_SC_R0_OFF + 13*8)
+#define LINUX_SC_R14_OFF  (LINUX_SC_R0_OFF + 14*8)
+#define LINUX_SC_R15_OFF  (LINUX_SC_R0_OFF + 15*8)
+#define LINUX_SC_R16_OFF  (LINUX_SC_R0_OFF + 16*8)
+#define LINUX_SC_R17_OFF  (LINUX_SC_R0_OFF + 17*8)
+#define LINUX_SC_R18_OFF  (LINUX_SC_R0_OFF + 18*8)
+#define LINUX_SC_R19_OFF  (LINUX_SC_R0_OFF + 19*8)
+#define LINUX_SC_R20_OFF  (LINUX_SC_R0_OFF + 20*8)
+#define LINUX_SC_R21_OFF  (LINUX_SC_R0_OFF + 21*8)
+#define LINUX_SC_R22_OFF  (LINUX_SC_R0_OFF + 22*8)
+#define LINUX_SC_R23_OFF  (LINUX_SC_R0_OFF + 23*8)
+#define LINUX_SC_R24_OFF  (LINUX_SC_R0_OFF + 24*8)
+#define LINUX_SC_R25_OFF  (LINUX_SC_R0_OFF + 25*8)
+#define LINUX_SC_R26_OFF  (LINUX_SC_R0_OFF + 26*8)
+#define LINUX_SC_R27_OFF  (LINUX_SC_R0_OFF + 27*8)
+#define LINUX_SC_R28_OFF  (LINUX_SC_R0_OFF + 28*8)
+#define LINUX_SC_R29_OFF  (LINUX_SC_R0_OFF + 29*8)
+#define LINUX_SC_R30_OFF  (LINUX_SC_R0_OFF + 30*8)
+#define LINUX_SC_R31_OFF  (LINUX_SC_R0_OFF + 31*8)
+
+#define LINUX_SC_SP_OFF   LINUX_SC_R29_OFF
+#define LINUX_SC_PC_OFF   (LINUX_UC_MCONTEXT_PC - LINUX_UC_MCONTEXT_OFF)
diff --git a/src/mips/regname.c b/src/mips/regname.c
index a4a6334..b137b97 100644
--- a/src/mips/regname.c
+++ b/src/mips/regname.c
@@ -36,7 +36,7 @@ static const char *regname[] =
     "$24",  "$25",  "$26", "$27",  "$28",  "$29",  "$30",  "$31",
   };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
diff --git a/src/mips/unwind_i.h b/src/mips/unwind_i.h
index fc9ab0b..3382dcf 100644
--- a/src/mips/unwind_i.h
+++ b/src/mips/unwind_i.h
@@ -31,12 +31,12 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-#define mips_lock			UNW_OBJ(lock)
-#define mips_local_resume		UNW_OBJ(local_resume)
-#define mips_local_addr_space_init	UNW_OBJ(local_addr_space_init)
+#define mips_lock                       UNW_OBJ(lock)
+#define mips_local_resume               UNW_OBJ(local_resume)
+#define mips_local_addr_space_init      UNW_OBJ(local_addr_space_init)
 
 extern int mips_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			     void *arg);
+                             void *arg);
 
 extern void mips_local_addr_space_init (void);
 
diff --git a/src/os-freebsd.c b/src/os-freebsd.c
index 76cdd23..753e819 100644
--- a/src/os-freebsd.c
+++ b/src/os-freebsd.c
@@ -56,7 +56,7 @@ get_pid_by_tid(int tid)
   size_t len, len1;
   char *buf;
   struct kinfo_proc *kv;
-  int i, pid;
+  unsigned i, pid;
 
   len = 0;
   mib[0] = CTL_KERN;
@@ -88,9 +88,9 @@ get_pid_by_tid(int tid)
   return (pid);
 }
 
-PROTECTED int
+int
 tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-		    unsigned long *segbase, unsigned long *mapoff, char *path, size_t pathlen)
+                    unsigned long *segbase, unsigned long *mapoff, char *path, size_t pathlen)
 {
   int mib[4], error, ret;
   size_t len, len1;
@@ -110,7 +110,7 @@ tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
       if (mib[3] != -1)
         error = sysctl(mib, 4, NULL, &len, NULL, 0);
       if (error == -1)
-	return (-UNW_EUNSPEC);
+        return (-UNW_EUNSPEC);
     } else
       return (-UNW_EUNSPEC);
   }
@@ -143,3 +143,24 @@ tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
   free_mem(buf, len1);
   return (ret);
 }
+
+#ifndef UNW_REMOTE_ONLY
+
+void
+tdep_get_exe_image_path (char *path)
+{
+  int mib[4], error;
+  size_t len;
+
+  len = 0;
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_PATHNAME;
+  mib[3] = getpid();
+
+  error = sysctl(mib, 4, path, &len, NULL, 0);
+  if (error == -1)
+	  path[0] = 0;
+}
+
+#endif
diff --git a/src/os-hpux.c b/src/os-hpux.c
index 11b1177..48bfb05 100644
--- a/src/os-hpux.c
+++ b/src/os-hpux.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -33,8 +33,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-		    unsigned long *segbase, unsigned long *mapoff,
-		    char *path, size_t pathlen)
+                    unsigned long *segbase, unsigned long *mapoff,
+                    char *path, size_t pathlen)
 {
   struct load_module_desc lmd;
   const char *path2;
@@ -49,7 +49,7 @@ tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
     return -UNW_ENOINFO;
 
   *segbase = lmd.text_base;
-  *mapoff = 0;			/* XXX fix me? */
+  *mapoff = 0;                  /* XXX fix me? */
 
   path2 = dlgetname (&lmd, sizeof (lmd), NULL, 0, 0);
   if (!path2)
@@ -65,3 +65,14 @@ tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
 
   return elf_map_image (ei, path);
 }
+
+#ifndef UNW_REMOTE_ONLY
+
+void
+tdep_get_exe_image_path (char *path)
+{
+  path[0] = 0; /* XXX */
+}
+
+#endif
+
diff --git a/src/os-linux.c b/src/os-linux.c
index bcc4036..8a00669 100644
--- a/src/os-linux.c
+++ b/src/os-linux.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -29,10 +29,10 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "libunwind_i.h"
 #include "os-linux.h"
 
-PROTECTED int
+int
 tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
-		    unsigned long *segbase, unsigned long *mapoff,
-		    char *path, size_t pathlen)
+                    unsigned long *segbase, unsigned long *mapoff,
+                    char *path, size_t pathlen)
 {
   struct map_iterator mi;
   int found = 0, rc;
@@ -44,8 +44,8 @@ tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
   while (maps_next (&mi, segbase, &hi, mapoff))
     if (ip >= *segbase && ip < hi)
       {
-	found = 1;
-	break;
+        found = 1;
+        break;
       }
 
   if (!found)
@@ -61,3 +61,13 @@ tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
   maps_close (&mi);
   return rc;
 }
+
+#ifndef UNW_REMOTE_ONLY
+
+void
+tdep_get_exe_image_path (char *path)
+{
+  strcpy(path, "/proc/self/exe");
+}
+
+#endif /* !UNW_REMOTE_ONLY */
diff --git a/src/os-linux.h b/src/os-linux.h
index ad9d675..3976b38 100644
--- a/src/os-linux.h
+++ b/src/os-linux.h
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -78,19 +78,19 @@ maps_init (struct map_iterator *mi, pid_t pid)
       /* Try to allocate a page-sized buffer.  */
       mi->buf_size = getpagesize ();
       cp = mmap (NULL, mi->buf_size, PROT_READ | PROT_WRITE,
-		 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
       if (cp == MAP_FAILED)
-	{
-	  close(mi->fd);
-	  mi->fd = -1;
-	  return -1;
-	}
+        {
+          close(mi->fd);
+          mi->fd = -1;
+          return -1;
+        }
       else
-	{
-	  mi->offset = 0;
-	  mi->buf = mi->buf_end = cp + mi->buf_size;
-	  return 0;
-	}
+        {
+          mi->offset = 0;
+          mi->buf = mi->buf_end = cp + mi->buf_size;
+          return 0;
+        }
     }
   return -1;
 }
@@ -119,13 +119,13 @@ scan_hex (char *cp, unsigned long *valp)
     {
       digit = *cp;
       if ((digit - '0') <= 9)
-	digit -= '0';
+        digit -= '0';
       else if ((digit - 'a') < 6)
-	digit -= 'a' - 10;
+        digit -= 'a' - 10;
       else if ((digit - 'A') < 6)
-	digit -= 'A' - 10;
+        digit -= 'A' - 10;
       else
-	break;
+        break;
       val = (val << 4) | digit;
       ++num_digits;
       ++cp;
@@ -148,12 +148,12 @@ scan_dec (char *cp, unsigned long *valp)
     {
       digit = *cp;
       if ((digit - '0') <= 9)
-	{
-	  digit -= '0';
-	  ++cp;
-	}
+        {
+          digit -= '0';
+          ++cp;
+        }
       else
-	break;
+        break;
       val = (10 * val) + digit;
       ++num_digits;
     }
@@ -190,7 +190,7 @@ scan_string (char *cp, char *valp, size_t buf_size)
   while (*cp != ' ' && *cp != '\t' && *cp != '\0')
     {
       if ((valp != NULL) && (i < buf_size - 1))
-	valp[i++] = *cp;
+        valp[i++] = *cp;
       ++cp;
     }
   if (i == 0 || i >= buf_size)
@@ -201,7 +201,7 @@ scan_string (char *cp, char *valp, size_t buf_size)
 
 static inline int
 maps_next (struct map_iterator *mi,
-	   unsigned long *low, unsigned long *high, unsigned long *offset)
+           unsigned long *low, unsigned long *high, unsigned long *offset)
 {
   char perm[16], dash = 0, colon = 0, *cp;
   unsigned long major, minor, inum;
@@ -216,45 +216,45 @@ maps_next (struct map_iterator *mi,
       char *eol = NULL;
 
       for (i = 0; i < bytes_left; ++i)
-	{
-	  if (mi->buf[i] == '\n')
-	    {
-	      eol = mi->buf + i;
-	      break;
-	    }
-	  else if (mi->buf[i] == '\0')
-	    break;
-	}
+        {
+          if (mi->buf[i] == '\n')
+            {
+              eol = mi->buf + i;
+              break;
+            }
+          else if (mi->buf[i] == '\0')
+            break;
+        }
       if (!eol)
-	{
-	  /* copy down the remaining bytes, if any */
-	  if (bytes_left > 0)
-	    memmove (mi->buf_end - mi->buf_size, mi->buf, bytes_left);
-
-	  mi->buf = mi->buf_end - mi->buf_size;
-	  nread = read (mi->fd, mi->buf + bytes_left,
-			mi->buf_size - bytes_left);
-	  if (nread <= 0)
-	    return 0;
-	  else if ((size_t) (nread + bytes_left) < mi->buf_size)
-	    {
-	      /* Move contents to the end of the buffer so we
-		 maintain the invariant that all bytes between
-		 mi->buf and mi->buf_end are valid.  */
-	      memmove (mi->buf_end - nread - bytes_left, mi->buf,
-		       nread + bytes_left);
-	      mi->buf = mi->buf_end - nread - bytes_left;
-	    }
-
-	  eol = mi->buf + bytes_left + nread - 1;
-
-	  for (i = bytes_left; i < bytes_left + nread; ++i)
-	    if (mi->buf[i] == '\n')
-	      {
-		eol = mi->buf + i;
-		break;
-	      }
-	}
+        {
+          /* copy down the remaining bytes, if any */
+          if (bytes_left > 0)
+            memmove (mi->buf_end - mi->buf_size, mi->buf, bytes_left);
+
+          mi->buf = mi->buf_end - mi->buf_size;
+          nread = read (mi->fd, mi->buf + bytes_left,
+                        mi->buf_size - bytes_left);
+          if (nread <= 0)
+            return 0;
+          else if ((size_t) (nread + bytes_left) < mi->buf_size)
+            {
+              /* Move contents to the end of the buffer so we
+                 maintain the invariant that all bytes between
+                 mi->buf and mi->buf_end are valid.  */
+              memmove (mi->buf_end - nread - bytes_left, mi->buf,
+                       nread + bytes_left);
+              mi->buf = mi->buf_end - nread - bytes_left;
+            }
+
+          eol = mi->buf + bytes_left + nread - 1;
+
+          for (i = bytes_left; i < bytes_left + nread; ++i)
+            if (mi->buf[i] == '\n')
+              {
+                eol = mi->buf + i;
+                break;
+              }
+        }
       cp = mi->buf;
       mi->buf = eol + 1;
       *eol = '\0';
@@ -271,10 +271,10 @@ maps_next (struct map_iterator *mi,
       cp = scan_dec (cp, &inum);
       cp = mi->path = skip_whitespace (cp);
       if (!cp)
-	continue;
+        continue;
       cp = scan_string (cp, NULL, 0);
       if (dash != '-' || colon != ':')
-	continue;	/* skip line with unknown or bad format */
+        continue;       /* skip line with unknown or bad format */
       return 1;
     }
   return 0;
diff --git a/src/os-qnx.c b/src/os-qnx.c
new file mode 100644
index 0000000..4a76c7c
--- /dev/null
+++ b/src/os-qnx.c
@@ -0,0 +1,117 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2013 Garmin International
+        Contributed by Matt Fischer <matt.fischer@garmin.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <string.h>
+
+#include "libunwind_i.h"
+
+struct cb_info
+{
+    unw_word_t ip;
+    unsigned long segbase;
+    unsigned long offset;
+    const char *path;
+};
+
+static int callback(const struct dl_phdr_info *info, size_t size, void *data)
+{
+  int i;
+  struct cb_info *cbi = (struct cb_info*)data;
+  for(i=0; i<info->dlpi_phnum; i++) {
+    int segbase = info->dlpi_addr + info->dlpi_phdr[i].p_vaddr;
+    if(cbi->ip >= segbase && cbi->ip < segbase + info->dlpi_phdr[i].p_memsz)
+    {
+      cbi->path = info->dlpi_name;
+      cbi->offset = info->dlpi_phdr[i].p_offset;
+      cbi->segbase = segbase;
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+int
+tdep_get_elf_image (struct elf_image *ei, pid_t pid, unw_word_t ip,
+                    unsigned long *segbase, unsigned long *mapoff,
+                    char *path, size_t pathlen)
+{
+  struct cb_info cbi;
+  int ret = -1;
+  cbi.ip = ip;
+  cbi.segbase = 0;
+  cbi.offset = 0;
+  cbi.path = NULL;
+
+  /* QNX's support for accessing symbol maps is severely broken.  There is
+     a devctl() call that can be made on a proc node (DCMD_PROC_MAPDEBUG)
+     which returns information similar to Linux's /proc/<pid>/maps
+     node, however the filename that is returned by this call is not an
+     absolute path, and there is no foolproof way to map the filename
+     back to the file that it came from.
+
+     Therefore, the normal approach for implementing this function,
+     which works equally well for both local and remote unwinding,
+     will not work here.  The only type of image lookup which works
+     reliably is locally, using dl_iterate_phdr().  However, the only
+     time that this function is required to look up a remote image is for
+     ptrace support, which doesn't work on QNX anyway.  Local unwinding,
+     which is the main case that makes use of this function, will work
+     fine with dl_iterate_phdr().  Therefore, in lieu of any better
+     platform support for remote image lookup, this function has just
+     been implemented in terms of dl_iterate_phdr().
+  */
+
+  if (pid != getpid())
+  {
+    /* Return an error if an attempt is made to perform remote image lookup */
+    return -1;
+  }
+
+  if (dl_iterate_phdr (callback, &cbi) != 0)
+  {
+    if (path)
+    {
+      strncpy (path, cbi.path, pathlen);
+    }
+
+    *mapoff = cbi.offset;
+    *segbase = cbi.segbase;
+
+    ret = elf_map_image (ei, cbi.path);
+  }
+
+  return ret;
+}
+
+#ifndef UNW_REMOTE_ONLY
+
+void
+tdep_get_exe_image_path (char *path)
+{
+  path[0] = 0; /* XXX */
+}
+
+#endif
diff --git a/src/ppc/Gget_proc_info.c b/src/ppc/Gget_proc_info.c
index ff08d1b..7dfb6d4 100644
--- a/src/ppc/Gget_proc_info.c
+++ b/src/ppc/Gget_proc_info.c
@@ -26,9 +26,16 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include <libunwind_i.h>
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
-  /* XXX: empty stub.  */
-  return -UNW_EINVAL;
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+
+  ret = dwarf_make_proc_info (&c->dwarf);
+  if (ret < 0)
+    return ret;
+
+  *pi = c->dwarf.pi;
+  return 0;
 }
diff --git a/src/ppc/Gget_save_loc.c b/src/ppc/Gget_save_loc.c
index c5beb81..5343fa4 100644
--- a/src/ppc/Gget_save_loc.c
+++ b/src/ppc/Gget_save_loc.c
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include <libunwind_i.h>
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   /* XXX: empty stub.  */
diff --git a/src/ppc/Ginit_local.c b/src/ppc/Ginit_local.c
index 4ca2b25..366cf5b 100644
--- a/src/ppc/Ginit_local.c
+++ b/src/ppc/Ginit_local.c
@@ -34,7 +34,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 {
   /* XXX: empty stub.  */
@@ -43,8 +43,8 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 
 #else /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
-unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+static int
+unw_init_local_common(unw_cursor_t *cursor, ucontext_t *uc, unsigned use_prev_instr)
 {
   struct cursor *c = (struct cursor *) cursor;
 
@@ -56,10 +56,33 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
   c->dwarf.as = unw_local_addr_space;
   c->dwarf.as_arg = uc;
   #ifdef UNW_TARGET_PPC64
-    return common_init_ppc64 (c, 1);
+    return common_init_ppc64 (c, use_prev_instr);
   #else
-    return common_init_ppc32 (c, 1);
+    return common_init_ppc32 (c, use_prev_instr);
   #endif
 }
 
+int
+unw_init_local(unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
+}
+
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/ppc/Ginit_remote.c b/src/ppc/Ginit_remote.c
index 4ee5402..ed85be8 100644
--- a/src/ppc/Ginit_remote.c
+++ b/src/ppc/Ginit_remote.c
@@ -33,7 +33,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "../ppc32/init.h"
 #endif
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/ppc/Gis_signal_frame.c b/src/ppc/Gis_signal_frame.c
index 4154429..6184dd5 100644
--- a/src/ppc/Gis_signal_frame.c
+++ b/src/ppc/Gis_signal_frame.c
@@ -27,18 +27,18 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include <libunwind_i.h>
 
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t * cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
-  unw_word_t w0, w1, ip;
+  unw_word_t w0, w1, i0, i1, i2, ip;
   unw_addr_space_t as;
   unw_accessors_t *a;
   void *arg;
   int ret;
 
   as = c->dwarf.as;
-  as->validate = 1;		/* Don't trust the ip */
+  as->validate = 1;             /* Don't trust the ip */
   arg = c->dwarf.as_arg;
 
   /* Check if return address points at sigreturn sequence.
@@ -56,11 +56,23 @@ unw_is_signal_frame (unw_cursor_t * cursor)
      consecutive 32-bit words, so the second 8-byte word needs to be
      shifted right by 32 bits (think big-endian) */
 
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   if ((ret = (*a->access_mem) (as, ip, &w0, 0, arg)) < 0
       || (ret = (*a->access_mem) (as, ip + 8, &w1, 0, arg)) < 0)
     return 0;
-  w1 >>= 32;
-  return (w0 == 0x38210080380000ac && w1 == 0x44000002);
 
+  if (tdep_big_endian (as))
+    {
+      i0 = w0 >> 32;
+      i1 = w0 & 0xffffffffUL;
+      i2 = w1 >> 32;
+    }
+  else
+    {
+      i0 = w0 & 0xffffffffUL;
+      i1 = w0 >> 32;
+      i2 = w1 & 0xffffffffUL;
+    }
+
+  return (i0 == 0x38210080 && i1 == 0x380000ac && i2 == 0x44000002);
 }
diff --git a/src/ppc32/Gapply_reg_state.c b/src/ppc32/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/ppc32/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/ppc32/Gcreate_addr_space.c b/src/ppc32/Gcreate_addr_space.c
new file mode 100644
index 0000000..aaa68bb
--- /dev/null
+++ b/src/ppc32/Gcreate_addr_space.c
@@ -0,0 +1,56 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2006-2007 IBM
+   Contributed by
+     Corey Ashford <cjashfor@us.ibm.com>
+     Jose Flavio Aguilar Paulino <jflavio@br.ibm.com> <joseflavio@gmail.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdlib.h>
+
+#include <libunwind_i.h>
+
+unw_addr_space_t
+unw_create_addr_space (unw_accessors_t *a, int byte_order)
+{
+#ifdef UNW_LOCAL_ONLY
+  return NULL;
+#else
+  unw_addr_space_t as;
+
+  /*
+   * We support only big-endian on Linux ppc32.
+   */
+  if (byte_order != 0 && byte_order != __BIG_ENDIAN)
+    return NULL;
+
+  as = malloc (sizeof (*as));
+  if (!as)
+    return NULL;
+
+  memset (as, 0, sizeof (*as));
+
+  as->acc = *a;
+
+  return as;
+#endif
+}
diff --git a/src/ppc32/Gglobal.c b/src/ppc32/Gglobal.c
index e817e09..a0f80be 100644
--- a/src/ppc32/Gglobal.c
+++ b/src/ppc32/Gglobal.c
@@ -35,77 +35,77 @@ HIDDEN int tdep_init_done;
    registers, for now at least.  */
 HIDDEN const uint8_t dwarf_to_unw_regnum_map[DWARF_REGNUM_MAP_LENGTH] =
   {
-	[UNW_PPC32_R0]=UNW_PPC32_R0,
-	[UNW_PPC32_R1]=UNW_PPC32_R1,
-	[UNW_PPC32_R2]=UNW_PPC32_R2,
-	[UNW_PPC32_R3]=UNW_PPC32_R3,
-	[UNW_PPC32_R4]=UNW_PPC32_R4,
-	[UNW_PPC32_R5]=UNW_PPC32_R5,
-	[UNW_PPC32_R6]=UNW_PPC32_R6,
-	[UNW_PPC32_R7]=UNW_PPC32_R7,
-	[UNW_PPC32_R8]=UNW_PPC32_R8,
-	[UNW_PPC32_R9]=UNW_PPC32_R9,
-	[UNW_PPC32_R10]=UNW_PPC32_R10,
-	[UNW_PPC32_R11]=UNW_PPC32_R11,
-	[UNW_PPC32_R12]=UNW_PPC32_R12,
-	[UNW_PPC32_R13]=UNW_PPC32_R13,
-	[UNW_PPC32_R14]=UNW_PPC32_R14,
-	[UNW_PPC32_R15]=UNW_PPC32_R15,
-	[UNW_PPC32_R16]=UNW_PPC32_R16,
-	[UNW_PPC32_R17]=UNW_PPC32_R17,
-	[UNW_PPC32_R18]=UNW_PPC32_R18,
-	[UNW_PPC32_R19]=UNW_PPC32_R19,
-	[UNW_PPC32_R20]=UNW_PPC32_R20,
-	[UNW_PPC32_R21]=UNW_PPC32_R21,
-	[UNW_PPC32_R22]=UNW_PPC32_R22,
-	[UNW_PPC32_R23]=UNW_PPC32_R23,
-	[UNW_PPC32_R24]=UNW_PPC32_R24,
-	[UNW_PPC32_R25]=UNW_PPC32_R25,
-	[UNW_PPC32_R26]=UNW_PPC32_R26,
-	[UNW_PPC32_R27]=UNW_PPC32_R27,
-	[UNW_PPC32_R28]=UNW_PPC32_R28,
-	[UNW_PPC32_R29]=UNW_PPC32_R29,
-	[UNW_PPC32_R30]=UNW_PPC32_R30,
-	[UNW_PPC32_R31]=UNW_PPC32_R31,
+        [UNW_PPC32_R0]=UNW_PPC32_R0,
+        [UNW_PPC32_R1]=UNW_PPC32_R1,
+        [UNW_PPC32_R2]=UNW_PPC32_R2,
+        [UNW_PPC32_R3]=UNW_PPC32_R3,
+        [UNW_PPC32_R4]=UNW_PPC32_R4,
+        [UNW_PPC32_R5]=UNW_PPC32_R5,
+        [UNW_PPC32_R6]=UNW_PPC32_R6,
+        [UNW_PPC32_R7]=UNW_PPC32_R7,
+        [UNW_PPC32_R8]=UNW_PPC32_R8,
+        [UNW_PPC32_R9]=UNW_PPC32_R9,
+        [UNW_PPC32_R10]=UNW_PPC32_R10,
+        [UNW_PPC32_R11]=UNW_PPC32_R11,
+        [UNW_PPC32_R12]=UNW_PPC32_R12,
+        [UNW_PPC32_R13]=UNW_PPC32_R13,
+        [UNW_PPC32_R14]=UNW_PPC32_R14,
+        [UNW_PPC32_R15]=UNW_PPC32_R15,
+        [UNW_PPC32_R16]=UNW_PPC32_R16,
+        [UNW_PPC32_R17]=UNW_PPC32_R17,
+        [UNW_PPC32_R18]=UNW_PPC32_R18,
+        [UNW_PPC32_R19]=UNW_PPC32_R19,
+        [UNW_PPC32_R20]=UNW_PPC32_R20,
+        [UNW_PPC32_R21]=UNW_PPC32_R21,
+        [UNW_PPC32_R22]=UNW_PPC32_R22,
+        [UNW_PPC32_R23]=UNW_PPC32_R23,
+        [UNW_PPC32_R24]=UNW_PPC32_R24,
+        [UNW_PPC32_R25]=UNW_PPC32_R25,
+        [UNW_PPC32_R26]=UNW_PPC32_R26,
+        [UNW_PPC32_R27]=UNW_PPC32_R27,
+        [UNW_PPC32_R28]=UNW_PPC32_R28,
+        [UNW_PPC32_R29]=UNW_PPC32_R29,
+        [UNW_PPC32_R30]=UNW_PPC32_R30,
+        [UNW_PPC32_R31]=UNW_PPC32_R31,
 
-	[UNW_PPC32_CTR]=UNW_PPC32_CTR,
-	[UNW_PPC32_XER]=UNW_PPC32_XER,
-	[UNW_PPC32_CCR]=UNW_PPC32_CCR,
-	[UNW_PPC32_LR]=UNW_PPC32_LR,
-	[UNW_PPC32_FPSCR]=UNW_PPC32_FPSCR,
+        [UNW_PPC32_CTR]=UNW_PPC32_CTR,
+        [UNW_PPC32_XER]=UNW_PPC32_XER,
+        [UNW_PPC32_CCR]=UNW_PPC32_CCR,
+        [UNW_PPC32_LR]=UNW_PPC32_LR,
+        [UNW_PPC32_FPSCR]=UNW_PPC32_FPSCR,
 
-	[UNW_PPC32_F0]=UNW_PPC32_F0,
-	[UNW_PPC32_F1]=UNW_PPC32_F1,
-	[UNW_PPC32_F2]=UNW_PPC32_F2,
-	[UNW_PPC32_F3]=UNW_PPC32_F3,
-	[UNW_PPC32_F4]=UNW_PPC32_F4,
-	[UNW_PPC32_F5]=UNW_PPC32_F5,
-	[UNW_PPC32_F6]=UNW_PPC32_F6,
-	[UNW_PPC32_F7]=UNW_PPC32_F7,
-	[UNW_PPC32_F8]=UNW_PPC32_F8,
-	[UNW_PPC32_F9]=UNW_PPC32_F9,
-	[UNW_PPC32_F10]=UNW_PPC32_F10,
-	[UNW_PPC32_F11]=UNW_PPC32_F11,
-	[UNW_PPC32_F12]=UNW_PPC32_F12,
-	[UNW_PPC32_F13]=UNW_PPC32_F13,
-	[UNW_PPC32_F14]=UNW_PPC32_F14,
-	[UNW_PPC32_F15]=UNW_PPC32_F15,
-	[UNW_PPC32_F16]=UNW_PPC32_F16,
-	[UNW_PPC32_F17]=UNW_PPC32_F17,
-	[UNW_PPC32_F18]=UNW_PPC32_F18,
-	[UNW_PPC32_F19]=UNW_PPC32_F19,
-	[UNW_PPC32_F20]=UNW_PPC32_F20,
-	[UNW_PPC32_F21]=UNW_PPC32_F21,
-	[UNW_PPC32_F22]=UNW_PPC32_F22,
-	[UNW_PPC32_F23]=UNW_PPC32_F23,
-	[UNW_PPC32_F24]=UNW_PPC32_F24,
-	[UNW_PPC32_F25]=UNW_PPC32_F25,
-	[UNW_PPC32_F26]=UNW_PPC32_F26,
-	[UNW_PPC32_F27]=UNW_PPC32_F27,
-	[UNW_PPC32_F28]=UNW_PPC32_F28,
-	[UNW_PPC32_F29]=UNW_PPC32_F29,
-	[UNW_PPC32_F30]=UNW_PPC32_F30,
-	[UNW_PPC32_F31]=UNW_PPC32_F31,
+        [UNW_PPC32_F0]=UNW_PPC32_F0,
+        [UNW_PPC32_F1]=UNW_PPC32_F1,
+        [UNW_PPC32_F2]=UNW_PPC32_F2,
+        [UNW_PPC32_F3]=UNW_PPC32_F3,
+        [UNW_PPC32_F4]=UNW_PPC32_F4,
+        [UNW_PPC32_F5]=UNW_PPC32_F5,
+        [UNW_PPC32_F6]=UNW_PPC32_F6,
+        [UNW_PPC32_F7]=UNW_PPC32_F7,
+        [UNW_PPC32_F8]=UNW_PPC32_F8,
+        [UNW_PPC32_F9]=UNW_PPC32_F9,
+        [UNW_PPC32_F10]=UNW_PPC32_F10,
+        [UNW_PPC32_F11]=UNW_PPC32_F11,
+        [UNW_PPC32_F12]=UNW_PPC32_F12,
+        [UNW_PPC32_F13]=UNW_PPC32_F13,
+        [UNW_PPC32_F14]=UNW_PPC32_F14,
+        [UNW_PPC32_F15]=UNW_PPC32_F15,
+        [UNW_PPC32_F16]=UNW_PPC32_F16,
+        [UNW_PPC32_F17]=UNW_PPC32_F17,
+        [UNW_PPC32_F18]=UNW_PPC32_F18,
+        [UNW_PPC32_F19]=UNW_PPC32_F19,
+        [UNW_PPC32_F20]=UNW_PPC32_F20,
+        [UNW_PPC32_F21]=UNW_PPC32_F21,
+        [UNW_PPC32_F22]=UNW_PPC32_F22,
+        [UNW_PPC32_F23]=UNW_PPC32_F23,
+        [UNW_PPC32_F24]=UNW_PPC32_F24,
+        [UNW_PPC32_F25]=UNW_PPC32_F25,
+        [UNW_PPC32_F26]=UNW_PPC32_F26,
+        [UNW_PPC32_F27]=UNW_PPC32_F27,
+        [UNW_PPC32_F28]=UNW_PPC32_F28,
+        [UNW_PPC32_F29]=UNW_PPC32_F29,
+        [UNW_PPC32_F30]=UNW_PPC32_F30,
+        [UNW_PPC32_F31]=UNW_PPC32_F31,
 };
 
 HIDDEN void
@@ -128,7 +128,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     ppc32_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&ppc32_lock, saved_mask);
diff --git a/src/ppc32/Ginit.c b/src/ppc32/Ginit.c
index f4f215e..ba30244 100644
--- a/src/ppc32/Ginit.c
+++ b/src/ppc32/Ginit.c
@@ -34,13 +34,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 static void *
 uc_addr (ucontext_t *uc, int reg)
@@ -60,22 +60,22 @@ uc_addr (ucontext_t *uc, int reg)
       unsigned gregs_idx;
 
       switch (reg)
-	{
-	case UNW_PPC32_CTR:
-	  gregs_idx = CTR_IDX;
-	  break;
-	case UNW_PPC32_LR:
-	  gregs_idx = LINK_IDX;
-	  break;
-	case UNW_PPC32_XER:
-	  gregs_idx = XER_IDX;
-	  break;
-	case UNW_PPC32_CCR:
-	  gregs_idx = CCR_IDX;
-	  break;
-	default:
-	  return NULL;
-	}
+        {
+        case UNW_PPC32_CTR:
+          gregs_idx = CTR_IDX;
+          break;
+        case UNW_PPC32_LR:
+          gregs_idx = LINK_IDX;
+          break;
+        case UNW_PPC32_XER:
+          gregs_idx = XER_IDX;
+          break;
+        case UNW_PPC32_CCR:
+          gregs_idx = CCR_IDX;
+          break;
+        default:
+          return NULL;
+        }
       addr = &uc->uc_mcontext.uc_regs->gregs[gregs_idx];
     }
   return addr;
@@ -89,7 +89,7 @@ tdep_uc_addr (ucontext_t *uc, int reg)
   return uc_addr (uc, reg);
 }
 
-# endif	/* UNW_LOCAL_ONLY */
+# endif /* UNW_LOCAL_ONLY */
 
 HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
 
@@ -102,7 +102,7 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
   return 0;
@@ -110,7 +110,7 @@ get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (write)
     {
@@ -127,7 +127,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
-	    int write, void *arg)
+            int write, void *arg)
 {
   unw_word_t *addr;
   ucontext_t *uc = arg;
@@ -159,7 +159,7 @@ badreg:
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = arg;
   unw_fpreg_t *addr;
@@ -191,8 +191,8 @@ badreg:
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf32_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -201,7 +201,7 @@ HIDDEN void
 ppc32_local_addr_space_init (void)
 {
   memset (&local_addr_space, 0, sizeof (local_addr_space));
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
diff --git a/src/ppc32/Greg_states_iterate.c b/src/ppc32/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/ppc32/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/ppc32/Gregs.c b/src/ppc32/Gregs.c
index 92be321..9344455 100644
--- a/src/ppc32/Gregs.c
+++ b/src/ppc32/Gregs.c
@@ -29,7 +29,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   struct dwarf_loc loc;
 
@@ -37,19 +37,19 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     {
     case UNW_TDEP_IP:
       if (write)
-	{
-	  c->dwarf.ip = *valp;	/* update the IP cache */
-	  if (c->dwarf.pi_valid && (*valp < c->dwarf.pi.start_ip
-				    || *valp >= c->dwarf.pi.end_ip))
-	    c->dwarf.pi_valid = 0;	/* new IP outside of current proc */
-	}
+        {
+          c->dwarf.ip = *valp;  /* update the IP cache */
+          if (c->dwarf.pi_valid && (*valp < c->dwarf.pi.start_ip
+                                    || *valp >= c->dwarf.pi.end_ip))
+            c->dwarf.pi_valid = 0;      /* new IP outside of current proc */
+        }
       else
-	*valp = c->dwarf.ip;
+        *valp = c->dwarf.ip;
       return 0;
 
     case UNW_TDEP_SP:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = c->dwarf.cfa;
       return 0;
 
@@ -72,7 +72,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   struct dwarf_loc loc;
 
diff --git a/src/ppc32/Gresume.c b/src/ppc32/Gresume.c
index 5446c98..c0f9583 100644
--- a/src/ppc32/Gresume.c
+++ b/src/ppc32/Gresume.c
@@ -61,7 +61,7 @@ establish_machine_state (struct cursor *c)
   return 0;
 }
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -73,5 +73,5 @@ unw_resume (unw_cursor_t *cursor)
     return ret;
 
   return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
-				     c->dwarf.as_arg);
+                                     c->dwarf.as_arg);
 }
diff --git a/src/ppc32/Gstep.c b/src/ppc32/Gstep.c
index efb993a..478d3a6 100644
--- a/src/ppc32/Gstep.c
+++ b/src/ppc32/Gstep.c
@@ -49,7 +49,7 @@ typedef struct
 } stack_frame_t;
 
 
-PROTECTED int
+int
 unw_step (unw_cursor_t * cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -79,49 +79,49 @@ unw_step (unw_cursor_t * cursor)
 
   if (unlikely (ret < 0))
     {
-      if (likely (!unw_is_signal_frame (cursor)))
-	{
-	  /* DWARF unwinding failed.  As of 09/26/2006, gcc in 64-bit mode
-	     produces the mandatory level of traceback record in the code, but
-	     I get the impression that this is transitory, that eventually gcc
-	     will not produce any traceback records at all.  So, for now, we
-	     won't bother to try to find and use these records.
-
-	     We can, however, attempt to unwind the frame by using the callback
-	     chain.  This is very crude, however, and won't be able to unwind
-	     any registers besides the IP, SP, and LR . */
-
-	  back_chain_offset = ((void *) &dummy.back_chain - (void *) &dummy);
-	  lr_save_offset = ((void *) &dummy.lr_save - (void *) &dummy);
-
-	  back_chain_loc = DWARF_LOC (c->dwarf.cfa + back_chain_offset, 0);
-
-	  if ((ret =
-	       dwarf_get (&c->dwarf, back_chain_loc, &c->dwarf.cfa)) < 0)
-	    {
-	      Debug (2,
-		 "Unable to retrieve CFA from back chain in stack frame - %d\n",
-		 ret);
-	      return ret;
-	    }
-	  if (c->dwarf.cfa == 0)
-	    /* Unless the cursor or stack is corrupt or uninitialized we've most
-	       likely hit the top of the stack */
-	    return 0;
-
-	  lr_save_loc = DWARF_LOC (c->dwarf.cfa + lr_save_offset, 0);
-
-	  if ((ret = dwarf_get (&c->dwarf, lr_save_loc, &c->dwarf.ip)) < 0)
-	    {
-	      Debug (2,
-		 "Unable to retrieve IP from lr save in stack frame - %d\n",
-		 ret);
-	      return ret;
-	    }
-	  ret = 1;
-	}
+      if (likely (unw_is_signal_frame (cursor) <= 0))
+        {
+          /* DWARF unwinding failed.  As of 09/26/2006, gcc in 64-bit mode
+             produces the mandatory level of traceback record in the code, but
+             I get the impression that this is transitory, that eventually gcc
+             will not produce any traceback records at all.  So, for now, we
+             won't bother to try to find and use these records.
+
+             We can, however, attempt to unwind the frame by using the callback
+             chain.  This is very crude, however, and won't be able to unwind
+             any registers besides the IP, SP, and LR . */
+
+          back_chain_offset = ((void *) &dummy.back_chain - (void *) &dummy);
+          lr_save_offset = ((void *) &dummy.lr_save - (void *) &dummy);
+
+          back_chain_loc = DWARF_LOC (c->dwarf.cfa + back_chain_offset, 0);
+
+          if ((ret =
+               dwarf_get (&c->dwarf, back_chain_loc, &c->dwarf.cfa)) < 0)
+            {
+              Debug (2,
+                 "Unable to retrieve CFA from back chain in stack frame - %d\n",
+                 ret);
+              return ret;
+            }
+          if (c->dwarf.cfa == 0)
+            /* Unless the cursor or stack is corrupt or uninitialized we've most
+               likely hit the top of the stack */
+            return 0;
+
+          lr_save_loc = DWARF_LOC (c->dwarf.cfa + lr_save_offset, 0);
+
+          if ((ret = dwarf_get (&c->dwarf, lr_save_loc, &c->dwarf.ip)) < 0)
+            {
+              Debug (2,
+                 "Unable to retrieve IP from lr save in stack frame - %d\n",
+                 ret);
+              return ret;
+            }
+          ret = 1;
+        }
       else
-	{
+        {
           /* Find the sigcontext record by taking the CFA and adjusting by
              the dummy signal frame size.
 
@@ -132,178 +132,178 @@ unw_step (unw_cursor_t * cursor)
              following code will likely cause a seg fault or other crash
              condition.  */
 
-	  unw_word_t ucontext = c->dwarf.cfa + __SIGNAL_FRAMESIZE;
-
-	  Debug (1, "signal frame, skip over trampoline\n");
-
-	  c->sigcontext_format = PPC_SCF_LINUX_RT_SIGFRAME;
-	  c->sigcontext_addr = ucontext;
-
-	  sp_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
-	  ip_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_LINK, 0);
-
-	  ret = dwarf_get (&c->dwarf, sp_loc, &c->dwarf.cfa);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-	  ret = dwarf_get (&c->dwarf, ip_loc, &c->dwarf.ip);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-
-	  /* Instead of just restoring the non-volatile registers, do all
-	     of the registers for now.  This will incur a performance hit,
-	     but it's rare enough not to cause too much of a problem, and
-	     might be useful in some cases.  */
-	  c->dwarf.loc[UNW_PPC32_R0] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R0, 0);
-	  c->dwarf.loc[UNW_PPC32_R1] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
-	  c->dwarf.loc[UNW_PPC32_R2] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R2, 0);
-	  c->dwarf.loc[UNW_PPC32_R3] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R3, 0);
-	  c->dwarf.loc[UNW_PPC32_R4] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R4, 0);
-	  c->dwarf.loc[UNW_PPC32_R5] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R5, 0);
-	  c->dwarf.loc[UNW_PPC32_R6] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R6, 0);
-	  c->dwarf.loc[UNW_PPC32_R7] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R7, 0);
-	  c->dwarf.loc[UNW_PPC32_R8] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R8, 0);
-	  c->dwarf.loc[UNW_PPC32_R9] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R9, 0);
-	  c->dwarf.loc[UNW_PPC32_R10] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R10, 0);
-	  c->dwarf.loc[UNW_PPC32_R11] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R11, 0);
-	  c->dwarf.loc[UNW_PPC32_R12] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R12, 0);
-	  c->dwarf.loc[UNW_PPC32_R13] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R13, 0);
-	  c->dwarf.loc[UNW_PPC32_R14] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R14, 0);
-	  c->dwarf.loc[UNW_PPC32_R15] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R15, 0);
-	  c->dwarf.loc[UNW_PPC32_R16] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R16, 0);
-	  c->dwarf.loc[UNW_PPC32_R17] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R17, 0);
-	  c->dwarf.loc[UNW_PPC32_R18] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R18, 0);
-	  c->dwarf.loc[UNW_PPC32_R19] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R19, 0);
-	  c->dwarf.loc[UNW_PPC32_R20] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R20, 0);
-	  c->dwarf.loc[UNW_PPC32_R21] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R21, 0);
-	  c->dwarf.loc[UNW_PPC32_R22] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R22, 0);
-	  c->dwarf.loc[UNW_PPC32_R23] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R23, 0);
-	  c->dwarf.loc[UNW_PPC32_R24] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R24, 0);
-	  c->dwarf.loc[UNW_PPC32_R25] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R25, 0);
-	  c->dwarf.loc[UNW_PPC32_R26] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R26, 0);
-	  c->dwarf.loc[UNW_PPC32_R27] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R27, 0);
-	  c->dwarf.loc[UNW_PPC32_R28] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R28, 0);
-	  c->dwarf.loc[UNW_PPC32_R29] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R29, 0);
-	  c->dwarf.loc[UNW_PPC32_R30] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R30, 0);
-	  c->dwarf.loc[UNW_PPC32_R31] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R31, 0);
-
-	  c->dwarf.loc[UNW_PPC32_LR] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_LINK, 0);
-	  c->dwarf.loc[UNW_PPC32_CTR] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CTR, 0);
-
-	  /* This CR0 assignment is probably wrong.  There are 8 dwarf columns
-	     assigned to the CR registers, but only one CR register in the
-	     mcontext structure */
-	  c->dwarf.loc[UNW_PPC32_CCR] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CCR, 0);
-	  c->dwarf.loc[UNW_PPC32_XER] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_XER, 0);
-
-	  c->dwarf.loc[UNW_PPC32_F0] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R0, 0);
-	  c->dwarf.loc[UNW_PPC32_F1] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R1, 0);
-	  c->dwarf.loc[UNW_PPC32_F2] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R2, 0);
-	  c->dwarf.loc[UNW_PPC32_F3] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R3, 0);
-	  c->dwarf.loc[UNW_PPC32_F4] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R4, 0);
-	  c->dwarf.loc[UNW_PPC32_F5] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R5, 0);
-	  c->dwarf.loc[UNW_PPC32_F6] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R6, 0);
-	  c->dwarf.loc[UNW_PPC32_F7] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R7, 0);
-	  c->dwarf.loc[UNW_PPC32_F8] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R8, 0);
-	  c->dwarf.loc[UNW_PPC32_F9] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R9, 0);
-	  c->dwarf.loc[UNW_PPC32_F10] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R10, 0);
-	  c->dwarf.loc[UNW_PPC32_F11] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R11, 0);
-	  c->dwarf.loc[UNW_PPC32_F12] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R12, 0);
-	  c->dwarf.loc[UNW_PPC32_F13] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R13, 0);
-	  c->dwarf.loc[UNW_PPC32_F14] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R14, 0);
-	  c->dwarf.loc[UNW_PPC32_F15] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R15, 0);
-	  c->dwarf.loc[UNW_PPC32_F16] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R16, 0);
-	  c->dwarf.loc[UNW_PPC32_F17] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R17, 0);
-	  c->dwarf.loc[UNW_PPC32_F18] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R18, 0);
-	  c->dwarf.loc[UNW_PPC32_F19] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R19, 0);
-	  c->dwarf.loc[UNW_PPC32_F20] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R20, 0);
-	  c->dwarf.loc[UNW_PPC32_F21] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R21, 0);
-	  c->dwarf.loc[UNW_PPC32_F22] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R22, 0);
-	  c->dwarf.loc[UNW_PPC32_F23] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R23, 0);
-	  c->dwarf.loc[UNW_PPC32_F24] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R24, 0);
-	  c->dwarf.loc[UNW_PPC32_F25] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R25, 0);
-	  c->dwarf.loc[UNW_PPC32_F26] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R26, 0);
-	  c->dwarf.loc[UNW_PPC32_F27] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R27, 0);
-	  c->dwarf.loc[UNW_PPC32_F28] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R28, 0);
-	  c->dwarf.loc[UNW_PPC32_F29] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R29, 0);
-	  c->dwarf.loc[UNW_PPC32_F30] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R30, 0);
-	  c->dwarf.loc[UNW_PPC32_F31] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R31, 0);
-
-	  ret = 1;
-	}
+          unw_word_t ucontext = c->dwarf.cfa + __SIGNAL_FRAMESIZE;
+
+          Debug (1, "signal frame, skip over trampoline\n");
+
+          c->sigcontext_format = PPC_SCF_LINUX_RT_SIGFRAME;
+          c->sigcontext_addr = ucontext;
+
+          sp_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
+          ip_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_LINK, 0);
+
+          ret = dwarf_get (&c->dwarf, sp_loc, &c->dwarf.cfa);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+          ret = dwarf_get (&c->dwarf, ip_loc, &c->dwarf.ip);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+
+          /* Instead of just restoring the non-volatile registers, do all
+             of the registers for now.  This will incur a performance hit,
+             but it's rare enough not to cause too much of a problem, and
+             might be useful in some cases.  */
+          c->dwarf.loc[UNW_PPC32_R0] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R0, 0);
+          c->dwarf.loc[UNW_PPC32_R1] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
+          c->dwarf.loc[UNW_PPC32_R2] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R2, 0);
+          c->dwarf.loc[UNW_PPC32_R3] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R3, 0);
+          c->dwarf.loc[UNW_PPC32_R4] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R4, 0);
+          c->dwarf.loc[UNW_PPC32_R5] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R5, 0);
+          c->dwarf.loc[UNW_PPC32_R6] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R6, 0);
+          c->dwarf.loc[UNW_PPC32_R7] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R7, 0);
+          c->dwarf.loc[UNW_PPC32_R8] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R8, 0);
+          c->dwarf.loc[UNW_PPC32_R9] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R9, 0);
+          c->dwarf.loc[UNW_PPC32_R10] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R10, 0);
+          c->dwarf.loc[UNW_PPC32_R11] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R11, 0);
+          c->dwarf.loc[UNW_PPC32_R12] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R12, 0);
+          c->dwarf.loc[UNW_PPC32_R13] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R13, 0);
+          c->dwarf.loc[UNW_PPC32_R14] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R14, 0);
+          c->dwarf.loc[UNW_PPC32_R15] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R15, 0);
+          c->dwarf.loc[UNW_PPC32_R16] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R16, 0);
+          c->dwarf.loc[UNW_PPC32_R17] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R17, 0);
+          c->dwarf.loc[UNW_PPC32_R18] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R18, 0);
+          c->dwarf.loc[UNW_PPC32_R19] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R19, 0);
+          c->dwarf.loc[UNW_PPC32_R20] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R20, 0);
+          c->dwarf.loc[UNW_PPC32_R21] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R21, 0);
+          c->dwarf.loc[UNW_PPC32_R22] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R22, 0);
+          c->dwarf.loc[UNW_PPC32_R23] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R23, 0);
+          c->dwarf.loc[UNW_PPC32_R24] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R24, 0);
+          c->dwarf.loc[UNW_PPC32_R25] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R25, 0);
+          c->dwarf.loc[UNW_PPC32_R26] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R26, 0);
+          c->dwarf.loc[UNW_PPC32_R27] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R27, 0);
+          c->dwarf.loc[UNW_PPC32_R28] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R28, 0);
+          c->dwarf.loc[UNW_PPC32_R29] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R29, 0);
+          c->dwarf.loc[UNW_PPC32_R30] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R30, 0);
+          c->dwarf.loc[UNW_PPC32_R31] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R31, 0);
+
+          c->dwarf.loc[UNW_PPC32_LR] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_LINK, 0);
+          c->dwarf.loc[UNW_PPC32_CTR] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CTR, 0);
+
+          /* This CR0 assignment is probably wrong.  There are 8 dwarf columns
+             assigned to the CR registers, but only one CR register in the
+             mcontext structure */
+          c->dwarf.loc[UNW_PPC32_CCR] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CCR, 0);
+          c->dwarf.loc[UNW_PPC32_XER] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_XER, 0);
+
+          c->dwarf.loc[UNW_PPC32_F0] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R0, 0);
+          c->dwarf.loc[UNW_PPC32_F1] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R1, 0);
+          c->dwarf.loc[UNW_PPC32_F2] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R2, 0);
+          c->dwarf.loc[UNW_PPC32_F3] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R3, 0);
+          c->dwarf.loc[UNW_PPC32_F4] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R4, 0);
+          c->dwarf.loc[UNW_PPC32_F5] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R5, 0);
+          c->dwarf.loc[UNW_PPC32_F6] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R6, 0);
+          c->dwarf.loc[UNW_PPC32_F7] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R7, 0);
+          c->dwarf.loc[UNW_PPC32_F8] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R8, 0);
+          c->dwarf.loc[UNW_PPC32_F9] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R9, 0);
+          c->dwarf.loc[UNW_PPC32_F10] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R10, 0);
+          c->dwarf.loc[UNW_PPC32_F11] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R11, 0);
+          c->dwarf.loc[UNW_PPC32_F12] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R12, 0);
+          c->dwarf.loc[UNW_PPC32_F13] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R13, 0);
+          c->dwarf.loc[UNW_PPC32_F14] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R14, 0);
+          c->dwarf.loc[UNW_PPC32_F15] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R15, 0);
+          c->dwarf.loc[UNW_PPC32_F16] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R16, 0);
+          c->dwarf.loc[UNW_PPC32_F17] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R17, 0);
+          c->dwarf.loc[UNW_PPC32_F18] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R18, 0);
+          c->dwarf.loc[UNW_PPC32_F19] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R19, 0);
+          c->dwarf.loc[UNW_PPC32_F20] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R20, 0);
+          c->dwarf.loc[UNW_PPC32_F21] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R21, 0);
+          c->dwarf.loc[UNW_PPC32_F22] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R22, 0);
+          c->dwarf.loc[UNW_PPC32_F23] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R23, 0);
+          c->dwarf.loc[UNW_PPC32_F24] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R24, 0);
+          c->dwarf.loc[UNW_PPC32_F25] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R25, 0);
+          c->dwarf.loc[UNW_PPC32_F26] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R26, 0);
+          c->dwarf.loc[UNW_PPC32_F27] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R27, 0);
+          c->dwarf.loc[UNW_PPC32_F28] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R28, 0);
+          c->dwarf.loc[UNW_PPC32_F29] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R29, 0);
+          c->dwarf.loc[UNW_PPC32_F30] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R30, 0);
+          c->dwarf.loc[UNW_PPC32_F31] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R31, 0);
+
+          ret = 1;
+        }
     }
   return ret;
 }
diff --git a/src/ppc32/Lapply_reg_state.c b/src/ppc32/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/ppc32/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/ppc32/Lcreate_addr_space.c b/src/ppc32/Lcreate_addr_space.c
new file mode 100644
index 0000000..0f2dc6b
--- /dev/null
+++ b/src/ppc32/Lcreate_addr_space.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gcreate_addr_space.c"
+#endif
diff --git a/src/ppc32/Lreg_states_iterate.c b/src/ppc32/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/ppc32/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/ppc32/get_func_addr.c b/src/ppc32/get_func_addr.c
index 14797c9..66ff795 100644
--- a/src/ppc32/get_func_addr.c
+++ b/src/ppc32/get_func_addr.c
@@ -29,7 +29,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 int
 tdep_get_func_addr (unw_addr_space_t as, unw_word_t symbol_val_addr,
-		    unw_word_t *real_func_addr)
+                    unw_word_t *real_func_addr)
 {
   *real_func_addr = symbol_val_addr;
   return 0;
diff --git a/src/ppc32/init.h b/src/ppc32/init.h
index 4cb9192..87a69b1 100644
--- a/src/ppc32/init.h
+++ b/src/ppc32/init.h
@@ -53,7 +53,7 @@ common_init_ppc32 (struct cursor *c, unsigned use_prev_instr)
     return ret;
 
   ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_PPC32_R1),
-		   &c->dwarf.cfa);
+                   &c->dwarf.cfa);
   if (ret < 0)
     return ret;
 
@@ -61,7 +61,6 @@ common_init_ppc32 (struct cursor *c, unsigned use_prev_instr)
   c->sigcontext_addr = 0;
 
   c->dwarf.args_size = 0;
-  c->dwarf.ret_addr_column = 0;
   c->dwarf.stash_frames = 0;
   c->dwarf.use_prev_instr = use_prev_instr;
   c->dwarf.pi_valid = 0;
diff --git a/src/ppc32/is_fpreg.c b/src/ppc32/is_fpreg.c
index cccc511..646ff23 100644
--- a/src/ppc32/is_fpreg.c
+++ b/src/ppc32/is_fpreg.c
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_is_fpreg (int regnum)
 {
   return (regnum >= UNW_PPC32_F0 && regnum <= UNW_PPC32_F31);
diff --git a/src/ppc32/regname.c b/src/ppc32/regname.c
index 79ba88a..459b83a 100644
--- a/src/ppc32/regname.c
+++ b/src/ppc32/regname.c
@@ -102,7 +102,7 @@ static const char *regname[] =
     [UNW_PPC32_F31]="FPR31"
 };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
diff --git a/src/ppc32/ucontext_i.h b/src/ppc32/ucontext_i.h
index 11e4a57..c6ba806 100644
--- a/src/ppc32/ucontext_i.h
+++ b/src/ppc32/ucontext_i.h
@@ -34,13 +34,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
    /usr/src/linux-2.6.18-1.8/arch/powerpc/kernel/ppc32.h
 */
 
-//#define NIP_IDX		32
-#define CTR_IDX		32
-#define XER_IDX		33
-#define CCR_IDX		34
-#define MSR_IDX		35
-//#define MQ_IDX		36
-#define LINK_IDX	36
+//#define NIP_IDX               32
+#define CTR_IDX         32
+#define XER_IDX         33
+#define CCR_IDX         34
+#define MSR_IDX         35
+//#define MQ_IDX                36
+#define LINK_IDX        36
 
 /* These are dummy structures used only for obtaining the offsets of the
    various structure members. */
diff --git a/src/ppc32/unwind_i.h b/src/ppc32/unwind_i.h
index 5f559bd..ad32d05 100644
--- a/src/ppc32/unwind_i.h
+++ b/src/ppc32/unwind_i.h
@@ -35,12 +35,12 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <libunwind_i.h>
 #include <sys/ucontext.h>
 
-#define ppc32_lock			UNW_OBJ(lock)
-#define ppc32_local_resume		UNW_OBJ(local_resume)
-#define ppc32_local_addr_space_init	UNW_OBJ(local_addr_space_init)
+#define ppc32_lock                      UNW_OBJ(lock)
+#define ppc32_local_resume              UNW_OBJ(local_resume)
+#define ppc32_local_addr_space_init     UNW_OBJ(local_addr_space_init)
 
 extern void ppc32_local_addr_space_init (void);
 extern int ppc32_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			     void *arg);
+                             void *arg);
 
 #endif /* unwind_i_h */
diff --git a/src/ppc64/Gapply_reg_state.c b/src/ppc64/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/ppc64/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/ppc64/Gcreate_addr_space.c b/src/ppc64/Gcreate_addr_space.c
new file mode 100644
index 0000000..bd48555
--- /dev/null
+++ b/src/ppc64/Gcreate_addr_space.c
@@ -0,0 +1,71 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2006-2007 IBM
+   Contributed by
+     Corey Ashford <cjashfor@us.ibm.com>
+     Jose Flavio Aguilar Paulino <jflavio@br.ibm.com> <joseflavio@gmail.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdlib.h>
+
+#include <libunwind_i.h>
+
+unw_addr_space_t
+unw_create_addr_space (unw_accessors_t *a, int byte_order)
+{
+#ifdef UNW_LOCAL_ONLY
+  return NULL;
+#else
+  unw_addr_space_t as;
+
+  /*
+   * We support both big- and little-endian on Linux ppc64.
+   */
+  if (byte_order != 0
+      && byte_order != __LITTLE_ENDIAN
+      && byte_order != __BIG_ENDIAN)
+    return NULL;
+
+  as = malloc (sizeof (*as));
+  if (!as)
+    return NULL;
+
+  memset (as, 0, sizeof (*as));
+
+  as->acc = *a;
+
+  if (byte_order == 0)
+    /* use host default: */
+    as->big_endian = (__BYTE_ORDER == __BIG_ENDIAN);
+  else
+    as->big_endian = (byte_order == __BIG_ENDIAN);
+
+  /* FIXME!  There is no way to specify the ABI.
+     Default to ELFv1 on big-endian and ELFv2 on little-endian.  */
+  if (as->big_endian)
+    as->abi = UNW_PPC64_ABI_ELFv1;
+  else
+    as->abi = UNW_PPC64_ABI_ELFv2;
+
+  return as;
+#endif
+}
diff --git a/src/ppc64/Gglobal.c b/src/ppc64/Gglobal.c
index 8b46c3d..9d0b0f5 100644
--- a/src/ppc64/Gglobal.c
+++ b/src/ppc64/Gglobal.c
@@ -35,124 +35,124 @@ HIDDEN int tdep_init_done;
    registers, for now at least.  */
 HIDDEN const uint8_t dwarf_to_unw_regnum_map[DWARF_REGNUM_MAP_LENGTH] =
   {
-	[UNW_PPC64_R0]=UNW_PPC64_R0,
-	[UNW_PPC64_R1]=UNW_PPC64_R1,
-	[UNW_PPC64_R2]=UNW_PPC64_R2,
-	[UNW_PPC64_R3]=UNW_PPC64_R3,
-	[UNW_PPC64_R4]=UNW_PPC64_R4,
-	[UNW_PPC64_R5]=UNW_PPC64_R5,
-	[UNW_PPC64_R6]=UNW_PPC64_R6,
-	[UNW_PPC64_R7]=UNW_PPC64_R7,
-	[UNW_PPC64_R8]=UNW_PPC64_R8,
-	[UNW_PPC64_R9]=UNW_PPC64_R9,
-	[UNW_PPC64_R10]=UNW_PPC64_R10,
-	[UNW_PPC64_R11]=UNW_PPC64_R11,
-	[UNW_PPC64_R12]=UNW_PPC64_R12,
-	[UNW_PPC64_R13]=UNW_PPC64_R13,
-	[UNW_PPC64_R14]=UNW_PPC64_R14,
-	[UNW_PPC64_R15]=UNW_PPC64_R15,
-	[UNW_PPC64_R16]=UNW_PPC64_R16,
-	[UNW_PPC64_R17]=UNW_PPC64_R17,
-	[UNW_PPC64_R18]=UNW_PPC64_R18,
-	[UNW_PPC64_R19]=UNW_PPC64_R19,
-	[UNW_PPC64_R20]=UNW_PPC64_R20,
-	[UNW_PPC64_R21]=UNW_PPC64_R21,
-	[UNW_PPC64_R22]=UNW_PPC64_R22,
-	[UNW_PPC64_R23]=UNW_PPC64_R23,
-	[UNW_PPC64_R24]=UNW_PPC64_R24,
-	[UNW_PPC64_R25]=UNW_PPC64_R25,
-	[UNW_PPC64_R26]=UNW_PPC64_R26,
-	[UNW_PPC64_R27]=UNW_PPC64_R27,
-	[UNW_PPC64_R28]=UNW_PPC64_R28,
-	[UNW_PPC64_R29]=UNW_PPC64_R29,
-	[UNW_PPC64_R30]=UNW_PPC64_R30,
-	[UNW_PPC64_R31]=UNW_PPC64_R31,
-
-	[UNW_PPC64_F0]=UNW_PPC64_F0,
-	[UNW_PPC64_F1]=UNW_PPC64_F1,
-	[UNW_PPC64_F2]=UNW_PPC64_F2,
-	[UNW_PPC64_F3]=UNW_PPC64_F3,
-	[UNW_PPC64_F4]=UNW_PPC64_F4,
-	[UNW_PPC64_F5]=UNW_PPC64_F5,
-	[UNW_PPC64_F6]=UNW_PPC64_F6,
-	[UNW_PPC64_F7]=UNW_PPC64_F7,
-	[UNW_PPC64_F8]=UNW_PPC64_F8,
-	[UNW_PPC64_F9]=UNW_PPC64_F9,
-	[UNW_PPC64_F10]=UNW_PPC64_F10,
-	[UNW_PPC64_F11]=UNW_PPC64_F11,
-	[UNW_PPC64_F12]=UNW_PPC64_F12,
-	[UNW_PPC64_F13]=UNW_PPC64_F13,
-	[UNW_PPC64_F14]=UNW_PPC64_F14,
-	[UNW_PPC64_F15]=UNW_PPC64_F15,
-	[UNW_PPC64_F16]=UNW_PPC64_F16,
-	[UNW_PPC64_F17]=UNW_PPC64_F17,
-	[UNW_PPC64_F18]=UNW_PPC64_F18,
-	[UNW_PPC64_F19]=UNW_PPC64_F19,
-	[UNW_PPC64_F20]=UNW_PPC64_F20,
-	[UNW_PPC64_F21]=UNW_PPC64_F21,
-	[UNW_PPC64_F22]=UNW_PPC64_F22,
-	[UNW_PPC64_F23]=UNW_PPC64_F23,
-	[UNW_PPC64_F24]=UNW_PPC64_F24,
-	[UNW_PPC64_F25]=UNW_PPC64_F25,
-	[UNW_PPC64_F26]=UNW_PPC64_F26,
-	[UNW_PPC64_F27]=UNW_PPC64_F27,
-	[UNW_PPC64_F28]=UNW_PPC64_F28,
-	[UNW_PPC64_F29]=UNW_PPC64_F29,
-	[UNW_PPC64_F30]=UNW_PPC64_F30,
-	[UNW_PPC64_F31]=UNW_PPC64_F31,
-
-	[UNW_PPC64_LR]=UNW_PPC64_LR,
-	[UNW_PPC64_CTR]=UNW_PPC64_CTR,
-	[UNW_PPC64_ARG_POINTER]=UNW_PPC64_ARG_POINTER,
-
-	[UNW_PPC64_CR0]=UNW_PPC64_CR0,
-	[UNW_PPC64_CR1]=UNW_PPC64_CR1,
-	[UNW_PPC64_CR2]=UNW_PPC64_CR2,
-	[UNW_PPC64_CR3]=UNW_PPC64_CR3,
-	[UNW_PPC64_CR4]=UNW_PPC64_CR4,
-	[UNW_PPC64_CR5]=UNW_PPC64_CR5,
-	[UNW_PPC64_CR6]=UNW_PPC64_CR6,
-	[UNW_PPC64_CR7]=UNW_PPC64_CR7,
-
-	[UNW_PPC64_XER]=UNW_PPC64_XER,
-
-	[UNW_PPC64_V0]=UNW_PPC64_V0,
-	[UNW_PPC64_V1]=UNW_PPC64_V1,
-	[UNW_PPC64_V2]=UNW_PPC64_V2,
-	[UNW_PPC64_V3]=UNW_PPC64_V3,
-	[UNW_PPC64_V4]=UNW_PPC64_V4,
-	[UNW_PPC64_V5]=UNW_PPC64_V5,
-	[UNW_PPC64_V6]=UNW_PPC64_V6,
-	[UNW_PPC64_V7]=UNW_PPC64_V7,
-	[UNW_PPC64_V8]=UNW_PPC64_V8,
-	[UNW_PPC64_V9]=UNW_PPC64_V9,
-	[UNW_PPC64_V10]=UNW_PPC64_V10,
-	[UNW_PPC64_V11]=UNW_PPC64_V11,
-	[UNW_PPC64_V12]=UNW_PPC64_V12,
-	[UNW_PPC64_V13]=UNW_PPC64_V13,
-	[UNW_PPC64_V14]=UNW_PPC64_V14,
-	[UNW_PPC64_V15]=UNW_PPC64_V15,
-	[UNW_PPC64_V16]=UNW_PPC64_V16,
-	[UNW_PPC64_V17]=UNW_PPC64_V17,
-	[UNW_PPC64_V18]=UNW_PPC64_V18,
-	[UNW_PPC64_V19]=UNW_PPC64_V19,
-	[UNW_PPC64_V20]=UNW_PPC64_V20,
-	[UNW_PPC64_V21]=UNW_PPC64_V21,
-	[UNW_PPC64_V22]=UNW_PPC64_V22,
-	[UNW_PPC64_V23]=UNW_PPC64_V23,
-	[UNW_PPC64_V24]=UNW_PPC64_V24,
-	[UNW_PPC64_V25]=UNW_PPC64_V25,
-	[UNW_PPC64_V26]=UNW_PPC64_V26,
-	[UNW_PPC64_V27]=UNW_PPC64_V27,
-	[UNW_PPC64_V28]=UNW_PPC64_V28,
-	[UNW_PPC64_V29]=UNW_PPC64_V29,
-	[UNW_PPC64_V30]=UNW_PPC64_V30,
-	[UNW_PPC64_V31]=UNW_PPC64_V31,
-
-	[UNW_PPC64_VRSAVE]=UNW_PPC64_VRSAVE,
-	[UNW_PPC64_VSCR]=UNW_PPC64_VSCR,
-	[UNW_PPC64_SPE_ACC]=UNW_PPC64_SPE_ACC,
-	[UNW_PPC64_SPEFSCR]=UNW_PPC64_SPEFSCR,
+        [UNW_PPC64_R0]=UNW_PPC64_R0,
+        [UNW_PPC64_R1]=UNW_PPC64_R1,
+        [UNW_PPC64_R2]=UNW_PPC64_R2,
+        [UNW_PPC64_R3]=UNW_PPC64_R3,
+        [UNW_PPC64_R4]=UNW_PPC64_R4,
+        [UNW_PPC64_R5]=UNW_PPC64_R5,
+        [UNW_PPC64_R6]=UNW_PPC64_R6,
+        [UNW_PPC64_R7]=UNW_PPC64_R7,
+        [UNW_PPC64_R8]=UNW_PPC64_R8,
+        [UNW_PPC64_R9]=UNW_PPC64_R9,
+        [UNW_PPC64_R10]=UNW_PPC64_R10,
+        [UNW_PPC64_R11]=UNW_PPC64_R11,
+        [UNW_PPC64_R12]=UNW_PPC64_R12,
+        [UNW_PPC64_R13]=UNW_PPC64_R13,
+        [UNW_PPC64_R14]=UNW_PPC64_R14,
+        [UNW_PPC64_R15]=UNW_PPC64_R15,
+        [UNW_PPC64_R16]=UNW_PPC64_R16,
+        [UNW_PPC64_R17]=UNW_PPC64_R17,
+        [UNW_PPC64_R18]=UNW_PPC64_R18,
+        [UNW_PPC64_R19]=UNW_PPC64_R19,
+        [UNW_PPC64_R20]=UNW_PPC64_R20,
+        [UNW_PPC64_R21]=UNW_PPC64_R21,
+        [UNW_PPC64_R22]=UNW_PPC64_R22,
+        [UNW_PPC64_R23]=UNW_PPC64_R23,
+        [UNW_PPC64_R24]=UNW_PPC64_R24,
+        [UNW_PPC64_R25]=UNW_PPC64_R25,
+        [UNW_PPC64_R26]=UNW_PPC64_R26,
+        [UNW_PPC64_R27]=UNW_PPC64_R27,
+        [UNW_PPC64_R28]=UNW_PPC64_R28,
+        [UNW_PPC64_R29]=UNW_PPC64_R29,
+        [UNW_PPC64_R30]=UNW_PPC64_R30,
+        [UNW_PPC64_R31]=UNW_PPC64_R31,
+
+        [UNW_PPC64_F0]=UNW_PPC64_F0,
+        [UNW_PPC64_F1]=UNW_PPC64_F1,
+        [UNW_PPC64_F2]=UNW_PPC64_F2,
+        [UNW_PPC64_F3]=UNW_PPC64_F3,
+        [UNW_PPC64_F4]=UNW_PPC64_F4,
+        [UNW_PPC64_F5]=UNW_PPC64_F5,
+        [UNW_PPC64_F6]=UNW_PPC64_F6,
+        [UNW_PPC64_F7]=UNW_PPC64_F7,
+        [UNW_PPC64_F8]=UNW_PPC64_F8,
+        [UNW_PPC64_F9]=UNW_PPC64_F9,
+        [UNW_PPC64_F10]=UNW_PPC64_F10,
+        [UNW_PPC64_F11]=UNW_PPC64_F11,
+        [UNW_PPC64_F12]=UNW_PPC64_F12,
+        [UNW_PPC64_F13]=UNW_PPC64_F13,
+        [UNW_PPC64_F14]=UNW_PPC64_F14,
+        [UNW_PPC64_F15]=UNW_PPC64_F15,
+        [UNW_PPC64_F16]=UNW_PPC64_F16,
+        [UNW_PPC64_F17]=UNW_PPC64_F17,
+        [UNW_PPC64_F18]=UNW_PPC64_F18,
+        [UNW_PPC64_F19]=UNW_PPC64_F19,
+        [UNW_PPC64_F20]=UNW_PPC64_F20,
+        [UNW_PPC64_F21]=UNW_PPC64_F21,
+        [UNW_PPC64_F22]=UNW_PPC64_F22,
+        [UNW_PPC64_F23]=UNW_PPC64_F23,
+        [UNW_PPC64_F24]=UNW_PPC64_F24,
+        [UNW_PPC64_F25]=UNW_PPC64_F25,
+        [UNW_PPC64_F26]=UNW_PPC64_F26,
+        [UNW_PPC64_F27]=UNW_PPC64_F27,
+        [UNW_PPC64_F28]=UNW_PPC64_F28,
+        [UNW_PPC64_F29]=UNW_PPC64_F29,
+        [UNW_PPC64_F30]=UNW_PPC64_F30,
+        [UNW_PPC64_F31]=UNW_PPC64_F31,
+
+        [UNW_PPC64_LR]=UNW_PPC64_LR,
+        [UNW_PPC64_CTR]=UNW_PPC64_CTR,
+        [UNW_PPC64_ARG_POINTER]=UNW_PPC64_ARG_POINTER,
+
+        [UNW_PPC64_CR0]=UNW_PPC64_CR0,
+        [UNW_PPC64_CR1]=UNW_PPC64_CR1,
+        [UNW_PPC64_CR2]=UNW_PPC64_CR2,
+        [UNW_PPC64_CR3]=UNW_PPC64_CR3,
+        [UNW_PPC64_CR4]=UNW_PPC64_CR4,
+        [UNW_PPC64_CR5]=UNW_PPC64_CR5,
+        [UNW_PPC64_CR6]=UNW_PPC64_CR6,
+        [UNW_PPC64_CR7]=UNW_PPC64_CR7,
+
+        [UNW_PPC64_XER]=UNW_PPC64_XER,
+
+        [UNW_PPC64_V0]=UNW_PPC64_V0,
+        [UNW_PPC64_V1]=UNW_PPC64_V1,
+        [UNW_PPC64_V2]=UNW_PPC64_V2,
+        [UNW_PPC64_V3]=UNW_PPC64_V3,
+        [UNW_PPC64_V4]=UNW_PPC64_V4,
+        [UNW_PPC64_V5]=UNW_PPC64_V5,
+        [UNW_PPC64_V6]=UNW_PPC64_V6,
+        [UNW_PPC64_V7]=UNW_PPC64_V7,
+        [UNW_PPC64_V8]=UNW_PPC64_V8,
+        [UNW_PPC64_V9]=UNW_PPC64_V9,
+        [UNW_PPC64_V10]=UNW_PPC64_V10,
+        [UNW_PPC64_V11]=UNW_PPC64_V11,
+        [UNW_PPC64_V12]=UNW_PPC64_V12,
+        [UNW_PPC64_V13]=UNW_PPC64_V13,
+        [UNW_PPC64_V14]=UNW_PPC64_V14,
+        [UNW_PPC64_V15]=UNW_PPC64_V15,
+        [UNW_PPC64_V16]=UNW_PPC64_V16,
+        [UNW_PPC64_V17]=UNW_PPC64_V17,
+        [UNW_PPC64_V18]=UNW_PPC64_V18,
+        [UNW_PPC64_V19]=UNW_PPC64_V19,
+        [UNW_PPC64_V20]=UNW_PPC64_V20,
+        [UNW_PPC64_V21]=UNW_PPC64_V21,
+        [UNW_PPC64_V22]=UNW_PPC64_V22,
+        [UNW_PPC64_V23]=UNW_PPC64_V23,
+        [UNW_PPC64_V24]=UNW_PPC64_V24,
+        [UNW_PPC64_V25]=UNW_PPC64_V25,
+        [UNW_PPC64_V26]=UNW_PPC64_V26,
+        [UNW_PPC64_V27]=UNW_PPC64_V27,
+        [UNW_PPC64_V28]=UNW_PPC64_V28,
+        [UNW_PPC64_V29]=UNW_PPC64_V29,
+        [UNW_PPC64_V30]=UNW_PPC64_V30,
+        [UNW_PPC64_V31]=UNW_PPC64_V31,
+
+        [UNW_PPC64_VRSAVE]=UNW_PPC64_VRSAVE,
+        [UNW_PPC64_VSCR]=UNW_PPC64_VSCR,
+        [UNW_PPC64_SPE_ACC]=UNW_PPC64_SPE_ACC,
+        [UNW_PPC64_SPEFSCR]=UNW_PPC64_SPEFSCR,
   };
 
 HIDDEN void
@@ -175,7 +175,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     ppc64_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&ppc64_lock, saved_mask);
diff --git a/src/ppc64/Ginit.c b/src/ppc64/Ginit.c
index 52bf715..4c88cd6 100644
--- a/src/ppc64/Ginit.c
+++ b/src/ppc64/Ginit.c
@@ -34,13 +34,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 static void *
 uc_addr (ucontext_t *uc, int reg)
@@ -61,25 +61,25 @@ uc_addr (ucontext_t *uc, int reg)
       unsigned gregs_idx;
 
       switch (reg)
-	{
-	case UNW_PPC64_NIP:
-	  gregs_idx = NIP_IDX;
-	  break;
-	case UNW_PPC64_CTR:
-	  gregs_idx = CTR_IDX;
-	  break;
-	case UNW_PPC64_LR:
-	  gregs_idx = LINK_IDX;
-	  break;
-	case UNW_PPC64_XER:
-	  gregs_idx = XER_IDX;
-	  break;
-	case UNW_PPC64_CR0:
-	  gregs_idx = CCR_IDX;
-	  break;
-	default:
-	  return NULL;
-	}
+        {
+        case UNW_PPC64_NIP:
+          gregs_idx = NIP_IDX;
+          break;
+        case UNW_PPC64_CTR:
+          gregs_idx = CTR_IDX;
+          break;
+        case UNW_PPC64_LR:
+          gregs_idx = LINK_IDX;
+          break;
+        case UNW_PPC64_XER:
+          gregs_idx = XER_IDX;
+          break;
+        case UNW_PPC64_CR0:
+          gregs_idx = CCR_IDX;
+          break;
+        default:
+          return NULL;
+        }
       addr = &uc->uc_mcontext.gp_regs[gregs_idx];
     }
   return addr;
@@ -93,7 +93,7 @@ tdep_uc_addr (ucontext_t *uc, int reg)
   return uc_addr (uc, reg);
 }
 
-# endif	/* UNW_LOCAL_ONLY */
+# endif /* UNW_LOCAL_ONLY */
 
 HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
 
@@ -106,7 +106,7 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
   return 0;
@@ -114,7 +114,7 @@ get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (write)
     {
@@ -131,7 +131,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
-	    int write, void *arg)
+            int write, void *arg)
 {
   unw_word_t *addr;
   ucontext_t *uc = arg;
@@ -164,18 +164,16 @@ badreg:
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = arg;
   unw_fpreg_t *addr;
 
-  if ((unsigned) (reg - UNW_PPC64_F0) < 0)
+  /* Allow only 32 fregs and 32 vregs */
+  if (!(((unsigned) (reg - UNW_PPC64_F0) < 32)
+	||((unsigned) (reg - UNW_PPC64_V0) < 32)))
     goto badreg;
 
-  if ((unsigned) (reg - UNW_PPC64_V0) >= 32)
-    goto badreg;
-
-
   addr = uc_addr (uc, reg);
   if (!addr)
     goto badreg;
@@ -200,8 +198,8 @@ badreg:
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf64_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -210,7 +208,13 @@ HIDDEN void
 ppc64_local_addr_space_init (void)
 {
   memset (&local_addr_space, 0, sizeof (local_addr_space));
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.big_endian = (__BYTE_ORDER == __BIG_ENDIAN);
+#if _CALL_ELF == 2
+  local_addr_space.abi = UNW_PPC64_ABI_ELFv2;
+#else
+  local_addr_space.abi = UNW_PPC64_ABI_ELFv1;
+#endif
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
diff --git a/src/ppc64/Greg_states_iterate.c b/src/ppc64/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/ppc64/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/ppc64/Gregs.c b/src/ppc64/Gregs.c
index b044504..1cb5d9d 100644
--- a/src/ppc64/Gregs.c
+++ b/src/ppc64/Gregs.c
@@ -29,42 +29,83 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   struct dwarf_loc loc;
 
   switch (reg)
     {
+    case UNW_PPC64_R0:
+    case UNW_PPC64_R2:
+    case UNW_PPC64_R3:
+    case UNW_PPC64_R4:
+    case UNW_PPC64_R5:
+    case UNW_PPC64_R6:
+    case UNW_PPC64_R7:
+    case UNW_PPC64_R8:
+    case UNW_PPC64_R9:
+    case UNW_PPC64_R10:
+    case UNW_PPC64_R11:
+    case UNW_PPC64_R12:
+    case UNW_PPC64_R13:
+    case UNW_PPC64_R14:
+    case UNW_PPC64_R15:
+    case UNW_PPC64_R16:
+    case UNW_PPC64_R17:
+    case UNW_PPC64_R18:
+    case UNW_PPC64_R19:
+    case UNW_PPC64_R20:
+    case UNW_PPC64_R21:
+    case UNW_PPC64_R22:
+    case UNW_PPC64_R23:
+    case UNW_PPC64_R24:
+    case UNW_PPC64_R25:
+    case UNW_PPC64_R26:
+    case UNW_PPC64_R27:
+    case UNW_PPC64_R28:
+    case UNW_PPC64_R29:
+    case UNW_PPC64_R30:
+    case UNW_PPC64_R31:
+    case UNW_PPC64_LR:
+    case UNW_PPC64_CTR:
+    case UNW_PPC64_CR0:
+    case UNW_PPC64_CR1:
+    case UNW_PPC64_CR2:
+    case UNW_PPC64_CR3:
+    case UNW_PPC64_CR4:
+    case UNW_PPC64_CR5:
+    case UNW_PPC64_CR6:
+    case UNW_PPC64_CR7:
+    case UNW_PPC64_VRSAVE:
+    case UNW_PPC64_VSCR:
+    case UNW_PPC64_SPE_ACC:
+    case UNW_PPC64_SPEFSCR:
+      loc = c->dwarf.loc[reg];
+      break;
+
     case UNW_TDEP_IP:
       if (write)
-	{
-	  c->dwarf.ip = *valp;	/* update the IP cache */
-	  if (c->dwarf.pi_valid && (*valp < c->dwarf.pi.start_ip
-				    || *valp >= c->dwarf.pi.end_ip))
-	    c->dwarf.pi_valid = 0;	/* new IP outside of current proc */
-	}
+        {
+          c->dwarf.ip = *valp;  /* update the IP cache */
+          if (c->dwarf.pi_valid && (*valp < c->dwarf.pi.start_ip
+                                    || *valp >= c->dwarf.pi.end_ip))
+            c->dwarf.pi_valid = 0;      /* new IP outside of current proc */
+        }
       else
-	*valp = c->dwarf.ip;
+        *valp = c->dwarf.ip;
       return 0;
 
     case UNW_TDEP_SP:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = c->dwarf.cfa;
       return 0;
 
-
     default:
+      return -UNW_EBADREG;
       break;
     }
 
-  /* make sure it's not an FP or VR register */
-  if ((((unsigned) (reg - UNW_PPC64_F0)) <= 31) ||
-      (((unsigned) (reg - UNW_PPC64_V0)) <= 31))
-    return -UNW_EBADREG;
-
-  loc = c->dwarf.loc[reg];
-
   if (write)
     return dwarf_put (&c->dwarf, loc, *valp);
   else
@@ -73,7 +114,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   struct dwarf_loc loc;
 
diff --git a/src/ppc64/Gresume.c b/src/ppc64/Gresume.c
index 893ea63..0d832d0 100644
--- a/src/ppc64/Gresume.c
+++ b/src/ppc64/Gresume.c
@@ -45,7 +45,20 @@ my_rt_sigreturn (void *new_sp)
 HIDDEN inline int
 ppc64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
 {
-  /* XXX: empty stub.  */
+  struct cursor *c = (struct cursor *) cursor;
+  ucontext_t *uc = (ucontext_t *)c->dwarf.as_arg;
+
+  if (unlikely (c->sigcontext_format != PPC_SCF_NONE))
+    {
+      my_rt_sigreturn(cursor);
+      abort();
+    }
+  else
+    {
+      Debug (8, "resuming at ip=%llx via setcontext()\n",
+            (unsigned long long) c->dwarf.ip);
+      setcontext (uc);
+    }
   return -UNW_EINVAL;
 }
 
@@ -57,11 +70,32 @@ ppc64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
 static inline int
 establish_machine_state (struct cursor *c)
 {
-  /* XXX: empty stub.  */
+  unw_addr_space_t as = c->dwarf.as;
+  void *arg = c->dwarf.as_arg;
+  unw_fpreg_t fpval;
+  unw_word_t val;
+  int reg;
+
+  Debug (8, "copying out cursor state\n");
+
+  for (reg = 0; reg <= UNW_REG_LAST; ++reg)
+    {
+      Debug (16, "copying %s %d\n", unw_regname (reg), reg);
+      if (unw_is_fpreg (reg))
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            as->acc.access_fpreg (as, reg, &fpval, 1, arg);
+        }
+      else
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            as->acc.access_reg (as, reg, &val, 1, arg);
+        }
+    }
   return 0;
 }
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -73,5 +107,5 @@ unw_resume (unw_cursor_t *cursor)
     return ret;
 
   return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
-				     c->dwarf.as_arg);
+                                     c->dwarf.as_arg);
 }
diff --git a/src/ppc64/Gstep.c b/src/ppc64/Gstep.c
index e9ab39f..f44e959 100644
--- a/src/ppc64/Gstep.c
+++ b/src/ppc64/Gstep.c
@@ -27,6 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 #include "ucontext_i.h"
+#include "remote.h"
 #include <signal.h>
 
 /* This definition originates in /usr/include/asm-ppc64/ptrace.h, but is
@@ -50,24 +51,17 @@ typedef struct
 } stack_frame_t;
 
 
-PROTECTED int
+int
 unw_step (unw_cursor_t * cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
   stack_frame_t dummy;
   unw_word_t back_chain_offset, lr_save_offset, v_regs_ptr;
   struct dwarf_loc back_chain_loc, lr_save_loc, sp_loc, ip_loc, v_regs_loc;
-  int ret;
+  int ret, i;
 
   Debug (1, "(cursor=%p, ip=0x%016lx)\n", c, (unsigned long) c->dwarf.ip);
 
-  if (c->dwarf.ip == 0)
-    {
-      /* Unless the cursor or stack is corrupt or uninitialized,
-         we've most likely hit the top of the stack */
-      return 0;
-    }
-
   /* Try DWARF-based unwinding... */
 
   ret = dwarf_step (&c->dwarf);
@@ -80,49 +74,54 @@ unw_step (unw_cursor_t * cursor)
 
   if (unlikely (ret < 0))
     {
-      if (likely (!unw_is_signal_frame (cursor)))
-	{
-	  /* DWARF unwinding failed.  As of 09/26/2006, gcc in 64-bit mode
-	     produces the mandatory level of traceback record in the code, but
-	     I get the impression that this is transitory, that eventually gcc
-	     will not produce any traceback records at all.  So, for now, we
-	     won't bother to try to find and use these records.
-
-	     We can, however, attempt to unwind the frame by using the callback
-	     chain.  This is very crude, however, and won't be able to unwind
-	     any registers besides the IP, SP, and LR . */
-
-	  back_chain_offset = ((void *) &dummy.back_chain - (void *) &dummy);
-	  lr_save_offset = ((void *) &dummy.lr_save - (void *) &dummy);
-
-	  back_chain_loc = DWARF_LOC (c->dwarf.cfa + back_chain_offset, 0);
-
-	  if ((ret =
-	       dwarf_get (&c->dwarf, back_chain_loc, &c->dwarf.cfa)) < 0)
-	    {
-	      Debug (2,
-		 "Unable to retrieve CFA from back chain in stack frame - %d\n",
-		 ret);
-	      return ret;
-	    }
-	  if (c->dwarf.cfa == 0)
-	    /* Unless the cursor or stack is corrupt or uninitialized we've most
-	       likely hit the top of the stack */
-	    return 0;
-
-	  lr_save_loc = DWARF_LOC (c->dwarf.cfa + lr_save_offset, 0);
-
-	  if ((ret = dwarf_get (&c->dwarf, lr_save_loc, &c->dwarf.ip)) < 0)
-	    {
-	      Debug (2,
-		 "Unable to retrieve IP from lr save in stack frame - %d\n",
-		 ret);
-	      return ret;
-	    }
-	  ret = 1;
-	}
+      if (likely (unw_is_signal_frame (cursor) <= 0))
+        {
+          /* DWARF unwinding failed.  As of 09/26/2006, gcc in 64-bit mode
+             produces the mandatory level of traceback record in the code, but
+             I get the impression that this is transitory, that eventually gcc
+             will not produce any traceback records at all.  So, for now, we
+             won't bother to try to find and use these records.
+
+             We can, however, attempt to unwind the frame by using the callback
+             chain.  This is very crude, however, and won't be able to unwind
+             any registers besides the IP, SP, and LR . */
+
+          back_chain_offset = ((void *) &dummy.back_chain - (void *) &dummy);
+          lr_save_offset = ((void *) &dummy.lr_save - (void *) &dummy);
+
+          back_chain_loc = DWARF_LOC (c->dwarf.cfa + back_chain_offset, 0);
+
+          if ((ret =
+               dwarf_get (&c->dwarf, back_chain_loc, &c->dwarf.cfa)) < 0)
+            {
+              Debug (2,
+                 "Unable to retrieve CFA from back chain in stack frame - %d\n",
+                 ret);
+              return ret;
+            }
+          if (c->dwarf.cfa == 0)
+            /* Unless the cursor or stack is corrupt or uninitialized we've most
+               likely hit the top of the stack */
+            return 0;
+
+          lr_save_loc = DWARF_LOC (c->dwarf.cfa + lr_save_offset, 0);
+
+          if ((ret = dwarf_get (&c->dwarf, lr_save_loc, &c->dwarf.ip)) < 0)
+            {
+              Debug (2,
+                 "Unable to retrieve IP from lr save in stack frame - %d\n",
+                 ret);
+              return ret;
+            }
+
+          /* Mark all registers unsaved */
+          for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
+            c->dwarf.loc[i] = DWARF_NULL_LOC;
+
+          ret = 1;
+        }
       else
-	{
+        {
           /* Find the sigcontext record by taking the CFA and adjusting by
              the dummy signal frame size.
 
@@ -133,304 +132,335 @@ unw_step (unw_cursor_t * cursor)
              following code will likely cause a seg fault or other crash
              condition.  */
 
-	  unw_word_t ucontext = c->dwarf.cfa + __SIGNAL_FRAMESIZE;
-
-	  Debug (1, "signal frame, skip over trampoline\n");
-
-	  c->sigcontext_format = PPC_SCF_LINUX_RT_SIGFRAME;
-	  c->sigcontext_addr = ucontext;
-
-	  sp_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
-	  ip_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_NIP, 0);
-
-	  ret = dwarf_get (&c->dwarf, sp_loc, &c->dwarf.cfa);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-	  ret = dwarf_get (&c->dwarf, ip_loc, &c->dwarf.ip);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-
-	  /* Instead of just restoring the non-volatile registers, do all
-	     of the registers for now.  This will incur a performance hit,
-	     but it's rare enough not to cause too much of a problem, and
-	     might be useful in some cases.  */
-	  c->dwarf.loc[UNW_PPC64_R0] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R0, 0);
-	  c->dwarf.loc[UNW_PPC64_R1] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
-	  c->dwarf.loc[UNW_PPC64_R2] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R2, 0);
-	  c->dwarf.loc[UNW_PPC64_R3] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R3, 0);
-	  c->dwarf.loc[UNW_PPC64_R4] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R4, 0);
-	  c->dwarf.loc[UNW_PPC64_R5] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R5, 0);
-	  c->dwarf.loc[UNW_PPC64_R6] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R6, 0);
-	  c->dwarf.loc[UNW_PPC64_R7] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R7, 0);
-	  c->dwarf.loc[UNW_PPC64_R8] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R8, 0);
-	  c->dwarf.loc[UNW_PPC64_R9] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R9, 0);
-	  c->dwarf.loc[UNW_PPC64_R10] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R10, 0);
-	  c->dwarf.loc[UNW_PPC64_R11] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R11, 0);
-	  c->dwarf.loc[UNW_PPC64_R12] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R12, 0);
-	  c->dwarf.loc[UNW_PPC64_R13] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R13, 0);
-	  c->dwarf.loc[UNW_PPC64_R14] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R14, 0);
-	  c->dwarf.loc[UNW_PPC64_R15] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R15, 0);
-	  c->dwarf.loc[UNW_PPC64_R16] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R16, 0);
-	  c->dwarf.loc[UNW_PPC64_R17] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R17, 0);
-	  c->dwarf.loc[UNW_PPC64_R18] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R18, 0);
-	  c->dwarf.loc[UNW_PPC64_R19] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R19, 0);
-	  c->dwarf.loc[UNW_PPC64_R20] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R20, 0);
-	  c->dwarf.loc[UNW_PPC64_R21] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R21, 0);
-	  c->dwarf.loc[UNW_PPC64_R22] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R22, 0);
-	  c->dwarf.loc[UNW_PPC64_R23] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R23, 0);
-	  c->dwarf.loc[UNW_PPC64_R24] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R24, 0);
-	  c->dwarf.loc[UNW_PPC64_R25] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R25, 0);
-	  c->dwarf.loc[UNW_PPC64_R26] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R26, 0);
-	  c->dwarf.loc[UNW_PPC64_R27] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R27, 0);
-	  c->dwarf.loc[UNW_PPC64_R28] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R28, 0);
-	  c->dwarf.loc[UNW_PPC64_R29] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R29, 0);
-	  c->dwarf.loc[UNW_PPC64_R30] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R30, 0);
-	  c->dwarf.loc[UNW_PPC64_R31] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R31, 0);
-
-	  c->dwarf.loc[UNW_PPC64_LR] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_LINK, 0);
-	  c->dwarf.loc[UNW_PPC64_CTR] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CTR, 0);
-	  /* This CR0 assignment is probably wrong.  There are 8 dwarf columns
-	     assigned to the CR registers, but only one CR register in the
-	     mcontext structure */
-	  c->dwarf.loc[UNW_PPC64_CR0] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CCR, 0);
-	  c->dwarf.loc[UNW_PPC64_XER] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_XER, 0);
-	  c->dwarf.loc[UNW_PPC64_NIP] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_NIP, 0);
-
-	  /* TODO: Is there a way of obtaining the value of the
-	     pseudo frame pointer (which is sp + some fixed offset, I
-	     assume), based on the contents of the ucontext record
-	     structure?  For now, set this loc to null. */
-	  c->dwarf.loc[UNW_PPC64_FRAME_POINTER] = DWARF_NULL_LOC;
-
-	  c->dwarf.loc[UNW_PPC64_F0] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R0, 0);
-	  c->dwarf.loc[UNW_PPC64_F1] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R1, 0);
-	  c->dwarf.loc[UNW_PPC64_F2] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R2, 0);
-	  c->dwarf.loc[UNW_PPC64_F3] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R3, 0);
-	  c->dwarf.loc[UNW_PPC64_F4] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R4, 0);
-	  c->dwarf.loc[UNW_PPC64_F5] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R5, 0);
-	  c->dwarf.loc[UNW_PPC64_F6] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R6, 0);
-	  c->dwarf.loc[UNW_PPC64_F7] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R7, 0);
-	  c->dwarf.loc[UNW_PPC64_F8] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R8, 0);
-	  c->dwarf.loc[UNW_PPC64_F9] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R9, 0);
-	  c->dwarf.loc[UNW_PPC64_F10] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R10, 0);
-	  c->dwarf.loc[UNW_PPC64_F11] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R11, 0);
-	  c->dwarf.loc[UNW_PPC64_F12] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R12, 0);
-	  c->dwarf.loc[UNW_PPC64_F13] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R13, 0);
-	  c->dwarf.loc[UNW_PPC64_F14] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R14, 0);
-	  c->dwarf.loc[UNW_PPC64_F15] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R15, 0);
-	  c->dwarf.loc[UNW_PPC64_F16] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R16, 0);
-	  c->dwarf.loc[UNW_PPC64_F17] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R17, 0);
-	  c->dwarf.loc[UNW_PPC64_F18] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R18, 0);
-	  c->dwarf.loc[UNW_PPC64_F19] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R19, 0);
-	  c->dwarf.loc[UNW_PPC64_F20] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R20, 0);
-	  c->dwarf.loc[UNW_PPC64_F21] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R21, 0);
-	  c->dwarf.loc[UNW_PPC64_F22] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R22, 0);
-	  c->dwarf.loc[UNW_PPC64_F23] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R23, 0);
-	  c->dwarf.loc[UNW_PPC64_F24] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R24, 0);
-	  c->dwarf.loc[UNW_PPC64_F25] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R25, 0);
-	  c->dwarf.loc[UNW_PPC64_F26] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R26, 0);
-	  c->dwarf.loc[UNW_PPC64_F27] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R27, 0);
-	  c->dwarf.loc[UNW_PPC64_F28] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R28, 0);
-	  c->dwarf.loc[UNW_PPC64_F29] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R29, 0);
-	  c->dwarf.loc[UNW_PPC64_F30] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R30, 0);
-	  c->dwarf.loc[UNW_PPC64_F31] =
-	    DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R31, 0);
-	  /* Note that there is no .eh_section register column for the
-	     FPSCR register.  I don't know why this is.  */
-
-	  v_regs_loc = DWARF_LOC (ucontext + UC_MCONTEXT_V_REGS, 0);
-	  ret = dwarf_get (&c->dwarf, v_regs_loc, &v_regs_ptr);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-	  if (v_regs_ptr != 0)
-	    {
-	      /* The v_regs_ptr is not null.  Set all of the AltiVec locs */
-
-	      c->dwarf.loc[UNW_PPC64_V0] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R0, 0);
-	      c->dwarf.loc[UNW_PPC64_V1] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R1, 0);
-	      c->dwarf.loc[UNW_PPC64_V2] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R2, 0);
-	      c->dwarf.loc[UNW_PPC64_V3] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R3, 0);
-	      c->dwarf.loc[UNW_PPC64_V4] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R4, 0);
-	      c->dwarf.loc[UNW_PPC64_V5] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R5, 0);
-	      c->dwarf.loc[UNW_PPC64_V6] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R6, 0);
-	      c->dwarf.loc[UNW_PPC64_V7] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R7, 0);
-	      c->dwarf.loc[UNW_PPC64_V8] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R8, 0);
-	      c->dwarf.loc[UNW_PPC64_V9] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R9, 0);
-	      c->dwarf.loc[UNW_PPC64_V10] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R10, 0);
-	      c->dwarf.loc[UNW_PPC64_V11] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R11, 0);
-	      c->dwarf.loc[UNW_PPC64_V12] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R12, 0);
-	      c->dwarf.loc[UNW_PPC64_V13] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R13, 0);
-	      c->dwarf.loc[UNW_PPC64_V14] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R14, 0);
-	      c->dwarf.loc[UNW_PPC64_V15] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R15, 0);
-	      c->dwarf.loc[UNW_PPC64_V16] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R16, 0);
-	      c->dwarf.loc[UNW_PPC64_V17] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R17, 0);
-	      c->dwarf.loc[UNW_PPC64_V18] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R18, 0);
-	      c->dwarf.loc[UNW_PPC64_V19] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R19, 0);
-	      c->dwarf.loc[UNW_PPC64_V20] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R20, 0);
-	      c->dwarf.loc[UNW_PPC64_V21] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R21, 0);
-	      c->dwarf.loc[UNW_PPC64_V22] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R22, 0);
-	      c->dwarf.loc[UNW_PPC64_V23] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R23, 0);
-	      c->dwarf.loc[UNW_PPC64_V24] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R24, 0);
-	      c->dwarf.loc[UNW_PPC64_V25] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R25, 0);
-	      c->dwarf.loc[UNW_PPC64_V26] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R26, 0);
-	      c->dwarf.loc[UNW_PPC64_V27] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R27, 0);
-	      c->dwarf.loc[UNW_PPC64_V28] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R28, 0);
-	      c->dwarf.loc[UNW_PPC64_V29] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R29, 0);
-	      c->dwarf.loc[UNW_PPC64_V30] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R30, 0);
-	      c->dwarf.loc[UNW_PPC64_V31] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R31, 0);
-	      c->dwarf.loc[UNW_PPC64_VRSAVE] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_VRSAVE, 0);
-	      c->dwarf.loc[UNW_PPC64_VSCR] =
-		DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_VSCR, 0);
-	    }
-	  else
-	    {
-	      c->dwarf.loc[UNW_PPC64_V0] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V1] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V2] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V3] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V4] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V5] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V6] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V7] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V8] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V9] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V10] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V11] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V12] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V13] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V14] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V15] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V16] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V17] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V18] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V19] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V20] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V21] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V22] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V23] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V24] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V25] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V26] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V27] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V28] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V29] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V30] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_V31] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_VRSAVE] = DWARF_NULL_LOC;
-	      c->dwarf.loc[UNW_PPC64_VSCR] = DWARF_NULL_LOC;
-	    }
-	  ret = 1;
-	}
+          unw_word_t ucontext = c->dwarf.cfa + __SIGNAL_FRAMESIZE;
+
+          Debug (1, "signal frame, skip over trampoline\n");
+
+          c->sigcontext_format = PPC_SCF_LINUX_RT_SIGFRAME;
+          c->sigcontext_addr = ucontext;
+
+          sp_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
+          ip_loc = DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_NIP, 0);
+
+          ret = dwarf_get (&c->dwarf, sp_loc, &c->dwarf.cfa);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+          ret = dwarf_get (&c->dwarf, ip_loc, &c->dwarf.ip);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+
+          /* Instead of just restoring the non-volatile registers, do all
+             of the registers for now.  This will incur a performance hit,
+             but it's rare enough not to cause too much of a problem, and
+             might be useful in some cases.  */
+          c->dwarf.loc[UNW_PPC64_R0] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R0, 0);
+          c->dwarf.loc[UNW_PPC64_R1] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R1, 0);
+          c->dwarf.loc[UNW_PPC64_R2] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R2, 0);
+          c->dwarf.loc[UNW_PPC64_R3] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R3, 0);
+          c->dwarf.loc[UNW_PPC64_R4] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R4, 0);
+          c->dwarf.loc[UNW_PPC64_R5] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R5, 0);
+          c->dwarf.loc[UNW_PPC64_R6] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R6, 0);
+          c->dwarf.loc[UNW_PPC64_R7] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R7, 0);
+          c->dwarf.loc[UNW_PPC64_R8] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R8, 0);
+          c->dwarf.loc[UNW_PPC64_R9] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R9, 0);
+          c->dwarf.loc[UNW_PPC64_R10] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R10, 0);
+          c->dwarf.loc[UNW_PPC64_R11] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R11, 0);
+          c->dwarf.loc[UNW_PPC64_R12] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R12, 0);
+          c->dwarf.loc[UNW_PPC64_R13] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R13, 0);
+          c->dwarf.loc[UNW_PPC64_R14] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R14, 0);
+          c->dwarf.loc[UNW_PPC64_R15] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R15, 0);
+          c->dwarf.loc[UNW_PPC64_R16] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R16, 0);
+          c->dwarf.loc[UNW_PPC64_R17] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R17, 0);
+          c->dwarf.loc[UNW_PPC64_R18] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R18, 0);
+          c->dwarf.loc[UNW_PPC64_R19] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R19, 0);
+          c->dwarf.loc[UNW_PPC64_R20] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R20, 0);
+          c->dwarf.loc[UNW_PPC64_R21] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R21, 0);
+          c->dwarf.loc[UNW_PPC64_R22] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R22, 0);
+          c->dwarf.loc[UNW_PPC64_R23] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R23, 0);
+          c->dwarf.loc[UNW_PPC64_R24] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R24, 0);
+          c->dwarf.loc[UNW_PPC64_R25] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R25, 0);
+          c->dwarf.loc[UNW_PPC64_R26] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R26, 0);
+          c->dwarf.loc[UNW_PPC64_R27] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R27, 0);
+          c->dwarf.loc[UNW_PPC64_R28] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R28, 0);
+          c->dwarf.loc[UNW_PPC64_R29] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R29, 0);
+          c->dwarf.loc[UNW_PPC64_R30] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R30, 0);
+          c->dwarf.loc[UNW_PPC64_R31] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_R31, 0);
+
+          c->dwarf.loc[UNW_PPC64_LR] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_LINK, 0);
+          c->dwarf.loc[UNW_PPC64_CTR] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CTR, 0);
+          /* This CR0 assignment is probably wrong.  There are 8 dwarf columns
+             assigned to the CR registers, but only one CR register in the
+             mcontext structure */
+          c->dwarf.loc[UNW_PPC64_CR0] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_CCR, 0);
+          c->dwarf.loc[UNW_PPC64_XER] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_XER, 0);
+          c->dwarf.loc[UNW_PPC64_NIP] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_GREGS_NIP, 0);
+
+          /* TODO: Is there a way of obtaining the value of the
+             pseudo frame pointer (which is sp + some fixed offset, I
+             assume), based on the contents of the ucontext record
+             structure?  For now, set this loc to null. */
+          c->dwarf.loc[UNW_PPC64_FRAME_POINTER] = DWARF_NULL_LOC;
+
+          c->dwarf.loc[UNW_PPC64_F0] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R0, 0);
+          c->dwarf.loc[UNW_PPC64_F1] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R1, 0);
+          c->dwarf.loc[UNW_PPC64_F2] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R2, 0);
+          c->dwarf.loc[UNW_PPC64_F3] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R3, 0);
+          c->dwarf.loc[UNW_PPC64_F4] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R4, 0);
+          c->dwarf.loc[UNW_PPC64_F5] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R5, 0);
+          c->dwarf.loc[UNW_PPC64_F6] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R6, 0);
+          c->dwarf.loc[UNW_PPC64_F7] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R7, 0);
+          c->dwarf.loc[UNW_PPC64_F8] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R8, 0);
+          c->dwarf.loc[UNW_PPC64_F9] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R9, 0);
+          c->dwarf.loc[UNW_PPC64_F10] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R10, 0);
+          c->dwarf.loc[UNW_PPC64_F11] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R11, 0);
+          c->dwarf.loc[UNW_PPC64_F12] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R12, 0);
+          c->dwarf.loc[UNW_PPC64_F13] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R13, 0);
+          c->dwarf.loc[UNW_PPC64_F14] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R14, 0);
+          c->dwarf.loc[UNW_PPC64_F15] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R15, 0);
+          c->dwarf.loc[UNW_PPC64_F16] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R16, 0);
+          c->dwarf.loc[UNW_PPC64_F17] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R17, 0);
+          c->dwarf.loc[UNW_PPC64_F18] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R18, 0);
+          c->dwarf.loc[UNW_PPC64_F19] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R19, 0);
+          c->dwarf.loc[UNW_PPC64_F20] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R20, 0);
+          c->dwarf.loc[UNW_PPC64_F21] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R21, 0);
+          c->dwarf.loc[UNW_PPC64_F22] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R22, 0);
+          c->dwarf.loc[UNW_PPC64_F23] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R23, 0);
+          c->dwarf.loc[UNW_PPC64_F24] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R24, 0);
+          c->dwarf.loc[UNW_PPC64_F25] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R25, 0);
+          c->dwarf.loc[UNW_PPC64_F26] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R26, 0);
+          c->dwarf.loc[UNW_PPC64_F27] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R27, 0);
+          c->dwarf.loc[UNW_PPC64_F28] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R28, 0);
+          c->dwarf.loc[UNW_PPC64_F29] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R29, 0);
+          c->dwarf.loc[UNW_PPC64_F30] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R30, 0);
+          c->dwarf.loc[UNW_PPC64_F31] =
+            DWARF_LOC (ucontext + UC_MCONTEXT_FREGS_R31, 0);
+          /* Note that there is no .eh_section register column for the
+             FPSCR register.  I don't know why this is.  */
+
+          v_regs_loc = DWARF_LOC (ucontext + UC_MCONTEXT_V_REGS, 0);
+          ret = dwarf_get (&c->dwarf, v_regs_loc, &v_regs_ptr);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+          if (v_regs_ptr != 0)
+            {
+              /* The v_regs_ptr is not null.  Set all of the AltiVec locs */
+
+              c->dwarf.loc[UNW_PPC64_V0] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R0, 0);
+              c->dwarf.loc[UNW_PPC64_V1] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R1, 0);
+              c->dwarf.loc[UNW_PPC64_V2] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R2, 0);
+              c->dwarf.loc[UNW_PPC64_V3] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R3, 0);
+              c->dwarf.loc[UNW_PPC64_V4] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R4, 0);
+              c->dwarf.loc[UNW_PPC64_V5] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R5, 0);
+              c->dwarf.loc[UNW_PPC64_V6] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R6, 0);
+              c->dwarf.loc[UNW_PPC64_V7] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R7, 0);
+              c->dwarf.loc[UNW_PPC64_V8] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R8, 0);
+              c->dwarf.loc[UNW_PPC64_V9] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R9, 0);
+              c->dwarf.loc[UNW_PPC64_V10] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R10, 0);
+              c->dwarf.loc[UNW_PPC64_V11] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R11, 0);
+              c->dwarf.loc[UNW_PPC64_V12] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R12, 0);
+              c->dwarf.loc[UNW_PPC64_V13] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R13, 0);
+              c->dwarf.loc[UNW_PPC64_V14] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R14, 0);
+              c->dwarf.loc[UNW_PPC64_V15] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R15, 0);
+              c->dwarf.loc[UNW_PPC64_V16] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R16, 0);
+              c->dwarf.loc[UNW_PPC64_V17] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R17, 0);
+              c->dwarf.loc[UNW_PPC64_V18] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R18, 0);
+              c->dwarf.loc[UNW_PPC64_V19] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R19, 0);
+              c->dwarf.loc[UNW_PPC64_V20] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R20, 0);
+              c->dwarf.loc[UNW_PPC64_V21] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R21, 0);
+              c->dwarf.loc[UNW_PPC64_V22] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R22, 0);
+              c->dwarf.loc[UNW_PPC64_V23] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R23, 0);
+              c->dwarf.loc[UNW_PPC64_V24] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R24, 0);
+              c->dwarf.loc[UNW_PPC64_V25] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R25, 0);
+              c->dwarf.loc[UNW_PPC64_V26] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R26, 0);
+              c->dwarf.loc[UNW_PPC64_V27] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R27, 0);
+              c->dwarf.loc[UNW_PPC64_V28] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R28, 0);
+              c->dwarf.loc[UNW_PPC64_V29] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R29, 0);
+              c->dwarf.loc[UNW_PPC64_V30] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R30, 0);
+              c->dwarf.loc[UNW_PPC64_V31] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_R31, 0);
+              c->dwarf.loc[UNW_PPC64_VRSAVE] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_VRSAVE, 0);
+              c->dwarf.loc[UNW_PPC64_VSCR] =
+                DWARF_LOC (v_regs_ptr + UC_MCONTEXT_VREGS_VSCR, 0);
+            }
+          else
+            {
+              c->dwarf.loc[UNW_PPC64_V0] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V1] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V2] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V3] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V4] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V5] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V6] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V7] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V8] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V9] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V10] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V11] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V12] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V13] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V14] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V15] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V16] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V17] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V18] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V19] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V20] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V21] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V22] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V23] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V24] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V25] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V26] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V27] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V28] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V29] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V30] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_V31] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_VRSAVE] = DWARF_NULL_LOC;
+              c->dwarf.loc[UNW_PPC64_VSCR] = DWARF_NULL_LOC;
+            }
+          ret = 1;
+        }
     }
+
+  if (c->dwarf.ip == 0)
+    {
+      /* Unless the cursor or stack is corrupt or uninitialized,
+         we've most likely hit the top of the stack */
+      Debug (2, "returning 0\n");
+      return 0;
+    }
+
+  // on ppc64, R2 register is used as pointer to TOC
+  // section which is used for symbol lookup in PIC code
+  // ppc64 linker generates "ld r2, 40(r1)" (ELFv1) or
+  // "ld r2, 24(r1)" (ELFv2) instruction after each
+  // @plt call. We need restore R2, but only for @plt calls
+  {
+    unw_word_t ip = c->dwarf.ip;
+    unw_addr_space_t as = c->dwarf.as;
+    unw_accessors_t *a = unw_get_accessors_int (as);
+    void *arg = c->dwarf.as_arg;
+    uint32_t toc_save = (as->abi == UNW_PPC64_ABI_ELFv2)? 24 : 40;
+    int32_t inst;
+
+    if (fetch32 (as, a, &ip, &inst, arg) >= 0
+	&& (uint32_t)inst == (0xE8410000U + toc_save))
+      {
+	// @plt call, restoring R2 from CFA+toc_save
+	c->dwarf.loc[UNW_PPC64_R2] = DWARF_LOC(c->dwarf.cfa + toc_save, 0);
+      }
+  }
+
+  Debug (2, "returning %d with last return statement\n", ret);
   return ret;
 }
diff --git a/src/ppc64/Lapply_reg_state.c b/src/ppc64/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/ppc64/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/ppc64/Lcreate_addr_space.c b/src/ppc64/Lcreate_addr_space.c
new file mode 100644
index 0000000..0f2dc6b
--- /dev/null
+++ b/src/ppc64/Lcreate_addr_space.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gcreate_addr_space.c"
+#endif
diff --git a/src/ppc64/Lreg_states_iterate.c b/src/ppc64/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/ppc64/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/ppc64/get_func_addr.c b/src/ppc64/get_func_addr.c
index a9c828d..80a58fa 100644
--- a/src/ppc64/get_func_addr.c
+++ b/src/ppc64/get_func_addr.c
@@ -29,17 +29,23 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 int
 tdep_get_func_addr (unw_addr_space_t as, unw_word_t addr,
-		    unw_word_t *entry_point)
+                    unw_word_t *entry_point)
 {
-  unw_accessors_t *a;
-  int ret;
-
-  a = unw_get_accessors (as);
-  /* Entry-point is stored in the 1st word of the function descriptor.
-     In case that changes in the future, we'd have to update the line
-     below and read the word at addr + offset: */
-  ret = (*a->access_mem) (as, addr, entry_point, 0, NULL);
-  if (ret < 0)
-    return ret;
+  if (as->abi == UNW_PPC64_ABI_ELFv1)
+    {
+      unw_accessors_t *a;
+      int ret;
+
+      a = unw_get_accessors_int (as);
+      /* Entry-point is stored in the 1st word of the function descriptor.
+         In case that changes in the future, we'd have to update the line
+         below and read the word at addr + offset: */
+      ret = (*a->access_mem) (as, addr, entry_point, 0, NULL);
+      if (ret < 0)
+        return ret;
+    }
+  else
+    *entry_point = addr;
+
   return 0;
 }
diff --git a/src/ppc64/init.h b/src/ppc64/init.h
index 7503a7c..9b81393 100644
--- a/src/ppc64/init.h
+++ b/src/ppc64/init.h
@@ -63,7 +63,7 @@ common_init_ppc64 (struct cursor *c, unsigned use_prev_instr)
     return ret;
 
   ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_PPC64_R1),
-		   &c->dwarf.cfa);
+                   &c->dwarf.cfa);
   if (ret < 0)
     return ret;
 
@@ -71,7 +71,6 @@ common_init_ppc64 (struct cursor *c, unsigned use_prev_instr)
   c->sigcontext_addr = 0;
 
   c->dwarf.args_size = 0;
-  c->dwarf.ret_addr_column = 0;
   c->dwarf.stash_frames = 0;
   c->dwarf.use_prev_instr = use_prev_instr;
   c->dwarf.pi_valid = 0;
diff --git a/src/ppc64/is_fpreg.c b/src/ppc64/is_fpreg.c
index b34bf87..653964a 100644
--- a/src/ppc64/is_fpreg.c
+++ b/src/ppc64/is_fpreg.c
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_is_fpreg (int regnum)
 {
   return (regnum >= UNW_PPC64_F0 && regnum <= UNW_PPC64_F31);
diff --git a/src/ppc64/regname.c b/src/ppc64/regname.c
index 3e3a141..58c6fa6 100644
--- a/src/ppc64/regname.c
+++ b/src/ppc64/regname.c
@@ -154,7 +154,7 @@ static const char *regname[] =
 
    };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
diff --git a/src/ppc64/ucontext_i.h b/src/ppc64/ucontext_i.h
index 245d667..2ddfdb8 100644
--- a/src/ppc64/ucontext_i.h
+++ b/src/ppc64/ucontext_i.h
@@ -33,18 +33,18 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
    /usr/src/linux-2.6.18-1.8/arch/powerpc/kernel/ppc32.h
 */
 
-#define NIP_IDX		32
-#define MSR_IDX		33
-#define ORIG_GPR3_IDX	34
-#define CTR_IDX		35
-#define LINK_IDX	36
-#define XER_IDX		37
-#define CCR_IDX		38
-#define SOFTE_IDX	39
-#define TRAP_IDX	40
-#define DAR_IDX		41
-#define DSISR_IDX	42
-#define RESULT_IDX	43
+#define NIP_IDX         32
+#define MSR_IDX         33
+#define ORIG_GPR3_IDX   34
+#define CTR_IDX         35
+#define LINK_IDX        36
+#define XER_IDX         37
+#define CCR_IDX         38
+#define SOFTE_IDX       39
+#define TRAP_IDX        40
+#define DAR_IDX         41
+#define DSISR_IDX       42
+#define RESULT_IDX      43
 
 #define VSCR_IDX        32
 #define VRSAVE_IDX      33
diff --git a/src/ppc64/unwind_i.h b/src/ppc64/unwind_i.h
index 206423e..26bbc2d 100644
--- a/src/ppc64/unwind_i.h
+++ b/src/ppc64/unwind_i.h
@@ -35,16 +35,16 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <libunwind_i.h>
 #include <sys/ucontext.h>
 
-#define ppc64_lock			UNW_OBJ(lock)
-#define ppc64_local_resume		UNW_OBJ(local_resume)
-#define ppc64_local_addr_space_init	UNW_OBJ(local_addr_space_init)
+#define ppc64_lock                      UNW_OBJ(lock)
+#define ppc64_local_resume              UNW_OBJ(local_resume)
+#define ppc64_local_addr_space_init     UNW_OBJ(local_addr_space_init)
 #if 0
-#define ppc64_scratch_loc		UNW_OBJ(scratch_loc)
+#define ppc64_scratch_loc               UNW_OBJ(scratch_loc)
 #endif
 
 extern void ppc64_local_addr_space_init (void);
 extern int ppc64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			     void *arg);
+                             void *arg);
 #if 0
 extern dwarf_loc_t ppc64_scratch_loc (struct cursor *c, unw_regnum_t reg);
 #endif
diff --git a/src/ptrace/_UPT_access_fpreg.c b/src/ptrace/_UPT_access_fpreg.c
index 4014377..37cd4ff 100644
--- a/src/ptrace/_UPT_access_fpreg.c
+++ b/src/ptrace/_UPT_access_fpreg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
    Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
 
 This file is part of libunwind.
@@ -29,7 +29,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #if HAVE_DECL_PTRACE_POKEUSER || HAVE_TTRACE
 int
 _UPT_access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-		   int write, void *arg)
+                   int write, void *arg)
 {
   unw_word_t *wp = (unw_word_t *) val;
   struct UPT_info *ui = arg;
@@ -44,57 +44,80 @@ _UPT_access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
     for (i = 0; i < (int) (sizeof (*val) / sizeof (wp[i])); ++i)
       {
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	ptrace (PTRACE_POKEUSER, pid, _UPT_reg_offset[reg] + i * sizeof(wp[i]),
-		wp[i]);
+        ptrace (PTRACE_POKEUSER, pid, _UPT_reg_offset[reg] + i * sizeof(wp[i]),
+                wp[i]);
 #endif
-	if (errno)
-	  return -UNW_EBADREG;
+        if (errno)
+          return -UNW_EBADREG;
       }
   else
     for (i = 0; i < (int) (sizeof (*val) / sizeof (wp[i])); ++i)
       {
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	wp[i] = ptrace (PTRACE_PEEKUSER, pid,
-			_UPT_reg_offset[reg] + i * sizeof(wp[i]), 0);
+        wp[i] = ptrace (PTRACE_PEEKUSER, pid,
+                        _UPT_reg_offset[reg] + i * sizeof(wp[i]), 0);
 #endif
-	if (errno)
-	  return -UNW_EBADREG;
+        if (errno)
+          return -UNW_EBADREG;
       }
   return 0;
 }
 #elif HAVE_DECL_PT_GETFPREGS
 int
 _UPT_access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-		   int write, void *arg)
+                   int write, void *arg)
 {
   struct UPT_info *ui = arg;
   pid_t pid = ui->pid;
   fpregset_t fpreg;
 
+#if defined(__amd64__)
+  if (1) /* XXXKIB */
+    return -UNW_EBADREG;
+#elif defined(__i386__)
+  if ((unsigned) reg < UNW_X86_ST0 || (unsigned) reg > UNW_X86_ST7)
+    return -UNW_EBADREG;
+#elif defined(__arm__)
+  if ((unsigned) reg < UNW_ARM_F0 || (unsigned) reg > UNW_ARM_F7)
+    return -UNW_EBADREG;
+#elif defined(__aarch64__)
+  if ((unsigned) reg < UNW_AARCH64_V0 || (unsigned) reg > UNW_AARCH64_V31)
+    return -UNW_EBADREG;
+#else
+#error Fix me
+#endif
   if ((unsigned) reg >= ARRAY_SIZE (_UPT_reg_offset))
     return -UNW_EBADREG;
 
   if (ptrace(PT_GETFPREGS, pid, (caddr_t)&fpreg, 0) == -1)
-	  return -UNW_EBADREG;
+          return -UNW_EBADREG;
   if (write) {
 #if defined(__amd64__)
-	  memcpy(&fpreg.fpr_xacc[reg], val, sizeof(unw_fpreg_t));
+          memcpy(&fpreg.fpr_xacc[reg], val, sizeof(unw_fpreg_t));
 #elif defined(__i386__)
-	  memcpy(&fpreg.fpr_acc[reg], val, sizeof(unw_fpreg_t));
+          memcpy(&fpreg.fpr_acc[reg], val, sizeof(unw_fpreg_t));
+#elif defined(__arm__)
+          memcpy(&fpreg.fpr[reg], val, sizeof(unw_fpreg_t));
+#elif defined(__aarch64__)
+          memcpy(&fpreg.fp_q[reg], val, sizeof(unw_fpreg_t));
 #else
 #error Fix me
 #endif
-	  if (ptrace(PT_SETFPREGS, pid, (caddr_t)&fpreg, 0) == -1)
-		  return -UNW_EBADREG;
+          if (ptrace(PT_SETFPREGS, pid, (caddr_t)&fpreg, 0) == -1)
+                  return -UNW_EBADREG;
   } else
 #if defined(__amd64__)
-	  memcpy(val, &fpreg.fpr_xacc[reg], sizeof(unw_fpreg_t));
+          memcpy(val, &fpreg.fpr_xacc[reg], sizeof(unw_fpreg_t));
 #elif defined(__i386__)
-	  memcpy(val, &fpreg.fpr_acc[reg], sizeof(unw_fpreg_t));
+          memcpy(val, &fpreg.fpr_acc[reg], sizeof(unw_fpreg_t));
+#elif defined(__arm__)
+          memcpy(val, &fpreg.fpr[reg], sizeof(unw_fpreg_t));
+#elif defined(__aarch64__)
+          memcpy(val, &fpreg.fp_q[reg], sizeof(unw_fpreg_t));
 #else
 #error Fix me
 #endif
diff --git a/src/ptrace/_UPT_access_mem.c b/src/ptrace/_UPT_access_mem.c
index 918a8f9..79bde25 100644
--- a/src/ptrace/_UPT_access_mem.c
+++ b/src/ptrace/_UPT_access_mem.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
    Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
 
 This file is part of libunwind.
@@ -29,47 +29,80 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #if HAVE_DECL_PTRACE_POKEDATA || HAVE_TTRACE
 int
 _UPT_access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val,
-		 int write, void *arg)
+                 int write, void *arg)
 {
   struct UPT_info *ui = arg;
+  int    i, end;
+  unw_word_t tmp_val;
+
   if (!ui)
-	return -UNW_EINVAL;
+        return -UNW_EINVAL;
 
   pid_t pid = ui->pid;
 
-  errno = 0;
-  if (write)
+  // Some 32-bit archs have to define a 64-bit unw_word_t.
+  // Callers of this function therefore expect a 64-bit
+  // return value, but ptrace only returns a 32-bit value
+  // in such cases.
+  if (sizeof(long) == 4 && sizeof(unw_word_t) == 8)
+    end = 2;
+  else
+    end = 1;
+
+  for (i = 0; i < end; i++)
     {
-      Debug (16, "mem[%lx] <- %lx\n", (long) addr, (long) *val);
+      unw_word_t tmp_addr = i == 0 ? addr : addr + 4;
+
+      errno = 0;
+      if (write)
+        {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+          tmp_val = i == 0 ? *val : *val >> 32;
+#else
+          tmp_val = i == 0 && end == 2 ? *val >> 32 : *val;
+#endif
+
+          Debug (16, "mem[%lx] <- %lx\n", (long) tmp_addr, (long) tmp_val);
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#         warning No support for ttrace() yet.
 #else
-      ptrace (PTRACE_POKEDATA, pid, addr, *val);
-      if (errno)
-	return -UNW_EINVAL;
+          ptrace (PTRACE_POKEDATA, pid, tmp_addr, tmp_val);
+          if (errno)
+            return -UNW_EINVAL;
 #endif
-    }
-  else
-    {
+        }
+      else
+        {
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#         warning No support for ttrace() yet.
+#else
+          tmp_val = (unsigned long) ptrace (PTRACE_PEEKDATA, pid, tmp_addr, 0);
+
+          if (i == 0)
+              *val = 0;
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+          *val |= tmp_val << (i * 32);
 #else
-      *val = ptrace (PTRACE_PEEKDATA, pid, addr, 0);
-      if (errno)
-	return -UNW_EINVAL;
+          *val |= i == 0 && end == 2 ? tmp_val << 32 : tmp_val;
+#endif
+
+          if (errno)
+            return -UNW_EINVAL;
 #endif
-      Debug (16, "mem[%lx] -> %lx\n", (long) addr, (long) *val);
+          Debug (16, "mem[%lx] -> %lx\n", (long) tmp_addr, (long) tmp_val);
+        }
     }
   return 0;
 }
 #elif HAVE_DECL_PT_IO
 int
 _UPT_access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val,
-		 int write, void *arg)
+                 int write, void *arg)
 {
   struct UPT_info *ui = arg;
   if (!ui)
-	return -UNW_EINVAL;
+        return -UNW_EINVAL;
   pid_t pid = ui->pid;
   struct ptrace_io_desc iod;
 
diff --git a/src/ptrace/_UPT_access_reg.c b/src/ptrace/_UPT_access_reg.c
index 782eeb7..ce25c78 100644
--- a/src/ptrace/_UPT_access_reg.c
+++ b/src/ptrace/_UPT_access_reg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
    Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
 
 This file is part of libunwind.
@@ -34,10 +34,53 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 # include "tdep-ia64/rse.h"
 #endif
 
-#if HAVE_DECL_PTRACE_POKEUSER || HAVE_TTRACE
+#if HAVE_DECL_PTRACE_SETREGSET
+#include <sys/uio.h>
 int
 _UPT_access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
-		 int write, void *arg)
+                 int write, void *arg)
+{
+  struct UPT_info *ui = arg;
+  pid_t pid = ui->pid;
+  gregset_t regs;
+  char *r;
+  struct iovec loc;
+
+#if UNW_DEBUG
+  Debug(16, "using getregset: reg: %s [%u], val: %lx, write: %u\n", 
+	unw_regname(reg), (unsigned) reg, (long) val, write);
+
+  if (write)
+    Debug (16, "%s [%u] <- %lx\n", unw_regname (reg), (unsigned) reg, (long) *val);
+#endif
+  if ((unsigned) reg >= ARRAY_SIZE (_UPT_reg_offset))
+    {
+      errno = EINVAL;
+      goto badreg;
+    }
+
+  loc.iov_base = &regs;
+  loc.iov_len = sizeof(regs);
+
+  r = (char *)&regs + _UPT_reg_offset[reg];
+  if (ptrace (PTRACE_GETREGSET, pid, NT_PRSTATUS, &loc) == -1)
+    goto badreg;
+  if (write) {
+    memcpy(r, val, sizeof(unw_word_t));
+    if (ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &loc) == -1)
+      goto badreg;
+  } else
+    memcpy(val, r, sizeof(unw_word_t));
+  return 0;
+
+badreg:
+  Debug (1, "bad register %s [%u] (error: %s)\n", unw_regname(reg), reg, strerror (errno));
+  return -UNW_EBADREG;
+}
+#elif HAVE_DECL_PTRACE_POKEUSER || HAVE_TTRACE
+int
+_UPT_access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
+                 int write, void *arg)
 {
   struct UPT_info *ui = arg;
   pid_t pid = ui->pid;
@@ -58,170 +101,170 @@ _UPT_access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
       mask = ((unw_word_t) 1) << (reg - UNW_IA64_NAT);
       errno = 0;
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
       nat_bits = ptrace (PTRACE_PEEKUSER, pid, PT_NAT_BITS, 0);
       if (errno)
-	goto badreg;
+        goto badreg;
 #endif
 
       if (write)
-	{
-	  if (*val)
-	    nat_bits |= mask;
-	  else
-	    nat_bits &= ~mask;
+        {
+          if (*val)
+            nat_bits |= mask;
+          else
+            nat_bits &= ~mask;
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	  errno = 0;
-	  ptrace (PTRACE_POKEUSER, pid, PT_NAT_BITS, nat_bits);
-	  if (errno)
-	    goto badreg;
+          errno = 0;
+          ptrace (PTRACE_POKEUSER, pid, PT_NAT_BITS, nat_bits);
+          if (errno)
+            goto badreg;
 #endif
-	}
+        }
       goto out;
     }
   else
     switch (reg)
       {
       case UNW_IA64_GR + 0:
-	if (write)
-	  goto badreg;
-	*val = 0;
-	return 0;
+        if (write)
+          goto badreg;
+        *val = 0;
+        return 0;
 
       case UNW_REG_IP:
-	{
-	  unsigned long ip, psr;
+        {
+          unsigned long ip, psr;
 
-	  /* distribute bundle-addr. & slot-number across PT_IIP & PT_IPSR.  */
+          /* distribute bundle-addr. & slot-number across PT_IIP & PT_IPSR.  */
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	  errno = 0;
-	  psr = ptrace (PTRACE_PEEKUSER, pid, PT_CR_IPSR, 0);
-	  if (errno)
-	    goto badreg;
+          errno = 0;
+          psr = ptrace (PTRACE_PEEKUSER, pid, PT_CR_IPSR, 0);
+          if (errno)
+            goto badreg;
 #endif
-	  if (write)
-	    {
-	      ip = *val & ~0xfUL;
-	      psr = (psr & ~0x3UL << 41) | (*val & 0x3);
+          if (write)
+            {
+              ip = *val & ~0xfUL;
+              psr = (psr & ~0x3UL << 41) | (*val & 0x3);
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	      errno = 0;
-	      ptrace (PTRACE_POKEUSER, pid, PT_CR_IIP, ip);
-	      ptrace (PTRACE_POKEUSER, pid, PT_CR_IPSR, psr);
-	      if (errno)
-		goto badreg;
+              errno = 0;
+              ptrace (PTRACE_POKEUSER, pid, PT_CR_IIP, ip);
+              ptrace (PTRACE_POKEUSER, pid, PT_CR_IPSR, psr);
+              if (errno)
+                goto badreg;
 #endif
-	    }
-	  else
-	    {
+            }
+          else
+            {
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	      errno = 0;
-	      ip = ptrace (PTRACE_PEEKUSER, pid, PT_CR_IIP, 0);
-	      if (errno)
-		goto badreg;
+              errno = 0;
+              ip = ptrace (PTRACE_PEEKUSER, pid, PT_CR_IIP, 0);
+              if (errno)
+                goto badreg;
 #endif
-	      *val = ip + ((psr >> 41) & 0x3);
-	    }
-	  goto out;
-	}
+              *val = ip + ((psr >> 41) & 0x3);
+            }
+          goto out;
+        }
 
       case UNW_IA64_AR_BSPSTORE:
-	reg = UNW_IA64_AR_BSP;
-	break;
+        reg = UNW_IA64_AR_BSP;
+        break;
 
       case UNW_IA64_AR_BSP:
       case UNW_IA64_BSP:
-	{
-	  unsigned long sof, cfm, bsp;
+        {
+          unsigned long sof, cfm, bsp;
 
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	  /* Account for the fact that ptrace() expects bsp to point
-	     _after_ the current register frame.  */
-	  errno = 0;
-	  cfm = ptrace (PTRACE_PEEKUSER, pid, PT_CFM, 0);
-	  if (errno)
-	    goto badreg;
+          /* Account for the fact that ptrace() expects bsp to point
+             _after_ the current register frame.  */
+          errno = 0;
+          cfm = ptrace (PTRACE_PEEKUSER, pid, PT_CFM, 0);
+          if (errno)
+            goto badreg;
 #endif
-	  sof = (cfm & 0x7f);
+          sof = (cfm & 0x7f);
 
-	  if (write)
-	    {
-	      bsp = rse_skip_regs (*val, sof);
+          if (write)
+            {
+              bsp = rse_skip_regs (*val, sof);
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	      errno = 0;
-	      ptrace (PTRACE_POKEUSER, pid, PT_AR_BSP, bsp);
-	      if (errno)
-		goto badreg;
+              errno = 0;
+              ptrace (PTRACE_POKEUSER, pid, PT_AR_BSP, bsp);
+              if (errno)
+                goto badreg;
 #endif
-	    }
-	  else
-	    {
+            }
+          else
+            {
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	      errno = 0;
-	      bsp = ptrace (PTRACE_PEEKUSER, pid, PT_AR_BSP, 0);
-	      if (errno)
-		goto badreg;
+              errno = 0;
+              bsp = ptrace (PTRACE_PEEKUSER, pid, PT_AR_BSP, 0);
+              if (errno)
+                goto badreg;
 #endif
-	      *val = rse_skip_regs (bsp, -sof);
-	    }
-	  goto out;
-	}
+              *val = rse_skip_regs (bsp, -sof);
+            }
+          goto out;
+        }
 
       case UNW_IA64_CFM:
-	/* If we change CFM, we need to adjust ptrace's notion of bsp
-	   accordingly, so that the real bsp remains unchanged.  */
-	if (write)
-	  {
-	    unsigned long new_sof, old_sof, cfm, bsp;
+        /* If we change CFM, we need to adjust ptrace's notion of bsp
+           accordingly, so that the real bsp remains unchanged.  */
+        if (write)
+          {
+            unsigned long new_sof, old_sof, cfm, bsp;
 
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	    errno = 0;
-	    bsp = ptrace (PTRACE_PEEKUSER, pid, PT_AR_BSP, 0);
-	    cfm = ptrace (PTRACE_PEEKUSER, pid, PT_CFM, 0);
+            errno = 0;
+            bsp = ptrace (PTRACE_PEEKUSER, pid, PT_AR_BSP, 0);
+            cfm = ptrace (PTRACE_PEEKUSER, pid, PT_CFM, 0);
 #endif
-	    if (errno)
-	      goto badreg;
-	    old_sof = (cfm & 0x7f);
-	    new_sof = (*val & 0x7f);
-	    if (old_sof != new_sof)
-	      {
-		bsp = rse_skip_regs (bsp, -old_sof + new_sof);
+            if (errno)
+              goto badreg;
+            old_sof = (cfm & 0x7f);
+            new_sof = (*val & 0x7f);
+            if (old_sof != new_sof)
+              {
+                bsp = rse_skip_regs (bsp, -old_sof + new_sof);
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-		errno = 0;
-		ptrace (PTRACE_POKEUSER, pid, PT_AR_BSP, 0);
-		if (errno)
-		  goto badreg;
+                errno = 0;
+                ptrace (PTRACE_POKEUSER, pid, PT_AR_BSP, 0);
+                if (errno)
+                  goto badreg;
 #endif
-	      }
+              }
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
-	    errno = 0;
-	    ptrace (PTRACE_POKEUSER, pid, PT_CFM, *val);
-	    if (errno)
-	      goto badreg;
+            errno = 0;
+            ptrace (PTRACE_POKEUSER, pid, PT_CFM, *val);
+            if (errno)
+              goto badreg;
 #endif
-	    goto out;
-	  }
-	break;
+            goto out;
+          }
+        break;
       }
 #endif /* End of IA64 */
 
@@ -235,7 +278,7 @@ _UPT_access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
     }
 
 #ifdef HAVE_TTRACE
-#	warning No support for ttrace() yet.
+#       warning No support for ttrace() yet.
 #else
   errno = 0;
   if (write)
@@ -271,7 +314,7 @@ _UPT_access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
 #elif HAVE_DECL_PT_GETREGS
 int
 _UPT_access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val,
-		 int write, void *arg)
+                 int write, void *arg)
 {
   struct UPT_info *ui = arg;
   pid_t pid = ui->pid;
diff --git a/src/ptrace/_UPT_accessors.c b/src/ptrace/_UPT_accessors.c
index 3feb60b..4724360 100644
--- a/src/ptrace/_UPT_accessors.c
+++ b/src/ptrace/_UPT_accessors.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,14 +25,14 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "_UPT_internal.h"
 
-PROTECTED unw_accessors_t _UPT_accessors =
+unw_accessors_t _UPT_accessors =
   {
-    .find_proc_info		= _UPT_find_proc_info,
-    .put_unwind_info		= _UPT_put_unwind_info,
-    .get_dyn_info_list_addr	= _UPT_get_dyn_info_list_addr,
-    .access_mem			= _UPT_access_mem,
-    .access_reg			= _UPT_access_reg,
-    .access_fpreg		= _UPT_access_fpreg,
-    .resume			= _UPT_resume,
-    .get_proc_name		= _UPT_get_proc_name
+    .find_proc_info             = _UPT_find_proc_info,
+    .put_unwind_info            = _UPT_put_unwind_info,
+    .get_dyn_info_list_addr     = _UPT_get_dyn_info_list_addr,
+    .access_mem                 = _UPT_access_mem,
+    .access_reg                 = _UPT_access_reg,
+    .access_fpreg               = _UPT_access_fpreg,
+    .resume                     = _UPT_resume,
+    .get_proc_name              = _UPT_get_proc_name
   };
diff --git a/src/ptrace/_UPT_create.c b/src/ptrace/_UPT_create.c
index f6a4158..dd59e97 100644
--- a/src/ptrace/_UPT_create.c
+++ b/src/ptrace/_UPT_create.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
diff --git a/src/ptrace/_UPT_destroy.c b/src/ptrace/_UPT_destroy.c
index 04ea22d..edb664c 100644
--- a/src/ptrace/_UPT_destroy.c
+++ b/src/ptrace/_UPT_destroy.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
diff --git a/src/ptrace/_UPT_elf.c b/src/ptrace/_UPT_elf.c
index cf0480f..efc43b5 100644
--- a/src/ptrace/_UPT_elf.c
+++ b/src/ptrace/_UPT_elf.c
@@ -1,5 +1,5 @@
 /* We need to get a separate copy of the ELF-code into
    libunwind-ptrace since it cannot (and must not) have any ELF
    dependencies on libunwind.  */
-#include "libunwind_i.h"	/* get ELFCLASS defined */
+#include "libunwind_i.h"        /* get ELFCLASS defined */
 #include "../elfxx.c"
diff --git a/src/ptrace/_UPT_find_proc_info.c b/src/ptrace/_UPT_find_proc_info.c
index 53dd1e7..b3209f4 100644
--- a/src/ptrace/_UPT_find_proc_info.c
+++ b/src/ptrace/_UPT_find_proc_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -91,7 +91,7 @@ get_unwind_info (struct elf_dyn_info *edi, pid_t pid, unw_addr_space_t as, unw_w
 
 int
 _UPT_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
-		     int need_unwind_info, void *arg)
+                     int need_unwind_info, void *arg)
 {
   struct UPT_info *ui = arg;
   int ret = -UNW_ENOINFO;
@@ -103,33 +103,37 @@ _UPT_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
   if (ui->edi.ktab.format != -1)
     {
       /* The kernel unwind table resides in local memory, so we have
-	 to use the local address space to search it.  Since
-	 _UPT_put_unwind_info() has no easy way of detecting this
-	 case, we simply make a copy of the unwind-info, so
-	 _UPT_put_unwind_info() can always free() the unwind-info
-	 without ill effects.  */
+         to use the local address space to search it.  Since
+         _UPT_put_unwind_info() has no easy way of detecting this
+         case, we simply make a copy of the unwind-info, so
+         _UPT_put_unwind_info() can always free() the unwind-info
+         without ill effects.  */
       ret = tdep_search_unwind_table (unw_local_addr_space, ip, &ui->edi.ktab, pi,
-				      need_unwind_info, arg);
+                                      need_unwind_info, arg);
       if (ret >= 0)
-	{
-	  if (!need_unwind_info)
-	    pi->unwind_info = NULL;
-	  else
-	    {
-	      void *mem = malloc (pi->unwind_info_size);
-
-	      if (!mem)
-		return -UNW_ENOMEM;
-	      memcpy (mem, pi->unwind_info, pi->unwind_info_size);
-	      pi->unwind_info = mem;
-	    }
-	}
+        {
+          if (!need_unwind_info)
+            pi->unwind_info = NULL;
+          else
+            {
+              void *mem = malloc (pi->unwind_info_size);
+
+              if (!mem)
+                return -UNW_ENOMEM;
+              memcpy (mem, pi->unwind_info, pi->unwind_info_size);
+              pi->unwind_info = mem;
+            }
+        }
     }
 #endif
 
   if (ret == -UNW_ENOINFO && ui->edi.di_cache.format != -1)
     ret = tdep_search_unwind_table (as, ip, &ui->edi.di_cache,
-				    pi, need_unwind_info, arg);
+                                    pi, need_unwind_info, arg);
+
+  if (ret == -UNW_ENOINFO && ui->edi.di_debug.format != -1)
+    ret = tdep_search_unwind_table (as, ip, &ui->edi.di_debug, pi,
+                                    need_unwind_info, arg);
 
 #if UNW_TARGET_ARM
   if (ret == -UNW_ENOINFO && ui->edi.di_arm.format != -1)
@@ -137,9 +141,5 @@ _UPT_find_proc_info (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
                                     need_unwind_info, arg);
 #endif
 
-  if (ret == -UNW_ENOINFO && ui->edi.di_debug.format != -1)
-    ret = tdep_search_unwind_table (as, ip, &ui->edi.di_debug, pi,
-				    need_unwind_info, arg);
-
   return ret;
 }
diff --git a/src/ptrace/_UPT_get_dyn_info_list_addr.c b/src/ptrace/_UPT_get_dyn_info_list_addr.c
index edc998f..cc5ed04 100644
--- a/src/ptrace/_UPT_get_dyn_info_list_addr.c
+++ b/src/ptrace/_UPT_get_dyn_info_list_addr.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -31,7 +31,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 static inline int
 get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
-	       int *countp)
+               int *countp)
 {
   unsigned long lo, hi, off;
   struct UPT_info *ui = arg;
@@ -44,25 +44,25 @@ get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
   while (maps_next (&mi, &lo, &hi, &off))
     {
       if (off)
-	continue;
+        continue;
 
       invalidate_edi(&ui->edi);
 
       if (elf_map_image (&ui->edi.ei, path) < 0)
-	/* ignore unmappable stuff like "/SYSV00001b58 (deleted)" */
-	continue;
+        /* ignore unmappable stuff like "/SYSV00001b58 (deleted)" */
+        continue;
 
       Debug (16, "checking object %s\n", path);
 
       if (tdep_find_unwind_table (&ui->edi, as, path, lo, off, 0) > 0)
-	{
-	  res = _Uia64_find_dyn_list (as, &ui->edi.di_cache, arg);
-	  if (res && count++ == 0)
-	    {
-	      Debug (12, "dyn_info_list_addr = 0x%lx\n", (long) res);
-	      *dil_addr = res;
-	    }
-	}
+        {
+          res = _Uia64_find_dyn_list (as, &ui->edi.di_cache, arg);
+          if (res && count++ == 0)
+            {
+              Debug (12, "dyn_info_list_addr = 0x%lx\n", (long) res);
+              *dil_addr = res;
+            }
+        }
     }
   maps_close (&mi);
   *countp = count;
@@ -73,7 +73,7 @@ get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
 
 static inline int
 get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
-	       int *countp)
+               int *countp)
 {
 # warning Implement get_list_addr(), please.
   *countp = 0;
@@ -84,7 +84,7 @@ get_list_addr (unw_addr_space_t as, unw_word_t *dil_addr, void *arg,
 
 int
 _UPT_get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dil_addr,
-			     void *arg)
+                             void *arg)
 {
   int count, ret;
 
diff --git a/src/ptrace/_UPT_get_proc_name.c b/src/ptrace/_UPT_get_proc_name.c
index 6ac85a0..79c1f38 100644
--- a/src/ptrace/_UPT_get_proc_name.c
+++ b/src/ptrace/_UPT_get_proc_name.c
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 int
 _UPT_get_proc_name (unw_addr_space_t as, unw_word_t ip,
-		    char *buf, size_t buf_len, unw_word_t *offp, void *arg)
+                    char *buf, size_t buf_len, unw_word_t *offp, void *arg)
 {
   struct UPT_info *ui = arg;
 
diff --git a/src/ptrace/_UPT_internal.h b/src/ptrace/_UPT_internal.h
index 2283dc4..5cef257 100644
--- a/src/ptrace/_UPT_internal.h
+++ b/src/ptrace/_UPT_internal.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -50,7 +50,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 struct UPT_info
   {
-    pid_t pid;		/* the process-id of the child we're unwinding */
+    pid_t pid;          /* the process-id of the child we're unwinding */
     struct elf_dyn_info edi;
   };
 
diff --git a/src/ptrace/_UPT_put_unwind_info.c b/src/ptrace/_UPT_put_unwind_info.c
index 852dd86..d4b8463 100644
--- a/src/ptrace/_UPT_put_unwind_info.c
+++ b/src/ptrace/_UPT_put_unwind_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
diff --git a/src/ptrace/_UPT_reg_offset.c b/src/ptrace/_UPT_reg_offset.c
index 765f7d5..52be799 100644
--- a/src/ptrace/_UPT_reg_offset.c
+++ b/src/ptrace/_UPT_reg_offset.c
@@ -1,6 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+   Copyright (C) 2013 Linaro Limited
 
 This file is part of libunwind.
 
@@ -35,223 +36,223 @@ const int _UPT_reg_offset[UNW_REG_LAST + 1] =
   {
 #ifdef HAVE_ASM_PTRACE_OFFSETS_H
 # ifndef PT_AR_CSD
-#  define PT_AR_CSD	-1	/* this was introduced with rev 2.1 of ia64 */
+#  define PT_AR_CSD     -1      /* this was introduced with rev 2.1 of ia64 */
 # endif
 
-    [UNW_IA64_GR +  0]	= -1,		[UNW_IA64_GR +  1]	= PT_R1,
-    [UNW_IA64_GR +  2]	= PT_R2,	[UNW_IA64_GR +  3]	= PT_R3,
-    [UNW_IA64_GR +  4]	= PT_R4,	[UNW_IA64_GR +  5]	= PT_R5,
-    [UNW_IA64_GR +  6]	= PT_R6,	[UNW_IA64_GR +  7]	= PT_R7,
-    [UNW_IA64_GR +  8]	= PT_R8,	[UNW_IA64_GR +  9]	= PT_R9,
-    [UNW_IA64_GR + 10]	= PT_R10,	[UNW_IA64_GR + 11]	= PT_R11,
-    [UNW_IA64_GR + 12]	= PT_R12,	[UNW_IA64_GR + 13]	= PT_R13,
-    [UNW_IA64_GR + 14]	= PT_R14,	[UNW_IA64_GR + 15]	= PT_R15,
-    [UNW_IA64_GR + 16]	= PT_R16,	[UNW_IA64_GR + 17]	= PT_R17,
-    [UNW_IA64_GR + 18]	= PT_R18,	[UNW_IA64_GR + 19]	= PT_R19,
-    [UNW_IA64_GR + 20]	= PT_R20,	[UNW_IA64_GR + 21]	= PT_R21,
-    [UNW_IA64_GR + 22]	= PT_R22,	[UNW_IA64_GR + 23]	= PT_R23,
-    [UNW_IA64_GR + 24]	= PT_R24,	[UNW_IA64_GR + 25]	= PT_R25,
-    [UNW_IA64_GR + 26]	= PT_R26,	[UNW_IA64_GR + 27]	= PT_R27,
-    [UNW_IA64_GR + 28]	= PT_R28,	[UNW_IA64_GR + 29]	= PT_R29,
-    [UNW_IA64_GR + 30]	= PT_R30,	[UNW_IA64_GR + 31]	= PT_R31,
+    [UNW_IA64_GR +  0]  = -1,           [UNW_IA64_GR +  1]      = PT_R1,
+    [UNW_IA64_GR +  2]  = PT_R2,        [UNW_IA64_GR +  3]      = PT_R3,
+    [UNW_IA64_GR +  4]  = PT_R4,        [UNW_IA64_GR +  5]      = PT_R5,
+    [UNW_IA64_GR +  6]  = PT_R6,        [UNW_IA64_GR +  7]      = PT_R7,
+    [UNW_IA64_GR +  8]  = PT_R8,        [UNW_IA64_GR +  9]      = PT_R9,
+    [UNW_IA64_GR + 10]  = PT_R10,       [UNW_IA64_GR + 11]      = PT_R11,
+    [UNW_IA64_GR + 12]  = PT_R12,       [UNW_IA64_GR + 13]      = PT_R13,
+    [UNW_IA64_GR + 14]  = PT_R14,       [UNW_IA64_GR + 15]      = PT_R15,
+    [UNW_IA64_GR + 16]  = PT_R16,       [UNW_IA64_GR + 17]      = PT_R17,
+    [UNW_IA64_GR + 18]  = PT_R18,       [UNW_IA64_GR + 19]      = PT_R19,
+    [UNW_IA64_GR + 20]  = PT_R20,       [UNW_IA64_GR + 21]      = PT_R21,
+    [UNW_IA64_GR + 22]  = PT_R22,       [UNW_IA64_GR + 23]      = PT_R23,
+    [UNW_IA64_GR + 24]  = PT_R24,       [UNW_IA64_GR + 25]      = PT_R25,
+    [UNW_IA64_GR + 26]  = PT_R26,       [UNW_IA64_GR + 27]      = PT_R27,
+    [UNW_IA64_GR + 28]  = PT_R28,       [UNW_IA64_GR + 29]      = PT_R29,
+    [UNW_IA64_GR + 30]  = PT_R30,       [UNW_IA64_GR + 31]      = PT_R31,
 
-    [UNW_IA64_NAT+  0]	= -1,		[UNW_IA64_NAT+  1]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+  2]	= PT_NAT_BITS,	[UNW_IA64_NAT+  3]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+  4]	= PT_NAT_BITS,	[UNW_IA64_NAT+  5]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+  6]	= PT_NAT_BITS,	[UNW_IA64_NAT+  7]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+  8]	= PT_NAT_BITS,	[UNW_IA64_NAT+  9]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 10]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 11]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 12]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 13]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 14]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 15]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 16]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 17]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 18]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 19]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 20]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 21]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 22]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 23]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 24]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 25]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 26]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 27]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 28]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 29]	= PT_NAT_BITS,
-    [UNW_IA64_NAT+ 30]	= PT_NAT_BITS,	[UNW_IA64_NAT+ 31]	= PT_NAT_BITS,
+    [UNW_IA64_NAT+  0]  = -1,           [UNW_IA64_NAT+  1]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+  2]  = PT_NAT_BITS,  [UNW_IA64_NAT+  3]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+  4]  = PT_NAT_BITS,  [UNW_IA64_NAT+  5]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+  6]  = PT_NAT_BITS,  [UNW_IA64_NAT+  7]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+  8]  = PT_NAT_BITS,  [UNW_IA64_NAT+  9]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 10]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 11]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 12]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 13]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 14]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 15]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 16]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 17]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 18]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 19]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 20]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 21]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 22]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 23]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 24]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 25]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 26]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 27]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 28]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 29]      = PT_NAT_BITS,
+    [UNW_IA64_NAT+ 30]  = PT_NAT_BITS,  [UNW_IA64_NAT+ 31]      = PT_NAT_BITS,
 
-    [UNW_IA64_FR +  0]	= -1,		[UNW_IA64_FR +  1]	= -1,
-    [UNW_IA64_FR +  2]	= PT_F2,	[UNW_IA64_FR +  3]	= PT_F3,
-    [UNW_IA64_FR +  4]	= PT_F4,	[UNW_IA64_FR +  5]	= PT_F5,
-    [UNW_IA64_FR +  6]	= PT_F6,	[UNW_IA64_FR +  7]	= PT_F7,
-    [UNW_IA64_FR +  8]	= PT_F8,	[UNW_IA64_FR +  9]	= PT_F9,
-    [UNW_IA64_FR + 10]	= PT_F10,	[UNW_IA64_FR + 11]	= PT_F11,
-    [UNW_IA64_FR + 12]	= PT_F12,	[UNW_IA64_FR + 13]	= PT_F13,
-    [UNW_IA64_FR + 14]	= PT_F14,	[UNW_IA64_FR + 15]	= PT_F15,
-    [UNW_IA64_FR + 16]	= PT_F16,	[UNW_IA64_FR + 17]	= PT_F17,
-    [UNW_IA64_FR + 18]	= PT_F18,	[UNW_IA64_FR + 19]	= PT_F19,
-    [UNW_IA64_FR + 20]	= PT_F20,	[UNW_IA64_FR + 21]	= PT_F21,
-    [UNW_IA64_FR + 22]	= PT_F22,	[UNW_IA64_FR + 23]	= PT_F23,
-    [UNW_IA64_FR + 24]	= PT_F24,	[UNW_IA64_FR + 25]	= PT_F25,
-    [UNW_IA64_FR + 26]	= PT_F26,	[UNW_IA64_FR + 27]	= PT_F27,
-    [UNW_IA64_FR + 28]	= PT_F28,	[UNW_IA64_FR + 29]	= PT_F29,
-    [UNW_IA64_FR + 30]	= PT_F30,	[UNW_IA64_FR + 31]	= PT_F31,
-    [UNW_IA64_FR + 32]	= PT_F32,	[UNW_IA64_FR + 33]	= PT_F33,
-    [UNW_IA64_FR + 34]	= PT_F34,	[UNW_IA64_FR + 35]	= PT_F35,
-    [UNW_IA64_FR + 36]	= PT_F36,	[UNW_IA64_FR + 37]	= PT_F37,
-    [UNW_IA64_FR + 38]	= PT_F38,	[UNW_IA64_FR + 39]	= PT_F39,
-    [UNW_IA64_FR + 40]	= PT_F40,	[UNW_IA64_FR + 41]	= PT_F41,
-    [UNW_IA64_FR + 42]	= PT_F42,	[UNW_IA64_FR + 43]	= PT_F43,
-    [UNW_IA64_FR + 44]	= PT_F44,	[UNW_IA64_FR + 45]	= PT_F45,
-    [UNW_IA64_FR + 46]	= PT_F46,	[UNW_IA64_FR + 47]	= PT_F47,
-    [UNW_IA64_FR + 48]	= PT_F48,	[UNW_IA64_FR + 49]	= PT_F49,
-    [UNW_IA64_FR + 50]	= PT_F50,	[UNW_IA64_FR + 51]	= PT_F51,
-    [UNW_IA64_FR + 52]	= PT_F52,	[UNW_IA64_FR + 53]	= PT_F53,
-    [UNW_IA64_FR + 54]	= PT_F54,	[UNW_IA64_FR + 55]	= PT_F55,
-    [UNW_IA64_FR + 56]	= PT_F56,	[UNW_IA64_FR + 57]	= PT_F57,
-    [UNW_IA64_FR + 58]	= PT_F58,	[UNW_IA64_FR + 59]	= PT_F59,
-    [UNW_IA64_FR + 60]	= PT_F60,	[UNW_IA64_FR + 61]	= PT_F61,
-    [UNW_IA64_FR + 62]	= PT_F62,	[UNW_IA64_FR + 63]	= PT_F63,
-    [UNW_IA64_FR + 64]	= PT_F64,	[UNW_IA64_FR + 65]	= PT_F65,
-    [UNW_IA64_FR + 66]	= PT_F66,	[UNW_IA64_FR + 67]	= PT_F67,
-    [UNW_IA64_FR + 68]	= PT_F68,	[UNW_IA64_FR + 69]	= PT_F69,
-    [UNW_IA64_FR + 70]	= PT_F70,	[UNW_IA64_FR + 71]	= PT_F71,
-    [UNW_IA64_FR + 72]	= PT_F72,	[UNW_IA64_FR + 73]	= PT_F73,
-    [UNW_IA64_FR + 74]	= PT_F74,	[UNW_IA64_FR + 75]	= PT_F75,
-    [UNW_IA64_FR + 76]	= PT_F76,	[UNW_IA64_FR + 77]	= PT_F77,
-    [UNW_IA64_FR + 78]	= PT_F78,	[UNW_IA64_FR + 79]	= PT_F79,
-    [UNW_IA64_FR + 80]	= PT_F80,	[UNW_IA64_FR + 81]	= PT_F81,
-    [UNW_IA64_FR + 82]	= PT_F82,	[UNW_IA64_FR + 83]	= PT_F83,
-    [UNW_IA64_FR + 84]	= PT_F84,	[UNW_IA64_FR + 85]	= PT_F85,
-    [UNW_IA64_FR + 86]	= PT_F86,	[UNW_IA64_FR + 87]	= PT_F87,
-    [UNW_IA64_FR + 88]	= PT_F88,	[UNW_IA64_FR + 89]	= PT_F89,
-    [UNW_IA64_FR + 90]	= PT_F90,	[UNW_IA64_FR + 91]	= PT_F91,
-    [UNW_IA64_FR + 92]	= PT_F92,	[UNW_IA64_FR + 93]	= PT_F93,
-    [UNW_IA64_FR + 94]	= PT_F94,	[UNW_IA64_FR + 95]	= PT_F95,
-    [UNW_IA64_FR + 96]	= PT_F96,	[UNW_IA64_FR + 97]	= PT_F97,
-    [UNW_IA64_FR + 98]	= PT_F98,	[UNW_IA64_FR + 99]	= PT_F99,
-    [UNW_IA64_FR +100]	= PT_F100,	[UNW_IA64_FR +101]	= PT_F101,
-    [UNW_IA64_FR +102]	= PT_F102,	[UNW_IA64_FR +103]	= PT_F103,
-    [UNW_IA64_FR +104]	= PT_F104,	[UNW_IA64_FR +105]	= PT_F105,
-    [UNW_IA64_FR +106]	= PT_F106,	[UNW_IA64_FR +107]	= PT_F107,
-    [UNW_IA64_FR +108]	= PT_F108,	[UNW_IA64_FR +109]	= PT_F109,
-    [UNW_IA64_FR +110]	= PT_F110,	[UNW_IA64_FR +111]	= PT_F111,
-    [UNW_IA64_FR +112]	= PT_F112,	[UNW_IA64_FR +113]	= PT_F113,
-    [UNW_IA64_FR +114]	= PT_F114,	[UNW_IA64_FR +115]	= PT_F115,
-    [UNW_IA64_FR +116]	= PT_F116,	[UNW_IA64_FR +117]	= PT_F117,
-    [UNW_IA64_FR +118]	= PT_F118,	[UNW_IA64_FR +119]	= PT_F119,
-    [UNW_IA64_FR +120]	= PT_F120,	[UNW_IA64_FR +121]	= PT_F121,
-    [UNW_IA64_FR +122]	= PT_F122,	[UNW_IA64_FR +123]	= PT_F123,
-    [UNW_IA64_FR +124]	= PT_F124,	[UNW_IA64_FR +125]	= PT_F125,
-    [UNW_IA64_FR +126]	= PT_F126,	[UNW_IA64_FR +127]	= PT_F127,
+    [UNW_IA64_FR +  0]  = -1,           [UNW_IA64_FR +  1]      = -1,
+    [UNW_IA64_FR +  2]  = PT_F2,        [UNW_IA64_FR +  3]      = PT_F3,
+    [UNW_IA64_FR +  4]  = PT_F4,        [UNW_IA64_FR +  5]      = PT_F5,
+    [UNW_IA64_FR +  6]  = PT_F6,        [UNW_IA64_FR +  7]      = PT_F7,
+    [UNW_IA64_FR +  8]  = PT_F8,        [UNW_IA64_FR +  9]      = PT_F9,
+    [UNW_IA64_FR + 10]  = PT_F10,       [UNW_IA64_FR + 11]      = PT_F11,
+    [UNW_IA64_FR + 12]  = PT_F12,       [UNW_IA64_FR + 13]      = PT_F13,
+    [UNW_IA64_FR + 14]  = PT_F14,       [UNW_IA64_FR + 15]      = PT_F15,
+    [UNW_IA64_FR + 16]  = PT_F16,       [UNW_IA64_FR + 17]      = PT_F17,
+    [UNW_IA64_FR + 18]  = PT_F18,       [UNW_IA64_FR + 19]      = PT_F19,
+    [UNW_IA64_FR + 20]  = PT_F20,       [UNW_IA64_FR + 21]      = PT_F21,
+    [UNW_IA64_FR + 22]  = PT_F22,       [UNW_IA64_FR + 23]      = PT_F23,
+    [UNW_IA64_FR + 24]  = PT_F24,       [UNW_IA64_FR + 25]      = PT_F25,
+    [UNW_IA64_FR + 26]  = PT_F26,       [UNW_IA64_FR + 27]      = PT_F27,
+    [UNW_IA64_FR + 28]  = PT_F28,       [UNW_IA64_FR + 29]      = PT_F29,
+    [UNW_IA64_FR + 30]  = PT_F30,       [UNW_IA64_FR + 31]      = PT_F31,
+    [UNW_IA64_FR + 32]  = PT_F32,       [UNW_IA64_FR + 33]      = PT_F33,
+    [UNW_IA64_FR + 34]  = PT_F34,       [UNW_IA64_FR + 35]      = PT_F35,
+    [UNW_IA64_FR + 36]  = PT_F36,       [UNW_IA64_FR + 37]      = PT_F37,
+    [UNW_IA64_FR + 38]  = PT_F38,       [UNW_IA64_FR + 39]      = PT_F39,
+    [UNW_IA64_FR + 40]  = PT_F40,       [UNW_IA64_FR + 41]      = PT_F41,
+    [UNW_IA64_FR + 42]  = PT_F42,       [UNW_IA64_FR + 43]      = PT_F43,
+    [UNW_IA64_FR + 44]  = PT_F44,       [UNW_IA64_FR + 45]      = PT_F45,
+    [UNW_IA64_FR + 46]  = PT_F46,       [UNW_IA64_FR + 47]      = PT_F47,
+    [UNW_IA64_FR + 48]  = PT_F48,       [UNW_IA64_FR + 49]      = PT_F49,
+    [UNW_IA64_FR + 50]  = PT_F50,       [UNW_IA64_FR + 51]      = PT_F51,
+    [UNW_IA64_FR + 52]  = PT_F52,       [UNW_IA64_FR + 53]      = PT_F53,
+    [UNW_IA64_FR + 54]  = PT_F54,       [UNW_IA64_FR + 55]      = PT_F55,
+    [UNW_IA64_FR + 56]  = PT_F56,       [UNW_IA64_FR + 57]      = PT_F57,
+    [UNW_IA64_FR + 58]  = PT_F58,       [UNW_IA64_FR + 59]      = PT_F59,
+    [UNW_IA64_FR + 60]  = PT_F60,       [UNW_IA64_FR + 61]      = PT_F61,
+    [UNW_IA64_FR + 62]  = PT_F62,       [UNW_IA64_FR + 63]      = PT_F63,
+    [UNW_IA64_FR + 64]  = PT_F64,       [UNW_IA64_FR + 65]      = PT_F65,
+    [UNW_IA64_FR + 66]  = PT_F66,       [UNW_IA64_FR + 67]      = PT_F67,
+    [UNW_IA64_FR + 68]  = PT_F68,       [UNW_IA64_FR + 69]      = PT_F69,
+    [UNW_IA64_FR + 70]  = PT_F70,       [UNW_IA64_FR + 71]      = PT_F71,
+    [UNW_IA64_FR + 72]  = PT_F72,       [UNW_IA64_FR + 73]      = PT_F73,
+    [UNW_IA64_FR + 74]  = PT_F74,       [UNW_IA64_FR + 75]      = PT_F75,
+    [UNW_IA64_FR + 76]  = PT_F76,       [UNW_IA64_FR + 77]      = PT_F77,
+    [UNW_IA64_FR + 78]  = PT_F78,       [UNW_IA64_FR + 79]      = PT_F79,
+    [UNW_IA64_FR + 80]  = PT_F80,       [UNW_IA64_FR + 81]      = PT_F81,
+    [UNW_IA64_FR + 82]  = PT_F82,       [UNW_IA64_FR + 83]      = PT_F83,
+    [UNW_IA64_FR + 84]  = PT_F84,       [UNW_IA64_FR + 85]      = PT_F85,
+    [UNW_IA64_FR + 86]  = PT_F86,       [UNW_IA64_FR + 87]      = PT_F87,
+    [UNW_IA64_FR + 88]  = PT_F88,       [UNW_IA64_FR + 89]      = PT_F89,
+    [UNW_IA64_FR + 90]  = PT_F90,       [UNW_IA64_FR + 91]      = PT_F91,
+    [UNW_IA64_FR + 92]  = PT_F92,       [UNW_IA64_FR + 93]      = PT_F93,
+    [UNW_IA64_FR + 94]  = PT_F94,       [UNW_IA64_FR + 95]      = PT_F95,
+    [UNW_IA64_FR + 96]  = PT_F96,       [UNW_IA64_FR + 97]      = PT_F97,
+    [UNW_IA64_FR + 98]  = PT_F98,       [UNW_IA64_FR + 99]      = PT_F99,
+    [UNW_IA64_FR +100]  = PT_F100,      [UNW_IA64_FR +101]      = PT_F101,
+    [UNW_IA64_FR +102]  = PT_F102,      [UNW_IA64_FR +103]      = PT_F103,
+    [UNW_IA64_FR +104]  = PT_F104,      [UNW_IA64_FR +105]      = PT_F105,
+    [UNW_IA64_FR +106]  = PT_F106,      [UNW_IA64_FR +107]      = PT_F107,
+    [UNW_IA64_FR +108]  = PT_F108,      [UNW_IA64_FR +109]      = PT_F109,
+    [UNW_IA64_FR +110]  = PT_F110,      [UNW_IA64_FR +111]      = PT_F111,
+    [UNW_IA64_FR +112]  = PT_F112,      [UNW_IA64_FR +113]      = PT_F113,
+    [UNW_IA64_FR +114]  = PT_F114,      [UNW_IA64_FR +115]      = PT_F115,
+    [UNW_IA64_FR +116]  = PT_F116,      [UNW_IA64_FR +117]      = PT_F117,
+    [UNW_IA64_FR +118]  = PT_F118,      [UNW_IA64_FR +119]      = PT_F119,
+    [UNW_IA64_FR +120]  = PT_F120,      [UNW_IA64_FR +121]      = PT_F121,
+    [UNW_IA64_FR +122]  = PT_F122,      [UNW_IA64_FR +123]      = PT_F123,
+    [UNW_IA64_FR +124]  = PT_F124,      [UNW_IA64_FR +125]      = PT_F125,
+    [UNW_IA64_FR +126]  = PT_F126,      [UNW_IA64_FR +127]      = PT_F127,
 
-    [UNW_IA64_AR +  0]	= -1,		[UNW_IA64_AR +  1]	= -1,
-    [UNW_IA64_AR +  2]	= -1,		[UNW_IA64_AR +  3]	= -1,
-    [UNW_IA64_AR +  4]	= -1,		[UNW_IA64_AR +  5]	= -1,
-    [UNW_IA64_AR +  6]	= -1,		[UNW_IA64_AR +  7]	= -1,
-    [UNW_IA64_AR +  8]	= -1,		[UNW_IA64_AR +  9]	= -1,
-    [UNW_IA64_AR + 10]	= -1,		[UNW_IA64_AR + 11]	= -1,
-    [UNW_IA64_AR + 12]	= -1,		[UNW_IA64_AR + 13]	= -1,
-    [UNW_IA64_AR + 14]	= -1,		[UNW_IA64_AR + 15]	= -1,
-    [UNW_IA64_AR + 16]	= PT_AR_RSC,	[UNW_IA64_AR + 17]	= PT_AR_BSP,
-    [UNW_IA64_AR + 18]	= PT_AR_BSPSTORE,[UNW_IA64_AR + 19]	= PT_AR_RNAT,
-    [UNW_IA64_AR + 20]	= -1,		[UNW_IA64_AR + 21]	= -1,
-    [UNW_IA64_AR + 22]	= -1,		[UNW_IA64_AR + 23]	= -1,
-    [UNW_IA64_AR + 24]	= -1,		[UNW_IA64_AR + 25]	= PT_AR_CSD,
-    [UNW_IA64_AR + 26]	= -1,		[UNW_IA64_AR + 27]	= -1,
-    [UNW_IA64_AR + 28]	= -1,		[UNW_IA64_AR + 29]	= -1,
-    [UNW_IA64_AR + 30]	= -1,		[UNW_IA64_AR + 31]	= -1,
-    [UNW_IA64_AR + 32]	= PT_AR_CCV,	[UNW_IA64_AR + 33]	= -1,
-    [UNW_IA64_AR + 34]	= -1,		[UNW_IA64_AR + 35]	= -1,
-    [UNW_IA64_AR + 36]	= PT_AR_UNAT,	[UNW_IA64_AR + 37]	= -1,
-    [UNW_IA64_AR + 38]	= -1,		[UNW_IA64_AR + 39]	= -1,
-    [UNW_IA64_AR + 40]	= PT_AR_FPSR,	[UNW_IA64_AR + 41]	= -1,
-    [UNW_IA64_AR + 42]	= -1,		[UNW_IA64_AR + 43]	= -1,
-    [UNW_IA64_AR + 44]	= -1,		[UNW_IA64_AR + 45]	= -1,
-    [UNW_IA64_AR + 46]	= -1,		[UNW_IA64_AR + 47]	= -1,
-    [UNW_IA64_AR + 48]	= -1,		[UNW_IA64_AR + 49]	= -1,
-    [UNW_IA64_AR + 50]	= -1,		[UNW_IA64_AR + 51]	= -1,
-    [UNW_IA64_AR + 52]	= -1,		[UNW_IA64_AR + 53]	= -1,
-    [UNW_IA64_AR + 54]	= -1,		[UNW_IA64_AR + 55]	= -1,
-    [UNW_IA64_AR + 56]	= -1,		[UNW_IA64_AR + 57]	= -1,
-    [UNW_IA64_AR + 58]	= -1,		[UNW_IA64_AR + 59]	= -1,
-    [UNW_IA64_AR + 60]	= -1,		[UNW_IA64_AR + 61]	= -1,
-    [UNW_IA64_AR + 62]	= -1,		[UNW_IA64_AR + 63]	= -1,
-    [UNW_IA64_AR + 64]	= PT_AR_PFS,	[UNW_IA64_AR + 65]	= PT_AR_LC,
-    [UNW_IA64_AR + 66]	= PT_AR_EC,	[UNW_IA64_AR + 67]	= -1,
-    [UNW_IA64_AR + 68]	= -1,		[UNW_IA64_AR + 69]	= -1,
-    [UNW_IA64_AR + 70]	= -1,		[UNW_IA64_AR + 71]	= -1,
-    [UNW_IA64_AR + 72]	= -1,		[UNW_IA64_AR + 73]	= -1,
-    [UNW_IA64_AR + 74]	= -1,		[UNW_IA64_AR + 75]	= -1,
-    [UNW_IA64_AR + 76]	= -1,		[UNW_IA64_AR + 77]	= -1,
-    [UNW_IA64_AR + 78]	= -1,		[UNW_IA64_AR + 79]	= -1,
-    [UNW_IA64_AR + 80]	= -1,		[UNW_IA64_AR + 81]	= -1,
-    [UNW_IA64_AR + 82]	= -1,		[UNW_IA64_AR + 83]	= -1,
-    [UNW_IA64_AR + 84]	= -1,		[UNW_IA64_AR + 85]	= -1,
-    [UNW_IA64_AR + 86]	= -1,		[UNW_IA64_AR + 87]	= -1,
-    [UNW_IA64_AR + 88]	= -1,		[UNW_IA64_AR + 89]	= -1,
-    [UNW_IA64_AR + 90]	= -1,		[UNW_IA64_AR + 91]	= -1,
-    [UNW_IA64_AR + 92]	= -1,		[UNW_IA64_AR + 93]	= -1,
-    [UNW_IA64_AR + 94]	= -1,		[UNW_IA64_AR + 95]	= -1,
-    [UNW_IA64_AR + 96]	= -1,		[UNW_IA64_AR + 97]	= -1,
-    [UNW_IA64_AR + 98]	= -1,		[UNW_IA64_AR + 99]	= -1,
-    [UNW_IA64_AR +100]	= -1,		[UNW_IA64_AR +101]	= -1,
-    [UNW_IA64_AR +102]	= -1,		[UNW_IA64_AR +103]	= -1,
-    [UNW_IA64_AR +104]	= -1,		[UNW_IA64_AR +105]	= -1,
-    [UNW_IA64_AR +106]	= -1,		[UNW_IA64_AR +107]	= -1,
-    [UNW_IA64_AR +108]	= -1,		[UNW_IA64_AR +109]	= -1,
-    [UNW_IA64_AR +110]	= -1,		[UNW_IA64_AR +111]	= -1,
-    [UNW_IA64_AR +112]	= -1,		[UNW_IA64_AR +113]	= -1,
-    [UNW_IA64_AR +114]	= -1,		[UNW_IA64_AR +115]	= -1,
-    [UNW_IA64_AR +116]	= -1,		[UNW_IA64_AR +117]	= -1,
-    [UNW_IA64_AR +118]	= -1,		[UNW_IA64_AR +119]	= -1,
-    [UNW_IA64_AR +120]	= -1,		[UNW_IA64_AR +121]	= -1,
-    [UNW_IA64_AR +122]	= -1,		[UNW_IA64_AR +123]	= -1,
-    [UNW_IA64_AR +124]	= -1,		[UNW_IA64_AR +125]	= -1,
-    [UNW_IA64_AR +126]	= -1,		[UNW_IA64_AR +127]	= -1,
+    [UNW_IA64_AR +  0]  = -1,           [UNW_IA64_AR +  1]      = -1,
+    [UNW_IA64_AR +  2]  = -1,           [UNW_IA64_AR +  3]      = -1,
+    [UNW_IA64_AR +  4]  = -1,           [UNW_IA64_AR +  5]      = -1,
+    [UNW_IA64_AR +  6]  = -1,           [UNW_IA64_AR +  7]      = -1,
+    [UNW_IA64_AR +  8]  = -1,           [UNW_IA64_AR +  9]      = -1,
+    [UNW_IA64_AR + 10]  = -1,           [UNW_IA64_AR + 11]      = -1,
+    [UNW_IA64_AR + 12]  = -1,           [UNW_IA64_AR + 13]      = -1,
+    [UNW_IA64_AR + 14]  = -1,           [UNW_IA64_AR + 15]      = -1,
+    [UNW_IA64_AR + 16]  = PT_AR_RSC,    [UNW_IA64_AR + 17]      = PT_AR_BSP,
+    [UNW_IA64_AR + 18]  = PT_AR_BSPSTORE,[UNW_IA64_AR + 19]     = PT_AR_RNAT,
+    [UNW_IA64_AR + 20]  = -1,           [UNW_IA64_AR + 21]      = -1,
+    [UNW_IA64_AR + 22]  = -1,           [UNW_IA64_AR + 23]      = -1,
+    [UNW_IA64_AR + 24]  = -1,           [UNW_IA64_AR + 25]      = PT_AR_CSD,
+    [UNW_IA64_AR + 26]  = -1,           [UNW_IA64_AR + 27]      = -1,
+    [UNW_IA64_AR + 28]  = -1,           [UNW_IA64_AR + 29]      = -1,
+    [UNW_IA64_AR + 30]  = -1,           [UNW_IA64_AR + 31]      = -1,
+    [UNW_IA64_AR + 32]  = PT_AR_CCV,    [UNW_IA64_AR + 33]      = -1,
+    [UNW_IA64_AR + 34]  = -1,           [UNW_IA64_AR + 35]      = -1,
+    [UNW_IA64_AR + 36]  = PT_AR_UNAT,   [UNW_IA64_AR + 37]      = -1,
+    [UNW_IA64_AR + 38]  = -1,           [UNW_IA64_AR + 39]      = -1,
+    [UNW_IA64_AR + 40]  = PT_AR_FPSR,   [UNW_IA64_AR + 41]      = -1,
+    [UNW_IA64_AR + 42]  = -1,           [UNW_IA64_AR + 43]      = -1,
+    [UNW_IA64_AR + 44]  = -1,           [UNW_IA64_AR + 45]      = -1,
+    [UNW_IA64_AR + 46]  = -1,           [UNW_IA64_AR + 47]      = -1,
+    [UNW_IA64_AR + 48]  = -1,           [UNW_IA64_AR + 49]      = -1,
+    [UNW_IA64_AR + 50]  = -1,           [UNW_IA64_AR + 51]      = -1,
+    [UNW_IA64_AR + 52]  = -1,           [UNW_IA64_AR + 53]      = -1,
+    [UNW_IA64_AR + 54]  = -1,           [UNW_IA64_AR + 55]      = -1,
+    [UNW_IA64_AR + 56]  = -1,           [UNW_IA64_AR + 57]      = -1,
+    [UNW_IA64_AR + 58]  = -1,           [UNW_IA64_AR + 59]      = -1,
+    [UNW_IA64_AR + 60]  = -1,           [UNW_IA64_AR + 61]      = -1,
+    [UNW_IA64_AR + 62]  = -1,           [UNW_IA64_AR + 63]      = -1,
+    [UNW_IA64_AR + 64]  = PT_AR_PFS,    [UNW_IA64_AR + 65]      = PT_AR_LC,
+    [UNW_IA64_AR + 66]  = PT_AR_EC,     [UNW_IA64_AR + 67]      = -1,
+    [UNW_IA64_AR + 68]  = -1,           [UNW_IA64_AR + 69]      = -1,
+    [UNW_IA64_AR + 70]  = -1,           [UNW_IA64_AR + 71]      = -1,
+    [UNW_IA64_AR + 72]  = -1,           [UNW_IA64_AR + 73]      = -1,
+    [UNW_IA64_AR + 74]  = -1,           [UNW_IA64_AR + 75]      = -1,
+    [UNW_IA64_AR + 76]  = -1,           [UNW_IA64_AR + 77]      = -1,
+    [UNW_IA64_AR + 78]  = -1,           [UNW_IA64_AR + 79]      = -1,
+    [UNW_IA64_AR + 80]  = -1,           [UNW_IA64_AR + 81]      = -1,
+    [UNW_IA64_AR + 82]  = -1,           [UNW_IA64_AR + 83]      = -1,
+    [UNW_IA64_AR + 84]  = -1,           [UNW_IA64_AR + 85]      = -1,
+    [UNW_IA64_AR + 86]  = -1,           [UNW_IA64_AR + 87]      = -1,
+    [UNW_IA64_AR + 88]  = -1,           [UNW_IA64_AR + 89]      = -1,
+    [UNW_IA64_AR + 90]  = -1,           [UNW_IA64_AR + 91]      = -1,
+    [UNW_IA64_AR + 92]  = -1,           [UNW_IA64_AR + 93]      = -1,
+    [UNW_IA64_AR + 94]  = -1,           [UNW_IA64_AR + 95]      = -1,
+    [UNW_IA64_AR + 96]  = -1,           [UNW_IA64_AR + 97]      = -1,
+    [UNW_IA64_AR + 98]  = -1,           [UNW_IA64_AR + 99]      = -1,
+    [UNW_IA64_AR +100]  = -1,           [UNW_IA64_AR +101]      = -1,
+    [UNW_IA64_AR +102]  = -1,           [UNW_IA64_AR +103]      = -1,
+    [UNW_IA64_AR +104]  = -1,           [UNW_IA64_AR +105]      = -1,
+    [UNW_IA64_AR +106]  = -1,           [UNW_IA64_AR +107]      = -1,
+    [UNW_IA64_AR +108]  = -1,           [UNW_IA64_AR +109]      = -1,
+    [UNW_IA64_AR +110]  = -1,           [UNW_IA64_AR +111]      = -1,
+    [UNW_IA64_AR +112]  = -1,           [UNW_IA64_AR +113]      = -1,
+    [UNW_IA64_AR +114]  = -1,           [UNW_IA64_AR +115]      = -1,
+    [UNW_IA64_AR +116]  = -1,           [UNW_IA64_AR +117]      = -1,
+    [UNW_IA64_AR +118]  = -1,           [UNW_IA64_AR +119]      = -1,
+    [UNW_IA64_AR +120]  = -1,           [UNW_IA64_AR +121]      = -1,
+    [UNW_IA64_AR +122]  = -1,           [UNW_IA64_AR +123]      = -1,
+    [UNW_IA64_AR +124]  = -1,           [UNW_IA64_AR +125]      = -1,
+    [UNW_IA64_AR +126]  = -1,           [UNW_IA64_AR +127]      = -1,
 
-    [UNW_IA64_BR +  0]	= PT_B0,	[UNW_IA64_BR +  1]	= PT_B1,
-    [UNW_IA64_BR +  2]	= PT_B2,	[UNW_IA64_BR +  3]	= PT_B3,
-    [UNW_IA64_BR +  4]	= PT_B4,	[UNW_IA64_BR +  5]	= PT_B5,
-    [UNW_IA64_BR +  6]	= PT_B6,	[UNW_IA64_BR +  7]	= PT_B7,
+    [UNW_IA64_BR +  0]  = PT_B0,        [UNW_IA64_BR +  1]      = PT_B1,
+    [UNW_IA64_BR +  2]  = PT_B2,        [UNW_IA64_BR +  3]      = PT_B3,
+    [UNW_IA64_BR +  4]  = PT_B4,        [UNW_IA64_BR +  5]      = PT_B5,
+    [UNW_IA64_BR +  6]  = PT_B6,        [UNW_IA64_BR +  7]      = PT_B7,
 
-    [UNW_IA64_PR]	= PT_PR,
-    [UNW_IA64_CFM]	= PT_CFM,
-    [UNW_IA64_IP]	= PT_CR_IIP
+    [UNW_IA64_PR]       = PT_PR,
+    [UNW_IA64_CFM]      = PT_CFM,
+    [UNW_IA64_IP]       = PT_CR_IIP
 #elif defined(HAVE_TTRACE)
 # warning No support for ttrace() yet.
 #elif defined(UNW_TARGET_HPPA)
-    [UNW_HPPA_GR +  0]	= 0x000,	[UNW_HPPA_GR +  1]	= 0x004,
-    [UNW_HPPA_GR +  2]	= 0x008,	[UNW_HPPA_GR +  3]	= 0x00c,
-    [UNW_HPPA_GR +  4]	= 0x010,	[UNW_HPPA_GR +  5]	= 0x014,
-    [UNW_HPPA_GR +  6]	= 0x018,	[UNW_HPPA_GR +  7]	= 0x01c,
-    [UNW_HPPA_GR +  8]	= 0x020,	[UNW_HPPA_GR +  9]	= 0x024,
-    [UNW_HPPA_GR + 10]	= 0x028,	[UNW_HPPA_GR + 11]	= 0x02c,
-    [UNW_HPPA_GR + 12]	= 0x030,	[UNW_HPPA_GR + 13]	= 0x034,
-    [UNW_HPPA_GR + 14]	= 0x038,	[UNW_HPPA_GR + 15]	= 0x03c,
-    [UNW_HPPA_GR + 16]	= 0x040,	[UNW_HPPA_GR + 17]	= 0x044,
-    [UNW_HPPA_GR + 18]	= 0x048,	[UNW_HPPA_GR + 19]	= 0x04c,
-    [UNW_HPPA_GR + 20]	= 0x050,	[UNW_HPPA_GR + 21]	= 0x054,
-    [UNW_HPPA_GR + 22]	= 0x058,	[UNW_HPPA_GR + 23]	= 0x05c,
-    [UNW_HPPA_GR + 24]	= 0x060,	[UNW_HPPA_GR + 25]	= 0x064,
-    [UNW_HPPA_GR + 26]	= 0x068,	[UNW_HPPA_GR + 27]	= 0x06c,
-    [UNW_HPPA_GR + 28]	= 0x070,	[UNW_HPPA_GR + 29]	= 0x074,
-    [UNW_HPPA_GR + 30]	= 0x078,	[UNW_HPPA_GR + 31]	= 0x07c,
+    [UNW_HPPA_GR +  0]  = 0x000,        [UNW_HPPA_GR +  1]      = 0x004,
+    [UNW_HPPA_GR +  2]  = 0x008,        [UNW_HPPA_GR +  3]      = 0x00c,
+    [UNW_HPPA_GR +  4]  = 0x010,        [UNW_HPPA_GR +  5]      = 0x014,
+    [UNW_HPPA_GR +  6]  = 0x018,        [UNW_HPPA_GR +  7]      = 0x01c,
+    [UNW_HPPA_GR +  8]  = 0x020,        [UNW_HPPA_GR +  9]      = 0x024,
+    [UNW_HPPA_GR + 10]  = 0x028,        [UNW_HPPA_GR + 11]      = 0x02c,
+    [UNW_HPPA_GR + 12]  = 0x030,        [UNW_HPPA_GR + 13]      = 0x034,
+    [UNW_HPPA_GR + 14]  = 0x038,        [UNW_HPPA_GR + 15]      = 0x03c,
+    [UNW_HPPA_GR + 16]  = 0x040,        [UNW_HPPA_GR + 17]      = 0x044,
+    [UNW_HPPA_GR + 18]  = 0x048,        [UNW_HPPA_GR + 19]      = 0x04c,
+    [UNW_HPPA_GR + 20]  = 0x050,        [UNW_HPPA_GR + 21]      = 0x054,
+    [UNW_HPPA_GR + 22]  = 0x058,        [UNW_HPPA_GR + 23]      = 0x05c,
+    [UNW_HPPA_GR + 24]  = 0x060,        [UNW_HPPA_GR + 25]      = 0x064,
+    [UNW_HPPA_GR + 26]  = 0x068,        [UNW_HPPA_GR + 27]      = 0x06c,
+    [UNW_HPPA_GR + 28]  = 0x070,        [UNW_HPPA_GR + 29]      = 0x074,
+    [UNW_HPPA_GR + 30]  = 0x078,        [UNW_HPPA_GR + 31]      = 0x07c,
 
-    [UNW_HPPA_FR +  0]	= 0x080,	[UNW_HPPA_FR +  1]	= 0x088,
-    [UNW_HPPA_FR +  2]	= 0x090,	[UNW_HPPA_FR +  3]	= 0x098,
-    [UNW_HPPA_FR +  4]	= 0x0a0,	[UNW_HPPA_FR +  5]	= 0x0a8,
-    [UNW_HPPA_FR +  6]	= 0x0b0,	[UNW_HPPA_FR +  7]	= 0x0b8,
-    [UNW_HPPA_FR +  8]	= 0x0c0,	[UNW_HPPA_FR +  9]	= 0x0c8,
-    [UNW_HPPA_FR + 10]	= 0x0d0,	[UNW_HPPA_FR + 11]	= 0x0d8,
-    [UNW_HPPA_FR + 12]	= 0x0e0,	[UNW_HPPA_FR + 13]	= 0x0e8,
-    [UNW_HPPA_FR + 14]	= 0x0f0,	[UNW_HPPA_FR + 15]	= 0x0f8,
-    [UNW_HPPA_FR + 16]	= 0x100,	[UNW_HPPA_FR + 17]	= 0x108,
-    [UNW_HPPA_FR + 18]	= 0x110,	[UNW_HPPA_FR + 19]	= 0x118,
-    [UNW_HPPA_FR + 20]	= 0x120,	[UNW_HPPA_FR + 21]	= 0x128,
-    [UNW_HPPA_FR + 22]	= 0x130,	[UNW_HPPA_FR + 23]	= 0x138,
-    [UNW_HPPA_FR + 24]	= 0x140,	[UNW_HPPA_FR + 25]	= 0x148,
-    [UNW_HPPA_FR + 26]	= 0x150,	[UNW_HPPA_FR + 27]	= 0x158,
-    [UNW_HPPA_FR + 28]	= 0x160,	[UNW_HPPA_FR + 29]	= 0x168,
-    [UNW_HPPA_FR + 30]	= 0x170,	[UNW_HPPA_FR + 31]	= 0x178,
+    [UNW_HPPA_FR +  0]  = 0x080,        [UNW_HPPA_FR +  1]      = 0x088,
+    [UNW_HPPA_FR +  2]  = 0x090,        [UNW_HPPA_FR +  3]      = 0x098,
+    [UNW_HPPA_FR +  4]  = 0x0a0,        [UNW_HPPA_FR +  5]      = 0x0a8,
+    [UNW_HPPA_FR +  6]  = 0x0b0,        [UNW_HPPA_FR +  7]      = 0x0b8,
+    [UNW_HPPA_FR +  8]  = 0x0c0,        [UNW_HPPA_FR +  9]      = 0x0c8,
+    [UNW_HPPA_FR + 10]  = 0x0d0,        [UNW_HPPA_FR + 11]      = 0x0d8,
+    [UNW_HPPA_FR + 12]  = 0x0e0,        [UNW_HPPA_FR + 13]      = 0x0e8,
+    [UNW_HPPA_FR + 14]  = 0x0f0,        [UNW_HPPA_FR + 15]      = 0x0f8,
+    [UNW_HPPA_FR + 16]  = 0x100,        [UNW_HPPA_FR + 17]      = 0x108,
+    [UNW_HPPA_FR + 18]  = 0x110,        [UNW_HPPA_FR + 19]      = 0x118,
+    [UNW_HPPA_FR + 20]  = 0x120,        [UNW_HPPA_FR + 21]      = 0x128,
+    [UNW_HPPA_FR + 22]  = 0x130,        [UNW_HPPA_FR + 23]      = 0x138,
+    [UNW_HPPA_FR + 24]  = 0x140,        [UNW_HPPA_FR + 25]      = 0x148,
+    [UNW_HPPA_FR + 26]  = 0x150,        [UNW_HPPA_FR + 27]      = 0x158,
+    [UNW_HPPA_FR + 28]  = 0x160,        [UNW_HPPA_FR + 29]      = 0x168,
+    [UNW_HPPA_FR + 30]  = 0x170,        [UNW_HPPA_FR + 31]      = 0x178,
 
-    [UNW_HPPA_IP]	= 0x1a8		/* IAOQ[0] */
+    [UNW_HPPA_IP]       = 0x1a8         /* IAOQ[0] */
 #elif defined(UNW_TARGET_X86)
 #if defined __FreeBSD__
 #define UNW_R_OFF(R, r) \
-    [UNW_X86_##R]	= offsetof(gregset_t, r_##r),
+    [UNW_X86_##R]       = offsetof(gregset_t, r_##r),
     UNW_R_OFF(EAX, eax)
     UNW_R_OFF(EDX, edx)
     UNW_R_OFF(ECX, ecx)
@@ -265,30 +266,30 @@ const int _UPT_reg_offset[UNW_REG_LAST + 1] =
 //  UNW_R_OFF(EFLAGS, eflags)
 //  UNW_R_OFF(SS, ss)
 #elif defined __linux__
-    [UNW_X86_EAX]	= 0x18,
-    [UNW_X86_EBX]	= 0x00,
-    [UNW_X86_ECX]	= 0x04,
-    [UNW_X86_EDX]	= 0x08,
-    [UNW_X86_ESI]	= 0x0c,
-    [UNW_X86_EDI]	= 0x10,
-    [UNW_X86_EBP]	= 0x14,
-    [UNW_X86_EIP]	= 0x30,
-    [UNW_X86_ESP]	= 0x3c
-/*  CS			= 0x34, */
-/*  DS			= 0x1c, */
-/*  ES			= 0x20, */
-/*  FS			= 0x24, */
-/*  GS			= 0x28, */
-/*  ORIG_EAX		= 0x2c, */
-/*  EFLAGS		= 0x38, */
-/*  SS			= 0x40 */
+    [UNW_X86_EAX]       = 0x18,
+    [UNW_X86_EBX]       = 0x00,
+    [UNW_X86_ECX]       = 0x04,
+    [UNW_X86_EDX]       = 0x08,
+    [UNW_X86_ESI]       = 0x0c,
+    [UNW_X86_EDI]       = 0x10,
+    [UNW_X86_EBP]       = 0x14,
+    [UNW_X86_EIP]       = 0x30,
+    [UNW_X86_ESP]       = 0x3c
+/*  CS                  = 0x34, */
+/*  DS                  = 0x1c, */
+/*  ES                  = 0x20, */
+/*  FS                  = 0x24, */
+/*  GS                  = 0x28, */
+/*  ORIG_EAX            = 0x2c, */
+/*  EFLAGS              = 0x38, */
+/*  SS                  = 0x40 */
 #else
 #error Port me
 #endif
 #elif defined(UNW_TARGET_X86_64)
 #if defined __FreeBSD__
 #define UNW_R_OFF(R, r) \
-    [UNW_X86_64_##R]	= offsetof(gregset_t, r_##r),
+    [UNW_X86_64_##R]    = offsetof(gregset_t, r_##r),
     UNW_R_OFF(RAX, rax)
     UNW_R_OFF(RDX, rdx)
     UNW_R_OFF(RCX, rcx)
@@ -311,27 +312,27 @@ const int _UPT_reg_offset[UNW_REG_LAST + 1] =
 //  UNW_R_OFF(SS, ss)
 #undef UNW_R_OFF
 #elif defined __linux__
-    [UNW_X86_64_RAX]	= 0x50,
-    [UNW_X86_64_RDX]	= 0x60,
-    [UNW_X86_64_RCX]	= 0x58,
-    [UNW_X86_64_RBX]	= 0x28,
-    [UNW_X86_64_RSI]	= 0x68,
-    [UNW_X86_64_RDI]	= 0x70,
-    [UNW_X86_64_RBP]	= 0x20,
-    [UNW_X86_64_RSP]	= 0x98,
-    [UNW_X86_64_R8]	= 0x48,
-    [UNW_X86_64_R9]	= 0x40,
-    [UNW_X86_64_R10]	= 0x38,
-    [UNW_X86_64_R11]	= 0x30,
-    [UNW_X86_64_R12]	= 0x18,
-    [UNW_X86_64_R13]	= 0x10,
-    [UNW_X86_64_R14]	= 0x08,
-    [UNW_X86_64_R15]	= 0x00,
-    [UNW_X86_64_RIP]	= 0x80
-//  [UNW_X86_64_CS]	= 0x88,
-//  [UNW_X86_64_EFLAGS]	= 0x90,
-//  [UNW_X86_64_RSP]	= 0x98,
-//  [UNW_X86_64_SS]	= 0xa0
+    [UNW_X86_64_RAX]    = 0x50,
+    [UNW_X86_64_RDX]    = 0x60,
+    [UNW_X86_64_RCX]    = 0x58,
+    [UNW_X86_64_RBX]    = 0x28,
+    [UNW_X86_64_RSI]    = 0x68,
+    [UNW_X86_64_RDI]    = 0x70,
+    [UNW_X86_64_RBP]    = 0x20,
+    [UNW_X86_64_RSP]    = 0x98,
+    [UNW_X86_64_R8]     = 0x48,
+    [UNW_X86_64_R9]     = 0x40,
+    [UNW_X86_64_R10]    = 0x38,
+    [UNW_X86_64_R11]    = 0x30,
+    [UNW_X86_64_R12]    = 0x18,
+    [UNW_X86_64_R13]    = 0x10,
+    [UNW_X86_64_R14]    = 0x08,
+    [UNW_X86_64_R15]    = 0x00,
+    [UNW_X86_64_RIP]    = 0x80
+//  [UNW_X86_64_CS]     = 0x88,
+//  [UNW_X86_64_EFLAGS] = 0x90,
+//  [UNW_X86_64_RSP]    = 0x98,
+//  [UNW_X86_64_SS]     = 0xa0
 #else
 #error Port me
 #endif
@@ -348,38 +349,38 @@ const int _UPT_reg_offset[UNW_REG_LAST + 1] =
     [UNW_PPC##b##_R##i] = UNW_PPC_R(PT_R##i)
 
 #define UNW_PPC_REGS(b) \
-    UNW_R_OFF(b, 0),	\
-    UNW_R_OFF(b, 1),	\
-    UNW_R_OFF(b, 2),	\
-    UNW_R_OFF(b, 3),	\
-    UNW_R_OFF(b, 4),	\
-    UNW_R_OFF(b, 5),	\
-    UNW_R_OFF(b, 6),	\
-    UNW_R_OFF(b, 7),	\
-    UNW_R_OFF(b, 8),	\
-    UNW_R_OFF(b, 9),	\
-    UNW_R_OFF(b, 10),	\
-    UNW_R_OFF(b, 11),	\
-    UNW_R_OFF(b, 12),	\
-    UNW_R_OFF(b, 13),	\
-    UNW_R_OFF(b, 14),	\
-    UNW_R_OFF(b, 15),	\
-    UNW_R_OFF(b, 16),	\
-    UNW_R_OFF(b, 17),	\
-    UNW_R_OFF(b, 18),	\
-    UNW_R_OFF(b, 19),	\
-    UNW_R_OFF(b, 20),	\
-    UNW_R_OFF(b, 21),	\
-    UNW_R_OFF(b, 22),	\
-    UNW_R_OFF(b, 23),	\
-    UNW_R_OFF(b, 24),	\
-    UNW_R_OFF(b, 25),	\
-    UNW_R_OFF(b, 26),	\
-    UNW_R_OFF(b, 27),	\
-    UNW_R_OFF(b, 28),	\
-    UNW_R_OFF(b, 29),	\
-    UNW_R_OFF(b, 30),	\
-    UNW_R_OFF(b, 31),	\
+    UNW_R_OFF(b, 0),    \
+    UNW_R_OFF(b, 1),    \
+    UNW_R_OFF(b, 2),    \
+    UNW_R_OFF(b, 3),    \
+    UNW_R_OFF(b, 4),    \
+    UNW_R_OFF(b, 5),    \
+    UNW_R_OFF(b, 6),    \
+    UNW_R_OFF(b, 7),    \
+    UNW_R_OFF(b, 8),    \
+    UNW_R_OFF(b, 9),    \
+    UNW_R_OFF(b, 10),   \
+    UNW_R_OFF(b, 11),   \
+    UNW_R_OFF(b, 12),   \
+    UNW_R_OFF(b, 13),   \
+    UNW_R_OFF(b, 14),   \
+    UNW_R_OFF(b, 15),   \
+    UNW_R_OFF(b, 16),   \
+    UNW_R_OFF(b, 17),   \
+    UNW_R_OFF(b, 18),   \
+    UNW_R_OFF(b, 19),   \
+    UNW_R_OFF(b, 20),   \
+    UNW_R_OFF(b, 21),   \
+    UNW_R_OFF(b, 22),   \
+    UNW_R_OFF(b, 23),   \
+    UNW_R_OFF(b, 24),   \
+    UNW_R_OFF(b, 25),   \
+    UNW_R_OFF(b, 26),   \
+    UNW_R_OFF(b, 27),   \
+    UNW_R_OFF(b, 28),   \
+    UNW_R_OFF(b, 29),   \
+    UNW_R_OFF(b, 30),   \
+    UNW_R_OFF(b, 31),   \
                                \
     [UNW_PPC##b##_CTR] = UNW_PPC_PT(CTR), \
     [UNW_PPC##b##_XER] = UNW_PPC_PT(XER), \
@@ -422,7 +423,7 @@ const int _UPT_reg_offset[UNW_REG_LAST + 1] =
     [UNW_PPC32_FPSCR] = UNW_PPC_PT(FPSCR), \
     [UNW_PPC32_CCR] = UNW_PPC_PT(CCR)
 
-#define UNW_VR_OFF(i)	\
+#define UNW_VR_OFF(i)   \
     [UNW_PPC64_V##i] = UNW_PPC_R(PT_VR0 + i * 2)
 
 #define UNW_PPC64_REGS \
@@ -483,6 +484,7 @@ const int _UPT_reg_offset[UNW_REG_LAST + 1] =
 #endif
 
 #elif defined(UNW_TARGET_ARM)
+#if defined(__linux__) || defined(__FreeBSD__)
     [UNW_ARM_R0]       = 0x00,
     [UNW_ARM_R1]       = 0x04,
     [UNW_ARM_R2]       = 0x08,
@@ -499,8 +501,171 @@ const int _UPT_reg_offset[UNW_REG_LAST + 1] =
     [UNW_ARM_R13]      = 0x34,
     [UNW_ARM_R14]      = 0x38,
     [UNW_ARM_R15]      = 0x3c,
+#else
+#error Fix me
+#endif
 #elif defined(UNW_TARGET_MIPS)
+    [UNW_MIPS_R0]  =  0,
+    [UNW_MIPS_R1]  =  1,
+    [UNW_MIPS_R2]  =  2,
+    [UNW_MIPS_R3]  =  3,
+    [UNW_MIPS_R4]  =  4,
+    [UNW_MIPS_R5]  =  5,
+    [UNW_MIPS_R6]  =  6,
+    [UNW_MIPS_R7]  =  7,
+    [UNW_MIPS_R8]  =  8,
+    [UNW_MIPS_R9]  =  9,
+    [UNW_MIPS_R10] = 10,
+    [UNW_MIPS_R11] = 11,
+    [UNW_MIPS_R12] = 12,
+    [UNW_MIPS_R13] = 13,
+    [UNW_MIPS_R14] = 14,
+    [UNW_MIPS_R15] = 15,
+    [UNW_MIPS_R16] = 16,
+    [UNW_MIPS_R17] = 17,
+    [UNW_MIPS_R18] = 18,
+    [UNW_MIPS_R19] = 19,
+    [UNW_MIPS_R20] = 20,
+    [UNW_MIPS_R21] = 21,
+    [UNW_MIPS_R22] = 22,
+    [UNW_MIPS_R23] = 23,
+    [UNW_MIPS_R24] = 24,
+    [UNW_MIPS_R25] = 25,
+    [UNW_MIPS_R26] = 26,
+    [UNW_MIPS_R27] = 27,
+    [UNW_MIPS_R28] = 28,
+    [UNW_MIPS_R29] = 29,
+    [UNW_MIPS_R30] = 30,
+    [UNW_MIPS_R31] = 31,
+    [UNW_MIPS_PC]  = 64,
 #elif defined(UNW_TARGET_SH)
+#elif defined(UNW_TARGET_AARCH64)
+    [UNW_AARCH64_X0]       = 0x00,
+    [UNW_AARCH64_X1]       = 0x08,
+    [UNW_AARCH64_X2]       = 0x10,
+    [UNW_AARCH64_X3]       = 0x18,
+    [UNW_AARCH64_X4]       = 0x20,
+    [UNW_AARCH64_X5]       = 0x28,
+    [UNW_AARCH64_X6]       = 0x30,
+    [UNW_AARCH64_X7]       = 0x38,
+    [UNW_AARCH64_X8]       = 0x40,
+    [UNW_AARCH64_X9]       = 0x48,
+    [UNW_AARCH64_X10]      = 0x50,
+    [UNW_AARCH64_X11]      = 0x58,
+    [UNW_AARCH64_X12]      = 0x60,
+    [UNW_AARCH64_X13]      = 0x68,
+    [UNW_AARCH64_X14]      = 0x70,
+    [UNW_AARCH64_X15]      = 0x78,
+    [UNW_AARCH64_X16]      = 0x80,
+    [UNW_AARCH64_X17]      = 0x88,
+    [UNW_AARCH64_X18]      = 0x90,
+    [UNW_AARCH64_X19]      = 0x98,
+    [UNW_AARCH64_X20]      = 0xa0,
+    [UNW_AARCH64_X21]      = 0xa8,
+    [UNW_AARCH64_X22]      = 0xb0,
+    [UNW_AARCH64_X23]      = 0xb8,
+    [UNW_AARCH64_X24]      = 0xc0,
+    [UNW_AARCH64_X25]      = 0xc8,
+    [UNW_AARCH64_X26]      = 0xd0,
+    [UNW_AARCH64_X27]      = 0xd8,
+    [UNW_AARCH64_X28]      = 0xe0,
+    [UNW_AARCH64_X29]      = 0xe8,
+    [UNW_AARCH64_X30]      = 0xf0,
+    [UNW_AARCH64_SP]       = 0xf8,
+    [UNW_AARCH64_PC]       = 0x100,
+    [UNW_AARCH64_PSTATE]   = 0x108
+#elif defined(UNW_TARGET_TILEGX)
+    [UNW_TILEGX_R0]    = 0x00,
+    [UNW_TILEGX_R1]    = 0x08,
+    [UNW_TILEGX_R2]    = 0x10,
+    [UNW_TILEGX_R3]    = 0x08,
+    [UNW_TILEGX_R4]    = 0x20,
+    [UNW_TILEGX_R5]    = 0x28,
+    [UNW_TILEGX_R6]    = 0x30,
+    [UNW_TILEGX_R7]    = 0x38,
+    [UNW_TILEGX_R8]    = 0x40,
+    [UNW_TILEGX_R9]    = 0x48,
+    [UNW_TILEGX_R10]    = 0x50,
+    [UNW_TILEGX_R11]    = 0x58,
+    [UNW_TILEGX_R12]    = 0x60,
+    [UNW_TILEGX_R13]    = 0x68,
+    [UNW_TILEGX_R14]    = 0x70,
+    [UNW_TILEGX_R15]    = 0x78,
+    [UNW_TILEGX_R16]    = 0x80,
+    [UNW_TILEGX_R17]    = 0x88,
+    [UNW_TILEGX_R18]    = 0x90,
+    [UNW_TILEGX_R19]    = 0x98,
+    [UNW_TILEGX_R20]    = 0xa0,
+    [UNW_TILEGX_R21]    = 0xa8,
+    [UNW_TILEGX_R22]    = 0xb0,
+    [UNW_TILEGX_R23]    = 0xb8,
+    [UNW_TILEGX_R24]    = 0xc0,
+    [UNW_TILEGX_R25]    = 0xc8,
+    [UNW_TILEGX_R26]    = 0xd0,
+    [UNW_TILEGX_R27]    = 0xd8,
+    [UNW_TILEGX_R28]    = 0xe0,
+    [UNW_TILEGX_R29]    = 0xe8,
+    [UNW_TILEGX_R30]    = 0xf0,
+    [UNW_TILEGX_R31]    = 0xf8,
+    [UNW_TILEGX_R32]    = 0x100,
+    [UNW_TILEGX_R33]    = 0x108,
+    [UNW_TILEGX_R34]    = 0x110,
+    [UNW_TILEGX_R35]    = 0x118,
+    [UNW_TILEGX_R36]    = 0x120,
+    [UNW_TILEGX_R37]    = 0x128,
+    [UNW_TILEGX_R38]    = 0x130,
+    [UNW_TILEGX_R39]    = 0x138,
+    [UNW_TILEGX_R40]    = 0x140,
+    [UNW_TILEGX_R41]    = 0x148,
+    [UNW_TILEGX_R42]    = 0x150,
+    [UNW_TILEGX_R43]    = 0x158,
+    [UNW_TILEGX_R44]    = 0x160,
+    [UNW_TILEGX_R45]    = 0x168,
+    [UNW_TILEGX_R46]    = 0x170,
+    [UNW_TILEGX_R47]    = 0x178,
+    [UNW_TILEGX_R48]    = 0x180,
+    [UNW_TILEGX_R49]    = 0x188,
+    [UNW_TILEGX_R50]    = 0x190,
+    [UNW_TILEGX_R51]    = 0x198,
+    [UNW_TILEGX_R52]    = 0x1a0,
+    [UNW_TILEGX_R53]    = 0x1a8,
+    [UNW_TILEGX_R54]    = 0x1b0,
+    [UNW_TILEGX_R55]    = 0x1b8,
+    [UNW_TILEGX_PC]     = 0x1a0
+#elif defined(UNW_TARGET_S390X)
+    [UNW_S390X_R0]      = 0x10,
+    [UNW_S390X_R1]      = 0x18,
+    [UNW_S390X_R2]      = 0x20,
+    [UNW_S390X_R3]      = 0x28,
+    [UNW_S390X_R4]      = 0x30,
+    [UNW_S390X_R5]      = 0x38,
+    [UNW_S390X_R6]      = 0x40,
+    [UNW_S390X_R7]      = 0x48,
+    [UNW_S390X_R8]      = 0x50,
+    [UNW_S390X_R9]      = 0x58,
+    [UNW_S390X_R10]     = 0x60,
+    [UNW_S390X_R11]     = 0x68,
+    [UNW_S390X_R12]     = 0x70,
+    [UNW_S390X_R13]     = 0x78,
+    [UNW_S390X_R14]     = 0x80,
+    [UNW_S390X_R15]     = 0x88,
+    [UNW_S390X_F0]      = 0xe0,
+    [UNW_S390X_F1]      = 0xe8,
+    [UNW_S390X_F2]      = 0xf0,
+    [UNW_S390X_F3]      = 0xf8,
+    [UNW_S390X_F4]      = 0x100,
+    [UNW_S390X_F5]      = 0x108,
+    [UNW_S390X_F6]      = 0x110,
+    [UNW_S390X_F7]      = 0x118,
+    [UNW_S390X_F8]      = 0x120,
+    [UNW_S390X_F9]      = 0x128,
+    [UNW_S390X_F10]     = 0x130,
+    [UNW_S390X_F11]     = 0x138,
+    [UNW_S390X_F12]     = 0x140,
+    [UNW_S390X_F13]     = 0x148,
+    [UNW_S390X_F14]     = 0x150,
+    [UNW_S390X_F15]     = 0x150,
+    [UNW_S390X_IP]      = 0x08
 #else
 # error Fix me.
 #endif
diff --git a/src/ptrace/_UPT_resume.c b/src/ptrace/_UPT_resume.c
index f419fed..d70a0d4 100644
--- a/src/ptrace/_UPT_resume.c
+++ b/src/ptrace/_UPT_resume.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
diff --git a/src/ptrace/libunwind-ptrace.pc.in b/src/ptrace/libunwind-ptrace.pc.in
index 4969ca2..673004b 100644
--- a/src/ptrace/libunwind-ptrace.pc.in
+++ b/src/ptrace/libunwind-ptrace.pc.in
@@ -8,3 +8,4 @@ Description: libunwind ptrace library
 Version: @VERSION@
 Requires: libunwind-generic libunwind
 Libs: -L${libdir} -lunwind-ptrace
+Cflags: -I${includedir}
diff --git a/src/s390x/Gapply_reg_state.c b/src/s390x/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/s390x/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/s390x/Gcreate_addr_space.c b/src/s390x/Gcreate_addr_space.c
new file mode 100644
index 0000000..d411454
--- /dev/null
+++ b/src/s390x/Gcreate_addr_space.c
@@ -0,0 +1,62 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2003 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdlib.h>
+
+#include "unwind_i.h"
+
+#if defined(_BIG_ENDIAN) && !defined(__BIG_ENDIAN)
+#define __BIG_ENDIAN _BIG_ENDIAN
+#endif
+
+unw_addr_space_t
+unw_create_addr_space (unw_accessors_t *a, int byte_order)
+{
+#ifdef UNW_LOCAL_ONLY
+  return NULL;
+#else
+  unw_addr_space_t as;
+
+  /*
+   * s390x supports only big-endian.
+   */
+  if (byte_order != 0 && byte_order != __BIG_ENDIAN)
+    return NULL;
+
+  as = malloc (sizeof (*as));
+  if (!as)
+    return NULL;
+
+  memset (as, 0, sizeof (*as));
+
+  as->acc = *a;
+
+  return as;
+#endif
+}
diff --git a/src/s390x/Gget_proc_info.c b/src/s390x/Gget_proc_info.c
new file mode 100644
index 0000000..50de1e4
--- /dev/null
+++ b/src/s390x/Gget_proc_info.c
@@ -0,0 +1,48 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  if (dwarf_make_proc_info (&c->dwarf) < 0)
+    {
+      /* On x86-64, some key routines such as _start() and _dl_start()
+         are missing DWARF unwind info.  We don't want to fail in that
+         case, because those frames are uninteresting and just mark
+         the end of the frame-chain anyhow.  */
+      memset (pi, 0, sizeof (*pi));
+      pi->start_ip = c->dwarf.ip;
+      pi->end_ip = c->dwarf.ip + 1;
+      return 0;
+    }
+  *pi = c->dwarf.pi;
+  return 0;
+}
diff --git a/src/s390x/Gget_save_loc.c b/src/s390x/Gget_save_loc.c
new file mode 100644
index 0000000..dc462c9
--- /dev/null
+++ b/src/s390x/Gget_save_loc.c
@@ -0,0 +1,86 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2004 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  dwarf_loc_t loc;
+
+  loc = DWARF_NULL_LOC;         /* default to "not saved" */
+
+  switch (reg)
+    {
+    case UNW_S390X_R6:
+    case UNW_S390X_R7:
+    case UNW_S390X_R8:
+    case UNW_S390X_R9:
+    case UNW_S390X_R10:
+    case UNW_S390X_R11:
+    case UNW_S390X_R12:
+    case UNW_S390X_R13:
+    case UNW_S390X_R15:
+    case UNW_S390X_F8:
+    case UNW_S390X_F9:
+    case UNW_S390X_F10:
+    case UNW_S390X_F11:
+    case UNW_S390X_F12:
+    case UNW_S390X_F13:
+    case UNW_S390X_F14:
+    case UNW_S390X_F15:
+      loc = c->dwarf.loc[reg];
+      break;
+
+    default:
+      break;
+    }
+
+  memset (sloc, 0, sizeof (*sloc));
+
+  if (DWARF_IS_NULL_LOC (loc))
+    {
+      sloc->type = UNW_SLT_NONE;
+      return 0;
+    }
+
+#if !defined(UNW_LOCAL_ONLY)
+  if (DWARF_IS_REG_LOC (loc))
+    {
+      sloc->type = UNW_SLT_REG;
+      sloc->u.regnum = DWARF_GET_LOC (loc);
+    }
+  else
+#endif
+    {
+      sloc->type = UNW_SLT_MEMORY;
+      sloc->u.addr = DWARF_GET_LOC (loc);
+    }
+  return 0;
+}
diff --git a/src/s390x/Gglobal.c b/src/s390x/Gglobal.c
new file mode 100644
index 0000000..e2abe89
--- /dev/null
+++ b/src/s390x/Gglobal.c
@@ -0,0 +1,101 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "config.h"
+#include "unwind_i.h"
+#include "dwarf_i.h"
+
+HIDDEN define_lock (s390x_lock);
+HIDDEN int tdep_init_done;
+
+/* The API register numbers are exactly the same as the .eh_frame
+   registers, for now at least.  */
+HIDDEN const uint8_t dwarf_to_unw_regnum_map[DWARF_NUM_PRESERVED_REGS] =
+  {
+    UNW_S390X_R0,
+    UNW_S390X_R1,
+    UNW_S390X_R2,
+    UNW_S390X_R3,
+    UNW_S390X_R4,
+    UNW_S390X_R5,
+    UNW_S390X_R6,
+    UNW_S390X_R7,
+    UNW_S390X_R8,
+    UNW_S390X_R9,
+    UNW_S390X_R10,
+    UNW_S390X_R11,
+    UNW_S390X_R12,
+    UNW_S390X_R13,
+    UNW_S390X_R14,
+    UNW_S390X_R15,
+
+    UNW_S390X_F0,
+    UNW_S390X_F2,
+    UNW_S390X_F4,
+    UNW_S390X_F6,
+    UNW_S390X_F1,
+    UNW_S390X_F3,
+    UNW_S390X_F5,
+    UNW_S390X_F7,
+    UNW_S390X_F8,
+    UNW_S390X_F10,
+    UNW_S390X_F12,
+    UNW_S390X_F14,
+    UNW_S390X_F9,
+    UNW_S390X_F11,
+    UNW_S390X_F13,
+    UNW_S390X_F15,
+  };
+
+HIDDEN void
+tdep_init (void)
+{
+  intrmask_t saved_mask;
+
+  sigfillset (&unwi_full_mask);
+
+  lock_acquire (&s390x_lock, saved_mask);
+  {
+    if (tdep_init_done)
+      /* another thread else beat us to it... */
+      goto out;
+
+    mi_init ();
+
+    dwarf_init ();
+
+    tdep_init_mem_validate ();
+
+#ifndef UNW_REMOTE_ONLY
+    s390x_local_addr_space_init ();
+#endif
+    tdep_init_done = 1; /* signal that we're initialized... */
+  }
+ out:
+  lock_release (&s390x_lock, saved_mask);
+}
diff --git a/src/s390x/Ginit.c b/src/s390x/Ginit.c
new file mode 100644
index 0000000..f0886ac
--- /dev/null
+++ b/src/s390x/Ginit.c
@@ -0,0 +1,366 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2002 Hewlett-Packard Co
+   Copyright (C) 2007 David Mosberger-Tang
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+#include "unwind_i.h"
+
+#ifdef UNW_REMOTE_ONLY
+
+/* unw_local_addr_space is a NULL pointer in this case.  */
+unw_addr_space_t unw_local_addr_space;
+
+#else /* !UNW_REMOTE_ONLY */
+
+static struct unw_addr_space local_addr_space;
+
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
+
+HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
+
+static inline void *
+uc_addr (ucontext_t *uc, int reg)
+{
+  if (reg >= UNW_S390X_R0 && reg <= UNW_S390X_R15)
+    return &uc->uc_mcontext.gregs[reg - UNW_S390X_R0];
+  if (reg >= UNW_S390X_F0 && reg <= UNW_S390X_F15)
+    return &uc->uc_mcontext.fpregs.fprs[reg - UNW_S390X_F0];
+  if (reg == UNW_S390X_IP)
+    return &uc->uc_mcontext.psw.addr;
+
+  return NULL;
+}
+
+# ifdef UNW_LOCAL_ONLY
+
+HIDDEN void *
+tdep_uc_addr (ucontext_t *uc, int reg)
+{
+  return uc_addr (uc, reg);
+}
+
+# endif /* UNW_LOCAL_ONLY */
+
+/* XXX fix me: there is currently no way to locate the dyn-info list
+       by a remote unwinder.  On ia64, this is done via a special
+       unwind-table entry.  Perhaps something similar can be done with
+       DWARF2 unwind info.  */
+
+static void
+put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
+{
+  /* it's a no-op */
+}
+
+static int
+get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
+                        void *arg)
+{
+  *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
+  return 0;
+}
+
+#define PAGE_SIZE 4096
+#define PAGE_START(a)   ((a) & ~(PAGE_SIZE-1))
+
+static int mem_validate_pipe[2] = {-1, -1};
+
+static inline void
+open_pipe (void)
+{
+  /* ignore errors for closing invalid fd's */
+  close (mem_validate_pipe[0]);
+  close (mem_validate_pipe[1]);
+
+  pipe2 (mem_validate_pipe, O_CLOEXEC | O_NONBLOCK);
+}
+
+ALWAYS_INLINE
+static int
+write_validate (void *addr)
+{
+  int ret = -1;
+  ssize_t bytes = 0;
+
+  do
+    {
+      char buf;
+      bytes = read (mem_validate_pipe[0], &buf, 1);
+    }
+  while ( errno == EINTR );
+
+  int valid_read = (bytes > 0 || errno == EAGAIN || errno == EWOULDBLOCK);
+  if (!valid_read)
+    {
+      // re-open closed pipe
+      open_pipe ();
+    }
+
+  do
+    {
+      /* use syscall insteadof write() so that ASAN does not complain */
+      ret = syscall (SYS_write, mem_validate_pipe[1], addr, 1);
+    }
+  while ( errno == EINTR );
+
+  return ret;
+}
+
+static int (*mem_validate_func) (void *addr, size_t len);
+static int msync_validate (void *addr, size_t len)
+{
+  if (msync (addr, len, MS_ASYNC) != 0)
+    {
+      return -1;
+    }
+
+  return write_validate (addr);
+}
+
+#ifdef HAVE_MINCORE
+static int mincore_validate (void *addr, size_t len)
+{
+  unsigned char mvec[2]; /* Unaligned access may cross page boundary */
+  size_t i;
+
+  /* mincore could fail with EAGAIN but we conservatively return -1
+     instead of looping. */
+  if (mincore (addr, len, mvec) != 0)
+    {
+      return -1;
+    }
+
+  for (i = 0; i < (len + PAGE_SIZE - 1) / PAGE_SIZE; i++)
+    {
+      if (!(mvec[i] & 1)) return -1;
+    }
+
+  return write_validate (addr);
+}
+#endif
+
+/* Initialise memory validation method. On linux kernels <2.6.21,
+   mincore() returns incorrect value for MAP_PRIVATE mappings,
+   such as stacks. If mincore() was available at compile time,
+   check if we can actually use it. If not, use msync() instead. */
+HIDDEN void
+tdep_init_mem_validate (void)
+{
+  open_pipe ();
+
+#ifdef HAVE_MINCORE
+  unsigned char present = 1;
+  unw_word_t addr = PAGE_START((unw_word_t)&present);
+  unsigned char mvec[1];
+  int ret;
+  while ((ret = mincore ((void*)addr, PAGE_SIZE, mvec)) == -1 &&
+         errno == EAGAIN) {}
+  if (ret == 0 && (mvec[0] & 1))
+    {
+      Debug(1, "using mincore to validate memory\n");
+      mem_validate_func = mincore_validate;
+    }
+  else
+#endif
+    {
+      Debug(1, "using msync to validate memory\n");
+      mem_validate_func = msync_validate;
+    }
+}
+
+/* Cache of already validated addresses */
+#define NLGA 4
+static unw_word_t last_good_addr[NLGA];
+static int lga_victim;
+
+static int
+validate_mem (unw_word_t addr)
+{
+  int i, victim;
+  size_t len;
+
+  if (PAGE_START(addr + sizeof (unw_word_t) - 1) == PAGE_START(addr))
+    len = PAGE_SIZE;
+  else
+    len = PAGE_SIZE * 2;
+
+  addr = PAGE_START(addr);
+
+  if (addr == 0)
+    return -1;
+
+  for (i = 0; i < NLGA; i++)
+    {
+      if (last_good_addr[i] && (addr == last_good_addr[i]))
+        return 0;
+    }
+
+  if (mem_validate_func ((void *) addr, len) == -1)
+    return -1;
+
+  victim = lga_victim;
+  for (i = 0; i < NLGA; i++) {
+    if (!last_good_addr[victim]) {
+      last_good_addr[victim++] = addr;
+      return 0;
+    }
+    victim = (victim + 1) % NLGA;
+  }
+
+  /* All slots full. Evict the victim. */
+  last_good_addr[victim] = addr;
+  victim = (victim + 1) % NLGA;
+  lga_victim = victim;
+
+  return 0;
+}
+
+static int
+access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
+            void *arg)
+{
+  if (unlikely (write))
+    {
+      Debug (16, "mem[%016lx] <- %lx\n", addr, *val);
+      *(unw_word_t *) addr = *val;
+    }
+  else
+    {
+      /* validate address */
+      const struct cursor *c = (const struct cursor *)arg;
+      if (likely (c != NULL) && unlikely (c->validate)
+          && unlikely (validate_mem (addr))) {
+        Debug (16, "mem[%016lx] -> invalid\n", addr);
+        return -1;
+      }
+      *val = *(unw_word_t *) addr;
+      Debug (16, "mem[%016lx] -> %lx\n", addr, *val);
+    }
+  return 0;
+}
+
+static int
+access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
+            void *arg)
+{
+  unw_word_t *addr;
+  ucontext_t *uc = ((struct cursor *)arg)->uc;
+
+  if (unw_is_fpreg (reg))
+    goto badreg;
+
+  if (!(addr = uc_addr (uc, reg)))
+    goto badreg;
+
+  if (write)
+    {
+      *(unw_word_t *) addr = *val;
+      Debug (12, "%s <- 0x%016lx\n", unw_regname (reg), *val);
+    }
+  else
+    {
+      *val = *(unw_word_t *) addr;
+      Debug (12, "%s -> 0x%016lx\n", unw_regname (reg), *val);
+    }
+  return 0;
+
+ badreg:
+  Debug (1, "bad register number %u\n", reg);
+  return -UNW_EBADREG;
+}
+
+static int
+access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
+              int write, void *arg)
+{
+  ucontext_t *uc = ((struct cursor *)arg)->uc;
+  unw_fpreg_t *addr;
+
+  if (!unw_is_fpreg (reg))
+    goto badreg;
+
+  if (!(addr = uc_addr (uc, reg)))
+    goto badreg;
+
+  if (write)
+    {
+      Debug (12, "%s <- %08lx.%08lx.%08lx\n", unw_regname (reg),
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+      *(unw_fpreg_t *) addr = *val;
+    }
+  else
+    {
+      *val = *(unw_fpreg_t *) addr;
+      Debug (12, "%s -> %08lx.%08lx.%08lx\n", unw_regname (reg),
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+    }
+  return 0;
+
+ badreg:
+  Debug (1, "bad register number %u\n", reg);
+  /* attempt to access a non-preserved register */
+  return -UNW_EBADREG;
+}
+
+static int
+get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
+{
+  return _Uelf64_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
+}
+
+HIDDEN void
+s390x_local_addr_space_init (void)
+{
+  memset (&local_addr_space, 0, sizeof (local_addr_space));
+  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
+  local_addr_space.acc.put_unwind_info = put_unwind_info;
+  local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
+  local_addr_space.acc.access_mem = access_mem;
+  local_addr_space.acc.access_reg = access_reg;
+  local_addr_space.acc.access_fpreg = access_fpreg;
+  local_addr_space.acc.resume = s390x_local_resume;
+  local_addr_space.acc.get_proc_name = get_static_proc_name;
+  unw_flush_cache (&local_addr_space, 0, 0);
+
+  memset (last_good_addr, 0, sizeof (unw_word_t) * NLGA);
+  lga_victim = 0;
+}
+
+#endif /* !UNW_REMOTE_ONLY */
diff --git a/src/s390x/Ginit_local.c b/src/s390x/Ginit_local.c
new file mode 100644
index 0000000..5eaead0
--- /dev/null
+++ b/src/s390x/Ginit_local.c
@@ -0,0 +1,81 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "init.h"
+
+#ifdef UNW_REMOTE_ONLY
+
+int
+unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return -UNW_EINVAL;
+}
+
+#else /* !UNW_REMOTE_ONLY */
+
+static int
+unw_init_local_common (unw_cursor_t *cursor, ucontext_t *uc, unsigned use_prev_instr)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  if (unlikely (!tdep_init_done))
+    tdep_init ();
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  c->dwarf.as = unw_local_addr_space;
+  c->dwarf.as_arg = c;
+  c->uc = uc;
+  c->validate = 0;
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
+}
+
+#endif /* !UNW_REMOTE_ONLY */
diff --git a/src/s390x/Ginit_remote.c b/src/s390x/Ginit_remote.c
new file mode 100644
index 0000000..efd61d6
--- /dev/null
+++ b/src/s390x/Ginit_remote.c
@@ -0,0 +1,57 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "init.h"
+#include "unwind_i.h"
+
+int
+unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
+{
+#ifdef UNW_LOCAL_ONLY
+  return -UNW_EINVAL;
+#else /* !UNW_LOCAL_ONLY */
+  struct cursor *c = (struct cursor *) cursor;
+
+  if (!tdep_init_done)
+    tdep_init ();
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  c->dwarf.as = as;
+  if (as == unw_local_addr_space)
+    {
+      c->dwarf.as_arg = c;
+      c->uc = as_arg;
+    }
+  else
+    {
+      c->dwarf.as_arg = as_arg;
+      c->uc = NULL;
+    }
+  return common_init (c, 0);
+#endif /* !UNW_LOCAL_ONLY */
+}
diff --git a/src/s390x/Gis_signal_frame.c b/src/s390x/Gis_signal_frame.c
new file mode 100644
index 0000000..7ed91e3
--- /dev/null
+++ b/src/s390x/Gis_signal_frame.c
@@ -0,0 +1,77 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
+   Copyright (C) 2013 Linaro Limited
+   Copyright (C) 2017 IBM
+
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+/* The restorer stub will be a system call:
+   - rt_sigreturn: svc 173 (0x0aad)
+   - sigreturn:    svc 119 (0x0a77)
+*/
+
+int
+unw_is_signal_frame (unw_cursor_t *cursor)
+{
+#ifdef __linux__
+  struct cursor *c = (struct cursor *) cursor;
+  unw_word_t w0, ip;
+  unw_addr_space_t as;
+  unw_accessors_t *a;
+  void *arg;
+  int ret, shift = 48;
+
+  as = c->dwarf.as;
+  a = unw_get_accessors (as);
+  arg = c->dwarf.as_arg;
+
+  /* Align the instruction pointer to 8 bytes so that we guarantee
+     an 8 byte read from it won't cross a page boundary.
+     Instructions on s390x are 2 byte aligned.  */
+  ip = c->dwarf.ip & ~7;
+  shift -= (c->dwarf.ip - ip) * 8;
+
+  ret = (*a->access_mem) (as, ip, &w0, 0, arg);
+  if (ret < 0)
+    return ret;
+
+  /* extract first 2 bytes of the next instruction */
+  w0 = (w0 >> shift) & 0xffff;
+
+  /* sigreturn */
+  if (w0 == 0x0a77)
+    return 1;
+
+  /* rt_sigreturn */
+  if (w0 == 0x0aad)
+    return 2;
+
+  return 0;
+
+#else
+  return -UNW_ENOINFO;
+#endif
+}
diff --git a/src/s390x/Greg_states_iterate.c b/src/s390x/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/s390x/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/s390x/Gregs.c b/src/s390x/Gregs.c
new file mode 100644
index 0000000..1a48833
--- /dev/null
+++ b/src/s390x/Gregs.c
@@ -0,0 +1,116 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2004 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+HIDDEN int
+tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
+                 int write)
+{
+  dwarf_loc_t loc = DWARF_NULL_LOC;
+
+  switch (reg)
+    {
+    case UNW_S390X_CFA:
+      if (write)
+        return -UNW_EREADONLYREG;
+      *valp = c->dwarf.cfa;
+      return 0;
+
+    case UNW_S390X_R0:
+    case UNW_S390X_R1:
+    case UNW_S390X_R2:
+    case UNW_S390X_R3:
+    case UNW_S390X_R4:
+    case UNW_S390X_R5:
+    case UNW_S390X_R6:
+    case UNW_S390X_R7:
+    case UNW_S390X_R8:
+    case UNW_S390X_R9:
+    case UNW_S390X_R10:
+    case UNW_S390X_R11:
+    case UNW_S390X_R12:
+    case UNW_S390X_R13:
+    case UNW_S390X_R14:
+    case UNW_S390X_IP:
+      loc = c->dwarf.loc[reg];
+      break;
+
+    case UNW_S390X_R15:
+      if (write)
+        return -UNW_EREADONLYREG;
+      loc = c->dwarf.loc[reg];
+      break;
+
+    default:
+      Debug (1, "bad register number %u\n", reg);
+      return -UNW_EBADREG;
+    }
+
+  if (write)
+    return dwarf_put (&c->dwarf, loc, *valp);
+  else
+    return dwarf_get (&c->dwarf, loc, valp);
+}
+
+HIDDEN int
+tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
+                   int write)
+{
+  dwarf_loc_t loc = DWARF_NULL_LOC;
+
+  switch (reg)
+    {
+    case UNW_S390X_F0:
+    case UNW_S390X_F1:
+    case UNW_S390X_F2:
+    case UNW_S390X_F3:
+    case UNW_S390X_F4:
+    case UNW_S390X_F5:
+    case UNW_S390X_F6:
+    case UNW_S390X_F7:
+    case UNW_S390X_F8:
+    case UNW_S390X_F9:
+    case UNW_S390X_F10:
+    case UNW_S390X_F11:
+    case UNW_S390X_F12:
+    case UNW_S390X_F13:
+    case UNW_S390X_F14:
+    case UNW_S390X_F15:
+      loc = c->dwarf.loc[reg];
+      break;
+    default:
+      Debug (1, "bad register number %u\n", reg);
+      return -UNW_EBADREG;
+    }
+
+  if (write)
+    return dwarf_putfp (&c->dwarf, loc, *valp);
+  else
+    return dwarf_getfp (&c->dwarf, loc, valp);
+}
diff --git a/src/s390x/Gresume.c b/src/s390x/Gresume.c
new file mode 100644
index 0000000..fd9d130
--- /dev/null
+++ b/src/s390x/Gresume.c
@@ -0,0 +1,160 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2004 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdlib.h>
+
+#include "unwind_i.h"
+
+#ifndef UNW_REMOTE_ONLY
+
+HIDDEN inline int
+s390x_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  ucontext_t uc = *c->uc;
+  ucontext_t *rt = NULL;
+  struct sigcontext *sc = NULL;
+  int i;
+  unw_word_t sp, ip;
+  uc.uc_mcontext.psw.addr = c->dwarf.ip;
+
+  /* Ensure c->pi is up-to-date.  On x86-64, it's relatively common to
+     be missing DWARF unwind info.  We don't want to fail in that
+     case, because the frame-chain still would let us do a backtrace
+     at least.  */
+  dwarf_make_proc_info (&c->dwarf);
+
+  switch (c->sigcontext_format)
+    {
+    case S390X_SCF_NONE:
+      Debug (8, "resuming at ip=%llx via setcontext()\n",
+                (unsigned long long) c->dwarf.ip);
+      setcontext (&uc);
+      abort(); /* unreachable */
+    case S390X_SCF_LINUX_SIGFRAME:
+      Debug (8, "resuming at ip=%llx via signal trampoline\n",
+                (unsigned long long) c->dwarf.ip);
+      sc = (struct sigcontext*)c->sigcontext_addr;
+      for (i = UNW_S390X_R0; i <= UNW_S390X_R15; ++i)
+        sc->sregs->regs.gprs[i-UNW_S390X_R0] = uc.uc_mcontext.gregs[i-UNW_S390X_R0];
+      for (i = UNW_S390X_F0; i <= UNW_S390X_F15; ++i)
+        sc->sregs->fpregs.fprs[i-UNW_S390X_F0] = uc.uc_mcontext.fpregs.fprs[i-UNW_S390X_F0].d;
+      sc->sregs->regs.psw.addr = uc.uc_mcontext.psw.addr;
+
+      sp = c->sigcontext_sp;
+      ip = c->sigcontext_pc;
+      __asm__ __volatile__ (
+        "lgr 15, %[sp]\n"
+        "br %[ip]\n"
+        : : [sp] "r" (sp), [ip] "r" (ip)
+      );
+      abort(); /* unreachable */
+    case S390X_SCF_LINUX_RT_SIGFRAME:
+      Debug (8, "resuming at ip=%llx via signal trampoline\n",
+                (unsigned long long) c->dwarf.ip);
+      rt = (ucontext_t*)c->sigcontext_addr;
+      for (i = UNW_S390X_R0; i <= UNW_S390X_R15; ++i)
+        rt->uc_mcontext.gregs[i-UNW_S390X_R0] = uc.uc_mcontext.gregs[i-UNW_S390X_R0];
+      for (i = UNW_S390X_F0; i <= UNW_S390X_F15; ++i)
+        rt->uc_mcontext.fpregs.fprs[i-UNW_S390X_F0] = uc.uc_mcontext.fpregs.fprs[i-UNW_S390X_F0];
+      rt->uc_mcontext.psw.addr = uc.uc_mcontext.psw.addr;
+
+      sp = c->sigcontext_sp;
+      ip = c->sigcontext_pc;
+      __asm__ __volatile__ (
+        "lgr 15, %[sp]\n"
+        "br %[ip]\n"
+        : : [sp] "r" (sp), [ip] "r" (ip)
+      );
+      abort(); /* unreachable */
+    }
+  return -UNW_EINVAL;
+}
+
+#endif /* !UNW_REMOTE_ONLY */
+
+/* This routine is responsible for copying the register values in
+   cursor C and establishing them as the current machine state. */
+
+static inline int
+establish_machine_state (struct cursor *c)
+{
+  int (*access_reg) (unw_addr_space_t, unw_regnum_t, unw_word_t *,
+                     int write, void *);
+  int (*access_fpreg) (unw_addr_space_t, unw_regnum_t, unw_fpreg_t *,
+                       int write, void *);
+  unw_addr_space_t as = c->dwarf.as;
+  void *arg = c->dwarf.as_arg;
+  unw_fpreg_t fpval;
+  unw_word_t val;
+  int reg;
+
+  access_reg = as->acc.access_reg;
+  access_fpreg = as->acc.access_fpreg;
+
+  Debug (8, "copying out cursor state\n");
+
+  for (reg = 0; reg <= UNW_REG_LAST; ++reg)
+    {
+      Debug (16, "copying %s %d\n", unw_regname (reg), reg);
+      if (unw_is_fpreg (reg))
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            (*access_fpreg) (as, reg, &fpval, 1, arg);
+        }
+      else
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            (*access_reg) (as, reg, &val, 1, arg);
+        }
+    }
+
+  if (c->dwarf.args_size)
+    {
+      if (tdep_access_reg (c, UNW_S390X_R15, &val, 0) >= 0)
+        {
+          val += c->dwarf.args_size;
+          (*access_reg) (as, UNW_S390X_R15, &val, 1, arg);
+        }
+    }
+  return 0;
+}
+
+int
+unw_resume (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  if ((ret = establish_machine_state (c)) < 0)
+    return ret;
+
+  return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
+                                     c->dwarf.as_arg);
+}
diff --git a/src/s390x/Gstep.c b/src/s390x/Gstep.c
new file mode 100644
index 0000000..0b79580
--- /dev/null
+++ b/src/s390x/Gstep.c
@@ -0,0 +1,146 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2002-2004 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include <signal.h>
+
+static int
+s390x_handle_signal_frame (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret, i;
+  unw_word_t sc_addr, sp, *gprs, *fprs, *psw;
+
+  ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_S390X_R15], &sp);
+  if (ret < 0)
+    return ret;
+
+  /* Save the SP and PC to be able to return execution at this point
+     later in time (unw_resume).  */
+  c->sigcontext_sp = sp;
+  c->sigcontext_pc = c->dwarf.ip;
+  switch (c->sigcontext_format)
+    {
+    case S390X_SCF_LINUX_SIGFRAME: /* sigreturn */
+      sc_addr = sp + 160;
+      gprs = ((struct sigcontext*)sc_addr)->sregs->regs.gprs;
+      fprs = (unw_word_t*)((struct sigcontext*)sc_addr)->sregs->fpregs.fprs;
+      psw  = &((struct sigcontext*)sc_addr)->sregs->regs.psw.addr;
+      break;
+    case S390X_SCF_LINUX_RT_SIGFRAME: /* rt_sigreturn */
+      sc_addr = sp + sizeof(siginfo_t) + 8 + 160;
+      gprs = ((ucontext_t*)sc_addr)->uc_mcontext.gregs;
+      fprs = (unw_word_t*)((ucontext_t*)sc_addr)->uc_mcontext.fpregs.fprs;
+      psw  = &((ucontext_t*)sc_addr)->uc_mcontext.psw.addr;
+      break;
+    default:
+      return -UNW_EUNSPEC;
+    }
+
+  c->sigcontext_addr = sc_addr;
+
+  /* Update the dwarf cursor.
+     Set the location of the registers to the corresponding addresses of the
+     uc_mcontext / sigcontext structure contents.  */
+  for (i = UNW_S390X_R0; i <= UNW_S390X_R15; ++i)
+    c->dwarf.loc[i] = DWARF_MEM_LOC (c, (unw_word_t) &gprs[i-UNW_S390X_R0]);
+  for (i = UNW_S390X_F0; i <= UNW_S390X_F15; ++i)
+    c->dwarf.loc[i] = DWARF_MEM_LOC (c, (unw_word_t) &fprs[i-UNW_S390X_F0]);
+
+  c->dwarf.loc[UNW_S390X_IP] = DWARF_MEM_LOC (c, (unw_word_t) psw);
+
+  /* Set SP/CFA and PC/IP.
+     Normally the default CFA on s390x is r15+160. We do not add that offset
+     here because dwarf_step will add the offset.  */
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_S390X_R15], &c->dwarf.cfa);
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_S390X_IP], &c->dwarf.ip);
+
+  c->dwarf.pi_valid = 0;
+  c->dwarf.use_prev_instr = 0;
+
+  return 1;
+}
+
+int
+unw_step (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret = 0, val = c->validate, sig;
+
+#if CONSERVATIVE_CHECKS
+  c->validate = 1;
+#endif
+
+  Debug (1, "(cursor=%p, ip=0x%016lx, cfa=0x%016lx)\n",
+         c, c->dwarf.ip, c->dwarf.cfa);
+
+  /* Try DWARF-based unwinding... */
+  c->sigcontext_format = S390X_SCF_NONE;
+  ret = dwarf_step (&c->dwarf);
+
+#if CONSERVATIVE_CHECKS
+  c->validate = val;
+#endif
+
+  if (unlikely (ret == -UNW_ENOINFO))
+    {
+      /* GCC doesn't currently emit debug information for signal
+         trampolines on s390x so we check for them explicitly.
+
+         If there isn't debug information available we could also
+         try using the backchain (if available).
+
+         Other platforms also detect PLT entries here. That's
+         tricky to do reliably on s390x so I've left it out for
+         now.  */
+
+      /* Memory accesses here are quite likely to be unsafe. */
+      c->validate = 1;
+
+      /* Check if this is a signal frame. */
+      sig = unw_is_signal_frame (cursor);
+      if (sig > 0)
+        {
+          c->sigcontext_format = sig;
+          ret = s390x_handle_signal_frame (cursor);
+        }
+      else
+        {
+          c->dwarf.ip = 0;
+          ret = 0;
+        }
+
+      c->validate = val;
+      return ret;
+    }
+
+  if (unlikely (ret > 0 && c->dwarf.ip == 0))
+    return 0;
+
+  return ret;
+}
diff --git a/src/s390x/Lapply_reg_state.c b/src/s390x/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/s390x/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/s390x/Lcreate_addr_space.c b/src/s390x/Lcreate_addr_space.c
new file mode 100644
index 0000000..0f2dc6b
--- /dev/null
+++ b/src/s390x/Lcreate_addr_space.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gcreate_addr_space.c"
+#endif
diff --git a/src/s390x/Lget_proc_info.c b/src/s390x/Lget_proc_info.c
new file mode 100644
index 0000000..69028b0
--- /dev/null
+++ b/src/s390x/Lget_proc_info.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gget_proc_info.c"
+#endif
diff --git a/src/s390x/Lget_save_loc.c b/src/s390x/Lget_save_loc.c
new file mode 100644
index 0000000..9ea048a
--- /dev/null
+++ b/src/s390x/Lget_save_loc.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gget_save_loc.c"
+#endif
diff --git a/src/s390x/Lglobal.c b/src/s390x/Lglobal.c
new file mode 100644
index 0000000..8c43a67
--- /dev/null
+++ b/src/s390x/Lglobal.c
@@ -0,0 +1,6 @@
+#define UNW_LOCAL_ONLY
+#include "config.h"
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gglobal.c"
+#endif
diff --git a/src/s390x/Linit.c b/src/s390x/Linit.c
new file mode 100644
index 0000000..e9abfdd
--- /dev/null
+++ b/src/s390x/Linit.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit.c"
+#endif
diff --git a/src/s390x/Linit_local.c b/src/s390x/Linit_local.c
new file mode 100644
index 0000000..68a1687
--- /dev/null
+++ b/src/s390x/Linit_local.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit_local.c"
+#endif
diff --git a/src/s390x/Linit_remote.c b/src/s390x/Linit_remote.c
new file mode 100644
index 0000000..58cb04a
--- /dev/null
+++ b/src/s390x/Linit_remote.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit_remote.c"
+#endif
diff --git a/src/s390x/Lis_signal_frame.c b/src/s390x/Lis_signal_frame.c
new file mode 100644
index 0000000..b9a7c4f
--- /dev/null
+++ b/src/s390x/Lis_signal_frame.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gis_signal_frame.c"
+#endif
diff --git a/src/s390x/Lreg_states_iterate.c b/src/s390x/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/s390x/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/s390x/Lregs.c b/src/s390x/Lregs.c
new file mode 100644
index 0000000..2c9c75c
--- /dev/null
+++ b/src/s390x/Lregs.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gregs.c"
+#endif
diff --git a/src/s390x/Lresume.c b/src/s390x/Lresume.c
new file mode 100644
index 0000000..41a8cf0
--- /dev/null
+++ b/src/s390x/Lresume.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gresume.c"
+#endif
diff --git a/src/s390x/Lstep.c b/src/s390x/Lstep.c
new file mode 100644
index 0000000..c1ac3c7
--- /dev/null
+++ b/src/s390x/Lstep.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gstep.c"
+#endif
diff --git a/src/s390x/getcontext.S b/src/s390x/getcontext.S
new file mode 100644
index 0000000..d35a3cf
--- /dev/null
+++ b/src/s390x/getcontext.S
@@ -0,0 +1,74 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 Google, Inc
+	Contributed by Paul Pluzhnikov <ppluzhnikov@google.com>
+   Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
+   Copyright (C) 2017 IBM
+
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+// int _Us390x_getcontext (unw_tdep_context_t *ucp)
+
+	.global _Us390x_getcontext
+	.type _Us390x_getcontext, @function
+_Us390x_getcontext:
+	.cfi_startproc
+
+	// Save the minimal set of registers required to restore the
+	// context. Generally speaking this is just the preserved
+	// registers but we've also saved the parameter registers
+	// so that return values can be modified too.
+
+	// save PSW address
+	// (not strictly needed but makes other code simpler)
+	stg   %r14,0x30(%r2)
+
+	// floating point parameters (not strictly needed)
+	std   %f0,0x100(%r2)
+	std   %f2,0x110(%r2)
+	std   %f4,0x120(%r2)
+	std   %f6,0x130(%r2)
+
+	// floating point preserved registers
+	stfpc 0xf8(%r2)
+	std   %f8,0x140(%r2)
+	std   %f9,0x148(%r2)
+	std   %f10,0x150(%r2)
+	std   %f11,0x158(%r2)
+	std   %f12,0x160(%r2)
+	std   %f13,0x168(%r2)
+	std   %f14,0x170(%r2)
+	std   %f15,0x178(%r2)
+
+	// preserved registers and parameters
+	lgr   %r1,%r2
+	lghi  %r2,0
+	stmg  %r2,%r15,0x48(%r1)
+
+	br    %r14
+
+	.cfi_endproc
+	.size _Us390x_getcontext, . - _Us390x_getcontext
+
+	// We do not need executable stack.
+	.section        .note.GNU-stack,"",@progbits
diff --git a/src/s390x/init.h b/src/s390x/init.h
new file mode 100644
index 0000000..86ced38
--- /dev/null
+++ b/src/s390x/init.h
@@ -0,0 +1,71 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2002 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+static inline int
+common_init (struct cursor *c, unsigned use_prev_instr)
+{
+  int ret;
+  int i;
+
+  for (i = UNW_S390X_R0; i <= UNW_S390X_R15; ++i) {
+    c->dwarf.loc[i] = DWARF_REG_LOC(&c->dwarf, i);
+  }
+  for (i = UNW_S390X_F0; i <= UNW_S390X_F15; ++i) {
+    c->dwarf.loc[i] = DWARF_FPREG_LOC(&c->dwarf, i);
+  }
+  /* IP isn't a real register, it is encoded in the PSW */
+  c->dwarf.loc[UNW_S390X_IP] = DWARF_REG_LOC(&c->dwarf, UNW_S390X_IP);
+
+  ret = dwarf_get (&c->dwarf, c->dwarf.loc[UNW_S390X_IP], &c->dwarf.ip);
+  if (ret < 0)
+    return ret;
+
+  /* Normally the CFA offset on s390x is biased, however this is taken
+     into account by the CFA offset in dwarf_step, so here we just mark
+     make it equal to the stack pointer.  */
+  ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_S390X_R15),
+                   &c->dwarf.cfa);
+  if (ret < 0)
+    return ret;
+
+  c->sigcontext_format = S390X_SCF_NONE;
+  c->sigcontext_addr = 0;
+
+  c->dwarf.args_size = 0;
+  c->dwarf.stash_frames = 0;
+  c->dwarf.use_prev_instr = use_prev_instr;
+  c->dwarf.pi_valid = 0;
+  c->dwarf.pi_is_dynamic = 0;
+  c->dwarf.hint = 0;
+  c->dwarf.prev_rs = 0;
+  c->dwarf.eh_valid_mask = 0;
+
+  return 0;
+}
diff --git a/src/s390x/is_fpreg.c b/src/s390x/is_fpreg.c
new file mode 100644
index 0000000..bc31f3e
--- /dev/null
+++ b/src/s390x/is_fpreg.c
@@ -0,0 +1,36 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2004-2005 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "libunwind_i.h"
+
+int
+unw_is_fpreg (int regnum)
+{
+  /* vector registers? */
+  return regnum >= UNW_S390X_F0 && regnum <= UNW_S390X_F15;
+}
diff --git a/src/s390x/regname.c b/src/s390x/regname.c
new file mode 100644
index 0000000..2421b37
--- /dev/null
+++ b/src/s390x/regname.c
@@ -0,0 +1,57 @@
+/* libunwind - a platform-independent unwind library
+
+        Contributed by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+static const char *regname[] =
+  {
+    [UNW_S390X_R0]="R0",
+    [UNW_S390X_R1]="R1",
+    [UNW_S390X_R2]="R2",
+    [UNW_S390X_R3]="R3",
+    [UNW_S390X_R4]="R4",
+    [UNW_S390X_R5]="R5",
+    [UNW_S390X_R6]="R6",
+    [UNW_S390X_R7]="R7",
+    [UNW_S390X_R8]="R8",
+    [UNW_S390X_R9]="R9",
+    [UNW_S390X_R10]="R10",
+    [UNW_S390X_R11]="R11",
+    [UNW_S390X_R12]="R12",
+    [UNW_S390X_R13]="R13",
+    [UNW_S390X_R14]="R14",
+    [UNW_S390X_R15]="R15",
+
+    [UNW_S390X_IP]="IP"
+   };
+
+const char *
+unw_regname (unw_regnum_t reg)
+{
+  if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
+    return regname[reg];
+  else
+    return "???";
+}
diff --git a/src/s390x/setcontext.S b/src/s390x/setcontext.S
new file mode 100644
index 0000000..6cf5568
--- /dev/null
+++ b/src/s390x/setcontext.S
@@ -0,0 +1,76 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 Google, Inc
+	Contributed by Paul Pluzhnikov <ppluzhnikov@google.com>
+   Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
+   Copyright (C) 2017 IBM
+
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+// int _Us390x_setcontext (const ucontext_t *ucp)
+
+	.global _Us390x_setcontext
+	.type _Us390x_setcontext, @function
+_Us390x_setcontext:
+	.cfi_startproc
+
+	// Must only restore registers saved by getcontext, other fields
+	// in the ucontext_t might be uninitialised.
+
+	// Stop this function being unwound. We are clobbering callee-save
+	// registers in this function so unwinding it is unsafe.
+	// Ideally we'd save callee-save registers, update the CFI for them
+	// and then switch to the new CFI once the context switch is
+	// complete.
+	.cfi_undefined %r14
+
+	// floating point parameters
+	ld    %f0,0x100(%r2)
+	ld    %f2,0x110(%r2)
+	ld    %f4,0x120(%r2)
+	ld    %f6,0x130(%r2)
+
+	// floating point preserved registers
+	lfpc  0xf8(%r2)
+	ld    %f8,0x140(%r2)
+	ld    %f9,0x148(%r2)
+	ld    %f10,0x150(%r2)
+	ld    %f11,0x158(%r2)
+	ld    %f12,0x160(%r2)
+	ld    %f13,0x168(%r2)
+	ld    %f14,0x170(%r2)
+	ld    %f15,0x178(%r2)
+
+	// preserved registers and parameters
+	lgr   %r1,%r2
+	lmg   %r2,%r15,0x48(%r1)
+
+	// restore PSW address
+	lg    %r1,0x30(%r1)
+	br    %r1
+
+	.cfi_endproc
+	.size _Us390x_setcontext, . - _Us390x_setcontext
+
+	// We do not need executable stack.
+	.section        .note.GNU-stack,"",@progbits
diff --git a/src/s390x/unwind_i.h b/src/s390x/unwind_i.h
new file mode 100644
index 0000000..6e4b99b
--- /dev/null
+++ b/src/s390x/unwind_i.h
@@ -0,0 +1,48 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2002, 2005 Hewlett-Packard Co
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+   Modified for s390x by Michael Munday <mike.munday@ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef unwind_i_h
+#define unwind_i_h
+
+#include <stdint.h>
+
+#include <libunwind-s390x.h>
+
+#include "libunwind_i.h"
+#include <sys/ucontext.h>
+
+#define s390x_lock                     UNW_OBJ(lock)
+#define s390x_local_resume             UNW_OBJ(local_resume)
+#define s390x_local_addr_space_init    UNW_OBJ(local_addr_space_init)
+#define setcontext                     UNW_ARCH_OBJ(setcontext)
+
+extern void s390x_local_addr_space_init (void);
+extern int s390x_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg);
+extern int setcontext (const ucontext_t *ucp);
+
+#endif /* unwind_i_h */
diff --git a/src/setjmp/libunwind-setjmp.pc.in b/src/setjmp/libunwind-setjmp.pc.in
index aa34b7b..7b71126 100644
--- a/src/setjmp/libunwind-setjmp.pc.in
+++ b/src/setjmp/libunwind-setjmp.pc.in
@@ -8,3 +8,4 @@ Description: libunwind setjmp library
 Version: @VERSION@
 Requires: libunwind
 Libs: -L${libdir} -lunwind-setjmp
+Cflags: -I${includedir}
diff --git a/src/setjmp/longjmp.c b/src/setjmp/longjmp.c
index 97dcdff..8295a9b 100644
--- a/src/setjmp/longjmp.c
+++ b/src/setjmp/longjmp.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -69,26 +69,26 @@ _longjmp (jmp_buf env, int val)
   do
     {
       if (unw_get_reg (&c, UNW_REG_SP, &sp) < 0)
-	abort ();
+        abort ();
 #ifdef __FreeBSD__
       if (sp != wp[JB_SP] + sizeof(unw_word_t))
 #else
       if (sp != wp[JB_SP])
 #endif
-	continue;
+        continue;
 
       if (!bsp_match (&c, wp))
-	continue;
+        continue;
 
       /* found the right frame: */
 
       assert (UNW_NUM_EH_REGS >= 2);
 
       if (unw_set_reg (&c, UNW_REG_EH + 0, wp[JB_RP]) < 0
-	  || unw_set_reg (&c, UNW_REG_EH + 1, val) < 0
-	  || unw_set_reg (&c, UNW_REG_IP,
-			  (unw_word_t) (uintptr_t) &_UI_longjmp_cont))
-	abort ();
+          || unw_set_reg (&c, UNW_REG_EH + 1, val) < 0
+          || unw_set_reg (&c, UNW_REG_IP,
+                          (unw_word_t) (uintptr_t) &_UI_longjmp_cont))
+        abort ();
 
       unw_resume (&c);
 
diff --git a/src/setjmp/setjmp_i.h b/src/setjmp/setjmp_i.h
index 1d7ca15..4d91396 100644
--- a/src/setjmp/setjmp_i.h
+++ b/src/setjmp/setjmp_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -50,20 +50,20 @@ bsp_match (unw_cursor_t *c, unw_word_t *wp)
       unw_cursor_t tmp = *c;
 
       /* The caller of {sig,}setjmp() cannot have a NULL-frame.  If we
-	 see a NULL-frame, we haven't reached the right target yet.
-	 To have a NULL-frame, the number of locals must be zero and
-	 the stack-frame must also be empty.  */
+         see a NULL-frame, we haven't reached the right target yet.
+         To have a NULL-frame, the number of locals must be zero and
+         the stack-frame must also be empty.  */
 
       if (unw_step (&tmp) < 0)
-	abort ();
+        abort ();
 
       if (unw_get_reg (&tmp, UNW_REG_SP, &sp) < 0
-	  || unw_get_reg (&tmp, UNW_REG_SP, &prev_sp) < 0)
-	abort ();
+          || unw_get_reg (&tmp, UNW_REG_SP, &prev_sp) < 0)
+        abort ();
 
       if (sp == prev_sp)
-	/* got a NULL-frame; keep looking... */
-	return 0;
+        /* got a NULL-frame; keep looking... */
+        return 0;
     }
   return 1;
 }
@@ -93,7 +93,7 @@ resume_restores_sigmask (unw_cursor_t *c, unw_word_t *wp)
   else
     {
       if (sigprocmask (SIG_BLOCK, NULL, &current_mask) < 0)
-	abort ();
+        abort ();
       mp = &current_mask;
     }
   memcpy (&sc->sc_mask, mp, sizeof (sc->sc_mask));
diff --git a/src/setjmp/siglongjmp.c b/src/setjmp/siglongjmp.c
index 55c2003..0e286f6 100644
--- a/src/setjmp/siglongjmp.c
+++ b/src/setjmp/siglongjmp.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -70,16 +70,16 @@ siglongjmp (sigjmp_buf env, int val)
   do
     {
       if (unw_get_reg (&c, UNW_REG_SP, &sp) < 0)
-	abort ();
+        abort ();
 #ifdef __FreeBSD__
       if (sp != wp[JB_SP] + sizeof(unw_word_t))
 #else
       if (sp != wp[JB_SP])
 #endif
-	continue;
+        continue;
 
       if (!bsp_match (&c, wp))
-	continue;
+        continue;
 
       /* found the right frame: */
 
@@ -87,35 +87,35 @@ siglongjmp (sigjmp_buf env, int val)
       cont = &_UI_longjmp_cont;
 
       /* Order of evaluation is important here: if unw_resume()
-	 restores signal mask, we must set it up appropriately, even
-	 if wp[JB_MASK_SAVED] is FALSE.  */
+         restores signal mask, we must set it up appropriately, even
+         if wp[JB_MASK_SAVED] is FALSE.  */
       if (!resume_restores_sigmask (&c, wp) && wp[JB_MASK_SAVED])
-	{
-	  /* sigmask was saved */
+        {
+          /* sigmask was saved */
 #if defined(__linux__)
-	  if (UNW_NUM_EH_REGS < 4 || _NSIG > 16 * sizeof (unw_word_t))
-	    /* signal mask doesn't fit into EH arguments and we can't
-	       put it on the stack without overwriting something
-	       else... */
-	    abort ();
-	  else
-	    if (unw_set_reg (&c, UNW_REG_EH + 2, wp[JB_MASK]) < 0
-		|| (_NSIG > 8 * sizeof (unw_word_t)
-		    && unw_set_reg (&c, UNW_REG_EH + 3, wp[JB_MASK + 1]) < 0))
-	      abort ();
+          if (UNW_NUM_EH_REGS < 4 || _NSIG > 16 * sizeof (unw_word_t))
+            /* signal mask doesn't fit into EH arguments and we can't
+               put it on the stack without overwriting something
+               else... */
+            abort ();
+          else
+            if (unw_set_reg (&c, UNW_REG_EH + 2, wp[JB_MASK]) < 0
+                || (_NSIG > 8 * sizeof (unw_word_t)
+                    && unw_set_reg (&c, UNW_REG_EH + 3, wp[JB_MASK + 1]) < 0))
+              abort ();
 #elif defined(__FreeBSD__)
-	  if (unw_set_reg (&c, UNW_REG_EH + 2, &wp[JB_MASK]) < 0)
-	      abort();
+          if (unw_set_reg (&c, UNW_REG_EH + 2, &wp[JB_MASK]) < 0)
+              abort();
 #else
 #error Port me
 #endif
-	  cont = &_UI_siglongjmp_cont;
-	}
+          cont = &_UI_siglongjmp_cont;
+        }
 
       if (unw_set_reg (&c, UNW_REG_EH + 0, wp[JB_RP]) < 0
-	  || unw_set_reg (&c, UNW_REG_EH + 1, val) < 0
-	  || unw_set_reg (&c, UNW_REG_IP, (unw_word_t) (uintptr_t) cont))
-	abort ();
+          || unw_set_reg (&c, UNW_REG_EH + 1, val) < 0
+          || unw_set_reg (&c, UNW_REG_IP, (unw_word_t) (uintptr_t) cont))
+        abort ();
 
       unw_resume (&c);
 
diff --git a/src/sh/Gapply_reg_state.c b/src/sh/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/sh/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/sh/Gcreate_addr_space.c b/src/sh/Gcreate_addr_space.c
index 1907d04..6ca3a38 100644
--- a/src/sh/Gcreate_addr_space.c
+++ b/src/sh/Gcreate_addr_space.c
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED unw_addr_space_t
+unw_addr_space_t
 unw_create_addr_space (unw_accessors_t *a, int byte_order)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/sh/Gget_proc_info.c b/src/sh/Gget_proc_info.c
index de9199f..c363d24 100644
--- a/src/sh/Gget_proc_info.c
+++ b/src/sh/Gget_proc_info.c
@@ -24,7 +24,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
   struct cursor *c = (struct cursor *) cursor;
diff --git a/src/sh/Gget_save_loc.c b/src/sh/Gget_save_loc.c
index 8b83c6f..24d9f63 100644
--- a/src/sh/Gget_save_loc.c
+++ b/src/sh/Gget_save_loc.c
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -55,7 +55,7 @@ unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
       break;
 
     default:
-      loc = DWARF_NULL_LOC;	/* default to "not saved" */
+      loc = DWARF_NULL_LOC;     /* default to "not saved" */
       break;
     }
 
diff --git a/src/sh/Gglobal.c b/src/sh/Gglobal.c
index 4776d22..ed27333 100644
--- a/src/sh/Gglobal.c
+++ b/src/sh/Gglobal.c
@@ -49,7 +49,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     sh_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&sh_lock, saved_mask);
diff --git a/src/sh/Ginit.c b/src/sh/Ginit.c
index d65bff6..52988a7 100644
--- a/src/sh/Ginit.c
+++ b/src/sh/Ginit.c
@@ -31,13 +31,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 static inline void *
 uc_addr (ucontext_t *uc, int reg)
@@ -73,7 +73,7 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
   return 0;
@@ -81,7 +81,7 @@ get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (write)
     {
@@ -98,7 +98,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   unw_word_t *addr;
   ucontext_t *uc = arg;
@@ -128,7 +128,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = arg;
   unw_fpreg_t *addr;
@@ -142,14 +142,14 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   if (write)
     {
       Debug (12, "%s <- %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
       *(unw_fpreg_t *) addr = *val;
     }
   else
     {
       *val = *(unw_fpreg_t *) addr;
       Debug (12, "%s -> %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
     }
   return 0;
 
@@ -161,8 +161,8 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf32_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -171,7 +171,7 @@ HIDDEN void
 sh_local_addr_space_init (void)
 {
   memset (&local_addr_space, 0, sizeof (local_addr_space));
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
diff --git a/src/sh/Ginit_local.c b/src/sh/Ginit_local.c
index e1cc30c..99ddb36 100644
--- a/src/sh/Ginit_local.c
+++ b/src/sh/Ginit_local.c
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
 {
   return -UNW_EINVAL;
@@ -36,8 +36,8 @@ unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
 
 #else /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
-unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
+static int
+unw_init_local (unw_cursor_t *cursor, unw_context_t *uc, unsigned use_prev_instr)
 {
   struct cursor *c = (struct cursor *) cursor;
 
@@ -49,7 +49,30 @@ unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
   c->dwarf.as = unw_local_addr_space;
   c->dwarf.as_arg = uc;
 
-  return common_init (c, 1);
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, unw_context_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
 }
 
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/sh/Ginit_remote.c b/src/sh/Ginit_remote.c
index f284e99..9b8ba5b 100644
--- a/src/sh/Ginit_remote.c
+++ b/src/sh/Ginit_remote.c
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "init.h"
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/sh/Gis_signal_frame.c b/src/sh/Gis_signal_frame.c
index 9719f8e..4481fe1 100644
--- a/src/sh/Gis_signal_frame.c
+++ b/src/sh/Gis_signal_frame.c
@@ -63,7 +63,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
   3e:   09 00           nop
 */
 
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
 #ifdef __linux__
@@ -75,7 +75,7 @@ unw_is_signal_frame (unw_cursor_t *cursor)
   int ret;
 
   as = c->dwarf.as;
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   arg = c->dwarf.as_arg;
 
   ip = c->dwarf.ip;
diff --git a/src/sh/Greg_states_iterate.c b/src/sh/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/sh/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/sh/Gregs.c b/src/sh/Gregs.c
index cd86a2d..7d8e8e9 100644
--- a/src/sh/Gregs.c
+++ b/src/sh/Gregs.c
@@ -27,12 +27,15 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   dwarf_loc_t loc = DWARF_NULL_LOC;
 
   switch (reg)
     {
+    case UNW_SH_PC:
+      if (write)
+        c->dwarf.ip = *valp;            /* update the IP cache */
     case UNW_SH_R0:
     case UNW_SH_R1:
     case UNW_SH_R2:
@@ -48,7 +51,6 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     case UNW_SH_R12:
     case UNW_SH_R13:
     case UNW_SH_R14:
-    case UNW_SH_PC:
     case UNW_SH_PR:
       loc = c->dwarf.loc[reg];
       break;
@@ -72,7 +74,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   Debug (1, "bad register number %u\n", reg);
   return -UNW_EBADREG;
diff --git a/src/sh/Gresume.c b/src/sh/Gresume.c
index 6a76fe1..a263c92 100644
--- a/src/sh/Gresume.c
+++ b/src/sh/Gresume.c
@@ -39,7 +39,7 @@ sh_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
   if (c->sigcontext_format == SH_SCF_NONE)
     {
       /* Since there are no signals involved here we restore the non scratch
-	 registers only.  */
+         registers only.  */
       unsigned long regs[8];
       regs[0] = uc->uc_mcontext.gregs[8];
       regs[1] = uc->uc_mcontext.gregs[9];
@@ -52,31 +52,31 @@ sh_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
       unsigned long pc = uc->uc_mcontext.pr;
 
       struct regs_overlay {
-	char x[sizeof(regs)];
+        char x[sizeof(regs)];
       };
 
       asm volatile (
-	"mov.l @%0+, r8\n"
-	"mov.l @%0+, r9\n"
-	"mov.l @%0+, r10\n"
-	"mov.l @%0+, r11\n"
-	"mov.l @%0+, r12\n"
-	"mov.l @%0+, r13\n"
-	"mov.l @%0+, r14\n"
-	"mov.l @%0,  r15\n"
-	"lds %1, pr\n"
-	"rts\n"
-	"nop\n"
-	:
-	: "r" (regs),
-	  "r" (pc),
-	  "m" (*(struct regs_overlay *)regs)
+        "mov.l @%0+, r8\n"
+        "mov.l @%0+, r9\n"
+        "mov.l @%0+, r10\n"
+        "mov.l @%0+, r11\n"
+        "mov.l @%0+, r12\n"
+        "mov.l @%0+, r13\n"
+        "mov.l @%0+, r14\n"
+        "mov.l @%0,  r15\n"
+        "lds %1, pr\n"
+        "rts\n"
+        "nop\n"
+        :
+        : "r" (regs),
+          "r" (pc),
+          "m" (*(struct regs_overlay *)regs)
       );
     }
   else
     {
       /* In case a signal frame is involved, we're using its trampoline which
-	 calls sigreturn.  */
+         calls sigreturn.  */
       struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
       sc->sc_regs[0] = uc->uc_mcontext.gregs[0];
       sc->sc_regs[1] = uc->uc_mcontext.gregs[1];
@@ -98,18 +98,18 @@ sh_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
       sc->sc_pr = uc->uc_mcontext.pr;
 
       /* Set the SP and the PC in order to continue execution at the modified
-	 trampoline which restores the signal mask and the registers.  */
+         trampoline which restores the signal mask and the registers.  */
       asm __volatile__ (
-	"mov %0, r15\n"
-	"lds %1, pr\n"
-	"rts\n"
-	"nop\n"
-	:
-	: "r" (c->sigcontext_sp),
-	  "r" (c->sigcontext_pc)
+        "mov %0, r15\n"
+        "lds %1, pr\n"
+        "rts\n"
+        "nop\n"
+        :
+        : "r" (c->sigcontext_sp),
+          "r" (c->sigcontext_pc)
       );
    }
-  __builtin_unreachable();
+  unreachable();
 #endif
   return -UNW_EINVAL;
 }
@@ -131,19 +131,19 @@ establish_machine_state (struct cursor *c)
     {
       Debug (16, "copying %s %d\n", unw_regname (reg), reg);
       if (unw_is_fpreg (reg))
-	{
-	  if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
-	    as->acc.access_fpreg (as, reg, &fpval, 1, arg);
-	}
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            as->acc.access_fpreg (as, reg, &fpval, 1, arg);
+        }
       else
-	{
-	  if (tdep_access_reg (c, reg, &val, 0) >= 0)
-	    as->acc.access_reg (as, reg, &val, 1, arg);
-	}
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            as->acc.access_reg (as, reg, &val, 1, arg);
+        }
     }
 }
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -153,7 +153,7 @@ unw_resume (unw_cursor_t *cursor)
   if (!c->dwarf.ip)
     {
       /* This can happen easily when the frame-chain gets truncated
-	 due to bad or missing unwind-info.  */
+         due to bad or missing unwind-info.  */
       Debug (1, "refusing to resume execution at address 0\n");
       return -UNW_EINVAL;
     }
@@ -161,5 +161,5 @@ unw_resume (unw_cursor_t *cursor)
   establish_machine_state (c);
 
   return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
-				     c->dwarf.as_arg);
+                                     c->dwarf.as_arg);
 }
diff --git a/src/sh/Gstep.c b/src/sh/Gstep.c
index 9bbb5ff..60d7ec2 100644
--- a/src/sh/Gstep.c
+++ b/src/sh/Gstep.c
@@ -27,8 +27,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include "offsets.h"
 
-PROTECTED int
-unw_handle_signal_frame (unw_cursor_t *cursor)
+static int
+sh_handle_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
   int ret;
@@ -94,7 +94,7 @@ unw_handle_signal_frame (unw_cursor_t *cursor)
   return 1;
 }
 
-PROTECTED int
+int
 unw_step (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -102,8 +102,8 @@ unw_step (unw_cursor_t *cursor)
 
   Debug (1, "(cursor=%p)\n", c);
 
-  if (unw_is_signal_frame (cursor))
-    return unw_handle_signal_frame (cursor);
+  if (unw_is_signal_frame (cursor) > 0)
+    return sh_handle_signal_frame (cursor);
 
   ret = dwarf_step (&c->dwarf);
 
diff --git a/src/sh/Lapply_reg_state.c b/src/sh/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/sh/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/sh/Lreg_states_iterate.c b/src/sh/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/sh/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/sh/init.h b/src/sh/init.h
index a180258..36713fe 100644
--- a/src/sh/init.h
+++ b/src/sh/init.h
@@ -62,7 +62,6 @@ common_init (struct cursor *c, unsigned use_prev_instr)
   c->sigcontext_pc = 0;
 
   c->dwarf.args_size = 0;
-  c->dwarf.ret_addr_column = 0;
   c->dwarf.stash_frames = 0;
   c->dwarf.use_prev_instr = use_prev_instr;
   c->dwarf.pi_valid = 0;
diff --git a/src/sh/is_fpreg.c b/src/sh/is_fpreg.c
index c351f81..de09340 100644
--- a/src/sh/is_fpreg.c
+++ b/src/sh/is_fpreg.c
@@ -24,7 +24,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_is_fpreg (int regnum)
 {
   /* FIXME: Support FP.  */
diff --git a/src/sh/offsets.h b/src/sh/offsets.h
index 75c86ca..b02d8ae 100644
--- a/src/sh/offsets.h
+++ b/src/sh/offsets.h
@@ -4,29 +4,29 @@
 
 /* Offsets for SH Linux "ucontext_t":  */
 
-#define LINUX_UC_FLAGS_OFF	0x0
-#define LINUX_UC_LINK_OFF	0x4
-#define LINUX_UC_STACK_OFF	0x8
-#define LINUX_UC_MCONTEXT_OFF	0x14
-#define LINUX_UC_SIGMASK_OFF	0xFC
+#define LINUX_UC_FLAGS_OFF      0x0
+#define LINUX_UC_LINK_OFF       0x4
+#define LINUX_UC_STACK_OFF      0x8
+#define LINUX_UC_MCONTEXT_OFF   0x14
+#define LINUX_UC_SIGMASK_OFF    0xFC
 
 /* Offsets for SH Linux "struct sigcontext":  */
 
-#define LINUX_SC_R0_OFF	0x4
-#define LINUX_SC_R1_OFF	0x8
-#define LINUX_SC_R2_OFF	0xC
-#define LINUX_SC_R3_OFF	0x10
-#define LINUX_SC_R4_OFF	0x14
-#define LINUX_SC_R5_OFF	0x18
-#define LINUX_SC_R6_OFF	0x1C
-#define LINUX_SC_R7_OFF	0x20
-#define LINUX_SC_R8_OFF	0x24
-#define LINUX_SC_R9_OFF	0x28
-#define LINUX_SC_R10_OFF	0x2C
-#define LINUX_SC_R11_OFF	0x30
-#define LINUX_SC_R12_OFF	0x34
-#define LINUX_SC_R13_OFF	0x38
-#define LINUX_SC_R14_OFF	0x3C
-#define LINUX_SC_R15_OFF	0x40
-#define LINUX_SC_PC_OFF	0x44
-#define LINUX_SC_PR_OFF	0x48
+#define LINUX_SC_R0_OFF 0x4
+#define LINUX_SC_R1_OFF 0x8
+#define LINUX_SC_R2_OFF 0xC
+#define LINUX_SC_R3_OFF 0x10
+#define LINUX_SC_R4_OFF 0x14
+#define LINUX_SC_R5_OFF 0x18
+#define LINUX_SC_R6_OFF 0x1C
+#define LINUX_SC_R7_OFF 0x20
+#define LINUX_SC_R8_OFF 0x24
+#define LINUX_SC_R9_OFF 0x28
+#define LINUX_SC_R10_OFF        0x2C
+#define LINUX_SC_R11_OFF        0x30
+#define LINUX_SC_R12_OFF        0x34
+#define LINUX_SC_R13_OFF        0x38
+#define LINUX_SC_R14_OFF        0x3C
+#define LINUX_SC_R15_OFF        0x40
+#define LINUX_SC_PC_OFF 0x44
+#define LINUX_SC_PR_OFF 0x48
diff --git a/src/sh/regname.c b/src/sh/regname.c
index dcab240..b52925b 100644
--- a/src/sh/regname.c
+++ b/src/sh/regname.c
@@ -46,7 +46,7 @@ static const char *const regname[] =
     [UNW_SH_PR]  = "pr",
   };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname) && regname[reg] != NULL)
diff --git a/src/sh/unwind_i.h b/src/sh/unwind_i.h
index 5de0bea..3066d84 100644
--- a/src/sh/unwind_i.h
+++ b/src/sh/unwind_i.h
@@ -29,9 +29,9 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-#define sh_lock				UNW_OBJ(lock)
-#define sh_local_resume			UNW_OBJ(local_resume)
-#define sh_local_addr_space_init	UNW_OBJ(local_addr_space_init)
+#define sh_lock                         UNW_OBJ(lock)
+#define sh_local_resume                 UNW_OBJ(local_resume)
+#define sh_local_addr_space_init        UNW_OBJ(local_addr_space_init)
 
 extern void sh_local_addr_space_init (void);
 extern int sh_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
diff --git a/src/tilegx/Gapply_reg_state.c b/src/tilegx/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/tilegx/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/tilegx/Gcreate_addr_space.c b/src/tilegx/Gcreate_addr_space.c
new file mode 100644
index 0000000..39acdc2
--- /dev/null
+++ b/src/tilegx/Gcreate_addr_space.c
@@ -0,0 +1,65 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdlib.h>
+
+#include "unwind_i.h"
+
+unw_addr_space_t
+unw_create_addr_space (unw_accessors_t *a, int byte_order)
+{
+#ifdef UNW_LOCAL_ONLY
+  return NULL;
+#else
+  unw_addr_space_t as = malloc (sizeof (*as));
+
+  if (!as)
+    return NULL;
+
+  memset (as, 0, sizeof (*as));
+
+  as->acc = *a;
+
+  /*
+   * Tilegx supports only big or little-endian, not weird stuff like
+   * PDP_ENDIAN.
+   */
+  if (byte_order != 0
+      && byte_order != __LITTLE_ENDIAN
+      && byte_order != __BIG_ENDIAN)
+    return NULL;
+
+  if (byte_order == 0)
+    /* use host default: */
+    as->big_endian = (__BYTE_ORDER == __BIG_ENDIAN);
+  else
+    as->big_endian = (byte_order == __BIG_ENDIAN);
+
+  as->abi = UNW_TILEGX_ABI_N64;
+  as->addr_size = 8;
+
+  return as;
+#endif
+}
diff --git a/src/tilegx/Gget_proc_info.c b/src/tilegx/Gget_proc_info.c
new file mode 100644
index 0000000..3a158da
--- /dev/null
+++ b/src/tilegx/Gget_proc_info.c
@@ -0,0 +1,48 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+
+  ret = dwarf_make_proc_info (&c->dwarf);
+
+  if (ret < 0)
+  {
+    /* On Tilegx, some routines i.e. _start() etc has no dwarf info.
+       Just simply mark the end of the frames. */
+    memset (pi, 0, sizeof (*pi));
+    pi->start_ip = c->dwarf.ip;
+    pi->end_ip = c->dwarf.ip + 1;
+    return 0;
+  }
+
+  *pi = c->dwarf.pi;
+  return 0;
+}
diff --git a/src/tilegx/Gget_save_loc.c b/src/tilegx/Gget_save_loc.c
new file mode 100644
index 0000000..fcf0697
--- /dev/null
+++ b/src/tilegx/Gget_save_loc.c
@@ -0,0 +1,62 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  dwarf_loc_t loc;
+
+  loc = DWARF_NULL_LOC;       /* default to "not saved" */
+
+  if (reg <= UNW_TILEGX_R55)
+    loc = c->dwarf.loc[reg - UNW_TILEGX_R0];
+  else
+    printf("\nInvalid register!");
+
+  memset (sloc, 0, sizeof (*sloc));
+
+  if (DWARF_IS_NULL_LOC (loc))
+    {
+      sloc->type = UNW_SLT_NONE;
+      return 0;
+    }
+
+#if !defined(UNW_LOCAL_ONLY)
+  if (DWARF_IS_REG_LOC (loc))
+    {
+      sloc->type = UNW_SLT_REG;
+      sloc->u.regnum = DWARF_GET_LOC (loc);
+    }
+  else
+#endif
+    {
+      sloc->type = UNW_SLT_MEMORY;
+      sloc->u.addr = DWARF_GET_LOC (loc);
+    }
+  return 0;
+}
diff --git a/src/tilegx/Gglobal.c b/src/tilegx/Gglobal.c
new file mode 100644
index 0000000..e18f50a
--- /dev/null
+++ b/src/tilegx/Gglobal.c
@@ -0,0 +1,64 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "dwarf_i.h"
+
+__attribute__((weak))
+pthread_mutex_t tilegx_lock = PTHREAD_MUTEX_INITIALIZER;
+HIDDEN int tdep_init_done;
+
+HIDDEN const uint8_t dwarf_to_unw_regnum_map[] =
+  {
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+    48, 49, 50, 51, 52, 53, 54, 55
+  };
+
+HIDDEN void
+tdep_init (void)
+{
+  intrmask_t saved_mask;
+
+  sigfillset (&unwi_full_mask);
+
+  lock_acquire (&tilegx_lock, saved_mask);
+
+  if (tdep_init_done)
+    /* another thread else beat us to it... */
+    goto out;
+
+  mi_init ();
+  dwarf_init ();
+
+#ifndef UNW_REMOTE_ONLY
+  tilegx_local_addr_space_init ();
+#endif
+  tdep_init_done = 1;  /* signal that we're initialized... */
+
+ out:
+  lock_release (&tilegx_lock, saved_mask);
+}
diff --git a/src/tilegx/Ginit.c b/src/tilegx/Ginit.c
new file mode 100644
index 0000000..7564a55
--- /dev/null
+++ b/src/tilegx/Ginit.c
@@ -0,0 +1,167 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "unwind_i.h"
+
+#ifdef UNW_REMOTE_ONLY
+
+/* unw_local_addr_space is a NULL pointer in this case.  */
+unw_addr_space_t unw_local_addr_space;
+
+#else /* !UNW_REMOTE_ONLY */
+
+static struct unw_addr_space local_addr_space;
+
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
+
+/* Return the address of the 64-bit slot in UC for REG (even for o32,
+   where registers are 32-bit, the slots are still 64-bit).  */
+
+static inline void *
+uc_addr (ucontext_t *uc, int reg)
+{
+  if (reg >= UNW_TILEGX_R0 && reg < UNW_TILEGX_R0 + 56)
+    return &uc->uc_mcontext.gregs[reg - UNW_TILEGX_R0];
+  else if (reg == UNW_TILEGX_PC)
+    return &uc->uc_mcontext.pc;
+  else
+    return NULL;
+}
+
+# ifdef UNW_LOCAL_ONLY
+
+HIDDEN void *
+tdep_uc_addr (ucontext_t *uc, int reg)
+{
+  char *addr = uc_addr (uc, reg);
+  return addr;
+}
+
+# endif /* UNW_LOCAL_ONLY */
+
+HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
+
+/* XXX fix me: there is currently no way to locate the dyn-info list
+       by a remote unwinder.  On ia64, this is done via a special
+       unwind-table entry.  Perhaps something similar can be done with
+       DWARF2 unwind info.  */
+
+static void
+put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
+{
+  /* it's a no-op */
+}
+
+static int
+get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
+                        void *arg)
+{
+  *dyn_info_list_addr = (unw_word_t) (intptr_t) &_U_dyn_info_list;
+  return 0;
+}
+
+static int
+access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
+            void *arg)
+{
+  if ((long long)addr & (sizeof(unw_word_t) - 1))
+    return 0;
+
+  if (write)
+    {
+      Debug (16, "mem[%llx] <- %llx\n", (long long) addr, (long long) *val);
+      *(unw_word_t *) (intptr_t) addr = *val;
+    }
+  else
+    {
+      *val = *(unw_word_t *) (intptr_t) addr;
+      Debug (16, "mem[%llx] -> %llx\n", (long long) addr, (long long) *val);
+    }
+  return 0;
+}
+
+static int
+access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
+            void *arg)
+{
+  unw_word_t *addr;
+  ucontext_t *uc = arg;
+
+  if (unw_is_fpreg (reg))
+    goto badreg;
+
+  Debug (16, "reg = %s\n", unw_regname (reg));
+  if (!(addr = uc_addr (uc, reg)))
+    goto badreg;
+
+  if (write)
+    {
+      *(unw_word_t *) (intptr_t) addr = (tilegx_reg_t) *val;
+      Debug (12, "%s <- %llx\n", unw_regname (reg), (long long) *val);
+    }
+  else
+    {
+      *val = (tilegx_reg_t) *(unw_word_t *) (intptr_t) addr;
+      Debug (12, "%s -> %llx\n", unw_regname (reg), (long long) *val);
+    }
+  return 0;
+
+ badreg:
+  Debug (1, "bad register number %u\n", reg);
+  return -UNW_EBADREG;
+}
+
+static int
+get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
+{
+  return elf_w (get_proc_name) (as, getpid (), ip, buf, buf_len, offp);
+}
+
+__attribute__((weak)) void
+tilegx_local_addr_space_init (void)
+{
+  memset (&local_addr_space, 0, sizeof (local_addr_space));
+  local_addr_space.big_endian = (__BYTE_ORDER == __BIG_ENDIAN);
+
+  local_addr_space.abi = UNW_TILEGX_ABI_N64;
+  local_addr_space.addr_size = sizeof (void *);
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
+  local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
+  local_addr_space.acc.put_unwind_info = put_unwind_info;
+  local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
+  local_addr_space.acc.access_mem = access_mem;
+  local_addr_space.acc.access_reg = access_reg;
+  local_addr_space.acc.access_fpreg = NULL;
+  local_addr_space.acc.resume = tilegx_local_resume;
+  local_addr_space.acc.get_proc_name = get_static_proc_name;
+  unw_flush_cache (&local_addr_space, 0, 0);
+}
+
+#endif /* !UNW_REMOTE_ONLY */
diff --git a/src/tilegx/Ginit_local.c b/src/tilegx/Ginit_local.c
new file mode 100644
index 0000000..31a716d
--- /dev/null
+++ b/src/tilegx/Ginit_local.c
@@ -0,0 +1,80 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "init.h"
+
+#ifdef UNW_REMOTE_ONLY
+
+int
+unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return -UNW_EINVAL;
+}
+
+#else /* !UNW_REMOTE_ONLY */
+
+static int
+unw_init_local_common(unw_cursor_t *cursor, ucontext_t *uc, unsigned use_prev_instr)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  if (!tdep_init_done)
+    tdep_init ();
+
+  memset(c, 0, sizeof(unw_cursor_t));
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  c->dwarf.as = unw_local_addr_space;
+
+  c->dwarf.as_arg = uc;
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
+}
+
+#endif /* !UNW_REMOTE_ONLY */
diff --git a/src/tilegx/Ginit_remote.c b/src/tilegx/Ginit_remote.c
new file mode 100644
index 0000000..2a31b18
--- /dev/null
+++ b/src/tilegx/Ginit_remote.c
@@ -0,0 +1,47 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "init.h"
+#include "unwind_i.h"
+
+int
+unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
+{
+#ifdef UNW_LOCAL_ONLY
+  return -UNW_EINVAL;
+#else /* !UNW_LOCAL_ONLY */
+  struct cursor *c = (struct cursor *) cursor;
+
+  if (!tdep_init_done)
+    tdep_init ();
+
+  Debug (1, "(cursor=%p)\n", c);
+
+  c->dwarf.as = as;
+  c->dwarf.as_arg = as_arg;
+
+  return common_init (c, 0);
+#endif /* !UNW_LOCAL_ONLY */
+}
diff --git a/src/tilegx/Gis_signal_frame.c b/src/tilegx/Gis_signal_frame.c
new file mode 100644
index 0000000..5452c2c
--- /dev/null
+++ b/src/tilegx/Gis_signal_frame.c
@@ -0,0 +1,115 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include <stdio.h>
+#include "offsets.h"
+
+#ifdef __linux__
+#include <sys/syscall.h>
+#include <arch/abi.h>
+#else
+# error "Only support Linux!"
+#endif
+
+#define  MOVELI_R10_RT_SIGRETURN                         \
+  ( 0x000007e051483000ULL    |                           \
+    ((unsigned long)__NR_rt_sigreturn << 43) |           \
+    ((unsigned long)TREG_SYSCALL_NR << 31) )
+#define  SWINT1      0x286b180051485000ULL
+
+int
+unw_is_signal_frame (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor*) cursor;
+  unw_word_t w0, w1, ip;
+  unw_addr_space_t as;
+  unw_accessors_t *a;
+  void *arg;
+  int ret;
+
+  as = c->dwarf.as;
+  a = unw_get_accessors_int (as);
+  arg = c->dwarf.as_arg;
+
+  ip = c->dwarf.ip;
+
+  if (!ip || !a->access_mem || (ip & (sizeof(unw_word_t) - 1)))
+    return 0;
+
+  if ((ret = (*a->access_mem) (as, ip, &w0, 0, arg)) < 0)
+    return ret;
+
+  if ((ret = (*a->access_mem) (as, ip + 8, &w1, 0, arg)) < 0)
+    return ret;
+
+  /* Return 1 if the IP points to a RT sigreturn sequence. */
+  if (w0 == MOVELI_R10_RT_SIGRETURN &&
+      w1 ==  SWINT1)
+    {
+      return 1;
+    }
+  return 0;
+}
+
+
+HIDDEN int
+tilegx_handle_signal_frame (unw_cursor_t *cursor)
+{
+  int i;
+  struct cursor *c = (struct cursor *) cursor;
+  unw_word_t sc_addr, sp, sp_addr = c->dwarf.cfa;
+  struct dwarf_loc sp_loc = DWARF_LOC (sp_addr, 0);
+  int ret;
+
+  if ((ret = dwarf_get (&c->dwarf, sp_loc, &sp)) < 0)
+    return -UNW_EUNSPEC;
+
+  /* Save the SP and PC to be able to return execution at this point
+     later in time (unw_resume).  */
+  c->sigcontext_sp = c->dwarf.cfa;
+  c->sigcontext_pc = c->dwarf.ip;
+
+  c->sigcontext_addr = sp_addr + sizeof (siginfo_t) +
+    C_ABI_SAVE_AREA_SIZE;
+  sc_addr = c->sigcontext_addr + LINUX_UC_MCONTEXT_OFF;
+
+  /* Update the dwarf cursor.
+     Set the location of the registers to the corresponding addresses of the
+     uc_mcontext / sigcontext structure contents.  */
+
+#define  SC_REG_OFFSET(X)   (8 * X)
+
+  for (i = UNW_TILEGX_R0; i <= UNW_TILEGX_R55; i++)
+    {
+      c->dwarf.loc[i] = DWARF_LOC (sc_addr + SC_REG_OFFSET(i), 0);
+    }
+
+  /* Set SP/CFA and PC/IP.  */
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_TILEGX_R54], &c->dwarf.cfa);
+  dwarf_get (&c->dwarf, c->dwarf.loc[UNW_TILEGX_R55], &c->dwarf.ip);
+
+  return 1;
+}
diff --git a/src/tilegx/Greg_states_iterate.c b/src/tilegx/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/tilegx/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/tilegx/Gregs.c b/src/tilegx/Gregs.c
new file mode 100644
index 0000000..565c6f4
--- /dev/null
+++ b/src/tilegx/Gregs.c
@@ -0,0 +1,76 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+HIDDEN int
+tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
+                 int write)
+{
+  dwarf_loc_t loc = DWARF_NULL_LOC;
+  
+  if (reg == UNW_TILEGX_R54 && !write)
+    {
+      reg = UNW_TILEGX_CFA;
+    }
+  
+  if (reg <= UNW_TILEGX_R55)
+    loc = c->dwarf.loc[reg - UNW_TILEGX_R0];
+  else if (reg == UNW_TILEGX_CFA)
+    {
+      if (write)
+        return -UNW_EREADONLYREG;
+      *valp = c->dwarf.cfa;
+      return 0;
+    }
+  else
+    {
+      Debug (1, "bad register number %u\n", reg);
+      return -UNW_EBADREG;
+    }
+  
+  if (write)
+    {
+      if (ci->dwarf.use_prev_instr == 0) {
+	if (reg == UNW_TILEGX_PC)
+	  c->dwarf.ip = *valp;            /* update the IP cache */
+       }
+      else {
+	if (reg == UNW_TILEGX_R55)
+	  c->dwarf.ip = *valp;            /* update the IP cache */
+      }
+      return dwarf_put (&c->dwarf, loc, *valp);
+    }
+  else
+    return dwarf_get (&c->dwarf, loc, valp);
+}
+
+HIDDEN int
+tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
+                   int write)
+{
+  Debug (1, "bad register number %u\n", reg);
+  return -UNW_EBADREG;
+}
diff --git a/src/tilegx/Gresume.c b/src/tilegx/Gresume.c
new file mode 100644
index 0000000..ece443a
--- /dev/null
+++ b/src/tilegx/Gresume.c
@@ -0,0 +1,94 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+
+#include "unwind_i.h"
+#include "offsets.h"
+#include <ucontext.h>
+
+#ifndef UNW_REMOTE_ONLY
+
+HIDDEN inline int
+tilegx_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
+{
+  int i;
+  struct cursor *c = (struct cursor *) cursor;
+  ucontext_t *uc = c->dwarf.as_arg;
+
+  Debug (1, "(cursor=%p\n", c);
+
+  return setcontext(uc);
+}
+
+#endif /* !UNW_REMOTE_ONLY */
+
+static inline void
+establish_machine_state (struct cursor *c)
+{
+  unw_addr_space_t as = c->dwarf.as;
+  void *arg = c->dwarf.as_arg;
+  unw_fpreg_t fpval;
+  unw_word_t val;
+  int reg;
+
+  Debug (8, "copying out cursor state\n");
+
+  for (reg = 0; reg <= UNW_REG_LAST; ++reg)
+    {
+      Debug (16, "copying %s %d\n", unw_regname (reg), reg);
+
+      if (unw_is_fpreg (reg))
+        {
+          Debug (1, "no fp!");
+          abort ();
+        }
+      else
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            as->acc.access_reg (as, reg, &val, 1, arg);
+        }
+    }
+}
+
+int
+unw_resume (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  Debug (1, "(cursor=%p) ip=0x%lx\n", c, c->dwarf.ip);
+
+  if (!c->dwarf.ip)
+    {
+      /* This can happen easily when the frame-chain gets truncated
+         due to bad or missing unwind-info.  */
+      Debug (1, "refusing to resume execution at address 0\n");
+      return -UNW_EINVAL;
+    }
+
+  establish_machine_state (c);
+
+  return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
+                                     c->dwarf.as_arg);
+}
diff --git a/src/tilegx/Gstep.c b/src/tilegx/Gstep.c
new file mode 100644
index 0000000..c748dbc
--- /dev/null
+++ b/src/tilegx/Gstep.c
@@ -0,0 +1,53 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+#include "offsets.h"
+
+int
+unw_step (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  int ret;
+
+  Debug (1, "(cursor=%p, ip=0x%016lx, sp=0x%016lx)\n",
+         c, c->dwarf.ip, c->dwarf.cfa);
+
+  /* Special handling the singal frame. */
+  if (unw_is_signal_frame (cursor) > 0)
+    return tilegx_handle_signal_frame (cursor);
+
+  /* Try DWARF-based unwinding... */
+  ret = dwarf_step (&c->dwarf);
+
+  if (unlikely (ret == -UNW_ESTOPUNWIND))
+    return ret;
+
+  /* Dwarf unwinding didn't work, stop.  */
+  if (unlikely (ret < 0))
+    return 0;
+
+  return (c->dwarf.ip == 0) ? 0 : 1;
+}
diff --git a/src/tilegx/Lapply_reg_state.c b/src/tilegx/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/tilegx/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/tilegx/Lcreate_addr_space.c b/src/tilegx/Lcreate_addr_space.c
new file mode 100644
index 0000000..0f2dc6b
--- /dev/null
+++ b/src/tilegx/Lcreate_addr_space.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gcreate_addr_space.c"
+#endif
diff --git a/src/tilegx/Lget_proc_info.c b/src/tilegx/Lget_proc_info.c
new file mode 100644
index 0000000..69028b0
--- /dev/null
+++ b/src/tilegx/Lget_proc_info.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gget_proc_info.c"
+#endif
diff --git a/src/tilegx/Lget_save_loc.c b/src/tilegx/Lget_save_loc.c
new file mode 100644
index 0000000..9ea048a
--- /dev/null
+++ b/src/tilegx/Lget_save_loc.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gget_save_loc.c"
+#endif
diff --git a/src/tilegx/Lglobal.c b/src/tilegx/Lglobal.c
new file mode 100644
index 0000000..6d7b489
--- /dev/null
+++ b/src/tilegx/Lglobal.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gglobal.c"
+#endif
diff --git a/src/tilegx/Linit.c b/src/tilegx/Linit.c
new file mode 100644
index 0000000..e9abfdd
--- /dev/null
+++ b/src/tilegx/Linit.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit.c"
+#endif
diff --git a/src/tilegx/Linit_local.c b/src/tilegx/Linit_local.c
new file mode 100644
index 0000000..68a1687
--- /dev/null
+++ b/src/tilegx/Linit_local.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit_local.c"
+#endif
diff --git a/src/tilegx/Linit_remote.c b/src/tilegx/Linit_remote.c
new file mode 100644
index 0000000..58cb04a
--- /dev/null
+++ b/src/tilegx/Linit_remote.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Ginit_remote.c"
+#endif
diff --git a/src/tilegx/Lis_signal_frame.c b/src/tilegx/Lis_signal_frame.c
new file mode 100644
index 0000000..b9a7c4f
--- /dev/null
+++ b/src/tilegx/Lis_signal_frame.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gis_signal_frame.c"
+#endif
diff --git a/src/tilegx/Lreg_states_iterate.c b/src/tilegx/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/tilegx/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/tilegx/Lregs.c b/src/tilegx/Lregs.c
new file mode 100644
index 0000000..2c9c75c
--- /dev/null
+++ b/src/tilegx/Lregs.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gregs.c"
+#endif
diff --git a/src/tilegx/Lresume.c b/src/tilegx/Lresume.c
new file mode 100644
index 0000000..41a8cf0
--- /dev/null
+++ b/src/tilegx/Lresume.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gresume.c"
+#endif
diff --git a/src/tilegx/Lstep.c b/src/tilegx/Lstep.c
new file mode 100644
index 0000000..c1ac3c7
--- /dev/null
+++ b/src/tilegx/Lstep.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gstep.c"
+#endif
diff --git a/src/tilegx/getcontext.S b/src/tilegx/getcontext.S
new file mode 100644
index 0000000..fbc8654
--- /dev/null
+++ b/src/tilegx/getcontext.S
@@ -0,0 +1,36 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+        
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "offsets.h"
+#include <endian.h>
+
+        .text
+        # define REG(X)    LINUX_UC_MCONTEXT_GREGS + 8 * (X)
+        .global _Utilegx_getcontext
+        .type   _Utilegx_getcontext, %function
+        # This is a stub version of getcontext() for TILEGX.
+_Utilegx_getcontext:
+
+
diff --git a/src/tilegx/init.h b/src/tilegx/init.h
new file mode 100644
index 0000000..0e0f7fd
--- /dev/null
+++ b/src/tilegx/init.h
@@ -0,0 +1,63 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+static inline int
+common_init (struct cursor *c, unsigned use_prev_instr)
+{
+  int ret, i;
+
+  for (i = 0; i < 56; i++)
+    c->dwarf.loc[i] = DWARF_REG_LOC (&c->dwarf, UNW_TILEGX_R0 + i);
+  for (i = 56; i < DWARF_NUM_PRESERVED_REGS; ++i)
+    c->dwarf.loc[i] = DWARF_NULL_LOC;
+
+  if (use_prev_instr == 0)
+    ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_TILEGX_PC),
+                     &c->dwarf.ip);
+  else
+    ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_TILEGX_R55),
+                     &c->dwarf.ip);
+
+  if (ret < 0)
+    return ret;
+
+  ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_TILEGX_R54),
+                   &c->dwarf.cfa);
+
+  if (ret < 0)
+    return ret;
+
+  c->dwarf.args_size = 0;
+  c->dwarf.stash_frames = 0;
+  c->dwarf.use_prev_instr = use_prev_instr;
+  c->dwarf.pi_valid = 0;
+  c->dwarf.pi_is_dynamic = 0;
+  c->dwarf.hint = 0;
+  c->dwarf.prev_rs = 0;
+
+  return 0;
+}
diff --git a/src/tilegx/is_fpreg.c b/src/tilegx/is_fpreg.c
new file mode 100644
index 0000000..d6d5896
--- /dev/null
+++ b/src/tilegx/is_fpreg.c
@@ -0,0 +1,33 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "libunwind_i.h"
+
+/* TILEGX has no FP. */
+
+int
+unw_is_fpreg (int regnum)
+{
+  return 0;
+}
diff --git a/src/tilegx/offsets.h b/src/tilegx/offsets.h
new file mode 100644
index 0000000..6d30f1e
--- /dev/null
+++ b/src/tilegx/offsets.h
@@ -0,0 +1,12 @@
+/* Linux-specific definitions: */
+
+/* Define various structure offsets to simplify cross-compilation.  */
+
+/* Offsets for TILEGX Linux "ucontext_t":  */
+
+#define LINUX_UC_FLAGS_OFF      0x0
+#define LINUX_UC_LINK_OFF       0x8
+#define LINUX_UC_STACK_OFF      0x10
+#define LINUX_UC_MCONTEXT_OFF   0x28
+#define LINUX_UC_SIGMASK_OFF    0x228
+#define LINUX_UC_MCONTEXT_GREGS 0x28
diff --git a/src/tilegx/regname.c b/src/tilegx/regname.c
new file mode 100644
index 0000000..0ce47b9
--- /dev/null
+++ b/src/tilegx/regname.c
@@ -0,0 +1,55 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+   Copyright (C) 2014 Tilera Corp.
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+static const char *regname[] =
+  {
+    /* 0.  */
+    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
+    /* 8.  */
+    "r8",  "r9",  "r10", "r11",  "r12",  "r13",  "r14",  "r15",
+    /* 16.  */
+    "r16",  "r17",  "r18", "r19",  "r20",  "r21",  "r22",  "r23",
+    /* 24.  */
+    "r24",  "r25",  "r26", "r27",  "r28",  "r29",  "r30",  "r31",
+    /* 32.  */
+    "r32",  "r33",  "r34", "r35",  "r36",  "r37",  "r38",  "r39",
+    /* 40.  */
+    "r40",  "r41",  "r42", "r43",  "r44",  "r45",  "r46",  "r47",
+    /* 48.  */
+    "r48",  "r49",  "r50", "r51",  "r52",  "r53",  "r54",  "r55",
+    /* pc, cfa */
+    "pc",  "cfa"
+  };
+
+const char *
+unw_regname (unw_regnum_t reg)
+{
+  if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
+    return regname[reg];
+  else
+    return "???";
+}
diff --git a/src/tilegx/siglongjmp.S b/src/tilegx/siglongjmp.S
new file mode 100644
index 0000000..bccb1c7
--- /dev/null
+++ b/src/tilegx/siglongjmp.S
@@ -0,0 +1,7 @@
+        /* Dummy implementation for now.  */
+        .globl _UI_siglongjmp_cont
+        .globl _UI_longjmp_cont
+
+_UI_siglongjmp_cont:
+_UI_longjmp_cont:
+        jrp      lr
diff --git a/src/tilegx/unwind_i.h b/src/tilegx/unwind_i.h
new file mode 100644
index 0000000..9d41c90
--- /dev/null
+++ b/src/tilegx/unwind_i.h
@@ -0,0 +1,46 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 CodeSourcery
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef unwind_i_h
+#define unwind_i_h
+
+#include <memory.h>
+#include <stdint.h>
+
+#include <libunwind-tilegx.h>
+
+#include "libunwind_i.h"
+
+#define tilegx_local_resume            UNW_OBJ(local_resume)
+#define tilegx_local_addr_space_init   UNW_OBJ(local_addr_space_init)
+
+extern int tilegx_local_resume (unw_addr_space_t as,
+                                unw_cursor_t *cursor,
+                                void *arg);
+#define tilegx_handle_signal_frame UNW_OBJ(handle_signal_frame)
+extern int tilegx_handle_signal_frame(unw_cursor_t *cursor);
+
+extern void tilegx_local_addr_space_init (void);
+
+#endif /* unwind_i_h */
diff --git a/src/unwind/Backtrace.c b/src/unwind/Backtrace.c
index 99c20fc..0b14df4 100644
--- a/src/unwind/Backtrace.c
+++ b/src/unwind/Backtrace.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED _Unwind_Reason_Code
+_Unwind_Reason_Code
 _Unwind_Backtrace (_Unwind_Trace_Fn trace, void *trace_parameter)
 {
   struct _Unwind_Context context;
@@ -40,15 +40,15 @@ _Unwind_Backtrace (_Unwind_Trace_Fn trace, void *trace_parameter)
   while (1)
     {
       if ((ret = unw_step (&context.cursor)) <= 0)
-	{
-	  if (ret == 0)
-	    return _URC_END_OF_STACK;
-	  else
-	    return _URC_FATAL_PHASE1_ERROR;
-	}
+        {
+          if (ret == 0)
+            return _URC_END_OF_STACK;
+          else
+            return _URC_FATAL_PHASE1_ERROR;
+        }
 
       if ((*trace) (&context, trace_parameter) != _URC_NO_REASON)
-	return _URC_FATAL_PHASE1_ERROR;
+        return _URC_FATAL_PHASE1_ERROR;
     }
 }
 
diff --git a/src/unwind/DeleteException.c b/src/unwind/DeleteException.c
index 5104b73..ad38eaf 100644
--- a/src/unwind/DeleteException.c
+++ b/src/unwind/DeleteException.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED void
+void
 _Unwind_DeleteException (struct _Unwind_Exception *exception_object)
 {
   _Unwind_Exception_Cleanup_Fn cleanup = exception_object->exception_cleanup;
diff --git a/src/unwind/FindEnclosingFunction.c b/src/unwind/FindEnclosingFunction.c
index e639894..4f10666 100644
--- a/src/unwind/FindEnclosingFunction.c
+++ b/src/unwind/FindEnclosingFunction.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,13 +25,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED void *
+void *
 _Unwind_FindEnclosingFunction (void *ip)
 {
   unw_proc_info_t pi;
 
   if (unw_get_proc_info_by_ip (unw_local_addr_space,
-			       (unw_word_t) (uintptr_t) ip, &pi, 0)
+                               (unw_word_t) (uintptr_t) ip, &pi, 0)
       < 0)
     return NULL;
 
diff --git a/src/unwind/ForcedUnwind.c b/src/unwind/ForcedUnwind.c
index bd334d3..905b31c 100644
--- a/src/unwind/ForcedUnwind.c
+++ b/src/unwind/ForcedUnwind.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,9 +25,9 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED _Unwind_Reason_Code
+_Unwind_Reason_Code
 _Unwind_ForcedUnwind (struct _Unwind_Exception *exception_object,
-		      _Unwind_Stop_Fn stop, void *stop_parameter)
+                      _Unwind_Stop_Fn stop, void *stop_parameter)
 {
   struct _Unwind_Context context;
   unw_context_t uc;
@@ -48,5 +48,5 @@ _Unwind_ForcedUnwind (struct _Unwind_Exception *exception_object,
 }
 
 _Unwind_Reason_Code __libunwind_Unwind_ForcedUnwind (struct _Unwind_Exception*,
-						     _Unwind_Stop_Fn, void *)
+                                                     _Unwind_Stop_Fn, void *)
      ALIAS (_Unwind_ForcedUnwind);
diff --git a/src/unwind/GetBSP.c b/src/unwind/GetBSP.c
index d53e401..d1bc84e 100644
--- a/src/unwind/GetBSP.c
+++ b/src/unwind/GetBSP.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetBSP (struct _Unwind_Context *context)
 {
 #ifdef UNW_TARGET_IA64
diff --git a/src/unwind/GetCFA.c b/src/unwind/GetCFA.c
index bd8559b..5ca6390 100644
--- a/src/unwind/GetCFA.c
+++ b/src/unwind/GetCFA.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetCFA (struct _Unwind_Context *context)
 {
   unw_word_t val;
diff --git a/src/unwind/GetDataRelBase.c b/src/unwind/GetDataRelBase.c
index cb60476..8e6914f 100644
--- a/src/unwind/GetDataRelBase.c
+++ b/src/unwind/GetDataRelBase.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetDataRelBase (struct _Unwind_Context *context)
 {
   unw_proc_info_t pi;
diff --git a/src/unwind/GetGR.c b/src/unwind/GetGR.c
index 3a875e8..fa70943 100644
--- a/src/unwind/GetGR.c
+++ b/src/unwind/GetGR.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetGR (struct _Unwind_Context *context, int index)
 {
   unw_word_t val;
diff --git a/src/unwind/GetIP.c b/src/unwind/GetIP.c
index 6fd48a2..e9fc494 100644
--- a/src/unwind/GetIP.c
+++ b/src/unwind/GetIP.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetIP (struct _Unwind_Context *context)
 {
   unw_word_t val;
diff --git a/src/unwind/GetIPInfo.c b/src/unwind/GetIPInfo.c
index b885ede..e8ee7fd 100644
--- a/src/unwind/GetIPInfo.c
+++ b/src/unwind/GetIPInfo.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2009 Red Hat
-	Contributed by Jan Kratochvil <jan.kratochvil@redhat.com>
+        Contributed by Jan Kratochvil <jan.kratochvil@redhat.com>
 
 This file is part of libunwind.
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 /* gcc/unwind-dw2.c: Retrieve the return address and flag whether that IP is
    before or after first not yet fully executed instruction.  */
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)
 {
   unw_word_t val;
diff --git a/src/unwind/GetLanguageSpecificData.c b/src/unwind/GetLanguageSpecificData.c
index eefcec7..e7ca9b4 100644
--- a/src/unwind/GetLanguageSpecificData.c
+++ b/src/unwind/GetLanguageSpecificData.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)
 {
   unw_proc_info_t pi;
diff --git a/src/unwind/GetRegionStart.c b/src/unwind/GetRegionStart.c
index 11c3460..f499581 100644
--- a/src/unwind/GetRegionStart.c
+++ b/src/unwind/GetRegionStart.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetRegionStart (struct _Unwind_Context *context)
 {
   unw_proc_info_t pi;
diff --git a/src/unwind/GetTextRelBase.c b/src/unwind/GetTextRelBase.c
index a53ca9b..ce65ae9 100644
--- a/src/unwind/GetTextRelBase.c
+++ b/src/unwind/GetTextRelBase.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED unsigned long
+unsigned long
 _Unwind_GetTextRelBase (struct _Unwind_Context *context)
 {
   return 0;
diff --git a/src/unwind/RaiseException.c b/src/unwind/RaiseException.c
index 66a681d..3c3ca19 100644
--- a/src/unwind/RaiseException.c
+++ b/src/unwind/RaiseException.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED _Unwind_Reason_Code
+_Unwind_Reason_Code
 _Unwind_RaiseException (struct _Unwind_Exception *exception_object)
 {
   uint64_t exception_class = exception_object->exception_class;
@@ -47,36 +47,36 @@ _Unwind_RaiseException (struct _Unwind_Exception *exception_object)
   while (1)
     {
       if ((ret = unw_step (&context.cursor)) <= 0)
-	{
-	  if (ret == 0)
-	    {
-	      Debug (1, "no handler found\n");
-	      return _URC_END_OF_STACK;
-	    }
-	  else
-	    return _URC_FATAL_PHASE1_ERROR;
-	}
+        {
+          if (ret == 0)
+            {
+              Debug (1, "no handler found\n");
+              return _URC_END_OF_STACK;
+            }
+          else
+            return _URC_FATAL_PHASE1_ERROR;
+        }
 
       if (unw_get_proc_info (&context.cursor, &pi) < 0)
-	return _URC_FATAL_PHASE1_ERROR;
+        return _URC_FATAL_PHASE1_ERROR;
 
       personality = (_Unwind_Personality_Fn) (uintptr_t) pi.handler;
       if (personality)
-	{
-	  reason = (*personality) (_U_VERSION, _UA_SEARCH_PHASE,
-				   exception_class, exception_object,
-				   &context);
-	  if (reason != _URC_CONTINUE_UNWIND)
-	    {
-	      if (reason == _URC_HANDLER_FOUND)
-		break;
-	      else
-		{
-		  Debug (1, "personality returned %d\n", reason);
-		  return _URC_FATAL_PHASE1_ERROR;
-		}
-	    }
-	}
+        {
+          reason = (*personality) (_U_VERSION, _UA_SEARCH_PHASE,
+                                   exception_class, exception_object,
+                                   &context);
+          if (reason != _URC_CONTINUE_UNWIND)
+            {
+              if (reason == _URC_HANDLER_FOUND)
+                break;
+              else
+                {
+                  Debug (1, "personality returned %d\n", reason);
+                  return _URC_FATAL_PHASE1_ERROR;
+                }
+            }
+        }
     }
 
   /* Exceptions are associated with IP-ranges.  If a given exception
@@ -86,8 +86,8 @@ _Unwind_RaiseException (struct _Unwind_Exception *exception_object)
      the exception.  */
   if (unw_get_reg (&context.cursor, UNW_REG_IP, &ip) < 0)
     return _URC_FATAL_PHASE1_ERROR;
-  exception_object->private_1 = 0;	/* clear "stop" pointer */
-  exception_object->private_2 = ip;	/* save frame marker */
+  exception_object->private_1 = 0;      /* clear "stop" pointer */
+  exception_object->private_2 = ip;     /* save frame marker */
 
   Debug (1, "found handler for IP=%lx; entering cleanup phase\n", (long) ip);
 
diff --git a/src/unwind/Resume.c b/src/unwind/Resume.c
index ddf9d2c..e23d6be 100644
--- a/src/unwind/Resume.c
+++ b/src/unwind/Resume.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED void
+void
 _Unwind_Resume (struct _Unwind_Exception *exception_object)
 {
   struct _Unwind_Context context;
diff --git a/src/unwind/Resume_or_Rethrow.c b/src/unwind/Resume_or_Rethrow.c
index ece0ced..9c76443 100644
--- a/src/unwind/Resume_or_Rethrow.c
+++ b/src/unwind/Resume_or_Rethrow.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED _Unwind_Reason_Code
+_Unwind_Reason_Code
 _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exception_object)
 {
   struct _Unwind_Context context;
@@ -34,7 +34,7 @@ _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exception_object)
   if (exception_object->private_1)
     {
       if (_Unwind_InitContext (&context, &uc) < 0)
-	return _URC_FATAL_PHASE2_ERROR;
+        return _URC_FATAL_PHASE2_ERROR;
 
       return _Unwind_Phase2 (exception_object, &context);
     }
diff --git a/src/unwind/SetGR.c b/src/unwind/SetGR.c
index 9653364..ae77a8e 100644
--- a/src/unwind/SetGR.c
+++ b/src/unwind/SetGR.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -28,9 +28,9 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "dwarf_i.h"
 #endif
 
-PROTECTED void
+void
 _Unwind_SetGR (struct _Unwind_Context *context, int index,
-	       unsigned long new_value)
+               unsigned long new_value)
 {
 #ifdef UNW_TARGET_X86
   index = dwarf_to_unw_regnum(index);
diff --git a/src/unwind/SetIP.c b/src/unwind/SetIP.c
index 0652a14..fccc2f0 100644
--- a/src/unwind/SetIP.c
+++ b/src/unwind/SetIP.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind-internal.h"
 
-PROTECTED void
+void
 _Unwind_SetIP (struct _Unwind_Context *context, unsigned long new_value)
 {
   unw_set_reg (&context->cursor, UNW_REG_IP, new_value);
diff --git a/src/unwind/libunwind.pc.in b/src/unwind/libunwind.pc.in
index c2799ea..1505c5d 100644
--- a/src/unwind/libunwind.pc.in
+++ b/src/unwind/libunwind.pc.in
@@ -7,3 +7,5 @@ Name: libunwind
 Description: libunwind base library
 Version: @VERSION@
 Libs: -L${libdir} -lunwind
+Libs.private: @LIBLZMA@
+Cflags: -I${includedir}
diff --git a/src/unwind/unwind-internal.h b/src/unwind/unwind-internal.h
index 130cb81..c68fc3c 100644
--- a/src/unwind/unwind-internal.h
+++ b/src/unwind/unwind-internal.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -35,28 +35,28 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "libunwind_i.h"
 
 /* The version of the _Unwind_*() interface implemented by this code.  */
-#define _U_VERSION	1
+#define _U_VERSION      1
 
 typedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)
-	(int, _Unwind_Action, uint64_t, struct _Unwind_Exception *,
-	 struct _Unwind_Context *);
+        (int, _Unwind_Action, uint64_t, struct _Unwind_Exception *,
+         struct _Unwind_Context *);
 
 struct _Unwind_Context {
   unw_cursor_t cursor;
-  int end_of_stack;	/* set to 1 if the end of stack was reached */
+  int end_of_stack;     /* set to 1 if the end of stack was reached */
 };
 
 /* This must be a macro because unw_getcontext() must be invoked from
    the callee, even if optimization (and hence inlining) is turned
    off.  The macro arguments MUST NOT have any side-effects. */
-#define _Unwind_InitContext(context, uc)				     \
-  ((context)->end_of_stack = 0,						     \
+#define _Unwind_InitContext(context, uc)                                     \
+  ((context)->end_of_stack = 0,                                              \
    ((unw_getcontext (uc) < 0 || unw_init_local (&(context)->cursor, uc) < 0) \
     ? -1 : 0))
 
 static _Unwind_Reason_Code ALWAYS_INLINE
 _Unwind_Phase2 (struct _Unwind_Exception *exception_object,
-		struct _Unwind_Context *context)
+                struct _Unwind_Context *context)
 {
   _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) exception_object->private_1;
   uint64_t exception_class = exception_object->exception_class;
@@ -76,65 +76,65 @@ _Unwind_Phase2 (struct _Unwind_Exception *exception_object,
     {
       ret = unw_step (&context->cursor);
       if (ret <= 0)
-	{
-	  if (ret == 0)
-	    {
-	      actions |= _UA_END_OF_STACK;
-	      context->end_of_stack = 1;
-	    }
-	  else
-	    return _URC_FATAL_PHASE2_ERROR;
-	}
+        {
+          if (ret == 0)
+            {
+              actions |= _UA_END_OF_STACK;
+              context->end_of_stack = 1;
+            }
+          else
+            return _URC_FATAL_PHASE2_ERROR;
+        }
 
       if (stop)
-	{
-	  reason = (*stop) (_U_VERSION, actions, exception_class,
-			    exception_object, context, stop_parameter);
-	  if (reason != _URC_NO_REASON)
-	    /* Stop function may return _URC_FATAL_PHASE2_ERROR if
-	       it's unable to handle end-of-stack condition or
-	       _URC_FATAL_PHASE2_ERROR if something is wrong.  Not
-	       that it matters: the resulting state is indeterminate
-	       anyhow so we must return _URC_FATAL_PHASE2_ERROR... */
-	    return _URC_FATAL_PHASE2_ERROR;
-	}
+        {
+          reason = (*stop) (_U_VERSION, actions, exception_class,
+                            exception_object, context, stop_parameter);
+          if (reason != _URC_NO_REASON)
+            /* Stop function may return _URC_FATAL_PHASE2_ERROR if
+               it's unable to handle end-of-stack condition or
+               _URC_FATAL_PHASE2_ERROR if something is wrong.  Not
+               that it matters: the resulting state is indeterminate
+               anyhow so we must return _URC_FATAL_PHASE2_ERROR... */
+            return _URC_FATAL_PHASE2_ERROR;
+        }
 
       if (context->end_of_stack
-	  || unw_get_proc_info (&context->cursor, &pi) < 0)
-	return _URC_FATAL_PHASE2_ERROR;
+          || unw_get_proc_info (&context->cursor, &pi) < 0)
+        return _URC_FATAL_PHASE2_ERROR;
 
       personality = (_Unwind_Personality_Fn) (uintptr_t) pi.handler;
       if (personality)
-	{
-	  if (!stop)
-	    {
-	      if (unw_get_reg (&context->cursor, UNW_REG_IP, &ip) < 0)
-		return _URC_FATAL_PHASE2_ERROR;
-
-	      if ((unsigned long) stop_parameter == ip)
-		actions |= _UA_HANDLER_FRAME;
-	    }
-
-	  reason = (*personality) (_U_VERSION, actions, exception_class,
-				   exception_object, context);
-	  if (reason != _URC_CONTINUE_UNWIND)
-	    {
-	      if (reason == _URC_INSTALL_CONTEXT)
-		{
-		  /* we may regain control via _Unwind_Resume() */
-		  unw_resume (&context->cursor);
-		  abort ();
-		}
-	      else
-		return _URC_FATAL_PHASE2_ERROR;
-	    }
-	  if (actions & _UA_HANDLER_FRAME)
-	    /* The personality routine for the handler-frame changed
-	       it's mind; that's a no-no... */
-	    abort ();
-	}
+        {
+          if (!stop)
+            {
+              if (unw_get_reg (&context->cursor, UNW_REG_IP, &ip) < 0)
+                return _URC_FATAL_PHASE2_ERROR;
+
+              if ((unsigned long) stop_parameter == ip)
+                actions |= _UA_HANDLER_FRAME;
+            }
+
+          reason = (*personality) (_U_VERSION, actions, exception_class,
+                                   exception_object, context);
+          if (reason != _URC_CONTINUE_UNWIND)
+            {
+              if (reason == _URC_INSTALL_CONTEXT)
+                {
+                  /* we may regain control via _Unwind_Resume() */
+                  unw_resume (&context->cursor);
+                  abort ();
+                }
+              else
+                return _URC_FATAL_PHASE2_ERROR;
+            }
+          if (actions & _UA_HANDLER_FRAME)
+            /* The personality routine for the handler-frame changed
+               it's mind; that's a no-no... */
+            abort ();
+        }
     }
-  return _URC_FATAL_PHASE2_ERROR;	/* shouldn't be reached */
+  return _URC_FATAL_PHASE2_ERROR;       /* shouldn't be reached */
 }
 
 #endif /* unwind_internal_h */
diff --git a/src/x86/Gapply_reg_state.c b/src/x86/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/x86/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/x86/Gcreate_addr_space.c b/src/x86/Gcreate_addr_space.c
index 5b07940..a7e41a5 100644
--- a/src/x86/Gcreate_addr_space.c
+++ b/src/x86/Gcreate_addr_space.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -31,7 +31,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #define __LITTLE_ENDIAN _LITTLE_ENDIAN
 #endif
 
-PROTECTED unw_addr_space_t
+unw_addr_space_t
 unw_create_addr_space (unw_accessors_t *a, int byte_order)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/x86/Gget_proc_info.c b/src/x86/Gget_proc_info.c
index a533483..4dc2cff 100644
--- a/src/x86/Gget_proc_info.c
+++ b/src/x86/Gget_proc_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,7 +25,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -33,8 +33,8 @@ unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
   if (dwarf_make_proc_info (&c->dwarf) < 0)
     {
       /* On x86, it's relatively common to be missing DWARF unwind
-	 info.  We don't want to fail in that case, because the
-	 frame-chain still would let us do a backtrace at least.  */
+         info.  We don't want to fail in that case, because the
+         frame-chain still would let us do a backtrace at least.  */
       memset (pi, 0, sizeof (*pi));
       pi->start_ip = c->dwarf.ip;
       pi->end_ip = c->dwarf.ip + 1;
diff --git a/src/x86/Gget_save_loc.c b/src/x86/Gget_save_loc.c
index e8cc79e..e459382 100644
--- a/src/x86/Gget_save_loc.c
+++ b/src/x86/Gget_save_loc.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,13 +25,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   struct cursor *c = (struct cursor *) cursor;
   dwarf_loc_t loc;
 
-  loc = DWARF_NULL_LOC;		/* default to "not saved" */
+  loc = DWARF_NULL_LOC;         /* default to "not saved" */
 
   switch (reg)
     {
diff --git a/src/x86/Gglobal.c b/src/x86/Gglobal.c
index 033a788..132b824 100644
--- a/src/x86/Gglobal.c
+++ b/src/x86/Gglobal.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -60,7 +60,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     x86_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&x86_lock, saved_mask);
diff --git a/src/x86/Ginit.c b/src/x86/Ginit.c
index b8890a3..f6b8dc2 100644
--- a/src/x86/Ginit.c
+++ b/src/x86/Ginit.c
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
 This file is part of libunwind.
 
@@ -36,13 +36,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 # ifdef UNW_LOCAL_ONLY
 
@@ -69,14 +69,14 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
   return 0;
 }
 
 #define PAGE_SIZE 4096
-#define PAGE_START(a)	((a) & ~(PAGE_SIZE-1))
+#define PAGE_START(a)   ((a) & ~(PAGE_SIZE-1))
 
 /* Cache of already validated addresses */
 #define NLGA 4
@@ -105,7 +105,7 @@ validate_mem (unw_word_t addr)
   for (i = 0; i < NLGA; i++)
     {
       if (last_good_addr[i] && (addr == last_good_addr[i]))
-	return 0;
+        return 0;
     }
 
 #ifdef HAVE_MINCORE
@@ -134,7 +134,7 @@ validate_mem (unw_word_t addr)
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (write)
     {
@@ -155,7 +155,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   unw_word_t *addr;
   ucontext_t *uc = ((struct cursor *)arg)->uc;
@@ -185,7 +185,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = ((struct cursor *)arg)->uc;
   unw_fpreg_t *addr;
@@ -199,14 +199,14 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   if (write)
     {
       Debug (12, "%s <- %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
       *(unw_fpreg_t *) addr = *val;
     }
   else
     {
       *val = *(unw_fpreg_t *) addr;
       Debug (12, "%s -> %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
     }
   return 0;
 
@@ -218,8 +218,8 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf32_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -228,7 +228,7 @@ HIDDEN void
 x86_local_addr_space_init (void)
 {
   memset (&local_addr_space, 0, sizeof (local_addr_space));
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
diff --git a/src/x86/Ginit_local.c b/src/x86/Ginit_local.c
index 412663b..bff0687 100644
--- a/src/x86/Ginit_local.c
+++ b/src/x86/Ginit_local.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 {
   return -UNW_EINVAL;
@@ -36,8 +36,8 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 
 #else /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
-unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+static int
+unw_init_local_common(unw_cursor_t *cursor, ucontext_t *uc, unsigned use_prev_instr)
 {
   struct cursor *c = (struct cursor *) cursor;
 
@@ -50,7 +50,30 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
   c->dwarf.as_arg = c;
   c->uc = uc;
   c->validate = 0;
-  return common_init (c, 1);
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
 }
 
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/x86/Ginit_remote.c b/src/x86/Ginit_remote.c
index c889905..7c15096 100644
--- a/src/x86/Ginit_remote.c
+++ b/src/x86/Ginit_remote.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "init.h"
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/x86/Gos-freebsd.c b/src/x86/Gos-freebsd.c
index 247c35f..7dd0140 100644
--- a/src/x86/Gos-freebsd.c
+++ b/src/x86/Gos-freebsd.c
@@ -35,7 +35,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include "offsets.h"
 
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -46,26 +46,26 @@ unw_is_signal_frame (unw_cursor_t *cursor)
   int ret;
 
   as = c->dwarf.as;
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   arg = c->dwarf.as_arg;
 
   /* Check if EIP points at sigreturn() sequence.  It can be:
 sigcode+4: from amd64 freebsd32 environment
-8d 44 24 20		lea    0x20(%esp),%eax
-50			push   %eax
-b8 a1 01 00 00		mov    $0x1a1,%eax
-50			push   %eax
-cd 80			int    $0x80
+8d 44 24 20             lea    0x20(%esp),%eax
+50                      push   %eax
+b8 a1 01 00 00          mov    $0x1a1,%eax
+50                      push   %eax
+cd 80                   int    $0x80
 
 sigcode+4: from real i386
-8d 44 24 20		lea    0x20(%esp),%eax
-50			push   %eax
-f7 40 54 00 02 00	testl  $0x20000,0x54(%eax)
-75 03			jne    sigcode+21
-8e 68 14		mov    0x14(%eax),%gs
-b8 a1 01 00 00		mov    $0x1a1,%eax
-50			push   %eax
-cd 80			int    $0x80
+8d 44 24 20             lea    0x20(%esp),%eax
+50                      push   %eax
+f7 40 54 00 02 00       testl  $0x20000,0x54(%eax)
+75 03                   jne    sigcode+21
+8e 68 14                mov    0x14(%eax),%gs
+b8 a1 01 00 00          mov    $0x1a1,%eax
+50                      push   %eax
+cd 80                   int    $0x80
 
 freebsd4_sigcode+4:
 XXX
@@ -85,19 +85,24 @@ XXX
     ret = X86_SCF_FREEBSD_SIGFRAME;
   else {
     if ((*a->access_mem) (as, ip + 16, &w4, 0, arg) < 0 ||
-	(*a->access_mem) (as, ip + 20, &w5, 0, arg) < 0)
+        (*a->access_mem) (as, ip + 20, &w5, 0, arg) < 0)
       return ret;
     if (w0 == 0x2024448d && w1 == 0x5440f750 && w2 == 0x75000200 &&
-	w3 == 0x14688e03 && w4 == 0x0001a1b8 && w5 == 0x80cd5000)
+        w3 == 0x14688e03 && w4 == 0x0001a1b8 && w5 == 0x80cd5000)
       ret = X86_SCF_FREEBSD_SIGFRAME;
   }
+
+  /* Check for syscall */
+  if (ret == X86_SCF_NONE && (*a->access_mem) (as, ip - 2, &w0, 0, arg) >= 0 &&
+      (w0 & 0xffff) == 0x80cd)
+    ret = X86_SCF_FREEBSD_SYSCALL;
   Debug (16, "returning %d\n", ret);
   c->sigcontext_format = ret;
   return (ret);
 }
 
-PROTECTED int
-unw_handle_signal_frame (unw_cursor_t *cursor)
+HIDDEN int
+x86_handle_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
   int ret;
@@ -115,8 +120,8 @@ unw_handle_signal_frame (unw_cursor_t *cursor)
     ret = dwarf_get (&c->dwarf, esp_loc, &c->dwarf.cfa);
     if (ret < 0)
     {
-	    Debug (2, "returning 0\n");
-	    return 0;
+            Debug (2, "returning 0\n");
+            return 0;
     }
 
     c->dwarf.loc[EIP] = DWARF_LOC (uc_addr + FREEBSD_UC_MCONTEXT_EIP_OFF, 0);
@@ -131,6 +136,11 @@ unw_handle_signal_frame (unw_cursor_t *cursor)
     c->dwarf.loc[EFLAGS] = DWARF_LOC (uc_addr + FREEBSD_UC_MCONTEXT_EFLAGS_OFF, 0);
     c->dwarf.loc[TRAPNO] = DWARF_LOC (uc_addr + FREEBSD_UC_MCONTEXT_TRAPNO_OFF, 0);
     c->dwarf.loc[ST0] = DWARF_NULL_LOC;
+  } else if (c->sigcontext_format == X86_SCF_FREEBSD_SYSCALL) {
+    c->dwarf.loc[EIP] = DWARF_LOC (c->dwarf.cfa, 0);
+    c->dwarf.loc[EAX] = DWARF_NULL_LOC;
+    c->dwarf.cfa += 4;
+    c->dwarf.use_prev_instr = 1;
   } else {
     Debug (8, "Gstep: not handling frame format %d\n", c->sigcontext_format);
     abort();
@@ -280,20 +290,20 @@ x86_get_scratch_loc (struct cursor *c, unw_regnum_t reg)
   if (is_fpstate)
     {
       if ((ret = dwarf_get (&c->dwarf,
-	   DWARF_MEM_LOC (&c->dwarf, addr + FREEBSD_UC_MCONTEXT_FPSTATE_OFF),
-	   &fpstate)) < 0)
-	return DWARF_NULL_LOC;
+           DWARF_MEM_LOC (&c->dwarf, addr + FREEBSD_UC_MCONTEXT_FPSTATE_OFF),
+           &fpstate)) < 0)
+        return DWARF_NULL_LOC;
       if (fpstate == FREEBSD_UC_MCONTEXT_FPOWNED_NONE)
-	return DWARF_NULL_LOC;
+        return DWARF_NULL_LOC;
       if ((ret = dwarf_get (&c->dwarf,
-	   DWARF_MEM_LOC (&c->dwarf, addr + FREEBSD_UC_MCONTEXT_FPFORMAT_OFF),
-	   &fpformat)) < 0)
-	return DWARF_NULL_LOC;
+           DWARF_MEM_LOC (&c->dwarf, addr + FREEBSD_UC_MCONTEXT_FPFORMAT_OFF),
+           &fpformat)) < 0)
+        return DWARF_NULL_LOC;
       if (fpformat == FREEBSD_UC_MCONTEXT_FPFMT_NODEV ||
-	  (is_xmmstate && fpformat != FREEBSD_UC_MCONTEXT_FPFMT_XMM))
-	return DWARF_NULL_LOC;
+          (is_xmmstate && fpformat != FREEBSD_UC_MCONTEXT_FPFMT_XMM))
+        return DWARF_NULL_LOC;
       if (is_xmmstate)
-	off = xmm_off;
+        off = xmm_off;
     }
 
     return DWARF_MEM_LOC (c, addr + off);
diff --git a/src/x86/Gos-linux.c b/src/x86/Gos-linux.c
index 31f83ba..fb9a5e3 100644
--- a/src/x86/Gos-linux.c
+++ b/src/x86/Gos-linux.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -26,7 +26,9 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include "offsets.h"
 
-PROTECTED int
+#include <sys/syscall.h>
+
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -37,37 +39,38 @@ unw_is_signal_frame (unw_cursor_t *cursor)
   int ret;
 
   as = c->dwarf.as;
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   arg = c->dwarf.as_arg;
 
   /* Check if EIP points at sigreturn() sequence.  On Linux, this is:
 
     __restore:
-	0x58				pop %eax
-	0xb8 0x77 0x00 0x00 0x00	movl 0x77,%eax
-	0xcd 0x80			int 0x80
+        0x58                            pop %eax
+        0xb8 0x77 0x00 0x00 0x00        movl 0x77,%eax
+        0xcd 0x80                       int 0x80
 
      without SA_SIGINFO, and
 
     __restore_rt:
        0xb8 0xad 0x00 0x00 0x00        movl 0xad,%eax
        0xcd 0x80                       int 0x80
-       0x00                            
+       0x00
 
      if SA_SIGINFO is specified.
   */
   ip = c->dwarf.ip;
-  if ((ret = (*a->access_mem) (as, ip, &w0, 0, arg)) < 0
-      || (ret = (*a->access_mem) (as, ip + 4, &w1, 0, arg)) < 0)
-    return ret;
-  ret = ((w0 == 0x0077b858 && w1 == 0x80cd0000)
-	 || (w0 == 0x0000adb8 && (w1 & 0xffffff) == 0x80cd00));
+  if ((*a->access_mem) (as, ip, &w0, 0, arg) < 0
+      || (*a->access_mem) (as, ip + 4, &w1, 0, arg) < 0)
+    ret = 0;
+  else
+    ret = ((w0 == 0x0077b858 && w1 == 0x80cd0000)
+         || (w0 == 0x0000adb8 && (w1 & 0xffffff) == 0x80cd00));
   Debug (16, "returning %d\n", ret);
   return ret;
 }
 
-PROTECTED int
-unw_handle_signal_frame (unw_cursor_t *cursor)
+HIDDEN int
+x86_handle_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
   int ret;
@@ -86,7 +89,7 @@ unw_handle_signal_frame (unw_cursor_t *cursor)
   siginfo_ptr_loc = DWARF_LOC (siginfo_ptr_addr, 0);
   sigcontext_ptr_loc = DWARF_LOC (sigcontext_ptr_addr, 0);
   ret = (dwarf_get (&c->dwarf, siginfo_ptr_loc, &siginfo_ptr)
-	 | dwarf_get (&c->dwarf, sigcontext_ptr_loc, &sigcontext_ptr));
+         | dwarf_get (&c->dwarf, sigcontext_ptr_loc, &sigcontext_ptr));
   if (ret < 0)
     {
       Debug (2, "returning 0\n");
@@ -104,10 +107,10 @@ unw_handle_signal_frame (unw_cursor_t *cursor)
   else
     {
       /* If SA_SIGINFO were not specified, we actually read
-	 various segment pointers instead.  We believe that at
-	 least fs and _fsh are always zero for linux, so it is
-	 not just unlikely, but impossible that we would end
-	 up here. */
+         various segment pointers instead.  We believe that at
+         least fs and _fsh are always zero for linux, so it is
+         not just unlikely, but impossible that we would end
+         up here. */
       c->sigcontext_format = X86_SCF_LINUX_RT_SIGFRAME;
       c->sigcontext_addr = sigcontext_ptr;
       sc_addr = sigcontext_ptr + LINUX_UC_MCONTEXT_OFF;
@@ -179,8 +182,8 @@ x86_get_scratch_loc (struct cursor *c, unw_regnum_t reg)
     case UNW_X86_SS: off = LINUX_SC_SS_OFF; break;
 
       /* The following is probably not correct for all possible cases.
-	 Somebody who understands this better should review this for
-	 correctness.  */
+         Somebody who understands this better should review this for
+         correctness.  */
 
     case UNW_X86_FCW: is_fpstate = 1; off = LINUX_FPSTATE_CW_OFF; break;
     case UNW_X86_FSW: is_fpstate = 1; off = LINUX_FPSTATE_SW_OFF; break;
@@ -232,13 +235,13 @@ x86_get_scratch_loc (struct cursor *c, unw_regnum_t reg)
   if (is_fpstate)
     {
       if ((ret = dwarf_get (&c->dwarf,
-			    DWARF_MEM_LOC (&c->dwarf,
-					   addr + LINUX_SC_FPSTATE_OFF),
-			    &fpstate_addr)) < 0)
-	return DWARF_NULL_LOC;
+                            DWARF_MEM_LOC (&c->dwarf,
+                                           addr + LINUX_SC_FPSTATE_OFF),
+                            &fpstate_addr)) < 0)
+        return DWARF_NULL_LOC;
 
       if (!fpstate_addr)
-	return DWARF_NULL_LOC;
+        return DWARF_NULL_LOC;
 
       return DWARF_MEM_LOC (c, fpstate_addr + off);
     }
@@ -295,7 +298,7 @@ x86_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
       struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
 
       Debug (8, "resuming at ip=%x via sigreturn(%p)\n", c->dwarf.ip, sc);
-      sigreturn (sc);
+      x86_sigreturn (sc);
     }
   else
     {
@@ -304,4 +307,25 @@ x86_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
     }
   return -UNW_EINVAL;
 }
+
+/* sigreturn() is a no-op on x86 glibc.  */
+HIDDEN void
+x86_sigreturn (unw_cursor_t *cursor)
+{
+  struct cursor *c = (struct cursor *) cursor;
+  struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
+  mcontext_t *sc_mcontext = &((ucontext_t*)sc)->uc_mcontext;
+  /* Copy in saved uc - all preserved regs are at the start of sigcontext */
+  memcpy(sc_mcontext, &c->uc->uc_mcontext,
+         DWARF_NUM_PRESERVED_REGS * sizeof(unw_word_t));
+
+  Debug (8, "resuming at ip=%llx via sigreturn(%p)\n",
+             (unsigned long long) c->dwarf.ip, sc);
+  __asm__ __volatile__ ("mov %0, %%esp;"
+                        "mov %1, %%eax;"
+                        "syscall"
+                        :: "r"(sc), "i"(SYS_rt_sigreturn)
+                        : "memory");
+  abort();
+}
 #endif
diff --git a/src/x86/Greg_states_iterate.c b/src/x86/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/x86/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/x86/Gregs.c b/src/x86/Gregs.c
index 05bc1a3..4a95926 100644
--- a/src/x86/Gregs.c
+++ b/src/x86/Gregs.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -37,7 +37,7 @@ x86_scratch_loc (struct cursor *c, unw_regnum_t reg)
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   dwarf_loc_t loc = DWARF_NULL_LOC;
   unsigned int mask;
@@ -48,14 +48,14 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
     case UNW_X86_EIP:
       if (write)
-	c->dwarf.ip = *valp;		/* also update the EIP cache */
+        c->dwarf.ip = *valp;            /* also update the EIP cache */
       loc = c->dwarf.loc[EIP];
       break;
 
     case UNW_X86_CFA:
     case UNW_X86_ESP:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = c->dwarf.cfa;
       return 0;
 
@@ -64,18 +64,18 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
       arg_num = reg - UNW_X86_EAX;
       mask = (1 << arg_num);
       if (write)
-	{
-	  c->dwarf.eh_args[arg_num] = *valp;
-	  c->dwarf.eh_valid_mask |= mask;
-	  return 0;
-	}
+        {
+          c->dwarf.eh_args[arg_num] = *valp;
+          c->dwarf.eh_valid_mask |= mask;
+          return 0;
+        }
       else if ((c->dwarf.eh_valid_mask & mask) != 0)
-	{
-	  *valp = c->dwarf.eh_args[arg_num];
-	  return 0;
-	}
+        {
+          *valp = c->dwarf.eh_args[arg_num];
+          return 0;
+        }
       else
-	loc = c->dwarf.loc[(reg == UNW_X86_EAX) ? EAX : EDX];
+        loc = c->dwarf.loc[(reg == UNW_X86_EAX) ? EAX : EDX];
       break;
 
     case UNW_X86_ECX: loc = c->dwarf.loc[ECX]; break;
@@ -120,7 +120,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
   struct dwarf_loc loc = DWARF_NULL_LOC;
 
diff --git a/src/x86/Gresume.c b/src/x86/Gresume.c
index c39c588..5072c4b 100644
--- a/src/x86/Gresume.c
+++ b/src/x86/Gresume.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -35,9 +35,9 @@ static inline int
 establish_machine_state (struct cursor *c)
 {
   int (*access_reg) (unw_addr_space_t, unw_regnum_t, unw_word_t *,
-		     int write, void *);
+                     int write, void *);
   int (*access_fpreg) (unw_addr_space_t, unw_regnum_t, unw_fpreg_t *,
-		       int write, void *);
+                       int write, void *);
   unw_addr_space_t as = c->dwarf.as;
   void *arg = c->dwarf.as_arg;
   unw_fpreg_t fpval;
@@ -53,20 +53,29 @@ establish_machine_state (struct cursor *c)
     {
       Debug (16, "copying %s %d\n", unw_regname (reg), reg);
       if (unw_is_fpreg (reg))
-	{
-	  if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
-	    (*access_fpreg) (as, reg, &fpval, 1, arg);
-	}
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            (*access_fpreg) (as, reg, &fpval, 1, arg);
+        }
       else
-	{
-	  if (tdep_access_reg (c, reg, &val, 0) >= 0)
-	    (*access_reg) (as, reg, &val, 1, arg);
-	}
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            (*access_reg) (as, reg, &val, 1, arg);
+        }
+    }
+
+  if (c->dwarf.args_size)
+    {
+      if (tdep_access_reg (c, UNW_X86_ESP, &val, 0) >= 0)
+        {
+          val += c->dwarf.args_size;
+          (*access_reg) (as, UNW_X86_ESP, &val, 1, arg);
+        }
     }
   return 0;
 }
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -78,5 +87,5 @@ unw_resume (unw_cursor_t *cursor)
     return ret;
 
   return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
-				     c->dwarf.as_arg);
+                                     c->dwarf.as_arg);
 }
diff --git a/src/x86/Gstep.c b/src/x86/Gstep.c
index 0965db2..129b739 100644
--- a/src/x86/Gstep.c
+++ b/src/x86/Gstep.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -26,7 +26,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include "offsets.h"
 
-PROTECTED int
+int
 unw_step (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -46,7 +46,7 @@ unw_step (unw_cursor_t *cursor)
   if (unlikely (ret < 0))
     {
       /* DWARF failed, let's see if we can follow the frame-chain
-	 or skip over the signal trampoline.  */
+         or skip over the signal trampoline.  */
       struct dwarf_loc ebp_loc, eip_loc;
 
       /* We could get here because of missing/bad unwind information.
@@ -55,59 +55,59 @@ unw_step (unw_cursor_t *cursor)
 
       Debug (13, "dwarf_step() failed (ret=%d), trying frame-chain\n", ret);
 
-      if (unw_is_signal_frame (cursor))
+      if (unw_is_signal_frame (cursor) > 0)
         {
-          ret = unw_handle_signal_frame(cursor);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning 0\n");
-	      return 0;
-	    }
+          ret = x86_handle_signal_frame(cursor);
+          if (ret < 0)
+            {
+              Debug (2, "returning 0\n");
+              return 0;
+            }
         }
       else
-	{
-	  ret = dwarf_get (&c->dwarf, c->dwarf.loc[EBP], &c->dwarf.cfa);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-
-	  Debug (13, "[EBP=0x%x] = 0x%x\n", DWARF_GET_LOC (c->dwarf.loc[EBP]),
-		 c->dwarf.cfa);
-
-	  ebp_loc = DWARF_LOC (c->dwarf.cfa, 0);
-	  eip_loc = DWARF_LOC (c->dwarf.cfa + 4, 0);
-	  c->dwarf.cfa += 8;
-
-	  /* Mark all registers unsaved, since we don't know where
-	     they are saved (if at all), except for the EBP and
-	     EIP.  */
-	  for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
-	    c->dwarf.loc[i] = DWARF_NULL_LOC;
+        {
+          ret = dwarf_get (&c->dwarf, c->dwarf.loc[EBP], &c->dwarf.cfa);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+
+          Debug (13, "[EBP=0x%x] = 0x%x\n", DWARF_GET_LOC (c->dwarf.loc[EBP]),
+                 c->dwarf.cfa);
+
+          ebp_loc = DWARF_LOC (c->dwarf.cfa, 0);
+          eip_loc = DWARF_LOC (c->dwarf.cfa + 4, 0);
+          c->dwarf.cfa += 8;
+
+          /* Mark all registers unsaved, since we don't know where
+             they are saved (if at all), except for the EBP and
+             EIP.  */
+          for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
+            c->dwarf.loc[i] = DWARF_NULL_LOC;
 
           c->dwarf.loc[EBP] = ebp_loc;
           c->dwarf.loc[EIP] = eip_loc;
-	}
-      c->dwarf.ret_addr_column = EIP;
+          c->dwarf.use_prev_instr = 1;
+        }
 
       if (!DWARF_IS_NULL_LOC (c->dwarf.loc[EBP]))
-	{
-	  ret = dwarf_get (&c->dwarf, c->dwarf.loc[EIP], &c->dwarf.ip);
-	  if (ret < 0)
-	    {
-	      Debug (13, "dwarf_get([EIP=0x%x]) failed\n", DWARF_GET_LOC (c->dwarf.loc[EIP]));
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-	  else
-	    {
-	      Debug (13, "[EIP=0x%x] = 0x%x\n", DWARF_GET_LOC (c->dwarf.loc[EIP]),
-		c->dwarf.ip);
-	    }
-	}
+        {
+          ret = dwarf_get (&c->dwarf, c->dwarf.loc[EIP], &c->dwarf.ip);
+          if (ret < 0)
+            {
+              Debug (13, "dwarf_get([EIP=0x%x]) failed\n", DWARF_GET_LOC (c->dwarf.loc[EIP]));
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+          else
+            {
+              Debug (13, "[EIP=0x%x] = 0x%x\n", DWARF_GET_LOC (c->dwarf.loc[EIP]),
+                c->dwarf.ip);
+            }
+        }
       else
-	c->dwarf.ip = 0;
+        c->dwarf.ip = 0;
     }
   ret = (c->dwarf.ip == 0) ? 0 : 1;
   Debug (2, "returning %d\n", ret);
diff --git a/src/x86/Lapply_reg_state.c b/src/x86/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/x86/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/x86/Lreg_states_iterate.c b/src/x86/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/x86/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/x86/init.h b/src/x86/init.h
index f35387d..b0db8d3 100644
--- a/src/x86/init.h
+++ b/src/x86/init.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -50,7 +50,7 @@ common_init (struct cursor *c, unsigned use_prev_instr)
     return ret;
 
   ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_X86_ESP),
-		   &c->dwarf.cfa);
+                   &c->dwarf.cfa);
   if (ret < 0)
     return ret;
 
@@ -58,7 +58,6 @@ common_init (struct cursor *c, unsigned use_prev_instr)
   c->sigcontext_addr = 0;
 
   c->dwarf.args_size = 0;
-  c->dwarf.ret_addr_column = 0;
   c->dwarf.stash_frames = 0;
   c->dwarf.use_prev_instr = use_prev_instr;
   c->dwarf.pi_valid = 0;
diff --git a/src/x86/is_fpreg.c b/src/x86/is_fpreg.c
index 8f1536d..a3a98ac 100644
--- a/src/x86/is_fpreg.c
+++ b/src/x86/is_fpreg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2004-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -25,10 +25,10 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_is_fpreg (int regnum)
 {
   return ((regnum >= UNW_X86_ST0 && regnum <= UNW_X86_ST7)
-	  || (regnum >= UNW_X86_XMM0_lo && regnum <= UNW_X86_XMM7_hi)
-	  || (regnum >= UNW_X86_XMM0 && regnum <= UNW_X86_XMM7));
+          || (regnum >= UNW_X86_XMM0_lo && regnum <= UNW_X86_XMM7_hi)
+          || (regnum >= UNW_X86_XMM0 && regnum <= UNW_X86_XMM7));
 }
diff --git a/src/x86/offsets.h b/src/x86/offsets.h
index e8a255c..e5aec7f 100644
--- a/src/x86/offsets.h
+++ b/src/x86/offsets.h
@@ -4,137 +4,137 @@
 
 /* Offsets for x86 Linux "ucontext_t":  */
 
-#define LINUX_UC_FLAGS_OFF	0x00
-#define LINUX_UC_LINK_OFF	0x04
-#define LINUX_UC_STACK_OFF	0x08
-#define LINUX_UC_MCONTEXT_OFF	0x14
-#define LINUX_UC_SIGMASK_OFF	0x6c
-#define LINUX_UC_FPREGS_MEM_OFF	0xec
+#define LINUX_UC_FLAGS_OFF      0x00
+#define LINUX_UC_LINK_OFF       0x04
+#define LINUX_UC_STACK_OFF      0x08
+#define LINUX_UC_MCONTEXT_OFF   0x14
+#define LINUX_UC_SIGMASK_OFF    0x6c
+#define LINUX_UC_FPREGS_MEM_OFF 0xec
 
 /* The struct sigcontext is located at an offset of 4
    from the stack pointer in the signal frame.         */
 
 /* Offsets for x86 Linux "struct sigcontext":  */
 
-#define LINUX_SC_GS_OFF		0x00
-#define LINUX_SC_GSH_OFF	0x02
-#define LINUX_SC_FS_OFF		0x04
-#define LINUX_SC_FSH_OFF	0x06
-#define LINUX_SC_ES_OFF		0x08
-#define LINUX_SC_ESH_OFF	0x0a
-#define LINUX_SC_DS_OFF		0x0c
-#define LINUX_SC_DSH_OFF	0x0e
-#define LINUX_SC_EDI_OFF	0x10
-#define LINUX_SC_ESI_OFF	0x14
-#define LINUX_SC_EBP_OFF	0x18
-#define LINUX_SC_ESP_OFF	0x1c
-#define LINUX_SC_EBX_OFF	0x20
-#define LINUX_SC_EDX_OFF	0x24
-#define LINUX_SC_ECX_OFF	0x28
-#define LINUX_SC_EAX_OFF	0x2c
-#define LINUX_SC_TRAPNO_OFF	0x30
-#define LINUX_SC_ERR_OFF	0x34
-#define LINUX_SC_EIP_OFF	0x38
-#define LINUX_SC_CS_OFF		0x3c
-#define LINUX_SC_CSH_OFF	0x3e
-#define LINUX_SC_EFLAGS_OFF	0x40
-#define LINUX_SC_ESP_AT_SIGNAL_OFF	0x44
-#define LINUX_SC_SS_OFF		0x48
-#define LINUX_SC_SSH_OFF	0x4a
-#define LINUX_SC_FPSTATE_OFF	0x4c
-#define LINUX_SC_OLDMASK_OFF	0x50
-#define LINUX_SC_CR2_OFF	0x54
+#define LINUX_SC_GS_OFF         0x00
+#define LINUX_SC_GSH_OFF        0x02
+#define LINUX_SC_FS_OFF         0x04
+#define LINUX_SC_FSH_OFF        0x06
+#define LINUX_SC_ES_OFF         0x08
+#define LINUX_SC_ESH_OFF        0x0a
+#define LINUX_SC_DS_OFF         0x0c
+#define LINUX_SC_DSH_OFF        0x0e
+#define LINUX_SC_EDI_OFF        0x10
+#define LINUX_SC_ESI_OFF        0x14
+#define LINUX_SC_EBP_OFF        0x18
+#define LINUX_SC_ESP_OFF        0x1c
+#define LINUX_SC_EBX_OFF        0x20
+#define LINUX_SC_EDX_OFF        0x24
+#define LINUX_SC_ECX_OFF        0x28
+#define LINUX_SC_EAX_OFF        0x2c
+#define LINUX_SC_TRAPNO_OFF     0x30
+#define LINUX_SC_ERR_OFF        0x34
+#define LINUX_SC_EIP_OFF        0x38
+#define LINUX_SC_CS_OFF         0x3c
+#define LINUX_SC_CSH_OFF        0x3e
+#define LINUX_SC_EFLAGS_OFF     0x40
+#define LINUX_SC_ESP_AT_SIGNAL_OFF      0x44
+#define LINUX_SC_SS_OFF         0x48
+#define LINUX_SC_SSH_OFF        0x4a
+#define LINUX_SC_FPSTATE_OFF    0x4c
+#define LINUX_SC_OLDMASK_OFF    0x50
+#define LINUX_SC_CR2_OFF        0x54
 
 /* Offsets for x86 Linux "struct _fpstate":  */
 
-#define LINUX_FPSTATE_CW_OFF		0x000
-#define LINUX_FPSTATE_SW_OFF		0x004
-#define LINUX_FPSTATE_TAG_OFF		0x008
-#define LINUX_FPSTATE_IPOFF_OFF		0x00c
-#define LINUX_FPSTATE_CSSEL_OFF		0x010
-#define LINUX_FPSTATE_DATAOFF_OFF	0x014
-#define LINUX_FPSTATE_DATASEL_OFF	0x018
-#define LINUX_FPSTATE_ST0_OFF		0x01c
-#define LINUX_FPSTATE_ST1_OFF		0x026
-#define LINUX_FPSTATE_ST2_OFF		0x030
-#define LINUX_FPSTATE_ST3_OFF		0x03a
-#define LINUX_FPSTATE_ST4_OFF		0x044
-#define LINUX_FPSTATE_ST5_OFF		0x04e
-#define LINUX_FPSTATE_ST6_OFF		0x058
-#define LINUX_FPSTATE_ST7_OFF		0x062
-#define LINUX_FPSTATE_STATUS_OFF	0x06c
-#define LINUX_FPSTATE_MAGIC_OFF		0x06e
-#define LINUX_FPSTATE_FXSR_ENV_OFF	0x070
-#define LINUX_FPSTATE_MXCSR_OFF		0x088
-#define LINUX_FPSTATE_FXSR_ST0_OFF	0x090
-#define LINUX_FPSTATE_FXSR_ST1_OFF	0x0a0
-#define LINUX_FPSTATE_FXSR_ST2_OFF	0x0b0
-#define LINUX_FPSTATE_FXSR_ST3_OFF	0x0c0
-#define LINUX_FPSTATE_FXSR_ST4_OFF	0x0d0
-#define LINUX_FPSTATE_FXSR_ST5_OFF	0x0e0
-#define LINUX_FPSTATE_FXSR_ST6_OFF	0x0f0
-#define LINUX_FPSTATE_FXSR_ST7_OFF	0x100
-#define LINUX_FPSTATE_XMM0_OFF		0x110
-#define LINUX_FPSTATE_XMM1_OFF		0x120
-#define LINUX_FPSTATE_XMM2_OFF		0x130
-#define LINUX_FPSTATE_XMM3_OFF		0x140
-#define LINUX_FPSTATE_XMM4_OFF		0x150
-#define LINUX_FPSTATE_XMM5_OFF		0x160
-#define LINUX_FPSTATE_XMM6_OFF		0x170
-#define LINUX_FPSTATE_XMM7_OFF		0x180
+#define LINUX_FPSTATE_CW_OFF            0x000
+#define LINUX_FPSTATE_SW_OFF            0x004
+#define LINUX_FPSTATE_TAG_OFF           0x008
+#define LINUX_FPSTATE_IPOFF_OFF         0x00c
+#define LINUX_FPSTATE_CSSEL_OFF         0x010
+#define LINUX_FPSTATE_DATAOFF_OFF       0x014
+#define LINUX_FPSTATE_DATASEL_OFF       0x018
+#define LINUX_FPSTATE_ST0_OFF           0x01c
+#define LINUX_FPSTATE_ST1_OFF           0x026
+#define LINUX_FPSTATE_ST2_OFF           0x030
+#define LINUX_FPSTATE_ST3_OFF           0x03a
+#define LINUX_FPSTATE_ST4_OFF           0x044
+#define LINUX_FPSTATE_ST5_OFF           0x04e
+#define LINUX_FPSTATE_ST6_OFF           0x058
+#define LINUX_FPSTATE_ST7_OFF           0x062
+#define LINUX_FPSTATE_STATUS_OFF        0x06c
+#define LINUX_FPSTATE_MAGIC_OFF         0x06e
+#define LINUX_FPSTATE_FXSR_ENV_OFF      0x070
+#define LINUX_FPSTATE_MXCSR_OFF         0x088
+#define LINUX_FPSTATE_FXSR_ST0_OFF      0x090
+#define LINUX_FPSTATE_FXSR_ST1_OFF      0x0a0
+#define LINUX_FPSTATE_FXSR_ST2_OFF      0x0b0
+#define LINUX_FPSTATE_FXSR_ST3_OFF      0x0c0
+#define LINUX_FPSTATE_FXSR_ST4_OFF      0x0d0
+#define LINUX_FPSTATE_FXSR_ST5_OFF      0x0e0
+#define LINUX_FPSTATE_FXSR_ST6_OFF      0x0f0
+#define LINUX_FPSTATE_FXSR_ST7_OFF      0x100
+#define LINUX_FPSTATE_XMM0_OFF          0x110
+#define LINUX_FPSTATE_XMM1_OFF          0x120
+#define LINUX_FPSTATE_XMM2_OFF          0x130
+#define LINUX_FPSTATE_XMM3_OFF          0x140
+#define LINUX_FPSTATE_XMM4_OFF          0x150
+#define LINUX_FPSTATE_XMM5_OFF          0x160
+#define LINUX_FPSTATE_XMM6_OFF          0x170
+#define LINUX_FPSTATE_XMM7_OFF          0x180
 
 /* FreeBSD-specific definitions: */
 
-#define FREEBSD_SC_UCONTEXT_OFF		0x20
-#define FREEBSD_UC_MCONTEXT_OFF		0x10
+#define FREEBSD_SC_UCONTEXT_OFF         0x20
+#define FREEBSD_UC_MCONTEXT_OFF         0x10
 
-#define FREEBSD_UC_MCONTEXT_GS_OFF	0x14
-#define FREEBSD_UC_MCONTEXT_FS_OFF	0x18
-#define FREEBSD_UC_MCONTEXT_ES_OFF	0x1c
-#define FREEBSD_UC_MCONTEXT_DS_OFF	0x20
-#define FREEBSD_UC_MCONTEXT_EDI_OFF	0x24
-#define FREEBSD_UC_MCONTEXT_ESI_OFF	0x28
-#define FREEBSD_UC_MCONTEXT_EBP_OFF	0x2c
-#define FREEBSD_UC_MCONTEXT_EBX_OFF	0x34
-#define FREEBSD_UC_MCONTEXT_EDX_OFF	0x38
-#define FREEBSD_UC_MCONTEXT_ECX_OFF	0x3c
-#define FREEBSD_UC_MCONTEXT_EAX_OFF	0x40
-#define FREEBSD_UC_MCONTEXT_TRAPNO_OFF	0x44
-#define FREEBSD_UC_MCONTEXT_EIP_OFF	0x4c
-#define FREEBSD_UC_MCONTEXT_ESP_OFF	0x58
-#define FREEBSD_UC_MCONTEXT_CS_OFF	0x50
-#define FREEBSD_UC_MCONTEXT_EFLAGS_OFF	0x54
-#define FREEBSD_UC_MCONTEXT_SS_OFF	0x5c
-#define FREEBSD_UC_MCONTEXT_MC_LEN_OFF	0x60
+#define FREEBSD_UC_MCONTEXT_GS_OFF      0x14
+#define FREEBSD_UC_MCONTEXT_FS_OFF      0x18
+#define FREEBSD_UC_MCONTEXT_ES_OFF      0x1c
+#define FREEBSD_UC_MCONTEXT_DS_OFF      0x20
+#define FREEBSD_UC_MCONTEXT_EDI_OFF     0x24
+#define FREEBSD_UC_MCONTEXT_ESI_OFF     0x28
+#define FREEBSD_UC_MCONTEXT_EBP_OFF     0x2c
+#define FREEBSD_UC_MCONTEXT_EBX_OFF     0x34
+#define FREEBSD_UC_MCONTEXT_EDX_OFF     0x38
+#define FREEBSD_UC_MCONTEXT_ECX_OFF     0x3c
+#define FREEBSD_UC_MCONTEXT_EAX_OFF     0x40
+#define FREEBSD_UC_MCONTEXT_TRAPNO_OFF  0x44
+#define FREEBSD_UC_MCONTEXT_EIP_OFF     0x4c
+#define FREEBSD_UC_MCONTEXT_ESP_OFF     0x58
+#define FREEBSD_UC_MCONTEXT_CS_OFF      0x50
+#define FREEBSD_UC_MCONTEXT_EFLAGS_OFF  0x54
+#define FREEBSD_UC_MCONTEXT_SS_OFF      0x5c
+#define FREEBSD_UC_MCONTEXT_MC_LEN_OFF  0x60
 #define FREEBSD_UC_MCONTEXT_FPFORMAT_OFF 0x64
-#define FREEBSD_UC_MCONTEXT_OWNEDFP_OFF	0x68
-#define FREEBSD_UC_MCONTEXT_FPSTATE_OFF	0x70
+#define FREEBSD_UC_MCONTEXT_OWNEDFP_OFF 0x68
+#define FREEBSD_UC_MCONTEXT_FPSTATE_OFF 0x70
 
-#define	FREEBSD_UC_MCONTEXT_CW_OFF	0x70
-#define	FREEBSD_UC_MCONTEXT_SW_OFF	0x74
-#define	FREEBSD_UC_MCONTEXT_TAG_OFF	0x78
-#define	FREEBSD_UC_MCONTEXT_IPOFF_OFF	0x7c
-#define	FREEBSD_UC_MCONTEXT_CSSEL_OFF	0x80
-#define	FREEBSD_UC_MCONTEXT_DATAOFF_OFF	0x84
-#define	FREEBSD_US_MCONTEXT_DATASEL_OFF	0x88
-#define	FREEBSD_UC_MCONTEXT_ST0_OFF	0x8c
+#define FREEBSD_UC_MCONTEXT_CW_OFF      0x70
+#define FREEBSD_UC_MCONTEXT_SW_OFF      0x74
+#define FREEBSD_UC_MCONTEXT_TAG_OFF     0x78
+#define FREEBSD_UC_MCONTEXT_IPOFF_OFF   0x7c
+#define FREEBSD_UC_MCONTEXT_CSSEL_OFF   0x80
+#define FREEBSD_UC_MCONTEXT_DATAOFF_OFF 0x84
+#define FREEBSD_US_MCONTEXT_DATASEL_OFF 0x88
+#define FREEBSD_UC_MCONTEXT_ST0_OFF     0x8c
 
-#define	FREEBSD_UC_MCONTEXT_CW_XMM_OFF	0x70
-#define	FREEBSD_UC_MCONTEXT_SW_XMM_OFF	0x72
-#define	FREEBSD_UC_MCONTEXT_TAG_XMM_OFF	0x74
-#define	FREEBSD_UC_MCONTEXT_IPOFF_XMM_OFF 0x78
-#define	FREEBSD_UC_MCONTEXT_CSSEL_XMM_OFF 0x7c
-#define	FREEBSD_UC_MCONTEXT_DATAOFF_XMM_OFF 0x80
-#define	FREEBSD_US_MCONTEXT_DATASEL_XMM_OFF 0x84
-#define	FREEBSD_UC_MCONTEXT_MXCSR_XMM_OFF 0x88
-#define	FREEBSD_UC_MCONTEXT_ST0_XMM_OFF	0x90
-#define	FREEBSD_UC_MCONTEXT_XMM0_OFF	0x110
+#define FREEBSD_UC_MCONTEXT_CW_XMM_OFF  0x70
+#define FREEBSD_UC_MCONTEXT_SW_XMM_OFF  0x72
+#define FREEBSD_UC_MCONTEXT_TAG_XMM_OFF 0x74
+#define FREEBSD_UC_MCONTEXT_IPOFF_XMM_OFF 0x78
+#define FREEBSD_UC_MCONTEXT_CSSEL_XMM_OFF 0x7c
+#define FREEBSD_UC_MCONTEXT_DATAOFF_XMM_OFF 0x80
+#define FREEBSD_US_MCONTEXT_DATASEL_XMM_OFF 0x84
+#define FREEBSD_UC_MCONTEXT_MXCSR_XMM_OFF 0x88
+#define FREEBSD_UC_MCONTEXT_ST0_XMM_OFF 0x90
+#define FREEBSD_UC_MCONTEXT_XMM0_OFF    0x110
 
-#define FREEBSD_UC_MCONTEXT_MC_LEN_VAL	0x280
-#define FREEBSD_UC_MCONTEXT_FPFMT_NODEV	0x10000
-#define FREEBSD_UC_MCONTEXT_FPFMT_387	0x10001
-#define FREEBSD_UC_MCONTEXT_FPFMT_XMM	0x10002
-#define	FREEBSD_UC_MCONTEXT_FPOWNED_NONE 0x20000
-#define	FREEBSD_UC_MCONTEXT_FPOWNED_FPU	0x20001
-#define	FREEBSD_UC_MCONTEXT_FPOWNED_PCB	0x20002
+#define FREEBSD_UC_MCONTEXT_MC_LEN_VAL  0x280
+#define FREEBSD_UC_MCONTEXT_FPFMT_NODEV 0x10000
+#define FREEBSD_UC_MCONTEXT_FPFMT_387   0x10001
+#define FREEBSD_UC_MCONTEXT_FPFMT_XMM   0x10002
+#define FREEBSD_UC_MCONTEXT_FPOWNED_NONE 0x20000
+#define FREEBSD_UC_MCONTEXT_FPOWNED_FPU 0x20001
+#define FREEBSD_UC_MCONTEXT_FPOWNED_PCB 0x20002
 
diff --git a/src/x86/regname.c b/src/x86/regname.c
index 2228510..11f6228 100644
--- a/src/x86/regname.c
+++ b/src/x86/regname.c
@@ -17,7 +17,7 @@ static const char *regname[] =
     "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7",
   };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
diff --git a/src/x86/unwind_i.h b/src/x86/unwind_i.h
index 1db2e98..caa7e02 100644
--- a/src/x86/unwind_i.h
+++ b/src/x86/unwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
 This file is part of libunwind.
 
@@ -33,31 +33,36 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "libunwind_i.h"
 
 /* DWARF column numbers: */
-#define EAX	0
-#define ECX	1
-#define EDX	2
-#define EBX	3
-#define ESP	4
-#define EBP	5
-#define ESI	6
-#define EDI	7
-#define EIP	8
-#define EFLAGS	9
-#define TRAPNO	10
-#define ST0	11
-
-#define x86_lock			UNW_OBJ(lock)
-#define x86_local_resume		UNW_OBJ(local_resume)
-#define x86_local_addr_space_init	UNW_OBJ(local_addr_space_init)
-#define x86_scratch_loc			UNW_OBJ(scratch_loc)
-#define x86_get_scratch_loc		UNW_OBJ(get_scratch_loc)
-#define x86_r_uc_addr			UNW_OBJ(r_uc_addr)
+#define EAX     0
+#define ECX     1
+#define EDX     2
+#define EBX     3
+#define ESP     4
+#define EBP     5
+#define ESI     6
+#define EDI     7
+#define EIP     8
+#define EFLAGS  9
+#define TRAPNO  10
+#define ST0     11
+
+#define x86_lock                        UNW_OBJ(lock)
+#define x86_local_resume                UNW_OBJ(local_resume)
+#define x86_local_addr_space_init       UNW_OBJ(local_addr_space_init)
+#define x86_scratch_loc                 UNW_OBJ(scratch_loc)
+#define x86_get_scratch_loc             UNW_OBJ(get_scratch_loc)
+#define x86_r_uc_addr                   UNW_OBJ(r_uc_addr)
+#define x86_sigreturn                   UNW_OBJ(sigreturn)
 
 extern void x86_local_addr_space_init (void);
 extern int x86_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			     void *arg);
+                             void *arg);
 extern dwarf_loc_t x86_scratch_loc (struct cursor *c, unw_regnum_t reg);
 extern dwarf_loc_t x86_get_scratch_loc (struct cursor *c, unw_regnum_t reg);
 extern void *x86_r_uc_addr (ucontext_t *uc, int reg);
 
+extern void x86_sigreturn (unw_cursor_t *cursor);
+#define x86_handle_signal_frame UNW_OBJ(handle_signal_frame)
+extern int x86_handle_signal_frame(unw_cursor_t *cursor);
+
 #endif /* unwind_i_h */
diff --git a/src/x86_64/Gapply_reg_state.c b/src/x86_64/Gapply_reg_state.c
new file mode 100644
index 0000000..82f056d
--- /dev/null
+++ b/src/x86_64/Gapply_reg_state.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_apply_reg_state (unw_cursor_t *cursor,
+		     void *reg_states_data)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_apply_reg_state (&c->dwarf, (dwarf_reg_state_t *)reg_states_data);
+}
diff --git a/src/x86_64/Gcreate_addr_space.c b/src/x86_64/Gcreate_addr_space.c
index aab126a..9b2db98 100644
--- a/src/x86_64/Gcreate_addr_space.c
+++ b/src/x86_64/Gcreate_addr_space.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
    Copyright (C) 2012 Tommi Rantala <tt.rantala@gmail.com>
@@ -34,7 +34,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #define __LITTLE_ENDIAN _LITTLE_ENDIAN
 #endif
 
-PROTECTED unw_addr_space_t
+unw_addr_space_t
 unw_create_addr_space (unw_accessors_t *a, int byte_order)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/x86_64/Gget_proc_info.c b/src/x86_64/Gget_proc_info.c
index 213666e..50de1e4 100644
--- a/src/x86_64/Gget_proc_info.c
+++ b/src/x86_64/Gget_proc_info.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -27,7 +27,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -35,9 +35,9 @@ unw_get_proc_info (unw_cursor_t *cursor, unw_proc_info_t *pi)
   if (dwarf_make_proc_info (&c->dwarf) < 0)
     {
       /* On x86-64, some key routines such as _start() and _dl_start()
-	 are missing DWARF unwind info.  We don't want to fail in that
-	 case, because those frames are uninteresting and just mark
-	 the end of the frame-chain anyhow.  */
+         are missing DWARF unwind info.  We don't want to fail in that
+         case, because those frames are uninteresting and just mark
+         the end of the frame-chain anyhow.  */
       memset (pi, 0, sizeof (*pi));
       pi->start_ip = c->dwarf.ip;
       pi->end_ip = c->dwarf.ip + 1;
diff --git a/src/x86_64/Gget_save_loc.c b/src/x86_64/Gget_save_loc.c
index 20b14a5..4056870 100644
--- a/src/x86_64/Gget_save_loc.c
+++ b/src/x86_64/Gget_save_loc.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -27,13 +27,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
 {
   struct cursor *c = (struct cursor *) cursor;
   dwarf_loc_t loc;
 
-  loc = DWARF_NULL_LOC;		/* default to "not saved" */
+  loc = DWARF_NULL_LOC;         /* default to "not saved" */
 
   switch (reg)
     {
@@ -44,6 +44,7 @@ unw_get_save_loc (unw_cursor_t *cursor, int reg, unw_save_loc_t *sloc)
     case UNW_X86_64_R13: loc = c->dwarf.loc[R13]; break;
     case UNW_X86_64_R14: loc = c->dwarf.loc[R14]; break;
     case UNW_X86_64_R15: loc = c->dwarf.loc[R15]; break;
+    case UNW_X86_64_RIP: loc = c->dwarf.loc[RIP]; break;
 
     default:
       break;
diff --git a/src/x86_64/Gglobal.c b/src/x86_64/Gglobal.c
index cf1e374..8d1fbb4 100644
--- a/src/x86_64/Gglobal.c
+++ b/src/x86_64/Gglobal.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003, 2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -95,7 +95,7 @@ tdep_init (void)
 #ifndef UNW_REMOTE_ONLY
     x86_64_local_addr_space_init ();
 #endif
-    tdep_init_done = 1;	/* signal that we're initialized... */
+    tdep_init_done = 1; /* signal that we're initialized... */
   }
  out:
   lock_release (&x86_64_lock, saved_mask);
diff --git a/src/x86_64/Ginit.c b/src/x86_64/Ginit.c
index daea078..6161da6 100644
--- a/src/x86_64/Ginit.c
+++ b/src/x86_64/Ginit.c
@@ -1,7 +1,7 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002 Hewlett-Packard Co
    Copyright (C) 2007 David Mosberger-Tang
-	Contributed by David Mosberger-Tang <dmosberger@gmail.com>
+        Contributed by David Mosberger-Tang <dmosberger@gmail.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -30,22 +30,24 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <config.h>
 #endif
 
+#include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/mman.h>
+#include <sys/syscall.h>
 
 #include "unwind_i.h"
 
 #ifdef UNW_REMOTE_ONLY
 
 /* unw_local_addr_space is a NULL pointer in this case.  */
-PROTECTED unw_addr_space_t unw_local_addr_space;
+unw_addr_space_t unw_local_addr_space;
 
 #else /* !UNW_REMOTE_ONLY */
 
 static struct unw_addr_space local_addr_space;
 
-PROTECTED unw_addr_space_t unw_local_addr_space = &local_addr_space;
+unw_addr_space_t unw_local_addr_space = &local_addr_space;
 
 HIDDEN unw_dyn_info_list_t _U_dyn_info_list;
 
@@ -62,26 +64,83 @@ put_unwind_info (unw_addr_space_t as, unw_proc_info_t *proc_info, void *arg)
 
 static int
 get_dyn_info_list_addr (unw_addr_space_t as, unw_word_t *dyn_info_list_addr,
-			void *arg)
+                        void *arg)
 {
   *dyn_info_list_addr = (unw_word_t) &_U_dyn_info_list;
   return 0;
 }
 
 #define PAGE_SIZE 4096
-#define PAGE_START(a)	((a) & ~(PAGE_SIZE-1))
+#define PAGE_START(a)   ((a) & ~(PAGE_SIZE-1))
+
+static int mem_validate_pipe[2] = {-1, -1};
+
+static inline void
+open_pipe (void)
+{
+  if (mem_validate_pipe[0] != -1)
+    close (mem_validate_pipe[0]);
+  if (mem_validate_pipe[1] != -1)
+    close (mem_validate_pipe[1]);
+
+  pipe2 (mem_validate_pipe, O_CLOEXEC | O_NONBLOCK);
+}
+
+ALWAYS_INLINE
+static int
+write_validate (void *addr)
+{
+  int ret = -1;
+  ssize_t bytes = 0;
+
+  do
+    {
+      char buf;
+      bytes = read (mem_validate_pipe[0], &buf, 1);
+    }
+  while ( errno == EINTR );
+
+  int valid_read = (bytes > 0 || errno == EAGAIN || errno == EWOULDBLOCK);
+  if (!valid_read)
+    {
+      // re-open closed pipe
+      open_pipe ();
+    }
+
+  do
+    {
+      /* use syscall insteadof write() so that ASAN does not complain */
+      ret = syscall (SYS_write, mem_validate_pipe[1], addr, 1);
+    }
+  while ( errno == EINTR );
+
+  return ret;
+}
 
 static int (*mem_validate_func) (void *addr, size_t len);
 static int msync_validate (void *addr, size_t len)
 {
-  return msync (addr, len, MS_ASYNC);
+  if (msync (addr, len, MS_ASYNC) != 0)
+    {
+      return -1;
+    }
+
+  return write_validate (addr);
 }
 
 #ifdef HAVE_MINCORE
 static int mincore_validate (void *addr, size_t len)
 {
   unsigned char mvec[2]; /* Unaligned access may cross page boundary */
-  return mincore (addr, len, mvec);
+
+  /* mincore could fail with EAGAIN but we conservatively return -1
+     instead of looping. */
+  if (mincore (addr, len, mvec) != 0)
+    {
+      return -1;
+    }
+
+  return write_validate (addr);
 }
 #endif
 
@@ -92,9 +151,16 @@ static int mincore_validate (void *addr, size_t len)
 HIDDEN void
 tdep_init_mem_validate (void)
 {
+  open_pipe ();
+
 #ifdef HAVE_MINCORE
   unsigned char present = 1;
-  if (mincore (&present, 1, &present) == 0)
+  unw_word_t addr = PAGE_START((unw_word_t)&present);
+  unsigned char mvec[1];
+  int ret;
+  while ((ret = mincore ((void*)addr, PAGE_SIZE, mvec)) == -1 &&
+         errno == EAGAIN) {}
+  if (ret == 0)
     {
       Debug(1, "using mincore to validate memory\n");
       mem_validate_func = mincore_validate;
@@ -109,13 +175,93 @@ tdep_init_mem_validate (void)
 
 /* Cache of already validated addresses */
 #define NLGA 4
-static unw_word_t last_good_addr[NLGA];
-static int lga_victim;
+#if defined(HAVE___THREAD) && HAVE___THREAD
+// thread-local variant
+static __thread unw_word_t last_good_addr[NLGA];
+static __thread int lga_victim;
 
 static int
-validate_mem (unw_word_t addr)
+is_cached_valid_mem(unw_word_t addr)
+{
+  int i;
+  for (i = 0; i < NLGA; i++)
+    {
+      if (addr == &last_good_addr[i])
+        return 1;
+    }
+  return 0;
+}
+
+static void
+cache_valid_mem(unw_word_t addr)
 {
   int i, victim;
+  victim = lga_victim;
+  for (i = 0; i < NLGA; i++) {
+    if (last_good_addr[victim] == 0) {
+      last_good_addr[victim] = addr;
+      return;
+    }
+    victim = (victim + 1) % NLGA;
+  }
+
+  /* All slots full. Evict the victim. */
+  last_good_addr[victim] = addr;
+  victim = (victim + 1) % NLGA;
+  lga_victim = victim;
+}
+
+#elif HAVE_ATOMIC_OPS_H
+// global, thread safe variant
+static AO_T last_good_addr[NLGA];
+static AO_T lga_victim;
+
+static int
+is_cached_valid_mem(unw_word_t addr)
+{
+  int i;
+  for (i = 0; i < NLGA; i++)
+    {
+      if (addr == AO_load(&last_good_addr[i]))
+        return 1;
+    }
+  return 0;
+}
+
+static void
+cache_valid_mem(unw_word_t addr)
+{
+  int i, victim;
+  victim = AO_load(&lga_victim);
+  for (i = 0; i < NLGA; i++) {
+    if (AO_compare_and_swap(&last_good_addr[victim], 0, addr)) {
+      return;
+    }
+    victim = (victim + 1) % NLGA;
+  }
+
+  /* All slots full. Evict the victim. */
+  AO_store(&last_good_addr[victim], addr);
+  victim = (victim + 1) % NLGA;
+  AO_store(&lga_victim, victim);
+}
+#else
+// disabled, no cache
+static int
+is_cached_valid_mem(unw_word_t addr UNUSED)
+{
+  return 0;
+}
+
+static void
+cache_valid_mem(unw_word_t addr UNUSED)
+{
+}
+#endif
+
+static int
+validate_mem (unw_word_t addr)
+{
   size_t len;
 
   if (PAGE_START(addr + sizeof (unw_word_t) - 1) == PAGE_START(addr))
@@ -128,35 +274,20 @@ validate_mem (unw_word_t addr)
   if (addr == 0)
     return -1;
 
-  for (i = 0; i < NLGA; i++)
-    {
-      if (last_good_addr[i] && (addr == last_good_addr[i]))
-	return 0;
-    }
+  if (is_cached_valid_mem(addr))
+    return 0;
 
   if (mem_validate_func ((void *) addr, len) == -1)
     return -1;
 
-  victim = lga_victim;
-  for (i = 0; i < NLGA; i++) {
-    if (!last_good_addr[victim]) {
-      last_good_addr[victim++] = addr;
-      return 0;
-    }
-    victim = (victim + 1) % NLGA;
-  }
-
-  /* All slots full. Evict the victim. */
-  last_good_addr[victim] = addr;
-  victim = (victim + 1) % NLGA;
-  lga_victim = victim;
+  cache_valid_mem(addr);
 
   return 0;
 }
 
 static int
 access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   if (unlikely (write))
     {
@@ -168,8 +299,10 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
       /* validate address */
       const struct cursor *c = (const struct cursor *)arg;
       if (likely (c != NULL) && unlikely (c->validate)
-          && unlikely (validate_mem (addr)))
+          && unlikely (validate_mem (addr))) {
+        Debug (16, "mem[%016lx] -> invalid\n", addr);
         return -1;
+      }
       *val = *(unw_word_t *) addr;
       Debug (16, "mem[%016lx] -> %lx\n", addr, *val);
     }
@@ -178,7 +311,7 @@ access_mem (unw_addr_space_t as, unw_word_t addr, unw_word_t *val, int write,
 
 static int
 access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
-	    void *arg)
+            void *arg)
 {
   unw_word_t *addr;
   ucontext_t *uc = ((struct cursor *)arg)->uc;
@@ -208,7 +341,7 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
 
 static int
 access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
-	      int write, void *arg)
+              int write, void *arg)
 {
   ucontext_t *uc = ((struct cursor *)arg)->uc;
   unw_fpreg_t *addr;
@@ -222,14 +355,14 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   if (write)
     {
       Debug (12, "%s <- %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
       *(unw_fpreg_t *) addr = *val;
     }
   else
     {
       *val = *(unw_fpreg_t *) addr;
       Debug (12, "%s -> %08lx.%08lx.%08lx\n", unw_regname (reg),
-	     ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
+             ((long *)val)[0], ((long *)val)[1], ((long *)val)[2]);
     }
   return 0;
 
@@ -241,8 +374,8 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
 
 static int
 get_static_proc_name (unw_addr_space_t as, unw_word_t ip,
-		      char *buf, size_t buf_len, unw_word_t *offp,
-		      void *arg)
+                      char *buf, size_t buf_len, unw_word_t *offp,
+                      void *arg)
 {
   return _Uelf64_get_proc_name (as, getpid (), ip, buf, buf_len, offp);
 }
@@ -251,7 +384,7 @@ HIDDEN void
 x86_64_local_addr_space_init (void)
 {
   memset (&local_addr_space, 0, sizeof (local_addr_space));
-  local_addr_space.caching_policy = UNW_CACHE_GLOBAL;
+  local_addr_space.caching_policy = UNWI_DEFAULT_CACHING_POLICY;
   local_addr_space.acc.find_proc_info = dwarf_find_proc_info;
   local_addr_space.acc.put_unwind_info = put_unwind_info;
   local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
@@ -261,9 +394,6 @@ x86_64_local_addr_space_init (void)
   local_addr_space.acc.resume = x86_64_local_resume;
   local_addr_space.acc.get_proc_name = get_static_proc_name;
   unw_flush_cache (&local_addr_space, 0, 0);
-
-  memset (last_good_addr, 0, sizeof (unw_word_t) * NLGA);
-  lga_victim = 0;
 }
 
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/x86_64/Ginit_local.c b/src/x86_64/Ginit_local.c
index 8c3f060..5eaead0 100644
--- a/src/x86_64/Ginit_local.c
+++ b/src/x86_64/Ginit_local.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -30,7 +30,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #ifdef UNW_REMOTE_ONLY
 
-PROTECTED int
+int
 unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 {
   return -UNW_EINVAL;
@@ -38,8 +38,8 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
 
 #else /* !UNW_REMOTE_ONLY */
 
-PROTECTED int
-unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+static int
+unw_init_local_common (unw_cursor_t *cursor, ucontext_t *uc, unsigned use_prev_instr)
 {
   struct cursor *c = (struct cursor *) cursor;
 
@@ -52,7 +52,30 @@ unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
   c->dwarf.as_arg = c;
   c->uc = uc;
   c->validate = 0;
-  return common_init (c, 1);
+  return common_init (c, use_prev_instr);
+}
+
+int
+unw_init_local (unw_cursor_t *cursor, ucontext_t *uc)
+{
+  return unw_init_local_common(cursor, uc, 1);
+}
+
+int
+unw_init_local2 (unw_cursor_t *cursor, ucontext_t *uc, int flag)
+{
+  if (!flag)
+    {
+      return unw_init_local_common(cursor, uc, 1);
+    }
+  else if (flag == UNW_INIT_SIGNAL_FRAME)
+    {
+      return unw_init_local_common(cursor, uc, 0);
+    }
+  else
+    {
+      return -UNW_EINVAL;
+    }
 }
 
 #endif /* !UNW_REMOTE_ONLY */
diff --git a/src/x86_64/Ginit_remote.c b/src/x86_64/Ginit_remote.c
index 4fd2092..efd61d6 100644
--- a/src/x86_64/Ginit_remote.c
+++ b/src/x86_64/Ginit_remote.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2003 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -28,7 +28,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "init.h"
 #include "unwind_i.h"
 
-PROTECTED int
+int
 unw_init_remote (unw_cursor_t *cursor, unw_addr_space_t as, void *as_arg)
 {
 #ifdef UNW_LOCAL_ONLY
diff --git a/src/x86_64/Gos-freebsd.c b/src/x86_64/Gos-freebsd.c
index 71695c6..883025c 100644
--- a/src/x86_64/Gos-freebsd.c
+++ b/src/x86_64/Gos-freebsd.c
@@ -33,7 +33,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include "unwind_i.h"
 #include "ucontext_i.h"
 
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
   /* XXXKIB */
@@ -45,16 +45,16 @@ unw_is_signal_frame (unw_cursor_t *cursor)
   int ret;
 
   as = c->dwarf.as;
-  a = unw_get_accessors (as);
+  a = unw_get_accessors_int (as);
   arg = c->dwarf.as_arg;
 
   /* Check if RIP points at sigreturn sequence.
-48 8d 7c 24 10		lea	SIGF_UC(%rsp),%rdi
-6a 00			pushq	$0
-48 c7 c0 a1 01 00 00	movq	$SYS_sigreturn,%rax
-0f 05			syscall
-f4		0:	hlt
-eb fd			jmp	0b
+48 8d 7c 24 10          lea     SIGF_UC(%rsp),%rdi
+6a 00                   pushq   $0
+48 c7 c0 a1 01 00 00    movq    $SYS_sigreturn,%rax
+0f 05                   syscall
+f4              0:      hlt
+eb fd                   jmp     0b
   */
 
   ip = c->dwarf.ip;
@@ -72,8 +72,8 @@ eb fd			jmp	0b
      return (c->sigcontext_format);
    }
   /* Check if RIP points at standard syscall sequence.
-49 89 ca	mov    %rcx,%r10
-0f 05		syscall
+49 89 ca        mov    %rcx,%r10
+0f 05           syscall
   */
   if ((ret = (*a->access_mem) (as, ip - 5, &b0, 0, arg)) < 0)
     return (0);
@@ -87,8 +87,8 @@ eb fd			jmp	0b
   return (X86_64_SCF_NONE);
 }
 
-PROTECTED int
-unw_handle_signal_frame (unw_cursor_t *cursor)
+HIDDEN int
+x86_64_handle_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
   unw_word_t ucontext;
@@ -131,19 +131,20 @@ unw_handle_signal_frame (unw_cursor_t *cursor)
   else if (c->sigcontext_format == X86_64_SCF_FREEBSD_SYSCALL)
    {
     c->dwarf.loc[RCX] = c->dwarf.loc[R10];
-    /*  rsp_loc = DWARF_LOC(c->dwarf.cfa - 8, 0);	*/
-    /*	rbp_loc = c->dwarf.loc[RBP];			*/
+    /*  rsp_loc = DWARF_LOC(c->dwarf.cfa - 8, 0);       */
+    /*  rbp_loc = c->dwarf.loc[RBP];                    */
     c->dwarf.loc[RIP] = DWARF_LOC (c->dwarf.cfa, 0);
     ret = dwarf_get (&c->dwarf, c->dwarf.loc[RIP], &c->dwarf.ip);
     Debug (1, "Frame Chain [RIP=0x%Lx] = 0x%Lx\n",
-	   (unsigned long long) DWARF_GET_LOC (c->dwarf.loc[RIP]),
-	   (unsigned long long) c->dwarf.ip);
+           (unsigned long long) DWARF_GET_LOC (c->dwarf.loc[RIP]),
+           (unsigned long long) c->dwarf.ip);
     if (ret < 0)
      {
        Debug (2, "returning %d\n", ret);
        return ret;
      }
     c->dwarf.cfa += 8;
+    c->dwarf.use_prev_instr = 1;
     return 1;
    }
   else
@@ -191,8 +192,26 @@ x86_64_sigreturn (unw_cursor_t *cursor)
   ucontext_t *uc = (ucontext_t *)(c->sigcontext_addr +
     offsetof(struct sigframe, sf_uc));
 
+  uc->uc_mcontext.mc_r8 = c->uc->uc_mcontext.mc_r8;
+  uc->uc_mcontext.mc_r9 = c->uc->uc_mcontext.mc_r9;
+  uc->uc_mcontext.mc_r10 = c->uc->uc_mcontext.mc_r10;
+  uc->uc_mcontext.mc_r11 = c->uc->uc_mcontext.mc_r11;
+  uc->uc_mcontext.mc_r12 = c->uc->uc_mcontext.mc_r12;
+  uc->uc_mcontext.mc_r13 = c->uc->uc_mcontext.mc_r13;
+  uc->uc_mcontext.mc_r14 = c->uc->uc_mcontext.mc_r14;
+  uc->uc_mcontext.mc_r15 = c->uc->uc_mcontext.mc_r15;
+  uc->uc_mcontext.mc_rdi = c->uc->uc_mcontext.mc_rdi;
+  uc->uc_mcontext.mc_rsi = c->uc->uc_mcontext.mc_rsi;
+  uc->uc_mcontext.mc_rbp = c->uc->uc_mcontext.mc_rbp;
+  uc->uc_mcontext.mc_rbx = c->uc->uc_mcontext.mc_rbx;
+  uc->uc_mcontext.mc_rdx = c->uc->uc_mcontext.mc_rdx;
+  uc->uc_mcontext.mc_rax = c->uc->uc_mcontext.mc_rax;
+  uc->uc_mcontext.mc_rcx = c->uc->uc_mcontext.mc_rcx;
+  uc->uc_mcontext.mc_rsp = c->uc->uc_mcontext.mc_rsp;
+  uc->uc_mcontext.mc_rip = c->uc->uc_mcontext.mc_rip;
+
   Debug (8, "resuming at ip=%llx via sigreturn(%p)\n",
-	     (unsigned long long) c->dwarf.ip, uc);
+             (unsigned long long) c->dwarf.ip, uc);
   sigreturn(uc);
   abort();
 }
diff --git a/src/x86_64/Gos-linux.c b/src/x86_64/Gos-linux.c
index a0ecce2..bd14234 100644
--- a/src/x86_64/Gos-linux.c
+++ b/src/x86_64/Gos-linux.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2003 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -47,21 +47,21 @@ tdep_fetch_frame (struct dwarf_cursor *dw, unw_word_t ip, int need_unwind_info)
         dw->ip, dw->cfa, c->sigcontext_format);
 }
 
-HIDDEN void
-tdep_cache_frame (struct dwarf_cursor *dw, struct dwarf_reg_state *rs)
+HIDDEN int
+tdep_cache_frame (struct dwarf_cursor *dw)
 {
   struct cursor *c = (struct cursor *) dw;
-  rs->signal_frame = c->sigcontext_format;
 
   Debug(5, "cache frame ip=0x%lx cfa=0x%lx format=%d\n",
         dw->ip, dw->cfa, c->sigcontext_format);
+  return c->sigcontext_format;
 }
 
 HIDDEN void
-tdep_reuse_frame (struct dwarf_cursor *dw, struct dwarf_reg_state *rs)
+tdep_reuse_frame (struct dwarf_cursor *dw, int frame)
 {
   struct cursor *c = (struct cursor *) dw;
-  c->sigcontext_format = rs->signal_frame;
+  c->sigcontext_format = frame;
   if (c->sigcontext_format == X86_64_SCF_LINUX_RT_SIGFRAME)
   {
     c->frame_info.frame_type = UNW_X86_64_FRAME_SIGRETURN;
@@ -69,24 +69,22 @@ tdep_reuse_frame (struct dwarf_cursor *dw, struct dwarf_reg_state *rs)
     c->frame_info.cfa_reg_offset = 0;
     c->sigcontext_addr = dw->cfa;
   }
-  else
-    c->sigcontext_addr = 0;
 
   Debug(5, "reuse frame ip=0x%lx cfa=0x%lx format=%d addr=0x%lx offset=%+d\n",
         dw->ip, dw->cfa, c->sigcontext_format, c->sigcontext_addr,
-	(c->sigcontext_format == X86_64_SCF_LINUX_RT_SIGFRAME
-	 ? c->frame_info.cfa_reg_offset : 0));
+        (c->sigcontext_format == X86_64_SCF_LINUX_RT_SIGFRAME
+         ? c->frame_info.cfa_reg_offset : 0));
 }
 
-PROTECTED int
+int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
   return c->sigcontext_format != X86_64_SCF_NONE;
 }
 
-PROTECTED int
-unw_handle_signal_frame (unw_cursor_t *cursor)
+HIDDEN int
+x86_64_handle_signal_frame (unw_cursor_t *cursor)
 {
 #if UNW_DEBUG /* To silence compiler warnings */
   /* Should not get here because we now use kernel-provided dwarf
@@ -96,7 +94,7 @@ unw_handle_signal_frame (unw_cursor_t *cursor)
      gating on unw_is_signal_frame() needs to be removed. */
   struct cursor *c = (struct cursor *) cursor;
   Debug(1, "old format signal frame? format=%d addr=0x%lx cfa=0x%lx\n",
-	c->sigcontext_format, c->sigcontext_addr, c->dwarf.cfa);
+        c->sigcontext_format, c->sigcontext_addr, c->dwarf.cfa);
 #endif
   return -UNW_EBADFRAME;
 }
@@ -140,14 +138,18 @@ x86_64_sigreturn (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
   struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
+  mcontext_t *sc_mcontext = &((ucontext_t*)sc)->uc_mcontext;
+  /* Copy in saved uc - all preserved regs are at the start of sigcontext */
+  memcpy(sc_mcontext, &c->uc->uc_mcontext,
+         DWARF_NUM_PRESERVED_REGS * sizeof(unw_word_t));
 
   Debug (8, "resuming at ip=%llx via sigreturn(%p)\n",
-	     (unsigned long long) c->dwarf.ip, sc);
+             (unsigned long long) c->dwarf.ip, sc);
   __asm__ __volatile__ ("mov %0, %%rsp;"
-			"mov %1, %%rax;"
-			"syscall"
-			:: "r"(sc), "i"(SYS_rt_sigreturn)
-			: "memory");
+                        "mov %1, %%rax;"
+                        "syscall"
+                        :: "r"(sc), "i"(SYS_rt_sigreturn)
+                        : "memory");
   abort();
 }
 
diff --git a/src/x86_64/Greg_states_iterate.c b/src/x86_64/Greg_states_iterate.c
new file mode 100644
index 0000000..a17dc1b
--- /dev/null
+++ b/src/x86_64/Greg_states_iterate.c
@@ -0,0 +1,37 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (c) 2002-2003 Hewlett-Packard Development Company, L.P.
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "unwind_i.h"
+
+int
+unw_reg_states_iterate (unw_cursor_t *cursor,
+			unw_reg_states_callback cb, void *token)
+{
+  struct cursor *c = (struct cursor *) cursor;
+
+  return dwarf_reg_states_iterate (&c->dwarf, cb, token);
+}
diff --git a/src/x86_64/Gregs.c b/src/x86_64/Gregs.c
index 5dd7b0b..baf8a24 100644
--- a/src/x86_64/Gregs.c
+++ b/src/x86_64/Gregs.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -63,7 +63,7 @@ x86_64_scratch_loc (struct cursor *c, unw_regnum_t reg)
 
 HIDDEN int
 tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
-		 int write)
+                 int write)
 {
   dwarf_loc_t loc = DWARF_NULL_LOC;
   unsigned int mask;
@@ -74,14 +74,14 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
     case UNW_X86_64_RIP:
       if (write)
-	c->dwarf.ip = *valp;		/* also update the RIP cache */
+        c->dwarf.ip = *valp;            /* also update the RIP cache */
       loc = c->dwarf.loc[RIP];
       break;
 
     case UNW_X86_64_CFA:
     case UNW_X86_64_RSP:
       if (write)
-	return -UNW_EREADONLYREG;
+        return -UNW_EREADONLYREG;
       *valp = c->dwarf.cfa;
       return 0;
 
@@ -90,18 +90,18 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
       arg_num = reg - UNW_X86_64_RAX;
       mask = (1 << arg_num);
       if (write)
-	{
-	  c->dwarf.eh_args[arg_num] = *valp;
-	  c->dwarf.eh_valid_mask |= mask;
-	  return 0;
-	}
+        {
+          c->dwarf.eh_args[arg_num] = *valp;
+          c->dwarf.eh_valid_mask |= mask;
+          return 0;
+        }
       else if ((c->dwarf.eh_valid_mask & mask) != 0)
-	{
-	  *valp = c->dwarf.eh_args[arg_num];
-	  return 0;
-	}
+        {
+          *valp = c->dwarf.eh_args[arg_num];
+          return 0;
+        }
       else
-	loc = c->dwarf.loc[(reg == UNW_X86_64_RAX) ? RAX : RDX];
+        loc = c->dwarf.loc[(reg == UNW_X86_64_RAX) ? RAX : RDX];
       break;
 
     case UNW_X86_64_RCX: loc = c->dwarf.loc[RCX]; break;
@@ -132,7 +132,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
 
 HIDDEN int
 tdep_access_fpreg (struct cursor *c, unw_regnum_t reg, unw_fpreg_t *valp,
-		   int write)
+                   int write)
 {
       return -UNW_EBADREG;
 }
diff --git a/src/x86_64/Gresume.c b/src/x86_64/Gresume.c
index d5239fc..944cdaa 100644
--- a/src/x86_64/Gresume.c
+++ b/src/x86_64/Gresume.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2002-2004 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -44,7 +44,7 @@ x86_64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
      at least.  */
   dwarf_make_proc_info (&c->dwarf);
 
-  if (unlikely (c->sigcontext_format != X86_64_SCF_NONE))
+  if (unlikely (c->sigcontext_addr != X86_64_SCF_NONE))
     {
       x86_64_sigreturn(cursor);
       abort();
@@ -52,7 +52,7 @@ x86_64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
   else
     {
       Debug (8, "resuming at ip=%llx via setcontext()\n",
-	     (unsigned long long) c->dwarf.ip);
+             (unsigned long long) c->dwarf.ip);
       setcontext (uc);
     }
   return -UNW_EINVAL;
@@ -67,9 +67,9 @@ static inline int
 establish_machine_state (struct cursor *c)
 {
   int (*access_reg) (unw_addr_space_t, unw_regnum_t, unw_word_t *,
-		     int write, void *);
+                     int write, void *);
   int (*access_fpreg) (unw_addr_space_t, unw_regnum_t, unw_fpreg_t *,
-		       int write, void *);
+                       int write, void *);
   unw_addr_space_t as = c->dwarf.as;
   void *arg = c->dwarf.as_arg;
   unw_fpreg_t fpval;
@@ -85,20 +85,29 @@ establish_machine_state (struct cursor *c)
     {
       Debug (16, "copying %s %d\n", unw_regname (reg), reg);
       if (unw_is_fpreg (reg))
-	{
-	  if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
-	    (*access_fpreg) (as, reg, &fpval, 1, arg);
-	}
+        {
+          if (tdep_access_fpreg (c, reg, &fpval, 0) >= 0)
+            (*access_fpreg) (as, reg, &fpval, 1, arg);
+        }
       else
-	{
-	  if (tdep_access_reg (c, reg, &val, 0) >= 0)
-	    (*access_reg) (as, reg, &val, 1, arg);
-	}
+        {
+          if (tdep_access_reg (c, reg, &val, 0) >= 0)
+            (*access_reg) (as, reg, &val, 1, arg);
+        }
+    }
+
+  if (c->dwarf.args_size)
+    {
+      if (tdep_access_reg (c, UNW_X86_64_RSP, &val, 0) >= 0)
+        {
+          val += c->dwarf.args_size;
+          (*access_reg) (as, UNW_X86_64_RSP, &val, 1, arg);
+        }
     }
   return 0;
 }
 
-PROTECTED int
+int
 unw_resume (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -110,5 +119,5 @@ unw_resume (unw_cursor_t *cursor)
     return ret;
 
   return (*c->dwarf.as->acc.resume) (c->dwarf.as, (unw_cursor_t *) c,
-				     c->dwarf.as_arg);
+                                     c->dwarf.as_arg);
 }
diff --git a/src/x86_64/Gstash_frame.c b/src/x86_64/Gstash_frame.c
index 962b103..2c7bc31 100644
--- a/src/x86_64/Gstash_frame.c
+++ b/src/x86_64/Gstash_frame.c
@@ -32,14 +32,31 @@ tdep_stash_frame (struct dwarf_cursor *d, struct dwarf_reg_state *rs)
   unw_tdep_frame_t *f = &c->frame_info;
 
   Debug (4, "ip=0x%lx cfa=0x%lx type %d cfa [where=%d val=%ld] cfaoff=%ld"
-	 " ra=0x%lx rbp [where=%d val=%ld @0x%lx] rsp [where=%d val=%ld @0x%lx]\n",
-	 d->ip, d->cfa, f->frame_type,
-	 rs->reg[DWARF_CFA_REG_COLUMN].where,
-	 rs->reg[DWARF_CFA_REG_COLUMN].val,
-	 rs->reg[DWARF_CFA_OFF_COLUMN].val,
-	 DWARF_GET_LOC(d->loc[d->ret_addr_column]),
-	 rs->reg[RBP].where, rs->reg[RBP].val, DWARF_GET_LOC(d->loc[RBP]),
-	 rs->reg[RSP].where, rs->reg[RSP].val, DWARF_GET_LOC(d->loc[RSP]));
+         " ra=0x%lx rbp [where=%d val=%ld @0x%lx] rsp [where=%d val=%ld @0x%lx]\n",
+         d->ip, d->cfa, f->frame_type,
+         rs->reg.where[DWARF_CFA_REG_COLUMN],
+         rs->reg.val[DWARF_CFA_REG_COLUMN],
+         rs->reg.val[DWARF_CFA_OFF_COLUMN],
+         DWARF_GET_LOC(d->loc[rs->ret_addr_column]),
+         rs->reg.where[RBP], rs->reg.val[RBP], DWARF_GET_LOC(d->loc[RBP]),
+         rs->reg.where[RSP], rs->reg.val[RSP], DWARF_GET_LOC(d->loc[RSP]));
+
+  if (rs->reg.where[DWARF_CFA_REG_COLUMN] == DWARF_WHERE_EXPR &&
+    rs->reg.where[RBP] == DWARF_WHERE_EXPR) {
+    /* Check for GCC generated alignment frame for rsp.  A simple
+     * def_cfa_expr that loads a constant offset from rbp, where the
+     * addres of the rip was pushed on the stack */
+    unw_word_t cfa_addr = rs->reg.val[DWARF_CFA_REG_COLUMN];
+    unw_word_t rbp_addr = rs->reg.val[RBP];
+    unw_word_t cfa_offset;
+
+    int ret = dwarf_stack_aligned(d, cfa_addr, rbp_addr, &cfa_offset);
+    if (ret) {
+      f->frame_type = UNW_X86_64_FRAME_ALIGNED;
+      f->cfa_reg_offset = cfa_offset;
+      f->cfa_reg_rsp = 0;
+    }
+  }
 
   /* A standard frame is defined as:
       - CFA is register-relative offset off RBP or RSP;
@@ -47,30 +64,30 @@ tdep_stash_frame (struct dwarf_cursor *d, struct dwarf_reg_state *rs)
       - RBP is unsaved or saved at CFA+offset, offset != -1;
       - RSP is unsaved or saved at CFA+offset, offset != -1.  */
   if (f->frame_type == UNW_X86_64_FRAME_OTHER
-      && (rs->reg[DWARF_CFA_REG_COLUMN].where == DWARF_WHERE_REG)
-      && (rs->reg[DWARF_CFA_REG_COLUMN].val == RBP
-	  || rs->reg[DWARF_CFA_REG_COLUMN].val == RSP)
-      && labs(rs->reg[DWARF_CFA_OFF_COLUMN].val) < (1 << 29)
-      && DWARF_GET_LOC(d->loc[d->ret_addr_column]) == d->cfa-8
-      && (rs->reg[RBP].where == DWARF_WHERE_UNDEF
-	  || rs->reg[RBP].where == DWARF_WHERE_SAME
-	  || (rs->reg[RBP].where == DWARF_WHERE_CFAREL
-	      && labs(rs->reg[RBP].val) < (1 << 14)
-	      && rs->reg[RBP].val+1 != 0))
-      && (rs->reg[RSP].where == DWARF_WHERE_UNDEF
-	  || rs->reg[RSP].where == DWARF_WHERE_SAME
-	  || (rs->reg[RSP].where == DWARF_WHERE_CFAREL
-	      && labs(rs->reg[RSP].val) < (1 << 14)
-	      && rs->reg[RSP].val+1 != 0)))
+      && (rs->reg.where[DWARF_CFA_REG_COLUMN] == DWARF_WHERE_REG)
+      && (rs->reg.val[DWARF_CFA_REG_COLUMN] == RBP
+          || rs->reg.val[DWARF_CFA_REG_COLUMN] == RSP)
+      && labs((long) rs->reg.val[DWARF_CFA_OFF_COLUMN]) < (1 << 28)
+      && DWARF_GET_LOC(d->loc[rs->ret_addr_column]) == d->cfa-8
+      && (rs->reg.where[RBP] == DWARF_WHERE_UNDEF
+          || rs->reg.where[RBP] == DWARF_WHERE_SAME
+          || (rs->reg.where[RBP] == DWARF_WHERE_CFAREL
+              && labs((long) rs->reg.val[RBP]) < (1 << 14)
+              && rs->reg.val[RBP]+1 != 0))
+      && (rs->reg.where[RSP] == DWARF_WHERE_UNDEF
+          || rs->reg.where[RSP] == DWARF_WHERE_SAME
+          || (rs->reg.where[RSP] == DWARF_WHERE_CFAREL
+              && labs((long) rs->reg.val[RSP]) < (1 << 14)
+              && rs->reg.val[RSP]+1 != 0)))
   {
     /* Save information for a standard frame. */
     f->frame_type = UNW_X86_64_FRAME_STANDARD;
-    f->cfa_reg_rsp = (rs->reg[DWARF_CFA_REG_COLUMN].val == RSP);
-    f->cfa_reg_offset = rs->reg[DWARF_CFA_OFF_COLUMN].val;
-    if (rs->reg[RBP].where == DWARF_WHERE_CFAREL)
-      f->rbp_cfa_offset = rs->reg[RBP].val;
-    if (rs->reg[RSP].where == DWARF_WHERE_CFAREL)
-      f->rsp_cfa_offset = rs->reg[RSP].val;
+    f->cfa_reg_rsp = (rs->reg.val[DWARF_CFA_REG_COLUMN] == RSP);
+    f->cfa_reg_offset = rs->reg.val[DWARF_CFA_OFF_COLUMN];
+    if (rs->reg.where[RBP] == DWARF_WHERE_CFAREL)
+      f->rbp_cfa_offset = rs->reg.val[RBP];
+    if (rs->reg.where[RSP] == DWARF_WHERE_CFAREL)
+      f->rsp_cfa_offset = rs->reg.val[RSP];
     Debug (4, " standard frame\n");
   }
 
@@ -92,6 +109,10 @@ tdep_stash_frame (struct dwarf_cursor *d, struct dwarf_reg_state *rs)
     Debug (4, " sigreturn frame\n");
   }
 
+  else if (f->frame_type == UNW_X86_64_FRAME_ALIGNED) {
+    Debug (4, " aligned frame, offset %li\n", f->cfa_reg_offset);
+  }
+
   /* PLT and guessed RBP-walked frames are handled in unw_step(). */
   else
     Debug (4, " unusual frame\n");
diff --git a/src/x86_64/Gstep.c b/src/x86_64/Gstep.c
index 9fa0967..1049817 100644
--- a/src/x86_64/Gstep.c
+++ b/src/x86_64/Gstep.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002-2004 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -39,20 +39,20 @@ is_plt_entry (struct dwarf_cursor *c)
   unw_accessors_t *a;
   int ret;
 
-  a = unw_get_accessors (c->as);
+  a = unw_get_accessors_int (c->as);
   if ((ret = (*a->access_mem) (c->as, c->ip, &w0, 0, c->as_arg)) < 0
       || (ret = (*a->access_mem) (c->as, c->ip + 8, &w1, 0, c->as_arg)) < 0)
     return 0;
 
   ret = (((w0 & 0xffff) == 0x25ff)
-	 && (((w0 >> 48) & 0xff) == 0x68)
-	 && (((w1 >> 24) & 0xff) == 0xe9));
+         && (((w0 >> 48) & 0xff) == 0x68)
+         && (((w1 >> 24) & 0xff) == 0xe9));
 
   Debug (14, "ip=0x%lx => 0x%016lx 0x%016lx, ret = %d\n", c->ip, w0, w1, ret);
   return ret;
 }
 
-PROTECTED int
+int
 unw_step (unw_cursor_t *cursor)
 {
   struct cursor *c = (struct cursor *) cursor;
@@ -64,7 +64,7 @@ unw_step (unw_cursor_t *cursor)
 #endif
 
   Debug (1, "(cursor=%p, ip=0x%016lx, cfa=0x%016lx)\n",
-	 c, c->dwarf.ip, c->dwarf.cfa);
+         c, c->dwarf.ip, c->dwarf.cfa);
 
   /* Try DWARF-based unwinding... */
   c->sigcontext_format = X86_64_SCF_NONE;
@@ -83,26 +83,26 @@ unw_step (unw_cursor_t *cursor)
   if (likely (ret >= 0))
     {
       /* x86_64 ABI specifies that end of call-chain is marked with a
-	 NULL RBP.  */
+         NULL RBP or undefined return address  */
       if (DWARF_IS_NULL_LOC (c->dwarf.loc[RBP]))
-	{
-	  c->dwarf.ip = 0;
-	  ret = 0;
-	}
+          {
+            c->dwarf.ip = 0;
+            ret = 0;
+          }
     }
   else
     {
       /* DWARF failed.  There isn't much of a usable frame-chain on x86-64,
-	 but we do need to handle two special-cases:
+         but we do need to handle two special-cases:
 
-	  (i) signal trampoline: Old kernels and older libcs don't
-	      export the vDSO needed to get proper unwind info for the
-	      trampoline.  Recognize that case by looking at the code
-	      and filling in things by hand.
+          (i) signal trampoline: Old kernels and older libcs don't
+              export the vDSO needed to get proper unwind info for the
+              trampoline.  Recognize that case by looking at the code
+              and filling in things by hand.
 
-	  (ii) PLT (shared-library) call-stubs: PLT stubs are invoked
-	      via CALLQ.  Try this for all non-signal trampoline
-	      code.  */
+          (ii) PLT (shared-library) call-stubs: PLT stubs are invoked
+              via CALLQ.  Try this for all non-signal trampoline
+              code.  */
 
       unw_word_t prev_ip = c->dwarf.ip, prev_cfa = c->dwarf.cfa;
       struct dwarf_loc rbp_loc, rsp_loc, rip_loc;
@@ -113,115 +113,114 @@ unw_step (unw_cursor_t *cursor)
 
       Debug (13, "dwarf_step() failed (ret=%d), trying frame-chain\n", ret);
 
-      if (unw_is_signal_frame (cursor))
-	{
-          ret = unw_handle_signal_frame(cursor);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning 0\n");
-	      return 0;
-	    }
-	}
+      if (unw_is_signal_frame (cursor) > 0)
+        {
+          ret = x86_64_handle_signal_frame(cursor);
+          if (ret < 0)
+            {
+              Debug (2, "returning 0\n");
+              return 0;
+            }
+        }
       else if (is_plt_entry (&c->dwarf))
-	{
+        {
           /* Like regular frame, CFA = RSP+8, RA = [CFA-8], no regs saved. */
-	  Debug (2, "found plt entry\n");
+          Debug (2, "found plt entry\n");
           c->frame_info.cfa_reg_offset = 8;
           c->frame_info.cfa_reg_rsp = -1;
           c->frame_info.frame_type = UNW_X86_64_FRAME_STANDARD;
           c->dwarf.loc[RIP] = DWARF_LOC (c->dwarf.cfa, 0);
           c->dwarf.cfa += 8;
-	}
+        }
       else if (DWARF_IS_NULL_LOC (c->dwarf.loc[RBP]))
         {
-	  for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
-	    c->dwarf.loc[i] = DWARF_NULL_LOC;
-	}
+          for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
+            c->dwarf.loc[i] = DWARF_NULL_LOC;
+        }
       else
-	{
-	  unw_word_t rbp;
-
-	  ret = dwarf_get (&c->dwarf, c->dwarf.loc[RBP], &rbp);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d [RBP=0x%lx]\n", ret,
-		     DWARF_GET_LOC (c->dwarf.loc[RBP]));
-	      return ret;
-	    }
-
-	  if (!rbp)
-	    {
-	      /* Looks like we may have reached the end of the call-chain.  */
-	      rbp_loc = DWARF_NULL_LOC;
-	      rsp_loc = DWARF_NULL_LOC;
-	      rip_loc = DWARF_NULL_LOC;
-	    }
-	  else
-	    {
-	      unw_word_t rbp1 = 0;
-	      rbp_loc = DWARF_LOC(rbp, 0);
-	      rsp_loc = DWARF_NULL_LOC;
-	      rip_loc = DWARF_LOC (rbp + 8, 0);
-	      ret = dwarf_get (&c->dwarf, rbp_loc, &rbp1);
-	      Debug (1, "[RBP=0x%lx] = 0x%lx (cfa = 0x%lx) -> 0x%lx\n",
-		     (unsigned long) DWARF_GET_LOC (c->dwarf.loc[RBP]),
-		     rbp, c->dwarf.cfa, rbp1);
-
-	      /* Heuristic to determine incorrect guess.  For RBP to be a
-	         valid frame it needs to be above current CFA, but don't
-		 let it go more than a little.  Note that we can't deduce
-		 anything about new RBP (rbp1) since it may not be a frame
-		 pointer in the frame above.  Just check we get the value. */
+        {
+          unw_word_t rbp;
+
+          ret = dwarf_get (&c->dwarf, c->dwarf.loc[RBP], &rbp);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d [RBP=0x%lx]\n", ret,
+                     DWARF_GET_LOC (c->dwarf.loc[RBP]));
+              return ret;
+            }
+
+          if (!rbp)
+            {
+              /* Looks like we may have reached the end of the call-chain.  */
+              rbp_loc = DWARF_NULL_LOC;
+              rsp_loc = DWARF_NULL_LOC;
+              rip_loc = DWARF_NULL_LOC;
+            }
+          else
+            {
+              unw_word_t rbp1 = 0;
+              rbp_loc = DWARF_LOC(rbp, 0);
+              rsp_loc = DWARF_NULL_LOC;
+              rip_loc = DWARF_LOC (rbp + 8, 0);
+              ret = dwarf_get (&c->dwarf, rbp_loc, &rbp1);
+              Debug (1, "[RBP=0x%lx] = 0x%lx (cfa = 0x%lx) -> 0x%lx\n",
+                     (unsigned long) DWARF_GET_LOC (c->dwarf.loc[RBP]),
+                     rbp, c->dwarf.cfa, rbp1);
+
+              /* Heuristic to determine incorrect guess.  For RBP to be a
+                 valid frame it needs to be above current CFA, but don't
+                 let it go more than a little.  Note that we can't deduce
+                 anything about new RBP (rbp1) since it may not be a frame
+                 pointer in the frame above.  Just check we get the value. */
               if (ret < 0
-		  || rbp <= c->dwarf.cfa
-		  || (rbp - c->dwarf.cfa) > 0x4000)
-	        {
+                  || rbp < c->dwarf.cfa
+                  || (rbp - c->dwarf.cfa) > 0x4000)
+                {
                   rip_loc = DWARF_NULL_LOC;
                   rbp_loc = DWARF_NULL_LOC;
-		}
+                }
 
               c->frame_info.frame_type = UNW_X86_64_FRAME_GUESSED;
               c->frame_info.cfa_reg_rsp = 0;
               c->frame_info.cfa_reg_offset = 16;
               c->frame_info.rbp_cfa_offset = -16;
-	      c->dwarf.cfa += 16;
-	    }
+              c->dwarf.cfa += 16;
+            }
 
-	  /* Mark all registers unsaved */
-	  for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
-	    c->dwarf.loc[i] = DWARF_NULL_LOC;
+          /* Mark all registers unsaved */
+          for (i = 0; i < DWARF_NUM_PRESERVED_REGS; ++i)
+            c->dwarf.loc[i] = DWARF_NULL_LOC;
 
           c->dwarf.loc[RBP] = rbp_loc;
           c->dwarf.loc[RSP] = rsp_loc;
           c->dwarf.loc[RIP] = rip_loc;
-	}
-
-      c->dwarf.ret_addr_column = RIP;
+          c->dwarf.use_prev_instr = 1;
+        }
 
       if (DWARF_IS_NULL_LOC (c->dwarf.loc[RBP]))
         {
-	  ret = 0;
-	  Debug (2, "NULL %%rbp loc, returning %d\n", ret);
-	  return ret;
+          ret = 0;
+          Debug (2, "NULL %%rbp loc, returning %d\n", ret);
+          return ret;
         }
       if (!DWARF_IS_NULL_LOC (c->dwarf.loc[RIP]))
-	{
-	  ret = dwarf_get (&c->dwarf, c->dwarf.loc[RIP], &c->dwarf.ip);
-	  Debug (1, "Frame Chain [RIP=0x%Lx] = 0x%Lx\n",
-		     (unsigned long long) DWARF_GET_LOC (c->dwarf.loc[RIP]),
-		     (unsigned long long) c->dwarf.ip);
-	  if (ret < 0)
-	    {
-	      Debug (2, "returning %d\n", ret);
-	      return ret;
-	    }
-	  ret = 1;
-	}
+        {
+          ret = dwarf_get (&c->dwarf, c->dwarf.loc[RIP], &c->dwarf.ip);
+          Debug (1, "Frame Chain [RIP=0x%Lx] = 0x%Lx\n",
+                     (unsigned long long) DWARF_GET_LOC (c->dwarf.loc[RIP]),
+                     (unsigned long long) c->dwarf.ip);
+          if (ret < 0)
+            {
+              Debug (2, "returning %d\n", ret);
+              return ret;
+            }
+          ret = 1;
+        }
       else
-	c->dwarf.ip = 0;
+        c->dwarf.ip = 0;
 
       if (c->dwarf.ip == prev_ip && c->dwarf.cfa == prev_cfa)
-	return -UNW_EBADFRAME;
+        return -UNW_EBADFRAME;
     }
   Debug (2, "returning %d\n", ret);
   return ret;
diff --git a/src/x86_64/Gtrace.c b/src/x86_64/Gtrace.c
index 9a86a06..7412271 100644
--- a/src/x86_64/Gtrace.c
+++ b/src/x86_64/Gtrace.c
@@ -41,7 +41,7 @@ typedef struct
   size_t log_size;
   size_t used;
   size_t dtor_count;  /* Counts how many times our destructor has already
-			 been called. */
+                         been called. */
 } unw_trace_cache_t;
 
 static const unw_tdep_frame_t empty_frame = { 0, UNW_X86_64_FRAME_OTHER, -1, -1, 0, -1, -1 };
@@ -63,7 +63,7 @@ trace_cache_free (void *arg)
     /* Not yet our turn to get destroyed. Re-install ourselves into the key. */
     pthread_setspecific(trace_cache_key, cache);
     Debug(5, "delayed freeing cache %p (%zx to go)\n", cache,
-	  PTHREAD_DESTRUCTOR_ITERATIONS - cache->dtor_count);
+          PTHREAD_DESTRUCTOR_ITERATIONS - cache->dtor_count);
     return;
   }
   tls_cache_destroyed = 1;
@@ -109,7 +109,7 @@ trace_cache_create (void)
     /* The current thread is in the process of exiting. Don't recreate
        cache, as we wouldn't have another chance to free it. */
     Debug(5, "refusing to reallocate cache: "
-	     "thread-locals are being deallocated\n");
+             "thread-locals are being deallocated\n");
     return NULL;
   }
 
@@ -212,11 +212,11 @@ trace_cache_get (void)
    highly unusual unwind info which uses these creatively. */
 static unw_tdep_frame_t *
 trace_init_addr (unw_tdep_frame_t *f,
-		 unw_cursor_t *cursor,
-		 unw_word_t cfa,
-		 unw_word_t rip,
-		 unw_word_t rbp,
-		 unw_word_t rsp)
+                 unw_cursor_t *cursor,
+                 unw_word_t cfa,
+                 unw_word_t rip,
+                 unw_word_t rbp,
+                 unw_word_t rsp)
 {
   struct cursor *c = (struct cursor *) cursor;
   struct dwarf_cursor *d = &c->dwarf;
@@ -258,9 +258,9 @@ trace_init_addr (unw_tdep_frame_t *f,
     f->last_frame = -1;
 
   Debug (3, "frame va %lx type %d last %d cfa %s+%d rbp @ cfa%+d rsp @ cfa%+d\n",
-	 f->virtual_address, f->frame_type, f->last_frame,
-	 f->cfa_reg_rsp ? "rsp" : "rbp", f->cfa_reg_offset,
-	 f->rbp_cfa_offset, f->rsp_cfa_offset);
+         f->virtual_address, f->frame_type, f->last_frame,
+         f->cfa_reg_rsp ? "rsp" : "rbp", f->cfa_reg_offset,
+         f->rbp_cfa_offset, f->rsp_cfa_offset);
 
   return f;
 }
@@ -271,11 +271,11 @@ trace_init_addr (unw_tdep_frame_t *f,
    frame cache slot which describes RIP. */
 static unw_tdep_frame_t *
 trace_lookup (unw_cursor_t *cursor,
-	      unw_trace_cache_t *cache,
-	      unw_word_t cfa,
-	      unw_word_t rip,
-	      unw_word_t rbp,
-	      unw_word_t rsp)
+              unw_trace_cache_t *cache,
+              unw_word_t cfa,
+              unw_word_t rip,
+              unw_word_t rbp,
+              unw_word_t rsp)
 {
   /* First look up for previously cached information using cache as
      linear probing hash table with probe step of 1.  Majority of
@@ -437,7 +437,7 @@ tdep_trace (unw_cursor_t *cursor, void **buffer, int *size)
   {
     rip -= d->use_prev_instr;
     Debug (2, "depth %d cfa 0x%lx rip 0x%lx rsp 0x%lx rbp 0x%lx\n",
-	   depth, cfa, rip, rsp, rbp);
+           depth, cfa, rip, rsp, rbp);
 
     /* See if we have this address cached.  If not, evaluate enough of
        the dwarf unwind information to fill the cache line data, or to
@@ -480,7 +480,7 @@ tdep_trace (unw_cursor_t *cursor, void **buffer, int *size)
       cfa = (f->cfa_reg_rsp ? rsp : rbp) + f->cfa_reg_offset;
       ACCESS_MEM_FAST(ret, c->validate, d, cfa - 8, rip);
       if (likely(ret >= 0) && likely(f->rbp_cfa_offset != -1))
-	ACCESS_MEM_FAST(ret, c->validate, d, cfa + f->rbp_cfa_offset, rbp);
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa + f->rbp_cfa_offset, rbp);
 
       /* Don't bother reading RSP from DWARF, CFA becomes new RSP. */
       rsp = cfa;
@@ -506,16 +506,34 @@ tdep_trace (unw_cursor_t *cursor, void **buffer, int *size)
       d->use_prev_instr = 0;
       break;
 
+    case UNW_X86_64_FRAME_ALIGNED:
+      /* Address of RIP was pushed on the stack via a simple
+       * def_cfa_expr - result stack offset stored in cfa_reg_offset */
+      cfa = (f->cfa_reg_rsp ? rsp : rbp) + f->cfa_reg_offset;
+      ACCESS_MEM_FAST(ret, c->validate, d, cfa, cfa);
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, cfa - 8, rip);
+      if (likely(ret >= 0))
+        ACCESS_MEM_FAST(ret, c->validate, d, rbp, rbp);
+
+      /* Don't bother reading RSP from DWARF, CFA becomes new RSP. */
+      rsp = cfa;
+
+      /* Next frame needs to back up for unwind info lookup. */
+      d->use_prev_instr = 1;
+
+      break;
+
     default:
       /* We cannot trace through this frame, give up and tell the
-	 caller we had to stop.  Data collected so far may still be
-	 useful to the caller, so let it know how far we got.  */
+         caller we had to stop.  Data collected so far may still be
+         useful to the caller, so let it know how far we got.  */
       ret = -UNW_ESTOPUNWIND;
       break;
     }
 
     Debug (4, "new cfa 0x%lx rip 0x%lx rsp 0x%lx rbp 0x%lx\n",
-	   cfa, rip, rsp, rbp);
+           cfa, rip, rsp, rbp);
 
     /* If we failed or ended up somewhere bogus, stop. */
     if (unlikely(ret < 0 || rip < 0x4000))
diff --git a/src/x86_64/Lapply_reg_state.c b/src/x86_64/Lapply_reg_state.c
new file mode 100644
index 0000000..7ebada4
--- /dev/null
+++ b/src/x86_64/Lapply_reg_state.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Gapply_reg_state.c"
+#endif
diff --git a/src/x86_64/Lreg_states_iterate.c b/src/x86_64/Lreg_states_iterate.c
new file mode 100644
index 0000000..f1eb1e7
--- /dev/null
+++ b/src/x86_64/Lreg_states_iterate.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if defined(UNW_LOCAL_ONLY) && !defined(UNW_REMOTE_ONLY)
+#include "Greg_states_iterate.c"
+#endif
diff --git a/src/x86_64/init.h b/src/x86_64/init.h
index e80e553..a7a996f 100644
--- a/src/x86_64/init.h
+++ b/src/x86_64/init.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -69,7 +69,7 @@ common_init (struct cursor *c, unsigned use_prev_instr)
     return ret;
 
   ret = dwarf_get (&c->dwarf, DWARF_REG_LOC (&c->dwarf, UNW_X86_64_RSP),
-		   &c->dwarf.cfa);
+                   &c->dwarf.cfa);
   if (ret < 0)
     return ret;
 
@@ -77,13 +77,13 @@ common_init (struct cursor *c, unsigned use_prev_instr)
   c->sigcontext_addr = 0;
 
   c->dwarf.args_size = 0;
-  c->dwarf.ret_addr_column = RIP;
   c->dwarf.stash_frames = 0;
   c->dwarf.use_prev_instr = use_prev_instr;
   c->dwarf.pi_valid = 0;
   c->dwarf.pi_is_dynamic = 0;
   c->dwarf.hint = 0;
   c->dwarf.prev_rs = 0;
+  c->dwarf.eh_valid_mask = 0;
 
   return 0;
 }
diff --git a/src/x86_64/is_fpreg.c b/src/x86_64/is_fpreg.c
index 030dd71..5c03613 100644
--- a/src/x86_64/is_fpreg.c
+++ b/src/x86_64/is_fpreg.c
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (c) 2004-2005 Hewlett-Packard Development Company, L.P.
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -27,12 +27,12 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "libunwind_i.h"
 
-PROTECTED int
+int
 unw_is_fpreg (int regnum)
 {
 #if 0
   return ((regnum >= UNW_X86_ST0 && regnum <= UNW_X86_ST7)
-	  || (regnum >= UNW_X86_XMM0_lo && regnum <= UNW_X86_XMM7_hi));
+          || (regnum >= UNW_X86_XMM0_lo && regnum <= UNW_X86_XMM7_hi));
 #endif
   return 0;
 }
diff --git a/src/x86_64/offsets.h b/src/x86_64/offsets.h
index 80cfe36..0807960 100644
--- a/src/x86_64/offsets.h
+++ b/src/x86_64/offsets.h
@@ -1,3 +1,3 @@
 /* FreeBSD specific definitions */
 
-#define FREEBSD_UC_MCONTEXT_OFF		0x10
+#define FREEBSD_UC_MCONTEXT_OFF         0x10
diff --git a/src/x86_64/regname.c b/src/x86_64/regname.c
index 6c0e2f3..77660af 100644
--- a/src/x86_64/regname.c
+++ b/src/x86_64/regname.c
@@ -46,7 +46,7 @@ static const char *regname[] =
     "RIP",
    };
 
-PROTECTED const char *
+const char *
 unw_regname (unw_regnum_t reg)
 {
   if (reg < (unw_regnum_t) ARRAY_SIZE (regname))
diff --git a/src/x86_64/setcontext.S b/src/x86_64/setcontext.S
index 1af8b67..358217d 100644
--- a/src/x86_64/setcontext.S
+++ b/src/x86_64/setcontext.S
@@ -25,19 +25,12 @@ OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #include "ucontext_i.h"
-#if defined __linux__
-#include <asm/unistd.h>
-#define	SIG_SETMASK   2
-#define	SIGSET_BYTE_SIZE   (64/8)
-#elif defined __FreeBSD__
-#include <sys/syscall.h>
-#endif
 
 /*  int _Ux86_64_setcontext (const ucontext_t *ucp)
 
   Restores the machine context provided.
   Unlike the libc implementation, doesn't clobber %rax
-  
+
 */
 	.global _Ux86_64_setcontext
 	.type _Ux86_64_setcontext, @function
@@ -45,32 +38,11 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 _Ux86_64_setcontext:
 
 #if defined __linux__
-	/* restore signal mask
-           sigprocmask(SIG_SETMASK, ucp->uc_sigmask, NULL, sizeof(sigset_t)) */
-	push %rdi
-	mov $__NR_rt_sigprocmask, %rax
-	lea UC_SIGMASK(%rdi), %rsi
-	mov $SIG_SETMASK, %rdi
-	xor %rdx, %rdx
-	mov $SIGSET_BYTE_SIZE, %r10
-	syscall
-	pop %rdi
-
         /* restore fp state */
 	mov    UC_MCONTEXT_FPREGS_PTR(%rdi),%r8
 	fldenv (%r8)
 	ldmxcsr FPREGS_OFFSET_MXCSR(%r8)
 #elif defined __FreeBSD__
-	/* restore signal mask */
-	pushq	%rdi
-	xorl	%edx,%edx
-	leaq	UC_SIGMASK(%rdi),%rsi
-	movl	$3,%edi/* SIG_SETMASK */
-	movl	$SYS_sigprocmask,%eax
-	movq	%rcx,%r10
-	syscall
-	popq	%rdi
-
 	/* restore fp state */
 	cmpq $UC_MCONTEXT_FPOWNED_FPU,UC_MCONTEXT_OWNEDFP(%rdi)
 	jne 1f
diff --git a/src/x86_64/ucontext_i.h b/src/x86_64/ucontext_i.h
index c1249bf..aded941 100644
--- a/src/x86_64/ucontext_i.h
+++ b/src/x86_64/ucontext_i.h
@@ -23,60 +23,60 @@ OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 #if defined __linux__
-#define UC_MCONTEXT_GREGS_R8	0x28
-#define UC_MCONTEXT_GREGS_R9	0x30
-#define UC_MCONTEXT_GREGS_R10	0x38
-#define UC_MCONTEXT_GREGS_R11	0x40
-#define UC_MCONTEXT_GREGS_R12	0x48
-#define UC_MCONTEXT_GREGS_R13	0x50
-#define UC_MCONTEXT_GREGS_R14	0x58
-#define UC_MCONTEXT_GREGS_R15	0x60
-#define UC_MCONTEXT_GREGS_RDI	0x68
-#define UC_MCONTEXT_GREGS_RSI	0x70
-#define UC_MCONTEXT_GREGS_RBP	0x78
-#define UC_MCONTEXT_GREGS_RBX	0x80
-#define UC_MCONTEXT_GREGS_RDX	0x88
-#define UC_MCONTEXT_GREGS_RAX	0x90
-#define UC_MCONTEXT_GREGS_RCX	0x98
-#define UC_MCONTEXT_GREGS_RSP	0xa0
-#define UC_MCONTEXT_GREGS_RIP	0xa8
+#define UC_MCONTEXT_GREGS_R8    0x28
+#define UC_MCONTEXT_GREGS_R9    0x30
+#define UC_MCONTEXT_GREGS_R10   0x38
+#define UC_MCONTEXT_GREGS_R11   0x40
+#define UC_MCONTEXT_GREGS_R12   0x48
+#define UC_MCONTEXT_GREGS_R13   0x50
+#define UC_MCONTEXT_GREGS_R14   0x58
+#define UC_MCONTEXT_GREGS_R15   0x60
+#define UC_MCONTEXT_GREGS_RDI   0x68
+#define UC_MCONTEXT_GREGS_RSI   0x70
+#define UC_MCONTEXT_GREGS_RBP   0x78
+#define UC_MCONTEXT_GREGS_RBX   0x80
+#define UC_MCONTEXT_GREGS_RDX   0x88
+#define UC_MCONTEXT_GREGS_RAX   0x90
+#define UC_MCONTEXT_GREGS_RCX   0x98
+#define UC_MCONTEXT_GREGS_RSP   0xa0
+#define UC_MCONTEXT_GREGS_RIP   0xa8
 #define UC_MCONTEXT_FPREGS_PTR  0x1a8
-#define UC_MCONTEXT_FPREGS_MEM	0xe0
-#define UC_SIGMASK		0x128
-#define FPREGS_OFFSET_MXCSR	0x18
+#define UC_MCONTEXT_FPREGS_MEM  0xe0
+#define UC_SIGMASK              0x128
+#define FPREGS_OFFSET_MXCSR     0x18
 #elif defined __FreeBSD__
-#define	UC_SIGMASK		0x0
-#define UC_MCONTEXT_GREGS_RDI	0x18
-#define UC_MCONTEXT_GREGS_RSI	0x20
-#define UC_MCONTEXT_GREGS_RDX	0x28
-#define UC_MCONTEXT_GREGS_RCX	0x30
-#define UC_MCONTEXT_GREGS_R8	0x38
-#define UC_MCONTEXT_GREGS_R9	0x40
-#define UC_MCONTEXT_GREGS_RAX	0x48
-#define UC_MCONTEXT_GREGS_RBX	0x50
-#define UC_MCONTEXT_GREGS_RBP	0x58
-#define UC_MCONTEXT_GREGS_R10	0x60
-#define UC_MCONTEXT_GREGS_R11	0x68
-#define UC_MCONTEXT_GREGS_R12	0x70
-#define UC_MCONTEXT_GREGS_R13	0x78
-#define UC_MCONTEXT_GREGS_R14	0x80
-#define UC_MCONTEXT_GREGS_R15	0x88
-#define UC_MCONTEXT_FS		0x94
-#define UC_MCONTEXT_GS		0x96
-#define UC_MCONTEXT_FLAGS	0xa0
-#define UC_MCONTEXT_ES		0xa4
-#define UC_MCONTEXT_DS		0xa6
-#define UC_MCONTEXT_GREGS_RIP	0xb0
-#define UC_MCONTEXT_CS		0xb8
-#define UC_MCONTEXT_RFLAGS	0xc0
-#define UC_MCONTEXT_GREGS_RSP	0xc8
-#define UC_MCONTEXT_SS		0xd0
-#define UC_MCONTEXT_MC_LEN	0xd8
-#define UC_MCONTEXT_FPFORMAT	0xe0
-#define UC_MCONTEXT_OWNEDFP	0xe8
-#define UC_MCONTEXT_FPSTATE	0xf0
-#define UC_MCONTEXT_FPOWNED_FPU	0x20001
-#define UC_MCONTEXT_FPFMT_XMM	0x10002
-#define UC_MCONTEXT_MC_LEN_VAL	0x320
+#define UC_SIGMASK              0x0
+#define UC_MCONTEXT_GREGS_RDI   0x18
+#define UC_MCONTEXT_GREGS_RSI   0x20
+#define UC_MCONTEXT_GREGS_RDX   0x28
+#define UC_MCONTEXT_GREGS_RCX   0x30
+#define UC_MCONTEXT_GREGS_R8    0x38
+#define UC_MCONTEXT_GREGS_R9    0x40
+#define UC_MCONTEXT_GREGS_RAX   0x48
+#define UC_MCONTEXT_GREGS_RBX   0x50
+#define UC_MCONTEXT_GREGS_RBP   0x58
+#define UC_MCONTEXT_GREGS_R10   0x60
+#define UC_MCONTEXT_GREGS_R11   0x68
+#define UC_MCONTEXT_GREGS_R12   0x70
+#define UC_MCONTEXT_GREGS_R13   0x78
+#define UC_MCONTEXT_GREGS_R14   0x80
+#define UC_MCONTEXT_GREGS_R15   0x88
+#define UC_MCONTEXT_FS          0x94
+#define UC_MCONTEXT_GS          0x96
+#define UC_MCONTEXT_FLAGS       0xa0
+#define UC_MCONTEXT_ES          0xa4
+#define UC_MCONTEXT_DS          0xa6
+#define UC_MCONTEXT_GREGS_RIP   0xb0
+#define UC_MCONTEXT_CS          0xb8
+#define UC_MCONTEXT_RFLAGS      0xc0
+#define UC_MCONTEXT_GREGS_RSP   0xc8
+#define UC_MCONTEXT_SS          0xd0
+#define UC_MCONTEXT_MC_LEN      0xd8
+#define UC_MCONTEXT_FPFORMAT    0xe0
+#define UC_MCONTEXT_OWNEDFP     0xe8
+#define UC_MCONTEXT_FPSTATE     0xf0
+#define UC_MCONTEXT_FPOWNED_FPU 0x20001
+#define UC_MCONTEXT_FPFMT_XMM   0x10002
+#define UC_MCONTEXT_MC_LEN_VAL  0x320
 
 #endif
diff --git a/src/x86_64/unwind_i.h b/src/x86_64/unwind_i.h
index 0f1fc0b..e95a60f 100644
--- a/src/x86_64/unwind_i.h
+++ b/src/x86_64/unwind_i.h
@@ -1,6 +1,6 @@
 /* libunwind - a platform-independent unwind library
    Copyright (C) 2002, 2005 Hewlett-Packard Co
-	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
 
    Modified for x86_64 by Max Asbock <masbock@us.ibm.com>
 
@@ -36,33 +36,33 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <sys/ucontext.h>
 
 /* DWARF column numbers for x86_64: */
-#define RAX	0
-#define RDX	1
-#define RCX	2
-#define RBX	3
-#define RSI	4
-#define RDI	5
-#define RBP	6
-#define RSP	7
-#define R8	8
-#define R9	9
-#define R10	10
-#define R11	11
-#define R12	12
-#define R13	13
-#define R14	14
-#define R15	15
-#define RIP	16
-
-#define x86_64_lock			UNW_OBJ(lock)
-#define x86_64_local_resume		UNW_OBJ(local_resume)
-#define x86_64_local_addr_space_init	UNW_OBJ(local_addr_space_init)
-#define setcontext			UNW_ARCH_OBJ (setcontext)
+#define RAX     0
+#define RDX     1
+#define RCX     2
+#define RBX     3
+#define RSI     4
+#define RDI     5
+#define RBP     6
+#define RSP     7
+#define R8      8
+#define R9      9
+#define R10     10
+#define R11     11
+#define R12     12
+#define R13     13
+#define R14     14
+#define R15     15
+#define RIP     16
+
+#define x86_64_lock                     UNW_OBJ(lock)
+#define x86_64_local_resume             UNW_OBJ(local_resume)
+#define x86_64_local_addr_space_init    UNW_OBJ(local_addr_space_init)
+#define setcontext                      UNW_ARCH_OBJ (setcontext)
 #if 0
-#define x86_64_scratch_loc		UNW_OBJ(scratch_loc)
+#define x86_64_scratch_loc              UNW_OBJ(scratch_loc)
 #endif
-#define x86_64_r_uc_addr		UNW_OBJ(r_uc_addr)
-#define x86_64_sigreturn		UNW_OBJ(sigreturn)
+#define x86_64_r_uc_addr                UNW_OBJ(r_uc_addr)
+#define x86_64_sigreturn                UNW_OBJ(sigreturn)
 
 /* By-pass calls to access_mem() when known to be safe. */
 #ifdef UNW_LOCAL_ONLY
@@ -78,7 +78,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
 extern void x86_64_local_addr_space_init (void);
 extern int x86_64_local_resume (unw_addr_space_t as, unw_cursor_t *cursor,
-			     void *arg);
+                             void *arg);
 extern int setcontext (const ucontext_t *ucp);
 
 #if 0
@@ -87,5 +87,7 @@ extern dwarf_loc_t x86_64_scratch_loc (struct cursor *c, unw_regnum_t reg);
 
 extern void *x86_64_r_uc_addr (ucontext_t *uc, int reg);
 extern NORETURN void x86_64_sigreturn (unw_cursor_t *cursor);
+#define x86_64_handle_signal_frame UNW_OBJ(handle_signal_frame)
+extern int x86_64_handle_signal_frame(unw_cursor_t *cursor);
 
 #endif /* unwind_i_h */
diff --git a/tests/Gperf-simple.c b/tests/Gperf-simple.c
index 2173406..e181918 100644
--- a/tests/Gperf-simple.c
+++ b/tests/Gperf-simple.c
@@ -249,6 +249,8 @@ main (int argc, char **argv)
 
   measure_init ();
 
+  doit ("default         ");
+
   unw_set_caching_policy (unw_local_addr_space, UNW_CACHE_NONE);
   doit ("no cache        ");
 
diff --git a/tests/Gperf-trace.c b/tests/Gperf-trace.c
index cc4fac6..4d24fa5 100644
--- a/tests/Gperf-trace.c
+++ b/tests/Gperf-trace.c
@@ -235,6 +235,8 @@ main (int argc, char **argv)
 
   measure_init ();
 
+  doit ("default         ");
+
   unw_set_caching_policy (unw_local_addr_space, UNW_CACHE_NONE);
   doit ("no cache        ");
 
diff --git a/tests/Gtest-bt.c b/tests/Gtest-bt.c
index 802dd08..beae2a3 100644
--- a/tests/Gtest-bt.c
+++ b/tests/Gtest-bt.c
@@ -37,6 +37,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <ucontext.h>
 #include <unistd.h>
 #include <libunwind.h>
 
diff --git a/tests/Gtest-resume-sig.c b/tests/Gtest-resume-sig.c
index 55eb00a..18ec65d 100644
--- a/tests/Gtest-resume-sig.c
+++ b/tests/Gtest-resume-sig.c
@@ -74,11 +74,19 @@ handler (int sig)
 #endif
 {
   unw_word_t ip;
-  sigset_t mask, oldmask;
+  sigset_t mask;
   unw_context_t uc;
   unw_cursor_t c;
   char foo;
   int ret;
+  // The test rely on SIGUSR2 mask to be cleared when the handler returns.
+  // For local context from the signal handler, there doesn't seem to be a way
+  // currently to set it so just clear the whole struct to make sure the signal mask is cleared.
+  // This should probably be fixed to avoid signal mask being set to random values
+  // by `unw_resume` if the context was not pre-zeroed.,
+  // Using the signal ucontext direction should also work automatically but currently doesn't
+  // on ARM/AArch64 (or any other archs that doesn't have a proper sigreturn implementation)
+  memset(&uc, 0x0, sizeof(uc));
 
 #if UNW_TARGET_IA64
   if (verbose)
@@ -95,17 +103,13 @@ handler (int sig)
 
       sigemptyset (&mask);
       sigaddset (&mask, SIGUSR2);
-      sigprocmask (SIG_BLOCK, &mask, &oldmask);
+      sigprocmask (SIG_BLOCK, &mask, NULL);
       kill (getpid (), SIGUSR2);	/* pend SIGUSR2 */
 
       signal (SIGUSR1, SIG_IGN);
 
       if ((ret = unw_getcontext (&uc)) < 0)
 	panic ("unw_getcontext() failed: ret=%d\n", ret);
-#if UNW_TARGET_X86_64
-      /* unw_getcontext() doesn't save signal mask to avoid a syscall */
-      uc.uc_sigmask = oldmask; 
-#endif
       if ((ret = unw_init_local (&c, &uc)) < 0)
 	panic ("unw_init_local() failed: ret=%d\n", ret);
 
@@ -115,6 +119,11 @@ handler (int sig)
       if ((ret = unw_step (&c)) < 0)		/* step to kill() */
 	panic ("unw_step(2) failed: ret=%d\n", ret);
 
+#if defined(UNW_TARGET_TILEGX)
+      if ((ret = unw_step (&c)) < 0)		/* step to signal trampoline */
+	panic ("unw_step(2) failed: ret=%d\n", ret);
+#endif
+
       if ((ret = unw_get_reg (&c, UNW_REG_IP, &ip)) < 0)
 	panic ("unw_get_reg(IP) failed: ret=%d\n", ret);
       if (verbose)
diff --git a/tests/Gtest-trace.c b/tests/Gtest-trace.c
index dcd467b..fc1f646 100644
--- a/tests/Gtest-trace.c
+++ b/tests/Gtest-trace.c
@@ -36,6 +36,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <ucontext.h>
 #include <unistd.h>
 #include <libunwind.h>
 
@@ -123,7 +124,7 @@ do_backtrace (void)
       if (labs((unw_word_t) addresses[1][i] - (unw_word_t) addresses[2][i]) > 1)
 	{
           printf ("FAILURE: backtrace() and unw_backtrace() addresses differ at %d: %p vs. %p\n",
-		  i, addresses[1][n], addresses[2][n]);
+                  i, addresses[1][i], addresses[2][i]);
           ++num_errors;
 	}
 
@@ -133,7 +134,7 @@ do_backtrace (void)
       if (labs((unw_word_t) addresses[0][i] - (unw_word_t) addresses[1][i]) > 1)
 	{
           printf ("FAILURE: unw_step() loop and backtrace() addresses differ at %d: %p vs. %p\n",
-		  i, addresses[0][n], addresses[1][n]);
+                  i, addresses[0][i], addresses[1][i]);
           ++num_errors;
 	}
 }
@@ -212,7 +213,11 @@ sighandler (int signal, void *siginfo UNUSED, void *context)
       printf (" @ %lx", (unsigned long) uc->uc_mcontext.mc_rip);
 #endif
 #elif defined UNW_TARGET_ARM
+#if defined __linux__
       printf (" @ %lx", (unsigned long) uc->uc_mcontext.arm_pc);
+#elif defined __FreeBSD__
+      printf (" @ %lx", (unsigned long) uc->uc_mcontext.__gregs[_REG_PC]);
+#endif
 #endif
       printf ("\n");
     }
diff --git a/tests/Gx64-test-dwarf-expressions.c b/tests/Gx64-test-dwarf-expressions.c
new file mode 100644
index 0000000..209f871
--- /dev/null
+++ b/tests/Gx64-test-dwarf-expressions.c
@@ -0,0 +1,68 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include <libunwind.h>
+
+static int verbose;
+static int nerrors;
+
+#define panic(args...)							  \
+	do { printf (args); ++nerrors; } while (0)
+
+// Assembly routine which sets up the stack for the test then calls another one
+// which clobbers the stack, and which in turn calls recover_register below
+extern int64_t DW_CFA_expression_testcase(int64_t regnum, int64_t height);
+
+// recover_register is called by the assembly routines. It returns the value of
+// a register at a specified height from the inner-most frame. The return value
+// is propagated back through the assembly routines to the testcase.
+extern int64_t recover_register(int64_t regnum, int64_t height)
+{
+  // Initialize cursor to current frame
+  int rc, i;
+  unw_cursor_t cursor;
+  unw_context_t context;
+  unw_getcontext(&context);
+  unw_init_local(&cursor, &context);
+  // Unwind frames until required height from inner-most frame (i.e. this one)
+  for (i = 0; i < height; ++i)
+    {
+      rc = unw_step(&cursor);
+      if (rc < 0)
+        panic("%s: unw_step failed on step %d with return code %d", __FUNCTION__, i, rc);
+      else if (rc == 0)
+        panic("%s: unw_step failed to reach the end of the stack", __FUNCTION__);
+      unw_word_t pc;
+      rc = unw_get_reg(&cursor, UNW_REG_IP, &pc);
+      if (rc < 0 || pc == 0)
+        panic("%s: unw_get_reg failed to locate the program counter", __FUNCTION__);
+    }
+  // We're now at the required height, extract register
+  uint64_t value;
+  if ((rc = unw_get_reg(&cursor, (unw_regnum_t) regnum, &value)) != 0)
+    panic("%s: unw_get_reg failed to retrieve register %lu", __FUNCTION__, regnum);
+  return value;
+}
+
+int
+main (int argc, char **argv)
+{
+  if (argc > 1)
+    verbose = 1;
+
+  if (DW_CFA_expression_testcase(12, 1) != 0)
+    panic("r12 should be clobbered at height 1 (DW_CFA_expression_inner)");
+  if (DW_CFA_expression_testcase(12, 2) != 111222333)
+    panic("r12 should be restored at height 2 (DW_CFA_expression_testcase)");
+
+  if (nerrors > 0)
+    {
+      fprintf (stderr, "FAILURE: detected %d errors\n", nerrors);
+      exit (-1);
+    }
+
+  if (verbose)
+    printf ("SUCCESS.\n");
+  return 0;
+}
diff --git a/tests/Ltest-init-local-signal-lib.c b/tests/Ltest-init-local-signal-lib.c
new file mode 100644
index 0000000..7474f71
--- /dev/null
+++ b/tests/Ltest-init-local-signal-lib.c
@@ -0,0 +1,6 @@
+#include <stdio.h>
+
+/* To prevent inlining and optimizing away */
+int foo(volatile int* f) {
+  return *f;
+}
diff --git a/tests/Ltest-init-local-signal.c b/tests/Ltest-init-local-signal.c
new file mode 100644
index 0000000..4bde218
--- /dev/null
+++ b/tests/Ltest-init-local-signal.c
@@ -0,0 +1,60 @@
+#include "libunwind.h"
+#include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <stdlib.h>
+
+#include <signal.h>
+#include <stdio.h>
+#include <assert.h>
+
+int stepper(unw_cursor_t* c) {
+  int steps = 0;
+  int ret = 1;
+  while (ret) {
+
+    ret = unw_step(c);
+    if (!ret) {
+      break;
+    }
+    steps++;
+  }
+  return steps;
+}
+
+/* Verify that we can step from both ucontext, and from getcontext()
+ * roughly the same.  This tests that the IP from ucontext is used
+ * correctly (see impl of unw_init_local2) */
+void handler(int num, siginfo_t* info, void* ucontext) {
+  unw_cursor_t c;
+  unw_context_t context;
+  unw_getcontext(&context);
+  int ret = unw_init_local2(&c, ucontext, UNW_INIT_SIGNAL_FRAME);
+  assert(!ret);
+  int ucontext_steps = stepper(&c);
+
+  ret = unw_init_local(&c, &context);
+  (void)ret;
+  assert(!ret);
+  int getcontext_steps = stepper(&c);
+  if (ucontext_steps == getcontext_steps - 2) {
+    exit(0);
+  }
+  printf("unw_getcontext steps was %i, ucontext steps was %i, should be %i\n",
+	 getcontext_steps, ucontext_steps, getcontext_steps - 2);
+  exit(-1);
+}
+
+int foo(volatile int* f);
+
+int main(){
+  struct sigaction a;
+  memset(&a, 0, sizeof(struct sigaction));
+  a.sa_sigaction = &handler;
+  a.sa_flags = SA_SIGINFO;
+  sigaction(SIGSEGV, &a, NULL);
+
+  foo(NULL);
+  return 0;
+}
diff --git a/tests/Ltest-mem-validate.c b/tests/Ltest-mem-validate.c
new file mode 100644
index 0000000..e5127b9
--- /dev/null
+++ b/tests/Ltest-mem-validate.c
@@ -0,0 +1,145 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2003-2004 Hewlett-Packard Co
+	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+This file is part of libunwind.
+
+Copyright (c) 2003 Hewlett-Packard Co.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "compiler.h"
+
+#include <libunwind.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/resource.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#define panic(args...)				\
+	{ fprintf (stderr, args); exit (-1); }
+
+void * stack_start;
+
+#define PAGE_SIZE 4096
+
+void do_backtrace (void)
+{
+  void* buffer[1024];
+  int size = 1024;
+  mprotect((void*)((uintptr_t)stack_start & ~(PAGE_SIZE - 1)),
+           PAGE_SIZE, PROT_NONE);
+
+  unw_cursor_t cursor;
+  unw_word_t ip, sp;
+  unw_context_t uc;
+  int ret;
+  int steps = 0;
+
+  unw_getcontext (&uc);
+  if (unw_init_local (&cursor, &uc) < 0)
+    panic ("unw_init_local failed!\n");
+
+  do
+    {
+      unw_get_reg (&cursor, UNW_REG_IP, &ip);
+      unw_get_reg (&cursor, UNW_REG_SP, &sp);
+
+      ret = unw_step (&cursor);
+      if (ret < 0)
+	{
+	  unw_get_reg (&cursor, UNW_REG_IP, &ip);
+	}
+      steps ++;
+    }
+  while (ret > 0);
+
+  if (steps < 5)
+    {
+      exit(-1);
+    }
+
+  mprotect((void*)((uintptr_t)stack_start & ~(PAGE_SIZE - 1)),
+           PAGE_SIZE, PROT_READ|PROT_WRITE);
+}
+
+void consume_and_run (int depth)
+{
+  unw_cursor_t cursor;
+  unw_context_t uc;
+  char string[1024];
+
+  sprintf (string, "hello %p %p\n", &cursor, &uc);
+  if (depth == 0) {
+    do_backtrace();
+  } else {
+    consume_and_run(depth - 1);
+  }
+}
+
+int
+main (int argc, char **argv UNUSED)
+{
+  int start;
+  unw_context_t uc;
+  unw_cursor_t cursor;
+
+  stack_start = &start;
+
+  // Initialize pipe mem validate check, opens file descriptors
+  unw_getcontext(&uc);
+  if (unw_init_local (&cursor, &uc) < 0)
+    panic ("unw_init_local failed!\n");
+
+  int i;
+  for (i = 3; i < 10; i++)
+    {
+
+      pid_t childpid = fork();
+      if (!childpid)
+        {
+          /* Close fds and make sure we still work */
+          int ret = close(i);
+        }
+
+      int status;
+      if (childpid)
+        {
+          wait(&status);
+          if (WIFEXITED(status))
+              return WEXITSTATUS(status);
+          else
+            return -1;
+        }
+      else
+        {
+          consume_and_run (10);
+
+          return 0;
+        }
+    }
+
+  return 0;
+}
diff --git a/tests/Lx64-test-dwarf-expressions.c b/tests/Lx64-test-dwarf-expressions.c
new file mode 100644
index 0000000..07e916e
--- /dev/null
+++ b/tests/Lx64-test-dwarf-expressions.c
@@ -0,0 +1,5 @@
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+#if !defined(UNW_REMOTE_ONLY)
+#include "Gx64-test-dwarf-expressions.c"
+#endif
diff --git a/tests/Makefile.am b/tests/Makefile.am
index a367eed..fee8a70 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -7,24 +7,27 @@ EXTRA_DIST =	run-ia64-test-dyn1 run-ptrace-mapper run-ptrace-misc	\
 
 MAINTAINERCLEANFILES = Makefile.in
 
+noinst_PROGRAMS_arch =
+noinst_PROGRAMS_cdep =
 noinst_PROGRAMS_common =
+check_PROGRAMS_arch =
+check_PROGRAMS_cdep =
 check_PROGRAMS_common = test-proc-info test-static-link \
 			test-strerror
+check_SCRIPTS_arch =
+check_SCRIPTS_cdep =
 check_SCRIPTS_common =	run-check-namespace
 
 if REMOTE_ONLY
- check_SCRIPTS_cdep =
- check_PROGRAMS_cdep =
- noinst_PROGRAMS_cdep = $(noinst_PROGRAMS_common)
 
 perf:
 
 else
  LIBUNWIND_local = $(top_builddir)/src/libunwind.la
 if ARCH_IA64
- noinst_PROGRAMS_arch = ia64-test-dyn1
- check_SCRIPTS_arch =	run-ia64-test-dyn1
- check_PROGRAMS_arch =	Gia64-test-stack Lia64-test-stack		\
+ noinst_PROGRAMS_arch += ia64-test-dyn1
+ check_SCRIPTS_arch +=	run-ia64-test-dyn1
+ check_PROGRAMS_arch +=	Gia64-test-stack Lia64-test-stack		\
 			Gia64-test-nat Lia64-test-nat			\
 			Gia64-test-rbs Lia64-test-rbs			\
 			Gia64-test-readonly Lia64-test-readonly		\
@@ -32,25 +35,37 @@ if ARCH_IA64
 else #!ARCH_IA64
 if ARCH_PPC64
 if USE_ALTIVEC
- noinst_PROGRAMS_arch = ppc64-test-altivec
+ noinst_PROGRAMS_arch += ppc64-test-altivec
 endif #USE_ALTIVEC
-endif #ARCH_PPC64
+else  #!ARCH_PPC64
+if ARCH_X86_64
+ check_PROGRAMS_arch +=	Gx64-test-dwarf-expressions Lx64-test-dwarf-expressions
+endif #ARCH X86_64
+endif #!ARCH_PPC64
 endif #!ARCH_IA64
- check_SCRIPTS_cdep =	run-ptrace-mapper run-ptrace-misc
- check_PROGRAMS_cdep =	Gtest-bt Ltest-bt Gtest-exc Ltest-exc		 \
+ check_PROGRAMS_cdep +=	Gtest-bt Ltest-bt Gtest-exc Ltest-exc		 \
 			Gtest-init Ltest-init				 \
 			Gtest-concurrent Ltest-concurrent		 \
 			Gtest-resume-sig Ltest-resume-sig		 \
 			Gtest-resume-sig-rt Ltest-resume-sig-rt		 \
-			Gtest-dyn1 Ltest-dyn1				 \
 			Gtest-trace Ltest-trace				 \
+			Ltest-init-local-signal				 \
+			Ltest-mem-validate				 \
 			test-async-sig test-flush-cache test-init-remote \
-			test-mem test-setjmp test-ptrace Ltest-varargs	 \
+			test-mem test-reg-state Ltest-varargs		 \
 			Ltest-nomalloc Ltest-nocalloc Lrs-race
- noinst_PROGRAMS_cdep = forker crasher mapper test-ptrace-misc		 \
-			Gperf-simple Lperf-simple
+ noinst_PROGRAMS_cdep += forker Gperf-simple Lperf-simple \
+			Gperf-trace Lperf-trace
 
- noinst_PROGRAMS_cdep += Gperf-trace Lperf-trace
+if BUILD_PTRACE
+ check_SCRIPTS_cdep += run-ptrace-mapper run-ptrace-misc
+ check_PROGRAMS_cdep += test-ptrace
+ noinst_PROGRAMS_cdep += mapper test-ptrace-misc
+endif
+
+if BUILD_SETJMP
+ check_PROGRAMS_cdep += test-setjmp
+endif
 
 if SUPPORT_CXX_EXCEPTIONS
  check_PROGRAMS_cdep += Ltest-cxx-exceptions
@@ -59,7 +74,7 @@ endif
 if OS_LINUX
 if BUILD_COREDUMP
  check_SCRIPTS_cdep += run-coredump-unwind
- noinst_PROGRAMS_cdep += test-coredump-unwind
+ noinst_PROGRAMS_cdep += crasher test-coredump-unwind
 
 if HAVE_LZMA
  check_SCRIPTS_cdep += run-coredump-unwind-mdi
@@ -86,6 +101,31 @@ check_SCRIPTS =	$(check_SCRIPTS_common) $(check_SCRIPTS_cdep) \
 
 
 TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
+XFAIL_TESTS =
+
+if ARCH_IA64
+ check_PROGRAMS_cdep += Gtest-dyn1 Ltest-dyn1
+endif
+
+# Use if arch defines but does not support PTRACE_SINGLESTEP
+# ptrace request used in the tests.
+XFAIL_TESTS_PTRACE_SINGLESTEP = run-ptrace-mapper run-ptrace-misc
+
+if ARCH_MIPS
+XFAIL_TESTS += $(XFAIL_TESTS_PTRACE_SINGLESTEP)
+endif
+
+if ARCH_ARM
+# ARM Linux kernel >=2.6.39 removed PTRACE_SINGLESTEP emulation
+XFAIL_TESTS += $(XFAIL_TESTS_PTRACE_SINGLESTEP)
+endif
+
+# This is meant for multilib binaries, -m32.
+# ptrace gives EBADREG when testing,
+# but generally everything else works.
+if NO_PTRACE_TEST
+ XFAIL_TESTS += run-ptrace-mapper test-ptrace Ltest-init-local-signal
+endif
 
 noinst_PROGRAMS = $(noinst_PROGRAMS_common) $(noinst_PROGRAMS_cdep) \
 	$(noinst_PROGRAMS_arch)
@@ -103,10 +143,20 @@ Gia64_test_nat_SOURCES = Gia64-test-nat.c ia64-test-nat-asm.S
 ia64_test_dyn1_SOURCES = ia64-test-dyn1.c ia64-dyn-asm.S flush-cache.S \
 				flush-cache.h
 ppc64_test_altivec_SOURCES = ppc64-test-altivec.c  ppc64-test-altivec-utils.c
+
+
+Gx64_test_dwarf_expressions_SOURCES =  Gx64-test-dwarf-expressions.c \
+																			 x64-test-dwarf-expressions.S
+Lx64_test_dwarf_expressions_SOURCES =  Lx64-test-dwarf-expressions.c \
+																			 x64-test-dwarf-expressions.S
+
+
 Gtest_init_SOURCES = Gtest-init.cxx
 Ltest_init_SOURCES = Ltest-init.cxx
 Ltest_cxx_exceptions_SOURCES = Ltest-cxx-exceptions.cxx
 
+Ltest_init_local_signal_SOURCES = Ltest-init-local-signal.c Ltest-init-local-signal-lib.c
+
 Gtest_dyn1_SOURCES = Gtest-dyn1.c flush-cache.S flush-cache.h
 Ltest_dyn1_SOURCES = Ltest-dyn1.c flush-cache.S flush-cache.h
 test_static_link_SOURCES = test-static-link-loc.c test-static-link-gen.c
@@ -119,6 +169,7 @@ Ltest_nomalloc_SOURCES = Ltest-nomalloc.c
 Ltest_nocalloc_SOURCES = Ltest-nocalloc.c
 Gtest_trace_SOURCES = Gtest-trace.c ident.c
 Ltest_trace_SOURCES = Ltest-trace.c ident.c
+Ltest_mem_validate_SOURCES = Ltest-mem-validate.c
 
 LIBUNWIND = $(top_builddir)/src/libunwind-$(arch).la
 LIBUNWIND_ptrace = $(top_builddir)/src/libunwind-ptrace.la
@@ -141,18 +192,20 @@ test_async_sig_LDADD = $(LIBUNWIND_local) -lpthread
 test_flush_cache_LDADD = $(LIBUNWIND_local)
 test_init_remote_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 test_mem_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
+test_reg_state_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 test_ptrace_LDADD = $(LIBUNWIND_ptrace) $(LIBUNWIND)
 test_proc_info_LDADD = $(LIBUNWIND)
 test_static_link_LDADD = $(LIBUNWIND)
 test_strerror_LDADD = $(LIBUNWIND)
 Lrs_race_LDADD = $(LIBUNWIND_local) -lpthread
 Ltest_varargs_LDADD = $(LIBUNWIND_local)
+Ltest_init_local_signal_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 
 Gtest_bt_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gtest_concurrent_LDADD = $(LIBUNWIND) $(LIBUNWIND_local) -lpthread
 Gtest_dyn1_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gtest_exc_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
-Gtest_init_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
+Gtest_init_LDADD = $(LIBUNWIND) $(LIBUNWIND_local) @BACKTRACELIB@
 Gtest_resume_sig_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gtest_resume_sig_rt_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gperf_simple_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
@@ -171,12 +224,13 @@ Ltest_resume_sig_rt_LDADD = $(LIBUNWIND_local)
 Lperf_simple_LDADD = $(LIBUNWIND_local)
 Ltest_trace_LDADD = $(LIBUNWIND_local)
 Lperf_trace_LDADD = $(LIBUNWIND_local)
+Ltest_mem_validate_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 
 test_setjmp_LDADD = $(LIBUNWIND_setjmp)
 ia64_test_setjmp_LDADD = $(LIBUNWIND_setjmp)
 
 if BUILD_COREDUMP
-test_coredump_unwind_LDADD = $(LIBUNWIND_coredump) $(LIBUNWIND)
+test_coredump_unwind_LDADD = $(LIBUNWIND_coredump) $(LIBUNWIND) @BACKTRACELIB@
 endif
 
 Gia64_test_nat_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
@@ -189,3 +243,7 @@ Lia64_test_rbs_LDADD = $(LIBUNWIND_local)
 Lia64_test_readonly_LDADD = $(LIBUNWIND_local)
 ia64_test_dyn1_LDADD = $(LIBUNWIND)
 ia64_test_sig_LDADD = $(LIBUNWIND)
+ppc64_test_altivec_LDADD = $(LIBUNWIND)
+
+Gx64_test_dwarf_expressions_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
+Lx64_test_dwarf_expressions_LDADD = $(LIBUNWIND_local)
diff --git a/tests/Makefile.in b/tests/Makefile.in
index 0bd784a..8d4d8da 100644
--- a/tests/Makefile.in
+++ b/tests/Makefile.in
@@ -1,9 +1,8 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.13.4 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +15,51 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -35,15 +79,56 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-@REMOTE_ONLY_FALSE@@SUPPORT_CXX_EXCEPTIONS_TRUE@am__append_1 = Ltest-cxx-exceptions
-@BUILD_COREDUMP_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__append_2 = run-coredump-unwind
-@BUILD_COREDUMP_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__append_3 = test-coredump-unwind
-@BUILD_COREDUMP_TRUE@@HAVE_LZMA_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__append_4 = run-coredump-unwind-mdi
-check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_3) $(am__EXEEXT_4)
-noinst_PROGRAMS = $(am__EXEEXT_5) $(am__EXEEXT_7) $(am__EXEEXT_8)
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__append_1 = ia64-test-dyn1
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__append_2 = run-ia64-test-dyn1
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__append_3 = Gia64-test-stack Lia64-test-stack		\
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			Gia64-test-nat Lia64-test-nat			\
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			Gia64-test-rbs Lia64-test-rbs			\
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			Gia64-test-readonly Lia64-test-readonly		\
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			ia64-test-setjmp ia64-test-sig
+
+@ARCH_IA64_FALSE@@ARCH_PPC64_TRUE@@REMOTE_ONLY_FALSE@@USE_ALTIVEC_TRUE@am__append_4 = ppc64-test-altivec
+@ARCH_IA64_FALSE@@ARCH_PPC64_FALSE@@ARCH_X86_64_TRUE@@REMOTE_ONLY_FALSE@am__append_5 = Gx64-test-dwarf-expressions Lx64-test-dwarf-expressions
+@REMOTE_ONLY_FALSE@am__append_6 = Gtest-bt Ltest-bt Gtest-exc Ltest-exc		 \
+@REMOTE_ONLY_FALSE@			Gtest-init Ltest-init				 \
+@REMOTE_ONLY_FALSE@			Gtest-concurrent Ltest-concurrent		 \
+@REMOTE_ONLY_FALSE@			Gtest-resume-sig Ltest-resume-sig		 \
+@REMOTE_ONLY_FALSE@			Gtest-resume-sig-rt Ltest-resume-sig-rt		 \
+@REMOTE_ONLY_FALSE@			Gtest-trace Ltest-trace				 \
+@REMOTE_ONLY_FALSE@			Ltest-init-local-signal				 \
+@REMOTE_ONLY_FALSE@			Ltest-mem-validate				 \
+@REMOTE_ONLY_FALSE@			test-async-sig test-flush-cache test-init-remote \
+@REMOTE_ONLY_FALSE@			test-mem test-reg-state Ltest-varargs		 \
+@REMOTE_ONLY_FALSE@			Ltest-nomalloc Ltest-nocalloc Lrs-race
+
+@REMOTE_ONLY_FALSE@am__append_7 = forker Gperf-simple Lperf-simple \
+@REMOTE_ONLY_FALSE@			Gperf-trace Lperf-trace
+
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@am__append_8 = run-ptrace-mapper run-ptrace-misc
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@am__append_9 = test-ptrace
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@am__append_10 = mapper test-ptrace-misc
+@BUILD_SETJMP_TRUE@@REMOTE_ONLY_FALSE@am__append_11 = test-setjmp
+@REMOTE_ONLY_FALSE@@SUPPORT_CXX_EXCEPTIONS_TRUE@am__append_12 = Ltest-cxx-exceptions
+@BUILD_COREDUMP_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__append_13 = run-coredump-unwind
+@BUILD_COREDUMP_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__append_14 = crasher test-coredump-unwind
+@BUILD_COREDUMP_TRUE@@HAVE_LZMA_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__append_15 = run-coredump-unwind-mdi
+check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_7) $(am__EXEEXT_10)
+XFAIL_TESTS = $(am__append_17) $(am__append_18) $(am__EXEEXT_19)
+@ARCH_IA64_TRUE@am__append_16 = Gtest-dyn1 Ltest-dyn1
+@ARCH_MIPS_TRUE@am__append_17 = $(XFAIL_TESTS_PTRACE_SINGLESTEP)
+
+# ARM Linux kernel >=2.6.39 removed PTRACE_SINGLESTEP emulation
+@ARCH_ARM_TRUE@am__append_18 = $(XFAIL_TESTS_PTRACE_SINGLESTEP)
+
+# This is meant for multilib binaries, -m32.
+# ptrace gives EBADREG when testing,
+# but generally everything else works.
+@NO_PTRACE_TEST_TRUE@am__append_19 = run-ptrace-mapper test-ptrace Ltest-init-local-signal
+noinst_PROGRAMS = $(am__EXEEXT_11) $(am__EXEEXT_15) $(am__EXEEXT_18)
 subdir = tests
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(srcdir)/check-namespace.sh.in
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(srcdir)/check-namespace.sh.in $(top_srcdir)/config/depcomp \
+	$(top_srcdir)/config/test-driver
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
 	$(top_srcdir)/configure.ac
@@ -55,8 +140,7 @@ CONFIG_CLEAN_FILES = check-namespace.sh
 CONFIG_CLEAN_VPATH_FILES =
 am__EXEEXT_1 = test-proc-info$(EXEEXT) test-static-link$(EXEEXT) \
 	test-strerror$(EXEEXT)
-@REMOTE_ONLY_FALSE@@SUPPORT_CXX_EXCEPTIONS_TRUE@am__EXEEXT_2 = Ltest-cxx-exceptions$(EXEEXT)
-@REMOTE_ONLY_FALSE@am__EXEEXT_3 = Gtest-bt$(EXEEXT) Ltest-bt$(EXEEXT) \
+@REMOTE_ONLY_FALSE@am__EXEEXT_2 = Gtest-bt$(EXEEXT) Ltest-bt$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Gtest-exc$(EXEEXT) Ltest-exc$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Gtest-init$(EXEEXT) Ltest-init$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Gtest-concurrent$(EXEEXT) \
@@ -65,18 +149,25 @@ am__EXEEXT_1 = test-proc-info$(EXEEXT) test-static-link$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Ltest-resume-sig$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Gtest-resume-sig-rt$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Ltest-resume-sig-rt$(EXEEXT) \
-@REMOTE_ONLY_FALSE@	Gtest-dyn1$(EXEEXT) Ltest-dyn1$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Gtest-trace$(EXEEXT) Ltest-trace$(EXEEXT) \
+@REMOTE_ONLY_FALSE@	Ltest-init-local-signal$(EXEEXT) \
+@REMOTE_ONLY_FALSE@	Ltest-mem-validate$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	test-async-sig$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	test-flush-cache$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	test-init-remote$(EXEEXT) test-mem$(EXEEXT) \
-@REMOTE_ONLY_FALSE@	test-setjmp$(EXEEXT) test-ptrace$(EXEEXT) \
+@REMOTE_ONLY_FALSE@	test-reg-state$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Ltest-varargs$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Ltest-nomalloc$(EXEEXT) \
-@REMOTE_ONLY_FALSE@	Ltest-nocalloc$(EXEEXT) Lrs-race$(EXEEXT) \
-@REMOTE_ONLY_FALSE@	$(am__EXEEXT_2)
-@REMOTE_ONLY_TRUE@am__EXEEXT_3 = $(am__EXEEXT_2)
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_4 =  \
+@REMOTE_ONLY_FALSE@	Ltest-nocalloc$(EXEEXT) Lrs-race$(EXEEXT)
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_3 =  \
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@	test-ptrace$(EXEEXT)
+@BUILD_SETJMP_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_4 =  \
+@BUILD_SETJMP_TRUE@@REMOTE_ONLY_FALSE@	test-setjmp$(EXEEXT)
+@REMOTE_ONLY_FALSE@@SUPPORT_CXX_EXCEPTIONS_TRUE@am__EXEEXT_5 = Ltest-cxx-exceptions$(EXEEXT)
+@ARCH_IA64_TRUE@am__EXEEXT_6 = Gtest-dyn1$(EXEEXT) Ltest-dyn1$(EXEEXT)
+am__EXEEXT_7 = $(am__EXEEXT_2) $(am__EXEEXT_3) $(am__EXEEXT_4) \
+	$(am__EXEEXT_5) $(am__EXEEXT_6)
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_8 =  \
 @ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@	Gia64-test-stack$(EXEEXT) \
 @ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@	Lia64-test-stack$(EXEEXT) \
 @ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@	Gia64-test-nat$(EXEEXT) \
@@ -87,22 +178,31 @@ am__EXEEXT_1 = test-proc-info$(EXEEXT) test-static-link$(EXEEXT) \
 @ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@	Lia64-test-readonly$(EXEEXT) \
 @ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@	ia64-test-setjmp$(EXEEXT) \
 @ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@	ia64-test-sig$(EXEEXT)
-am__EXEEXT_5 =
-@BUILD_COREDUMP_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_6 = test-coredump-unwind$(EXEEXT)
-@REMOTE_ONLY_FALSE@am__EXEEXT_7 = forker$(EXEEXT) crasher$(EXEEXT) \
-@REMOTE_ONLY_FALSE@	mapper$(EXEEXT) test-ptrace-misc$(EXEEXT) \
+@ARCH_IA64_FALSE@@ARCH_PPC64_FALSE@@ARCH_X86_64_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_9 = Gx64-test-dwarf-expressions$(EXEEXT) \
+@ARCH_IA64_FALSE@@ARCH_PPC64_FALSE@@ARCH_X86_64_TRUE@@REMOTE_ONLY_FALSE@	Lx64-test-dwarf-expressions$(EXEEXT)
+am__EXEEXT_10 = $(am__EXEEXT_8) $(am__EXEEXT_9)
+am__EXEEXT_11 =
+@REMOTE_ONLY_FALSE@am__EXEEXT_12 = forker$(EXEEXT) \
 @REMOTE_ONLY_FALSE@	Gperf-simple$(EXEEXT) Lperf-simple$(EXEEXT) \
-@REMOTE_ONLY_FALSE@	Gperf-trace$(EXEEXT) Lperf-trace$(EXEEXT) \
-@REMOTE_ONLY_FALSE@	$(am__EXEEXT_6)
-@REMOTE_ONLY_TRUE@am__EXEEXT_7 = $(am__EXEEXT_5) $(am__EXEEXT_6)
-@ARCH_IA64_FALSE@@ARCH_PPC64_TRUE@@REMOTE_ONLY_FALSE@@USE_ALTIVEC_TRUE@am__EXEEXT_8 = ppc64-test-altivec$(EXEEXT)
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_8 =  \
+@REMOTE_ONLY_FALSE@	Gperf-trace$(EXEEXT) Lperf-trace$(EXEEXT)
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_13 = mapper$(EXEEXT) \
+@BUILD_PTRACE_TRUE@@REMOTE_ONLY_FALSE@	test-ptrace-misc$(EXEEXT)
+@BUILD_COREDUMP_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_14 = crasher$(EXEEXT) \
+@BUILD_COREDUMP_TRUE@@OS_LINUX_TRUE@@REMOTE_ONLY_FALSE@	test-coredump-unwind$(EXEEXT)
+am__EXEEXT_15 = $(am__EXEEXT_12) $(am__EXEEXT_13) $(am__EXEEXT_14)
+@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@am__EXEEXT_16 =  \
 @ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@	ia64-test-dyn1$(EXEEXT)
+@ARCH_IA64_FALSE@@ARCH_PPC64_TRUE@@REMOTE_ONLY_FALSE@@USE_ALTIVEC_TRUE@am__EXEEXT_17 = ppc64-test-altivec$(EXEEXT)
+am__EXEEXT_18 = $(am__EXEEXT_16) $(am__EXEEXT_17)
 PROGRAMS = $(noinst_PROGRAMS)
 am_Gia64_test_nat_OBJECTS = Gia64-test-nat.$(OBJEXT) \
 	ia64-test-nat-asm.$(OBJEXT)
 Gia64_test_nat_OBJECTS = $(am_Gia64_test_nat_OBJECTS)
 Gia64_test_nat_DEPENDENCIES = $(LIBUNWIND) $(LIBUNWIND_local)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 am_Gia64_test_rbs_OBJECTS = Gia64-test-rbs.$(OBJEXT) \
 	ia64-test-rbs-asm.$(OBJEXT)
 Gia64_test_rbs_OBJECTS = $(am_Gia64_test_rbs_OBJECTS)
@@ -145,6 +245,13 @@ Gtest_resume_sig_rt_DEPENDENCIES = $(LIBUNWIND) $(LIBUNWIND_local)
 am_Gtest_trace_OBJECTS = Gtest-trace.$(OBJEXT) ident.$(OBJEXT)
 Gtest_trace_OBJECTS = $(am_Gtest_trace_OBJECTS)
 Gtest_trace_DEPENDENCIES = $(LIBUNWIND) $(LIBUNWIND_local)
+am_Gx64_test_dwarf_expressions_OBJECTS =  \
+	Gx64-test-dwarf-expressions.$(OBJEXT) \
+	x64-test-dwarf-expressions.$(OBJEXT)
+Gx64_test_dwarf_expressions_OBJECTS =  \
+	$(am_Gx64_test_dwarf_expressions_OBJECTS)
+Gx64_test_dwarf_expressions_DEPENDENCIES = $(LIBUNWIND) \
+	$(LIBUNWIND_local)
 am_Lia64_test_nat_OBJECTS = Lia64-test-nat.$(OBJEXT) \
 	ia64-test-nat-asm.$(OBJEXT)
 Lia64_test_nat_OBJECTS = $(am_Lia64_test_nat_OBJECTS)
@@ -188,6 +295,15 @@ Ltest_exc_DEPENDENCIES = $(LIBUNWIND_local)
 am_Ltest_init_OBJECTS = Ltest-init.$(OBJEXT)
 Ltest_init_OBJECTS = $(am_Ltest_init_OBJECTS)
 Ltest_init_DEPENDENCIES = $(LIBUNWIND_local)
+am_Ltest_init_local_signal_OBJECTS =  \
+	Ltest-init-local-signal.$(OBJEXT) \
+	Ltest-init-local-signal-lib.$(OBJEXT)
+Ltest_init_local_signal_OBJECTS =  \
+	$(am_Ltest_init_local_signal_OBJECTS)
+Ltest_init_local_signal_DEPENDENCIES = $(LIBUNWIND) $(LIBUNWIND_local)
+am_Ltest_mem_validate_OBJECTS = Ltest-mem-validate.$(OBJEXT)
+Ltest_mem_validate_OBJECTS = $(am_Ltest_mem_validate_OBJECTS)
+Ltest_mem_validate_DEPENDENCIES = $(LIBUNWIND) $(LIBUNWIND_local)
 am_Ltest_nocalloc_OBJECTS = Ltest-nocalloc.$(OBJEXT)
 Ltest_nocalloc_OBJECTS = $(am_Ltest_nocalloc_OBJECTS)
 Ltest_nocalloc_DEPENDENCIES = $(LIBUNWIND_local)
@@ -206,15 +322,21 @@ Ltest_trace_DEPENDENCIES = $(LIBUNWIND_local)
 Ltest_varargs_SOURCES = Ltest-varargs.c
 Ltest_varargs_OBJECTS = Ltest-varargs.$(OBJEXT)
 Ltest_varargs_DEPENDENCIES = $(LIBUNWIND_local)
+am_Lx64_test_dwarf_expressions_OBJECTS =  \
+	Lx64-test-dwarf-expressions.$(OBJEXT) \
+	x64-test-dwarf-expressions.$(OBJEXT)
+Lx64_test_dwarf_expressions_OBJECTS =  \
+	$(am_Lx64_test_dwarf_expressions_OBJECTS)
+Lx64_test_dwarf_expressions_DEPENDENCIES = $(LIBUNWIND_local)
 crasher_SOURCES = crasher.c
 crasher_OBJECTS = crasher.$(OBJEXT)
 crasher_LDADD = $(LDADD)
 forker_SOURCES = forker.c
 forker_OBJECTS = forker.$(OBJEXT)
 forker_LDADD = $(LDADD)
-forker_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(forker_LDFLAGS) \
-	$(LDFLAGS) -o $@
+forker_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(forker_LDFLAGS) $(LDFLAGS) -o $@
 am_ia64_test_dyn1_OBJECTS = ia64-test-dyn1.$(OBJEXT) \
 	ia64-dyn-asm.$(OBJEXT) flush-cache.$(OBJEXT)
 ia64_test_dyn1_OBJECTS = $(am_ia64_test_dyn1_OBJECTS)
@@ -231,7 +353,7 @@ mapper_LDADD = $(LDADD)
 am_ppc64_test_altivec_OBJECTS = ppc64-test-altivec.$(OBJEXT) \
 	ppc64-test-altivec-utils.$(OBJEXT)
 ppc64_test_altivec_OBJECTS = $(am_ppc64_test_altivec_OBJECTS)
-ppc64_test_altivec_LDADD = $(LDADD)
+ppc64_test_altivec_DEPENDENCIES = $(LIBUNWIND)
 test_async_sig_SOURCES = test-async-sig.c
 test_async_sig_OBJECTS = test-async-sig.$(OBJEXT)
 test_async_sig_DEPENDENCIES = $(LIBUNWIND_local)
@@ -258,6 +380,9 @@ am_test_ptrace_misc_OBJECTS = test-ptrace-misc.$(OBJEXT) \
 	ident.$(OBJEXT)
 test_ptrace_misc_OBJECTS = $(am_test_ptrace_misc_OBJECTS)
 test_ptrace_misc_LDADD = $(LDADD)
+test_reg_state_SOURCES = test-reg-state.c
+test_reg_state_OBJECTS = test-reg-state.$(OBJEXT)
+test_reg_state_DEPENDENCIES = $(LIBUNWIND) $(LIBUNWIND_local)
 test_setjmp_SOURCES = test-setjmp.c
 test_setjmp_OBJECTS = test-setjmp.$(OBJEXT)
 test_setjmp_DEPENDENCIES = $(LIBUNWIND_setjmp)
@@ -265,92 +390,361 @@ am_test_static_link_OBJECTS = test-static-link-loc.$(OBJEXT) \
 	test-static-link-gen.$(OBJEXT)
 test_static_link_OBJECTS = $(am_test_static_link_OBJECTS)
 test_static_link_DEPENDENCIES = $(LIBUNWIND)
-test_static_link_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(test_static_link_LDFLAGS) $(LDFLAGS) -o $@
+test_static_link_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(test_static_link_LDFLAGS) $(LDFLAGS) \
+	-o $@
 test_strerror_SOURCES = test-strerror.c
 test_strerror_OBJECTS = test-strerror.$(OBJEXT)
 test_strerror_DEPENDENCIES = $(LIBUNWIND)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/include
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
 CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)
-LTCPPASCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)
+LTCPPASCOMPILE = $(LIBTOOL) $(AM_V_lt) $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CCASFLAGS) $(CCASFLAGS)
+AM_V_CPPAS = $(am__v_CPPAS_@AM_V@)
+am__v_CPPAS_ = $(am__v_CPPAS_@AM_DEFAULT_V@)
+am__v_CPPAS_0 = @echo "  CPPAS   " $@;
+am__v_CPPAS_1 = 
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
 CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
-	$(LDFLAGS) -o $@
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
 CXXLD = $(CXX)
-CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \
-	$(LDFLAGS) -o $@
+CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
+	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
 SOURCES = $(Gia64_test_nat_SOURCES) $(Gia64_test_rbs_SOURCES) \
 	$(Gia64_test_readonly_SOURCES) $(Gia64_test_stack_SOURCES) \
 	Gperf-simple.c Gperf-trace.c $(Gtest_bt_SOURCES) \
 	Gtest-concurrent.c $(Gtest_dyn1_SOURCES) Gtest-exc.c \
 	$(Gtest_init_SOURCES) Gtest-resume-sig.c Gtest-resume-sig-rt.c \
-	$(Gtest_trace_SOURCES) $(Lia64_test_nat_SOURCES) \
-	$(Lia64_test_rbs_SOURCES) $(Lia64_test_readonly_SOURCES) \
-	$(Lia64_test_stack_SOURCES) Lperf-simple.c Lperf-trace.c \
-	Lrs-race.c $(Ltest_bt_SOURCES) Ltest-concurrent.c \
-	$(Ltest_cxx_exceptions_SOURCES) $(Ltest_dyn1_SOURCES) \
-	Ltest-exc.c $(Ltest_init_SOURCES) $(Ltest_nocalloc_SOURCES) \
+	$(Gtest_trace_SOURCES) $(Gx64_test_dwarf_expressions_SOURCES) \
+	$(Lia64_test_nat_SOURCES) $(Lia64_test_rbs_SOURCES) \
+	$(Lia64_test_readonly_SOURCES) $(Lia64_test_stack_SOURCES) \
+	Lperf-simple.c Lperf-trace.c Lrs-race.c $(Ltest_bt_SOURCES) \
+	Ltest-concurrent.c $(Ltest_cxx_exceptions_SOURCES) \
+	$(Ltest_dyn1_SOURCES) Ltest-exc.c $(Ltest_init_SOURCES) \
+	$(Ltest_init_local_signal_SOURCES) \
+	$(Ltest_mem_validate_SOURCES) $(Ltest_nocalloc_SOURCES) \
 	$(Ltest_nomalloc_SOURCES) Ltest-resume-sig.c \
 	Ltest-resume-sig-rt.c $(Ltest_trace_SOURCES) Ltest-varargs.c \
-	crasher.c forker.c $(ia64_test_dyn1_SOURCES) \
-	ia64-test-setjmp.c ia64-test-sig.c mapper.c \
-	$(ppc64_test_altivec_SOURCES) test-async-sig.c \
+	$(Lx64_test_dwarf_expressions_SOURCES) crasher.c forker.c \
+	$(ia64_test_dyn1_SOURCES) ia64-test-setjmp.c ia64-test-sig.c \
+	mapper.c $(ppc64_test_altivec_SOURCES) test-async-sig.c \
 	test-coredump-unwind.c test-flush-cache.c test-init-remote.c \
 	test-mem.c test-proc-info.c test-ptrace.c \
-	$(test_ptrace_misc_SOURCES) test-setjmp.c \
+	$(test_ptrace_misc_SOURCES) test-reg-state.c test-setjmp.c \
 	$(test_static_link_SOURCES) test-strerror.c
 DIST_SOURCES = $(Gia64_test_nat_SOURCES) $(Gia64_test_rbs_SOURCES) \
 	$(Gia64_test_readonly_SOURCES) $(Gia64_test_stack_SOURCES) \
 	Gperf-simple.c Gperf-trace.c $(Gtest_bt_SOURCES) \
 	Gtest-concurrent.c $(Gtest_dyn1_SOURCES) Gtest-exc.c \
 	$(Gtest_init_SOURCES) Gtest-resume-sig.c Gtest-resume-sig-rt.c \
-	$(Gtest_trace_SOURCES) $(Lia64_test_nat_SOURCES) \
-	$(Lia64_test_rbs_SOURCES) $(Lia64_test_readonly_SOURCES) \
-	$(Lia64_test_stack_SOURCES) Lperf-simple.c Lperf-trace.c \
-	Lrs-race.c $(Ltest_bt_SOURCES) Ltest-concurrent.c \
-	$(Ltest_cxx_exceptions_SOURCES) $(Ltest_dyn1_SOURCES) \
-	Ltest-exc.c $(Ltest_init_SOURCES) $(Ltest_nocalloc_SOURCES) \
+	$(Gtest_trace_SOURCES) $(Gx64_test_dwarf_expressions_SOURCES) \
+	$(Lia64_test_nat_SOURCES) $(Lia64_test_rbs_SOURCES) \
+	$(Lia64_test_readonly_SOURCES) $(Lia64_test_stack_SOURCES) \
+	Lperf-simple.c Lperf-trace.c Lrs-race.c $(Ltest_bt_SOURCES) \
+	Ltest-concurrent.c $(Ltest_cxx_exceptions_SOURCES) \
+	$(Ltest_dyn1_SOURCES) Ltest-exc.c $(Ltest_init_SOURCES) \
+	$(Ltest_init_local_signal_SOURCES) \
+	$(Ltest_mem_validate_SOURCES) $(Ltest_nocalloc_SOURCES) \
 	$(Ltest_nomalloc_SOURCES) Ltest-resume-sig.c \
 	Ltest-resume-sig-rt.c $(Ltest_trace_SOURCES) Ltest-varargs.c \
-	crasher.c forker.c $(ia64_test_dyn1_SOURCES) \
-	ia64-test-setjmp.c ia64-test-sig.c mapper.c \
-	$(ppc64_test_altivec_SOURCES) test-async-sig.c \
+	$(Lx64_test_dwarf_expressions_SOURCES) crasher.c forker.c \
+	$(ia64_test_dyn1_SOURCES) ia64-test-setjmp.c ia64-test-sig.c \
+	mapper.c $(ppc64_test_altivec_SOURCES) test-async-sig.c \
 	test-coredump-unwind.c test-flush-cache.c test-init-remote.c \
 	test-mem.c test-proc-info.c test-ptrace.c \
-	$(test_ptrace_misc_SOURCES) test-setjmp.c \
+	$(test_ptrace_misc_SOURCES) test-reg-state.c test-setjmp.c \
 	$(test_static_link_SOURCES) test-strerror.c
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
-am__tty_colors = \
-red=; grn=; lgn=; blu=; std=
+am__tty_colors_dummy = \
+  mgn= red= grn= lgn= blu= brg= std=; \
+  am__color_tests=no
+am__tty_colors = { \
+  $(am__tty_colors_dummy); \
+  if test "X$(AM_COLOR_TESTS)" = Xno; then \
+    am__color_tests=no; \
+  elif test "X$(AM_COLOR_TESTS)" = Xalways; then \
+    am__color_tests=yes; \
+  elif test "X$$TERM" != Xdumb && { test -t 1; } 2>/dev/null; then \
+    am__color_tests=yes; \
+  fi; \
+  if test $$am__color_tests = yes; then \
+    red='[0;31m'; \
+    grn='[0;32m'; \
+    lgn='[1;32m'; \
+    blu='[1;34m'; \
+    mgn='[0;35m'; \
+    brg='[1m'; \
+    std='[m'; \
+  fi; \
+}
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__recheck_rx = ^[ 	]*:recheck:[ 	]*
+am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*
+am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*
+# A command that, given a newline-separated list of test names on the
+# standard input, print the name of the tests that are to be re-run
+# upon "make recheck".
+am__list_recheck_tests = $(AWK) '{ \
+  recheck = 1; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+        { \
+          if ((getline line2 < ($$0 ".log")) < 0) \
+	    recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[nN][Oo]/) \
+        { \
+          recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[yY][eE][sS]/) \
+        { \
+          break; \
+        } \
+    }; \
+  if (recheck) \
+    print $$0; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# A command that, given a newline-separated list of test names on the
+# standard input, create the global log from their .trs and .log files.
+am__create_global_log = $(AWK) ' \
+function fatal(msg) \
+{ \
+  print "fatal: making $@: " msg | "cat >&2"; \
+  exit 1; \
+} \
+function rst_section(header) \
+{ \
+  print header; \
+  len = length(header); \
+  for (i = 1; i <= len; i = i + 1) \
+    printf "="; \
+  printf "\n\n"; \
+} \
+{ \
+  copy_in_global_log = 1; \
+  global_test_result = "RUN"; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+         fatal("failed to read from " $$0 ".trs"); \
+      if (line ~ /$(am__global_test_result_rx)/) \
+        { \
+          sub("$(am__global_test_result_rx)", "", line); \
+          sub("[ 	]*$$", "", line); \
+          global_test_result = line; \
+        } \
+      else if (line ~ /$(am__copy_in_global_log_rx)[nN][oO]/) \
+        copy_in_global_log = 0; \
+    }; \
+  if (copy_in_global_log) \
+    { \
+      rst_section(global_test_result ": " $$0); \
+      while ((rc = (getline line < ($$0 ".log"))) != 0) \
+      { \
+        if (rc < 0) \
+          fatal("failed to read from " $$0 ".log"); \
+        print line; \
+      }; \
+      printf "\n"; \
+    }; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# Restructured Text title.
+am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }
+# Solaris 10 'make', and several other traditional 'make' implementations,
+# pass "-e" to $(SHELL), and POSIX 2008 even requires this.  Work around it
+# by disabling -e (using the XSI extension "set +e") if it's set.
+am__sh_e_setup = case $$- in *e*) set +e;; esac
+# Default flags passed to test drivers.
+am__common_driver_flags = \
+  --color-tests "$$am__color_tests" \
+  --enable-hard-errors "$$am__enable_hard_errors" \
+  --expect-failure "$$am__expect_failure"
+# To be inserted before the command running the test.  Creates the
+# directory for the log if needed.  Stores in $dir the directory
+# containing $f, in $tst the test, in $log the log.  Executes the
+# developer- defined test setup AM_TESTS_ENVIRONMENT (if any), and
+# passes TESTS_ENVIRONMENT.  Set up options for the wrapper that
+# will run the test scripts (or their associated LOG_COMPILER, if
+# thy have one).
+am__check_pre = \
+$(am__sh_e_setup);					\
+$(am__vpath_adj_setup) $(am__vpath_adj)			\
+$(am__tty_colors);					\
+srcdir=$(srcdir); export srcdir;			\
+case "$@" in						\
+  */*) am__odir=`echo "./$@" | sed 's|/[^/]*$$||'`;;	\
+    *) am__odir=.;; 					\
+esac;							\
+test "x$$am__odir" = x"." || test -d "$$am__odir" 	\
+  || $(MKDIR_P) "$$am__odir" || exit $$?;		\
+if test -f "./$$f"; then dir=./;			\
+elif test -f "$$f"; then dir=;				\
+else dir="$(srcdir)/"; fi;				\
+tst=$$dir$$f; log='$@'; 				\
+if test -n '$(DISABLE_HARD_ERRORS)'; then		\
+  am__enable_hard_errors=no; 				\
+else							\
+  am__enable_hard_errors=yes; 				\
+fi; 							\
+case " $(XFAIL_TESTS) " in				\
+  *[\ \	]$$f[\ \	]* | *[\ \	]$$dir$$f[\ \	]*) \
+    am__expect_failure=yes;;				\
+  *)							\
+    am__expect_failure=no;;				\
+esac; 							\
+$(AM_TESTS_ENVIRONMENT) $(TESTS_ENVIRONMENT)
+# A shell command to get the names of the tests scripts with any registered
+# extension removed (i.e., equivalently, the names of the test logs, with
+# the '.log' extension removed).  The result is saved in the shell variable
+# '$bases'.  This honors runtime overriding of TESTS and TEST_LOGS.  Sadly,
+# we cannot use something simpler, involving e.g., "$(TEST_LOGS:.log=)",
+# since that might cause problem with VPATH rewrites for suffix-less tests.
+# See also 'test-harness-vpath-rewrite.sh' and 'test-trs-basic.sh'.
+am__set_TESTS_bases = \
+  bases='$(TEST_LOGS)'; \
+  bases=`for i in $$bases; do echo $$i; done | sed 's/\.log$$//'`; \
+  bases=`echo $$bases`
+RECHECK_LOGS = $(TEST_LOGS)
+AM_RECURSIVE_TARGETS = check recheck
+@NO_PTRACE_TEST_TRUE@am__EXEEXT_19 = run-ptrace-mapper \
+@NO_PTRACE_TEST_TRUE@	test-ptrace$(EXEEXT) \
+@NO_PTRACE_TEST_TRUE@	Ltest-init-local-signal$(EXEEXT)
+TEST_SUITE_LOG = test-suite.log
+TEST_EXTENSIONS = @EXEEXT@ .test
+LOG_DRIVER = $(SHELL) $(top_srcdir)/config/test-driver
+LOG_COMPILE = $(LOG_COMPILER) $(AM_LOG_FLAGS) $(LOG_FLAGS)
+am__set_b = \
+  case '$@' in \
+    */*) \
+      case '$*' in \
+        */*) b='$*';; \
+          *) b=`echo '$@' | sed 's/\.log$$//'`; \
+       esac;; \
+    *) \
+      b='$*';; \
+  esac
+am__test_logs1 = $(TESTS:=.log)
+am__test_logs2 = $(am__test_logs1:@EXEEXT@.log=.log)
+TEST_LOGS = $(am__test_logs2:.test.log=.log)
+TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)/config/test-driver
+TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \
+	$(TEST_LOG_FLAGS)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AR = @AR@
 ARCH = @ARCH@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BACKTRACELIB = @BACKTRACELIB@
 CC = @CC@
 CCAS = @CCAS@
 CCASDEPMODE = @CCASDEPMODE@
@@ -382,8 +776,10 @@ INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LATEX2MAN = @LATEX2MAN@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
+LDFLAGS_NOSTARTFILES = @LDFLAGS_NOSTARTFILES@
 LDFLAGS_STATIC_LIBCXA = @LDFLAGS_STATIC_LIBCXA@
 LIBCRTS = @LIBCRTS@
 LIBLZMA = @LIBLZMA@
@@ -489,45 +885,28 @@ EXTRA_DIST = run-ia64-test-dyn1 run-ptrace-mapper run-ptrace-misc	\
 		Gtest-nomalloc.c
 
 MAINTAINERCLEANFILES = Makefile.in
+noinst_PROGRAMS_arch = $(am__append_1) $(am__append_4)
+noinst_PROGRAMS_cdep = $(am__append_7) $(am__append_10) \
+	$(am__append_14)
 noinst_PROGRAMS_common = 
+check_PROGRAMS_arch = $(am__append_3) $(am__append_5)
+check_PROGRAMS_cdep = $(am__append_6) $(am__append_9) $(am__append_11) \
+	$(am__append_12) $(am__append_16)
 check_PROGRAMS_common = test-proc-info test-static-link \
 			test-strerror
 
+check_SCRIPTS_arch = $(am__append_2)
+check_SCRIPTS_cdep = $(am__append_8) $(am__append_13) $(am__append_15)
 check_SCRIPTS_common = run-check-namespace
-@REMOTE_ONLY_FALSE@check_SCRIPTS_cdep = run-ptrace-mapper \
-@REMOTE_ONLY_FALSE@	run-ptrace-misc $(am__append_2) \
-@REMOTE_ONLY_FALSE@	$(am__append_4)
-@REMOTE_ONLY_TRUE@check_SCRIPTS_cdep = $(am__append_2) $(am__append_4)
-@REMOTE_ONLY_FALSE@check_PROGRAMS_cdep = Gtest-bt Ltest-bt Gtest-exc \
-@REMOTE_ONLY_FALSE@	Ltest-exc Gtest-init Ltest-init \
-@REMOTE_ONLY_FALSE@	Gtest-concurrent Ltest-concurrent \
-@REMOTE_ONLY_FALSE@	Gtest-resume-sig Ltest-resume-sig \
-@REMOTE_ONLY_FALSE@	Gtest-resume-sig-rt Ltest-resume-sig-rt \
-@REMOTE_ONLY_FALSE@	Gtest-dyn1 Ltest-dyn1 Gtest-trace \
-@REMOTE_ONLY_FALSE@	Ltest-trace test-async-sig test-flush-cache \
-@REMOTE_ONLY_FALSE@	test-init-remote test-mem test-setjmp \
-@REMOTE_ONLY_FALSE@	test-ptrace Ltest-varargs Ltest-nomalloc \
-@REMOTE_ONLY_FALSE@	Ltest-nocalloc Lrs-race $(am__append_1)
-@REMOTE_ONLY_TRUE@check_PROGRAMS_cdep = $(am__append_1)
-@REMOTE_ONLY_FALSE@noinst_PROGRAMS_cdep = forker crasher mapper \
-@REMOTE_ONLY_FALSE@	test-ptrace-misc Gperf-simple Lperf-simple \
-@REMOTE_ONLY_FALSE@	Gperf-trace Lperf-trace $(am__append_3)
-@REMOTE_ONLY_TRUE@noinst_PROGRAMS_cdep = $(noinst_PROGRAMS_common) \
-@REMOTE_ONLY_TRUE@	$(am__append_3)
 @REMOTE_ONLY_FALSE@LIBUNWIND_local = $(top_builddir)/src/libunwind.la
-@ARCH_IA64_FALSE@@ARCH_PPC64_TRUE@@REMOTE_ONLY_FALSE@@USE_ALTIVEC_TRUE@noinst_PROGRAMS_arch = ppc64-test-altivec
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@noinst_PROGRAMS_arch = ia64-test-dyn1
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@check_SCRIPTS_arch = run-ia64-test-dyn1
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@check_PROGRAMS_arch = Gia64-test-stack Lia64-test-stack		\
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			Gia64-test-nat Lia64-test-nat			\
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			Gia64-test-rbs Lia64-test-rbs			\
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			Gia64-test-readonly Lia64-test-readonly		\
-@ARCH_IA64_TRUE@@REMOTE_ONLY_FALSE@			ia64-test-setjmp ia64-test-sig
-
 check_SCRIPTS = $(check_SCRIPTS_common) $(check_SCRIPTS_cdep) \
 		$(check_SCRIPTS_arch)
 
 TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
+
+# Use if arch defines but does not support PTRACE_SINGLESTEP
+# ptrace request used in the tests.
+XFAIL_TESTS_PTRACE_SINGLESTEP = run-ptrace-mapper run-ptrace-misc
 Lia64_test_readonly_SOURCES = Lia64-test-readonly.c ia64-test-readonly-asm.S
 Gia64_test_readonly_SOURCES = Gia64-test-readonly.c ia64-test-readonly-asm.S
 Lia64_test_stack_SOURCES = Lia64-test-stack.c ia64-test-stack-asm.S \
@@ -544,9 +923,16 @@ ia64_test_dyn1_SOURCES = ia64-test-dyn1.c ia64-dyn-asm.S flush-cache.S \
 				flush-cache.h
 
 ppc64_test_altivec_SOURCES = ppc64-test-altivec.c  ppc64-test-altivec-utils.c
+Gx64_test_dwarf_expressions_SOURCES = Gx64-test-dwarf-expressions.c \
+																			 x64-test-dwarf-expressions.S
+
+Lx64_test_dwarf_expressions_SOURCES = Lx64-test-dwarf-expressions.c \
+																			 x64-test-dwarf-expressions.S
+
 Gtest_init_SOURCES = Gtest-init.cxx
 Ltest_init_SOURCES = Ltest-init.cxx
 Ltest_cxx_exceptions_SOURCES = Ltest-cxx-exceptions.cxx
+Ltest_init_local_signal_SOURCES = Ltest-init-local-signal.c Ltest-init-local-signal-lib.c
 Gtest_dyn1_SOURCES = Gtest-dyn1.c flush-cache.S flush-cache.h
 Ltest_dyn1_SOURCES = Ltest-dyn1.c flush-cache.S flush-cache.h
 test_static_link_SOURCES = test-static-link-loc.c test-static-link-gen.c
@@ -559,6 +945,7 @@ Ltest_nomalloc_SOURCES = Ltest-nomalloc.c
 Ltest_nocalloc_SOURCES = Ltest-nocalloc.c
 Gtest_trace_SOURCES = Gtest-trace.c ident.c
 Ltest_trace_SOURCES = Ltest-trace.c ident.c
+Ltest_mem_validate_SOURCES = Ltest-mem-validate.c
 LIBUNWIND = $(top_builddir)/src/libunwind-$(arch).la
 LIBUNWIND_ptrace = $(top_builddir)/src/libunwind-ptrace.la
 LIBUNWIND_coredump = $(top_builddir)/src/libunwind-coredump.la
@@ -572,17 +959,19 @@ test_async_sig_LDADD = $(LIBUNWIND_local) -lpthread
 test_flush_cache_LDADD = $(LIBUNWIND_local)
 test_init_remote_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 test_mem_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
+test_reg_state_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 test_ptrace_LDADD = $(LIBUNWIND_ptrace) $(LIBUNWIND)
 test_proc_info_LDADD = $(LIBUNWIND)
 test_static_link_LDADD = $(LIBUNWIND)
 test_strerror_LDADD = $(LIBUNWIND)
 Lrs_race_LDADD = $(LIBUNWIND_local) -lpthread
 Ltest_varargs_LDADD = $(LIBUNWIND_local)
+Ltest_init_local_signal_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gtest_bt_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gtest_concurrent_LDADD = $(LIBUNWIND) $(LIBUNWIND_local) -lpthread
 Gtest_dyn1_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gtest_exc_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
-Gtest_init_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
+Gtest_init_LDADD = $(LIBUNWIND) $(LIBUNWIND_local) @BACKTRACELIB@
 Gtest_resume_sig_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gtest_resume_sig_rt_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gperf_simple_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
@@ -600,9 +989,10 @@ Ltest_resume_sig_rt_LDADD = $(LIBUNWIND_local)
 Lperf_simple_LDADD = $(LIBUNWIND_local)
 Ltest_trace_LDADD = $(LIBUNWIND_local)
 Lperf_trace_LDADD = $(LIBUNWIND_local)
+Ltest_mem_validate_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 test_setjmp_LDADD = $(LIBUNWIND_setjmp)
 ia64_test_setjmp_LDADD = $(LIBUNWIND_setjmp)
-@BUILD_COREDUMP_TRUE@test_coredump_unwind_LDADD = $(LIBUNWIND_coredump) $(LIBUNWIND)
+@BUILD_COREDUMP_TRUE@test_coredump_unwind_LDADD = $(LIBUNWIND_coredump) $(LIBUNWIND) @BACKTRACELIB@
 Gia64_test_nat_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gia64_test_stack_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
 Gia64_test_rbs_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
@@ -613,10 +1003,13 @@ Lia64_test_rbs_LDADD = $(LIBUNWIND_local)
 Lia64_test_readonly_LDADD = $(LIBUNWIND_local)
 ia64_test_dyn1_LDADD = $(LIBUNWIND)
 ia64_test_sig_LDADD = $(LIBUNWIND)
+ppc64_test_altivec_LDADD = $(LIBUNWIND)
+Gx64_test_dwarf_expressions_LDADD = $(LIBUNWIND) $(LIBUNWIND_local)
+Lx64_test_dwarf_expressions_LDADD = $(LIBUNWIND_local)
 all: all-am
 
 .SUFFIXES:
-.SUFFIXES: .S .c .cxx .lo .o .obj
+.SUFFIXES: .S .c .cxx .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
@@ -667,159 +1060,230 @@ clean-noinstPROGRAMS:
 	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
 	echo " rm -f" $$list; \
 	rm -f $$list
+
 Gia64-test-nat$(EXEEXT): $(Gia64_test_nat_OBJECTS) $(Gia64_test_nat_DEPENDENCIES) $(EXTRA_Gia64_test_nat_DEPENDENCIES) 
 	@rm -f Gia64-test-nat$(EXEEXT)
-	$(LINK) $(Gia64_test_nat_OBJECTS) $(Gia64_test_nat_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gia64_test_nat_OBJECTS) $(Gia64_test_nat_LDADD) $(LIBS)
+
 Gia64-test-rbs$(EXEEXT): $(Gia64_test_rbs_OBJECTS) $(Gia64_test_rbs_DEPENDENCIES) $(EXTRA_Gia64_test_rbs_DEPENDENCIES) 
 	@rm -f Gia64-test-rbs$(EXEEXT)
-	$(LINK) $(Gia64_test_rbs_OBJECTS) $(Gia64_test_rbs_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gia64_test_rbs_OBJECTS) $(Gia64_test_rbs_LDADD) $(LIBS)
+
 Gia64-test-readonly$(EXEEXT): $(Gia64_test_readonly_OBJECTS) $(Gia64_test_readonly_DEPENDENCIES) $(EXTRA_Gia64_test_readonly_DEPENDENCIES) 
 	@rm -f Gia64-test-readonly$(EXEEXT)
-	$(LINK) $(Gia64_test_readonly_OBJECTS) $(Gia64_test_readonly_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gia64_test_readonly_OBJECTS) $(Gia64_test_readonly_LDADD) $(LIBS)
+
 Gia64-test-stack$(EXEEXT): $(Gia64_test_stack_OBJECTS) $(Gia64_test_stack_DEPENDENCIES) $(EXTRA_Gia64_test_stack_DEPENDENCIES) 
 	@rm -f Gia64-test-stack$(EXEEXT)
-	$(LINK) $(Gia64_test_stack_OBJECTS) $(Gia64_test_stack_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gia64_test_stack_OBJECTS) $(Gia64_test_stack_LDADD) $(LIBS)
+
 Gperf-simple$(EXEEXT): $(Gperf_simple_OBJECTS) $(Gperf_simple_DEPENDENCIES) $(EXTRA_Gperf_simple_DEPENDENCIES) 
 	@rm -f Gperf-simple$(EXEEXT)
-	$(LINK) $(Gperf_simple_OBJECTS) $(Gperf_simple_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gperf_simple_OBJECTS) $(Gperf_simple_LDADD) $(LIBS)
+
 Gperf-trace$(EXEEXT): $(Gperf_trace_OBJECTS) $(Gperf_trace_DEPENDENCIES) $(EXTRA_Gperf_trace_DEPENDENCIES) 
 	@rm -f Gperf-trace$(EXEEXT)
-	$(LINK) $(Gperf_trace_OBJECTS) $(Gperf_trace_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gperf_trace_OBJECTS) $(Gperf_trace_LDADD) $(LIBS)
+
 Gtest-bt$(EXEEXT): $(Gtest_bt_OBJECTS) $(Gtest_bt_DEPENDENCIES) $(EXTRA_Gtest_bt_DEPENDENCIES) 
 	@rm -f Gtest-bt$(EXEEXT)
-	$(LINK) $(Gtest_bt_OBJECTS) $(Gtest_bt_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gtest_bt_OBJECTS) $(Gtest_bt_LDADD) $(LIBS)
+
 Gtest-concurrent$(EXEEXT): $(Gtest_concurrent_OBJECTS) $(Gtest_concurrent_DEPENDENCIES) $(EXTRA_Gtest_concurrent_DEPENDENCIES) 
 	@rm -f Gtest-concurrent$(EXEEXT)
-	$(LINK) $(Gtest_concurrent_OBJECTS) $(Gtest_concurrent_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gtest_concurrent_OBJECTS) $(Gtest_concurrent_LDADD) $(LIBS)
+
 Gtest-dyn1$(EXEEXT): $(Gtest_dyn1_OBJECTS) $(Gtest_dyn1_DEPENDENCIES) $(EXTRA_Gtest_dyn1_DEPENDENCIES) 
 	@rm -f Gtest-dyn1$(EXEEXT)
-	$(LINK) $(Gtest_dyn1_OBJECTS) $(Gtest_dyn1_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gtest_dyn1_OBJECTS) $(Gtest_dyn1_LDADD) $(LIBS)
+
 Gtest-exc$(EXEEXT): $(Gtest_exc_OBJECTS) $(Gtest_exc_DEPENDENCIES) $(EXTRA_Gtest_exc_DEPENDENCIES) 
 	@rm -f Gtest-exc$(EXEEXT)
-	$(LINK) $(Gtest_exc_OBJECTS) $(Gtest_exc_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gtest_exc_OBJECTS) $(Gtest_exc_LDADD) $(LIBS)
+
 Gtest-init$(EXEEXT): $(Gtest_init_OBJECTS) $(Gtest_init_DEPENDENCIES) $(EXTRA_Gtest_init_DEPENDENCIES) 
 	@rm -f Gtest-init$(EXEEXT)
-	$(CXXLINK) $(Gtest_init_OBJECTS) $(Gtest_init_LDADD) $(LIBS)
+	$(AM_V_CXXLD)$(CXXLINK) $(Gtest_init_OBJECTS) $(Gtest_init_LDADD) $(LIBS)
+
 Gtest-resume-sig$(EXEEXT): $(Gtest_resume_sig_OBJECTS) $(Gtest_resume_sig_DEPENDENCIES) $(EXTRA_Gtest_resume_sig_DEPENDENCIES) 
 	@rm -f Gtest-resume-sig$(EXEEXT)
-	$(LINK) $(Gtest_resume_sig_OBJECTS) $(Gtest_resume_sig_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gtest_resume_sig_OBJECTS) $(Gtest_resume_sig_LDADD) $(LIBS)
+
 Gtest-resume-sig-rt$(EXEEXT): $(Gtest_resume_sig_rt_OBJECTS) $(Gtest_resume_sig_rt_DEPENDENCIES) $(EXTRA_Gtest_resume_sig_rt_DEPENDENCIES) 
 	@rm -f Gtest-resume-sig-rt$(EXEEXT)
-	$(LINK) $(Gtest_resume_sig_rt_OBJECTS) $(Gtest_resume_sig_rt_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gtest_resume_sig_rt_OBJECTS) $(Gtest_resume_sig_rt_LDADD) $(LIBS)
+
 Gtest-trace$(EXEEXT): $(Gtest_trace_OBJECTS) $(Gtest_trace_DEPENDENCIES) $(EXTRA_Gtest_trace_DEPENDENCIES) 
 	@rm -f Gtest-trace$(EXEEXT)
-	$(LINK) $(Gtest_trace_OBJECTS) $(Gtest_trace_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Gtest_trace_OBJECTS) $(Gtest_trace_LDADD) $(LIBS)
+
+Gx64-test-dwarf-expressions$(EXEEXT): $(Gx64_test_dwarf_expressions_OBJECTS) $(Gx64_test_dwarf_expressions_DEPENDENCIES) $(EXTRA_Gx64_test_dwarf_expressions_DEPENDENCIES) 
+	@rm -f Gx64-test-dwarf-expressions$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(Gx64_test_dwarf_expressions_OBJECTS) $(Gx64_test_dwarf_expressions_LDADD) $(LIBS)
+
 Lia64-test-nat$(EXEEXT): $(Lia64_test_nat_OBJECTS) $(Lia64_test_nat_DEPENDENCIES) $(EXTRA_Lia64_test_nat_DEPENDENCIES) 
 	@rm -f Lia64-test-nat$(EXEEXT)
-	$(LINK) $(Lia64_test_nat_OBJECTS) $(Lia64_test_nat_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Lia64_test_nat_OBJECTS) $(Lia64_test_nat_LDADD) $(LIBS)
+
 Lia64-test-rbs$(EXEEXT): $(Lia64_test_rbs_OBJECTS) $(Lia64_test_rbs_DEPENDENCIES) $(EXTRA_Lia64_test_rbs_DEPENDENCIES) 
 	@rm -f Lia64-test-rbs$(EXEEXT)
-	$(LINK) $(Lia64_test_rbs_OBJECTS) $(Lia64_test_rbs_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Lia64_test_rbs_OBJECTS) $(Lia64_test_rbs_LDADD) $(LIBS)
+
 Lia64-test-readonly$(EXEEXT): $(Lia64_test_readonly_OBJECTS) $(Lia64_test_readonly_DEPENDENCIES) $(EXTRA_Lia64_test_readonly_DEPENDENCIES) 
 	@rm -f Lia64-test-readonly$(EXEEXT)
-	$(LINK) $(Lia64_test_readonly_OBJECTS) $(Lia64_test_readonly_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Lia64_test_readonly_OBJECTS) $(Lia64_test_readonly_LDADD) $(LIBS)
+
 Lia64-test-stack$(EXEEXT): $(Lia64_test_stack_OBJECTS) $(Lia64_test_stack_DEPENDENCIES) $(EXTRA_Lia64_test_stack_DEPENDENCIES) 
 	@rm -f Lia64-test-stack$(EXEEXT)
-	$(LINK) $(Lia64_test_stack_OBJECTS) $(Lia64_test_stack_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Lia64_test_stack_OBJECTS) $(Lia64_test_stack_LDADD) $(LIBS)
+
 Lperf-simple$(EXEEXT): $(Lperf_simple_OBJECTS) $(Lperf_simple_DEPENDENCIES) $(EXTRA_Lperf_simple_DEPENDENCIES) 
 	@rm -f Lperf-simple$(EXEEXT)
-	$(LINK) $(Lperf_simple_OBJECTS) $(Lperf_simple_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Lperf_simple_OBJECTS) $(Lperf_simple_LDADD) $(LIBS)
+
 Lperf-trace$(EXEEXT): $(Lperf_trace_OBJECTS) $(Lperf_trace_DEPENDENCIES) $(EXTRA_Lperf_trace_DEPENDENCIES) 
 	@rm -f Lperf-trace$(EXEEXT)
-	$(LINK) $(Lperf_trace_OBJECTS) $(Lperf_trace_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Lperf_trace_OBJECTS) $(Lperf_trace_LDADD) $(LIBS)
+
 Lrs-race$(EXEEXT): $(Lrs_race_OBJECTS) $(Lrs_race_DEPENDENCIES) $(EXTRA_Lrs_race_DEPENDENCIES) 
 	@rm -f Lrs-race$(EXEEXT)
-	$(LINK) $(Lrs_race_OBJECTS) $(Lrs_race_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Lrs_race_OBJECTS) $(Lrs_race_LDADD) $(LIBS)
+
 Ltest-bt$(EXEEXT): $(Ltest_bt_OBJECTS) $(Ltest_bt_DEPENDENCIES) $(EXTRA_Ltest_bt_DEPENDENCIES) 
 	@rm -f Ltest-bt$(EXEEXT)
-	$(LINK) $(Ltest_bt_OBJECTS) $(Ltest_bt_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_bt_OBJECTS) $(Ltest_bt_LDADD) $(LIBS)
+
 Ltest-concurrent$(EXEEXT): $(Ltest_concurrent_OBJECTS) $(Ltest_concurrent_DEPENDENCIES) $(EXTRA_Ltest_concurrent_DEPENDENCIES) 
 	@rm -f Ltest-concurrent$(EXEEXT)
-	$(LINK) $(Ltest_concurrent_OBJECTS) $(Ltest_concurrent_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_concurrent_OBJECTS) $(Ltest_concurrent_LDADD) $(LIBS)
+
 Ltest-cxx-exceptions$(EXEEXT): $(Ltest_cxx_exceptions_OBJECTS) $(Ltest_cxx_exceptions_DEPENDENCIES) $(EXTRA_Ltest_cxx_exceptions_DEPENDENCIES) 
 	@rm -f Ltest-cxx-exceptions$(EXEEXT)
-	$(CXXLINK) $(Ltest_cxx_exceptions_OBJECTS) $(Ltest_cxx_exceptions_LDADD) $(LIBS)
+	$(AM_V_CXXLD)$(CXXLINK) $(Ltest_cxx_exceptions_OBJECTS) $(Ltest_cxx_exceptions_LDADD) $(LIBS)
+
 Ltest-dyn1$(EXEEXT): $(Ltest_dyn1_OBJECTS) $(Ltest_dyn1_DEPENDENCIES) $(EXTRA_Ltest_dyn1_DEPENDENCIES) 
 	@rm -f Ltest-dyn1$(EXEEXT)
-	$(LINK) $(Ltest_dyn1_OBJECTS) $(Ltest_dyn1_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_dyn1_OBJECTS) $(Ltest_dyn1_LDADD) $(LIBS)
+
 Ltest-exc$(EXEEXT): $(Ltest_exc_OBJECTS) $(Ltest_exc_DEPENDENCIES) $(EXTRA_Ltest_exc_DEPENDENCIES) 
 	@rm -f Ltest-exc$(EXEEXT)
-	$(LINK) $(Ltest_exc_OBJECTS) $(Ltest_exc_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_exc_OBJECTS) $(Ltest_exc_LDADD) $(LIBS)
+
 Ltest-init$(EXEEXT): $(Ltest_init_OBJECTS) $(Ltest_init_DEPENDENCIES) $(EXTRA_Ltest_init_DEPENDENCIES) 
 	@rm -f Ltest-init$(EXEEXT)
-	$(CXXLINK) $(Ltest_init_OBJECTS) $(Ltest_init_LDADD) $(LIBS)
+	$(AM_V_CXXLD)$(CXXLINK) $(Ltest_init_OBJECTS) $(Ltest_init_LDADD) $(LIBS)
+
+Ltest-init-local-signal$(EXEEXT): $(Ltest_init_local_signal_OBJECTS) $(Ltest_init_local_signal_DEPENDENCIES) $(EXTRA_Ltest_init_local_signal_DEPENDENCIES) 
+	@rm -f Ltest-init-local-signal$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(Ltest_init_local_signal_OBJECTS) $(Ltest_init_local_signal_LDADD) $(LIBS)
+
+Ltest-mem-validate$(EXEEXT): $(Ltest_mem_validate_OBJECTS) $(Ltest_mem_validate_DEPENDENCIES) $(EXTRA_Ltest_mem_validate_DEPENDENCIES) 
+	@rm -f Ltest-mem-validate$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(Ltest_mem_validate_OBJECTS) $(Ltest_mem_validate_LDADD) $(LIBS)
+
 Ltest-nocalloc$(EXEEXT): $(Ltest_nocalloc_OBJECTS) $(Ltest_nocalloc_DEPENDENCIES) $(EXTRA_Ltest_nocalloc_DEPENDENCIES) 
 	@rm -f Ltest-nocalloc$(EXEEXT)
-	$(LINK) $(Ltest_nocalloc_OBJECTS) $(Ltest_nocalloc_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_nocalloc_OBJECTS) $(Ltest_nocalloc_LDADD) $(LIBS)
+
 Ltest-nomalloc$(EXEEXT): $(Ltest_nomalloc_OBJECTS) $(Ltest_nomalloc_DEPENDENCIES) $(EXTRA_Ltest_nomalloc_DEPENDENCIES) 
 	@rm -f Ltest-nomalloc$(EXEEXT)
-	$(LINK) $(Ltest_nomalloc_OBJECTS) $(Ltest_nomalloc_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_nomalloc_OBJECTS) $(Ltest_nomalloc_LDADD) $(LIBS)
+
 Ltest-resume-sig$(EXEEXT): $(Ltest_resume_sig_OBJECTS) $(Ltest_resume_sig_DEPENDENCIES) $(EXTRA_Ltest_resume_sig_DEPENDENCIES) 
 	@rm -f Ltest-resume-sig$(EXEEXT)
-	$(LINK) $(Ltest_resume_sig_OBJECTS) $(Ltest_resume_sig_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_resume_sig_OBJECTS) $(Ltest_resume_sig_LDADD) $(LIBS)
+
 Ltest-resume-sig-rt$(EXEEXT): $(Ltest_resume_sig_rt_OBJECTS) $(Ltest_resume_sig_rt_DEPENDENCIES) $(EXTRA_Ltest_resume_sig_rt_DEPENDENCIES) 
 	@rm -f Ltest-resume-sig-rt$(EXEEXT)
-	$(LINK) $(Ltest_resume_sig_rt_OBJECTS) $(Ltest_resume_sig_rt_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_resume_sig_rt_OBJECTS) $(Ltest_resume_sig_rt_LDADD) $(LIBS)
+
 Ltest-trace$(EXEEXT): $(Ltest_trace_OBJECTS) $(Ltest_trace_DEPENDENCIES) $(EXTRA_Ltest_trace_DEPENDENCIES) 
 	@rm -f Ltest-trace$(EXEEXT)
-	$(LINK) $(Ltest_trace_OBJECTS) $(Ltest_trace_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_trace_OBJECTS) $(Ltest_trace_LDADD) $(LIBS)
+
 Ltest-varargs$(EXEEXT): $(Ltest_varargs_OBJECTS) $(Ltest_varargs_DEPENDENCIES) $(EXTRA_Ltest_varargs_DEPENDENCIES) 
 	@rm -f Ltest-varargs$(EXEEXT)
-	$(LINK) $(Ltest_varargs_OBJECTS) $(Ltest_varargs_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(Ltest_varargs_OBJECTS) $(Ltest_varargs_LDADD) $(LIBS)
+
+Lx64-test-dwarf-expressions$(EXEEXT): $(Lx64_test_dwarf_expressions_OBJECTS) $(Lx64_test_dwarf_expressions_DEPENDENCIES) $(EXTRA_Lx64_test_dwarf_expressions_DEPENDENCIES) 
+	@rm -f Lx64-test-dwarf-expressions$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(Lx64_test_dwarf_expressions_OBJECTS) $(Lx64_test_dwarf_expressions_LDADD) $(LIBS)
+
 crasher$(EXEEXT): $(crasher_OBJECTS) $(crasher_DEPENDENCIES) $(EXTRA_crasher_DEPENDENCIES) 
 	@rm -f crasher$(EXEEXT)
-	$(LINK) $(crasher_OBJECTS) $(crasher_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(crasher_OBJECTS) $(crasher_LDADD) $(LIBS)
+
 forker$(EXEEXT): $(forker_OBJECTS) $(forker_DEPENDENCIES) $(EXTRA_forker_DEPENDENCIES) 
 	@rm -f forker$(EXEEXT)
-	$(forker_LINK) $(forker_OBJECTS) $(forker_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(forker_LINK) $(forker_OBJECTS) $(forker_LDADD) $(LIBS)
+
 ia64-test-dyn1$(EXEEXT): $(ia64_test_dyn1_OBJECTS) $(ia64_test_dyn1_DEPENDENCIES) $(EXTRA_ia64_test_dyn1_DEPENDENCIES) 
 	@rm -f ia64-test-dyn1$(EXEEXT)
-	$(LINK) $(ia64_test_dyn1_OBJECTS) $(ia64_test_dyn1_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(ia64_test_dyn1_OBJECTS) $(ia64_test_dyn1_LDADD) $(LIBS)
+
 ia64-test-setjmp$(EXEEXT): $(ia64_test_setjmp_OBJECTS) $(ia64_test_setjmp_DEPENDENCIES) $(EXTRA_ia64_test_setjmp_DEPENDENCIES) 
 	@rm -f ia64-test-setjmp$(EXEEXT)
-	$(LINK) $(ia64_test_setjmp_OBJECTS) $(ia64_test_setjmp_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(ia64_test_setjmp_OBJECTS) $(ia64_test_setjmp_LDADD) $(LIBS)
+
 ia64-test-sig$(EXEEXT): $(ia64_test_sig_OBJECTS) $(ia64_test_sig_DEPENDENCIES) $(EXTRA_ia64_test_sig_DEPENDENCIES) 
 	@rm -f ia64-test-sig$(EXEEXT)
-	$(LINK) $(ia64_test_sig_OBJECTS) $(ia64_test_sig_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(ia64_test_sig_OBJECTS) $(ia64_test_sig_LDADD) $(LIBS)
+
 mapper$(EXEEXT): $(mapper_OBJECTS) $(mapper_DEPENDENCIES) $(EXTRA_mapper_DEPENDENCIES) 
 	@rm -f mapper$(EXEEXT)
-	$(LINK) $(mapper_OBJECTS) $(mapper_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(mapper_OBJECTS) $(mapper_LDADD) $(LIBS)
+
 ppc64-test-altivec$(EXEEXT): $(ppc64_test_altivec_OBJECTS) $(ppc64_test_altivec_DEPENDENCIES) $(EXTRA_ppc64_test_altivec_DEPENDENCIES) 
 	@rm -f ppc64-test-altivec$(EXEEXT)
-	$(LINK) $(ppc64_test_altivec_OBJECTS) $(ppc64_test_altivec_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(ppc64_test_altivec_OBJECTS) $(ppc64_test_altivec_LDADD) $(LIBS)
+
 test-async-sig$(EXEEXT): $(test_async_sig_OBJECTS) $(test_async_sig_DEPENDENCIES) $(EXTRA_test_async_sig_DEPENDENCIES) 
 	@rm -f test-async-sig$(EXEEXT)
-	$(LINK) $(test_async_sig_OBJECTS) $(test_async_sig_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_async_sig_OBJECTS) $(test_async_sig_LDADD) $(LIBS)
+
 test-coredump-unwind$(EXEEXT): $(test_coredump_unwind_OBJECTS) $(test_coredump_unwind_DEPENDENCIES) $(EXTRA_test_coredump_unwind_DEPENDENCIES) 
 	@rm -f test-coredump-unwind$(EXEEXT)
-	$(LINK) $(test_coredump_unwind_OBJECTS) $(test_coredump_unwind_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_coredump_unwind_OBJECTS) $(test_coredump_unwind_LDADD) $(LIBS)
+
 test-flush-cache$(EXEEXT): $(test_flush_cache_OBJECTS) $(test_flush_cache_DEPENDENCIES) $(EXTRA_test_flush_cache_DEPENDENCIES) 
 	@rm -f test-flush-cache$(EXEEXT)
-	$(LINK) $(test_flush_cache_OBJECTS) $(test_flush_cache_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_flush_cache_OBJECTS) $(test_flush_cache_LDADD) $(LIBS)
+
 test-init-remote$(EXEEXT): $(test_init_remote_OBJECTS) $(test_init_remote_DEPENDENCIES) $(EXTRA_test_init_remote_DEPENDENCIES) 
 	@rm -f test-init-remote$(EXEEXT)
-	$(LINK) $(test_init_remote_OBJECTS) $(test_init_remote_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_init_remote_OBJECTS) $(test_init_remote_LDADD) $(LIBS)
+
 test-mem$(EXEEXT): $(test_mem_OBJECTS) $(test_mem_DEPENDENCIES) $(EXTRA_test_mem_DEPENDENCIES) 
 	@rm -f test-mem$(EXEEXT)
-	$(LINK) $(test_mem_OBJECTS) $(test_mem_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_mem_OBJECTS) $(test_mem_LDADD) $(LIBS)
+
 test-proc-info$(EXEEXT): $(test_proc_info_OBJECTS) $(test_proc_info_DEPENDENCIES) $(EXTRA_test_proc_info_DEPENDENCIES) 
 	@rm -f test-proc-info$(EXEEXT)
-	$(LINK) $(test_proc_info_OBJECTS) $(test_proc_info_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_proc_info_OBJECTS) $(test_proc_info_LDADD) $(LIBS)
+
 test-ptrace$(EXEEXT): $(test_ptrace_OBJECTS) $(test_ptrace_DEPENDENCIES) $(EXTRA_test_ptrace_DEPENDENCIES) 
 	@rm -f test-ptrace$(EXEEXT)
-	$(LINK) $(test_ptrace_OBJECTS) $(test_ptrace_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_ptrace_OBJECTS) $(test_ptrace_LDADD) $(LIBS)
+
 test-ptrace-misc$(EXEEXT): $(test_ptrace_misc_OBJECTS) $(test_ptrace_misc_DEPENDENCIES) $(EXTRA_test_ptrace_misc_DEPENDENCIES) 
 	@rm -f test-ptrace-misc$(EXEEXT)
-	$(LINK) $(test_ptrace_misc_OBJECTS) $(test_ptrace_misc_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_ptrace_misc_OBJECTS) $(test_ptrace_misc_LDADD) $(LIBS)
+
+test-reg-state$(EXEEXT): $(test_reg_state_OBJECTS) $(test_reg_state_DEPENDENCIES) $(EXTRA_test_reg_state_DEPENDENCIES) 
+	@rm -f test-reg-state$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(test_reg_state_OBJECTS) $(test_reg_state_LDADD) $(LIBS)
+
 test-setjmp$(EXEEXT): $(test_setjmp_OBJECTS) $(test_setjmp_DEPENDENCIES) $(EXTRA_test_setjmp_DEPENDENCIES) 
 	@rm -f test-setjmp$(EXEEXT)
-	$(LINK) $(test_setjmp_OBJECTS) $(test_setjmp_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_setjmp_OBJECTS) $(test_setjmp_LDADD) $(LIBS)
+
 test-static-link$(EXEEXT): $(test_static_link_OBJECTS) $(test_static_link_DEPENDENCIES) $(EXTRA_test_static_link_DEPENDENCIES) 
 	@rm -f test-static-link$(EXEEXT)
-	$(test_static_link_LINK) $(test_static_link_OBJECTS) $(test_static_link_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(test_static_link_LINK) $(test_static_link_OBJECTS) $(test_static_link_LDADD) $(LIBS)
+
 test-strerror$(EXEEXT): $(test_strerror_OBJECTS) $(test_strerror_DEPENDENCIES) $(EXTRA_test_strerror_DEPENDENCIES) 
 	@rm -f test-strerror$(EXEEXT)
-	$(LINK) $(test_strerror_OBJECTS) $(test_strerror_LDADD) $(LIBS)
+	$(AM_V_CCLD)$(LINK) $(test_strerror_OBJECTS) $(test_strerror_LDADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -841,6 +1305,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Gtest-resume-sig-rt.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Gtest-resume-sig.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Gtest-trace.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Gx64-test-dwarf-expressions.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Lia64-test-nat.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Lia64-test-rbs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Lia64-test-readonly.Po@am__quote@
@@ -853,13 +1318,17 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-cxx-exceptions.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-dyn1.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-exc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-init-local-signal-lib.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-init-local-signal.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-init.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-mem-validate.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-nocalloc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-nomalloc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-resume-sig-rt.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-resume-sig.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-trace.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ltest-varargs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Lx64-test-dwarf-expressions.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/crasher.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flush-cache.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/forker.Po@am__quote@
@@ -883,82 +1352,84 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-proc-info.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-ptrace-misc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-ptrace.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-reg-state.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-setjmp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-static-link-gen.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-static-link-loc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test-strerror.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/x64-test-dwarf-expressions.Po@am__quote@
 
 .S.o:
-@am__fastdepCCAS_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
 @am__fastdepCCAS_TRUE@	$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCCAS_FALSE@	$(CPPASCOMPILE) -c -o $@ $<
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ $<
 
 .S.obj:
-@am__fastdepCCAS_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
 @am__fastdepCCAS_TRUE@	$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
 @am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCCAS_FALSE@	$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 .S.lo:
-@am__fastdepCCAS_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
 @am__fastdepCCAS_TRUE@	$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCCAS_FALSE@	$(LTCPPASCOMPILE) -c -o $@ $<
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(LTCPPASCOMPILE) -c -o $@ $<
 
 .c.o:
-@am__fastdepCC_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c -o $@ $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
 
 .c.obj:
-@am__fastdepCC_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
 @am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 .c.lo:
-@am__fastdepCC_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
 @am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
 
 .cxx.o:
-@am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
 @am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCXX_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
 
 .cxx.obj:
-@am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
 @am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
 @am__fastdepCXX_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
 .cxx.lo:
-@am__fastdepCXX_TRUE@	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
 @am__fastdepCXX_TRUE@	$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCXX_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ $<
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
 
 mostlyclean-libtool:
 	-rm -f *.lo
@@ -966,26 +1437,15 @@ mostlyclean-libtool:
 clean-libtool:
 	-rm -rf .libs _libs
 
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
 	set x; \
 	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	$(am__define_uniq_tagged_files); \
 	shift; \
 	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
@@ -997,15 +1457,11 @@ TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 	      $$unique; \
 	  fi; \
 	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
 	test -z "$(CTAGS_ARGS)$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$unique
@@ -1014,102 +1470,537 @@ GTAGS:
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-check-TESTS: $(TESTS)
-	@failed=0; all=0; xfail=0; xpass=0; skip=0; \
-	srcdir=$(srcdir); export srcdir; \
-	list=' $(TESTS) '; \
-	$(am__tty_colors); \
-	if test -n "$$list"; then \
-	  for tst in $$list; do \
-	    if test -f ./$$tst; then dir=./; \
-	    elif test -f $$tst; then dir=; \
-	    else dir="$(srcdir)/"; fi; \
-	    if $(TESTS_ENVIRONMENT) $${dir}$$tst; then \
-	      all=`expr $$all + 1`; \
-	      case " $(XFAIL_TESTS) " in \
-	      *[\ \	]$$tst[\ \	]*) \
-		xpass=`expr $$xpass + 1`; \
-		failed=`expr $$failed + 1`; \
-		col=$$red; res=XPASS; \
-	      ;; \
-	      *) \
-		col=$$grn; res=PASS; \
-	      ;; \
-	      esac; \
-	    elif test $$? -ne 77; then \
-	      all=`expr $$all + 1`; \
-	      case " $(XFAIL_TESTS) " in \
-	      *[\ \	]$$tst[\ \	]*) \
-		xfail=`expr $$xfail + 1`; \
-		col=$$lgn; res=XFAIL; \
-	      ;; \
-	      *) \
-		failed=`expr $$failed + 1`; \
-		col=$$red; res=FAIL; \
-	      ;; \
-	      esac; \
-	    else \
-	      skip=`expr $$skip + 1`; \
-	      col=$$blu; res=SKIP; \
-	    fi; \
-	    echo "$${col}$$res$${std}: $$tst"; \
-	  done; \
-	  if test "$$all" -eq 1; then \
-	    tests="test"; \
-	    All=""; \
-	  else \
-	    tests="tests"; \
-	    All="All "; \
+# Recover from deleted '.trs' file; this should ensure that
+# "rm -f foo.log; make foo.trs" re-run 'foo.test', and re-create
+# both 'foo.log' and 'foo.trs'.  Break the recipe in two subshells
+# to avoid problems with "make -n".
+.log.trs:
+	rm -f $< $@
+	$(MAKE) $(AM_MAKEFLAGS) $<
+
+# Leading 'am--fnord' is there to ensure the list of targets does not
+# expand to empty, as could happen e.g. with make check TESTS=''.
+am--fnord $(TEST_LOGS) $(TEST_LOGS:.log=.trs): $(am__force_recheck)
+am--force-recheck:
+	@:
+
+$(TEST_SUITE_LOG): $(TEST_LOGS)
+	@$(am__set_TESTS_bases); \
+	am__f_ok () { test -f "$$1" && test -r "$$1"; }; \
+	redo_bases=`for i in $$bases; do \
+	              am__f_ok $$i.trs && am__f_ok $$i.log || echo $$i; \
+	            done`; \
+	if test -n "$$redo_bases"; then \
+	  redo_logs=`for i in $$redo_bases; do echo $$i.log; done`; \
+	  redo_results=`for i in $$redo_bases; do echo $$i.trs; done`; \
+	  if $(am__make_dryrun); then :; else \
+	    rm -f $$redo_logs && rm -f $$redo_results || exit 1; \
 	  fi; \
-	  if test "$$failed" -eq 0; then \
-	    if test "$$xfail" -eq 0; then \
-	      banner="$$All$$all $$tests passed"; \
-	    else \
-	      if test "$$xfail" -eq 1; then failures=failure; else failures=failures; fi; \
-	      banner="$$All$$all $$tests behaved as expected ($$xfail expected $$failures)"; \
-	    fi; \
-	  else \
-	    if test "$$xpass" -eq 0; then \
-	      banner="$$failed of $$all $$tests failed"; \
+	fi; \
+	if test -n "$$am__remaking_logs"; then \
+	  echo "fatal: making $(TEST_SUITE_LOG): possible infinite" \
+	       "recursion detected" >&2; \
+	else \
+	  am__remaking_logs=yes $(MAKE) $(AM_MAKEFLAGS) $$redo_logs; \
+	fi; \
+	if $(am__make_dryrun); then :; else \
+	  st=0;  \
+	  errmsg="fatal: making $(TEST_SUITE_LOG): failed to create"; \
+	  for i in $$redo_bases; do \
+	    test -f $$i.trs && test -r $$i.trs \
+	      || { echo "$$errmsg $$i.trs" >&2; st=1; }; \
+	    test -f $$i.log && test -r $$i.log \
+	      || { echo "$$errmsg $$i.log" >&2; st=1; }; \
+	  done; \
+	  test $$st -eq 0 || exit 1; \
+	fi
+	@$(am__sh_e_setup); $(am__tty_colors); $(am__set_TESTS_bases); \
+	ws='[ 	]'; \
+	results=`for b in $$bases; do echo $$b.trs; done`; \
+	test -n "$$results" || results=/dev/null; \
+	all=`  grep "^$$ws*:test-result:"           $$results | wc -l`; \
+	pass=` grep "^$$ws*:test-result:$$ws*PASS"  $$results | wc -l`; \
+	fail=` grep "^$$ws*:test-result:$$ws*FAIL"  $$results | wc -l`; \
+	skip=` grep "^$$ws*:test-result:$$ws*SKIP"  $$results | wc -l`; \
+	xfail=`grep "^$$ws*:test-result:$$ws*XFAIL" $$results | wc -l`; \
+	xpass=`grep "^$$ws*:test-result:$$ws*XPASS" $$results | wc -l`; \
+	error=`grep "^$$ws*:test-result:$$ws*ERROR" $$results | wc -l`; \
+	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
+	  success=true; \
+	else \
+	  success=false; \
+	fi; \
+	br='==================='; br=$$br$$br$$br$$br; \
+	result_count () \
+	{ \
+	    if test x"$$1" = x"--maybe-color"; then \
+	      maybe_colorize=yes; \
+	    elif test x"$$1" = x"--no-color"; then \
+	      maybe_colorize=no; \
 	    else \
-	      if test "$$xpass" -eq 1; then passes=pass; else passes=passes; fi; \
-	      banner="$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)"; \
+	      echo "$@: invalid 'result_count' usage" >&2; exit 4; \
 	    fi; \
-	  fi; \
-	  dashes="$$banner"; \
-	  skipped=""; \
-	  if test "$$skip" -ne 0; then \
-	    if test "$$skip" -eq 1; then \
-	      skipped="($$skip test was not run)"; \
+	    shift; \
+	    desc=$$1 count=$$2; \
+	    if test $$maybe_colorize = yes && test $$count -gt 0; then \
+	      color_start=$$3 color_end=$$std; \
 	    else \
-	      skipped="($$skip tests were not run)"; \
+	      color_start= color_end=; \
 	    fi; \
-	    test `echo "$$skipped" | wc -c` -le `echo "$$banner" | wc -c` || \
-	      dashes="$$skipped"; \
-	  fi; \
-	  report=""; \
-	  if test "$$failed" -ne 0 && test -n "$(PACKAGE_BUGREPORT)"; then \
-	    report="Please report to $(PACKAGE_BUGREPORT)"; \
-	    test `echo "$$report" | wc -c` -le `echo "$$banner" | wc -c` || \
-	      dashes="$$report"; \
-	  fi; \
-	  dashes=`echo "$$dashes" | sed s/./=/g`; \
-	  if test "$$failed" -eq 0; then \
-	    col="$$grn"; \
-	  else \
-	    col="$$red"; \
-	  fi; \
-	  echo "$${col}$$dashes$${std}"; \
-	  echo "$${col}$$banner$${std}"; \
-	  test -z "$$skipped" || echo "$${col}$$skipped$${std}"; \
-	  test -z "$$report" || echo "$${col}$$report$${std}"; \
-	  echo "$${col}$$dashes$${std}"; \
-	  test "$$failed" -eq 0; \
-	else :; fi
+	    echo "$${color_start}# $$desc $$count$${color_end}"; \
+	}; \
+	create_testsuite_report () \
+	{ \
+	  result_count $$1 "TOTAL:" $$all   "$$brg"; \
+	  result_count $$1 "PASS: " $$pass  "$$grn"; \
+	  result_count $$1 "SKIP: " $$skip  "$$blu"; \
+	  result_count $$1 "XFAIL:" $$xfail "$$lgn"; \
+	  result_count $$1 "FAIL: " $$fail  "$$red"; \
+	  result_count $$1 "XPASS:" $$xpass "$$red"; \
+	  result_count $$1 "ERROR:" $$error "$$mgn"; \
+	}; \
+	{								\
+	  echo "$(PACKAGE_STRING): $(subdir)/$(TEST_SUITE_LOG)" |	\
+	    $(am__rst_title);						\
+	  create_testsuite_report --no-color;				\
+	  echo;								\
+	  echo ".. contents:: :depth: 2";				\
+	  echo;								\
+	  for b in $$bases; do echo $$b; done				\
+	    | $(am__create_global_log);					\
+	} >$(TEST_SUITE_LOG).tmp || exit 1;				\
+	mv $(TEST_SUITE_LOG).tmp $(TEST_SUITE_LOG);			\
+	if $$success; then						\
+	  col="$$grn";							\
+	 else								\
+	  col="$$red";							\
+	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
+	fi;								\
+	echo "$${col}$$br$${std}"; 					\
+	echo "$${col}Testsuite summary for $(PACKAGE_STRING)$${std}";	\
+	echo "$${col}$$br$${std}"; 					\
+	create_testsuite_report --maybe-color;				\
+	echo "$$col$$br$$std";						\
+	if $$success; then :; else					\
+	  echo "$${col}See $(subdir)/$(TEST_SUITE_LOG)$${std}";		\
+	  if test -n "$(PACKAGE_BUGREPORT)"; then			\
+	    echo "$${col}Please report to $(PACKAGE_BUGREPORT)$${std}";	\
+	  fi;								\
+	  echo "$$col$$br$$std";					\
+	fi;								\
+	$$success || exit 1
+
+check-TESTS:
+	@list='$(RECHECK_LOGS)';           test -z "$$list" || rm -f $$list
+	@list='$(RECHECK_LOGS:.log=.trs)'; test -z "$$list" || rm -f $$list
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	trs_list=`for i in $$bases; do echo $$i.trs; done`; \
+	log_list=`echo $$log_list`; trs_list=`echo $$trs_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) TEST_LOGS="$$log_list"; \
+	exit $$?;
+recheck: all $(check_PROGRAMS) $(check_SCRIPTS)
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	bases=`for i in $$bases; do echo $$i; done \
+	         | $(am__list_recheck_tests)` || exit 1; \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	log_list=`echo $$log_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) \
+	        am__force_recheck=am--force-recheck \
+	        TEST_LOGS="$$log_list"; \
+	exit $$?
+test-proc-info.log: test-proc-info$(EXEEXT)
+	@p='test-proc-info$(EXEEXT)'; \
+	b='test-proc-info'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-static-link.log: test-static-link$(EXEEXT)
+	@p='test-static-link$(EXEEXT)'; \
+	b='test-static-link'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-strerror.log: test-strerror$(EXEEXT)
+	@p='test-strerror$(EXEEXT)'; \
+	b='test-strerror'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-bt.log: Gtest-bt$(EXEEXT)
+	@p='Gtest-bt$(EXEEXT)'; \
+	b='Gtest-bt'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-bt.log: Ltest-bt$(EXEEXT)
+	@p='Ltest-bt$(EXEEXT)'; \
+	b='Ltest-bt'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-exc.log: Gtest-exc$(EXEEXT)
+	@p='Gtest-exc$(EXEEXT)'; \
+	b='Gtest-exc'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-exc.log: Ltest-exc$(EXEEXT)
+	@p='Ltest-exc$(EXEEXT)'; \
+	b='Ltest-exc'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-init.log: Gtest-init$(EXEEXT)
+	@p='Gtest-init$(EXEEXT)'; \
+	b='Gtest-init'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-init.log: Ltest-init$(EXEEXT)
+	@p='Ltest-init$(EXEEXT)'; \
+	b='Ltest-init'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-concurrent.log: Gtest-concurrent$(EXEEXT)
+	@p='Gtest-concurrent$(EXEEXT)'; \
+	b='Gtest-concurrent'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-concurrent.log: Ltest-concurrent$(EXEEXT)
+	@p='Ltest-concurrent$(EXEEXT)'; \
+	b='Ltest-concurrent'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-resume-sig.log: Gtest-resume-sig$(EXEEXT)
+	@p='Gtest-resume-sig$(EXEEXT)'; \
+	b='Gtest-resume-sig'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-resume-sig.log: Ltest-resume-sig$(EXEEXT)
+	@p='Ltest-resume-sig$(EXEEXT)'; \
+	b='Ltest-resume-sig'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-resume-sig-rt.log: Gtest-resume-sig-rt$(EXEEXT)
+	@p='Gtest-resume-sig-rt$(EXEEXT)'; \
+	b='Gtest-resume-sig-rt'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-resume-sig-rt.log: Ltest-resume-sig-rt$(EXEEXT)
+	@p='Ltest-resume-sig-rt$(EXEEXT)'; \
+	b='Ltest-resume-sig-rt'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-trace.log: Gtest-trace$(EXEEXT)
+	@p='Gtest-trace$(EXEEXT)'; \
+	b='Gtest-trace'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-trace.log: Ltest-trace$(EXEEXT)
+	@p='Ltest-trace$(EXEEXT)'; \
+	b='Ltest-trace'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-init-local-signal.log: Ltest-init-local-signal$(EXEEXT)
+	@p='Ltest-init-local-signal$(EXEEXT)'; \
+	b='Ltest-init-local-signal'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-mem-validate.log: Ltest-mem-validate$(EXEEXT)
+	@p='Ltest-mem-validate$(EXEEXT)'; \
+	b='Ltest-mem-validate'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-async-sig.log: test-async-sig$(EXEEXT)
+	@p='test-async-sig$(EXEEXT)'; \
+	b='test-async-sig'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-flush-cache.log: test-flush-cache$(EXEEXT)
+	@p='test-flush-cache$(EXEEXT)'; \
+	b='test-flush-cache'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-init-remote.log: test-init-remote$(EXEEXT)
+	@p='test-init-remote$(EXEEXT)'; \
+	b='test-init-remote'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-mem.log: test-mem$(EXEEXT)
+	@p='test-mem$(EXEEXT)'; \
+	b='test-mem'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-reg-state.log: test-reg-state$(EXEEXT)
+	@p='test-reg-state$(EXEEXT)'; \
+	b='test-reg-state'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-varargs.log: Ltest-varargs$(EXEEXT)
+	@p='Ltest-varargs$(EXEEXT)'; \
+	b='Ltest-varargs'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-nomalloc.log: Ltest-nomalloc$(EXEEXT)
+	@p='Ltest-nomalloc$(EXEEXT)'; \
+	b='Ltest-nomalloc'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-nocalloc.log: Ltest-nocalloc$(EXEEXT)
+	@p='Ltest-nocalloc$(EXEEXT)'; \
+	b='Ltest-nocalloc'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Lrs-race.log: Lrs-race$(EXEEXT)
+	@p='Lrs-race$(EXEEXT)'; \
+	b='Lrs-race'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-ptrace.log: test-ptrace$(EXEEXT)
+	@p='test-ptrace$(EXEEXT)'; \
+	b='test-ptrace'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test-setjmp.log: test-setjmp$(EXEEXT)
+	@p='test-setjmp$(EXEEXT)'; \
+	b='test-setjmp'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-cxx-exceptions.log: Ltest-cxx-exceptions$(EXEEXT)
+	@p='Ltest-cxx-exceptions$(EXEEXT)'; \
+	b='Ltest-cxx-exceptions'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gtest-dyn1.log: Gtest-dyn1$(EXEEXT)
+	@p='Gtest-dyn1$(EXEEXT)'; \
+	b='Gtest-dyn1'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Ltest-dyn1.log: Ltest-dyn1$(EXEEXT)
+	@p='Ltest-dyn1$(EXEEXT)'; \
+	b='Ltest-dyn1'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gia64-test-stack.log: Gia64-test-stack$(EXEEXT)
+	@p='Gia64-test-stack$(EXEEXT)'; \
+	b='Gia64-test-stack'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Lia64-test-stack.log: Lia64-test-stack$(EXEEXT)
+	@p='Lia64-test-stack$(EXEEXT)'; \
+	b='Lia64-test-stack'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gia64-test-nat.log: Gia64-test-nat$(EXEEXT)
+	@p='Gia64-test-nat$(EXEEXT)'; \
+	b='Gia64-test-nat'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Lia64-test-nat.log: Lia64-test-nat$(EXEEXT)
+	@p='Lia64-test-nat$(EXEEXT)'; \
+	b='Lia64-test-nat'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gia64-test-rbs.log: Gia64-test-rbs$(EXEEXT)
+	@p='Gia64-test-rbs$(EXEEXT)'; \
+	b='Gia64-test-rbs'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Lia64-test-rbs.log: Lia64-test-rbs$(EXEEXT)
+	@p='Lia64-test-rbs$(EXEEXT)'; \
+	b='Lia64-test-rbs'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gia64-test-readonly.log: Gia64-test-readonly$(EXEEXT)
+	@p='Gia64-test-readonly$(EXEEXT)'; \
+	b='Gia64-test-readonly'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Lia64-test-readonly.log: Lia64-test-readonly$(EXEEXT)
+	@p='Lia64-test-readonly$(EXEEXT)'; \
+	b='Lia64-test-readonly'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+ia64-test-setjmp.log: ia64-test-setjmp$(EXEEXT)
+	@p='ia64-test-setjmp$(EXEEXT)'; \
+	b='ia64-test-setjmp'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+ia64-test-sig.log: ia64-test-sig$(EXEEXT)
+	@p='ia64-test-sig$(EXEEXT)'; \
+	b='ia64-test-sig'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Gx64-test-dwarf-expressions.log: Gx64-test-dwarf-expressions$(EXEEXT)
+	@p='Gx64-test-dwarf-expressions$(EXEEXT)'; \
+	b='Gx64-test-dwarf-expressions'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+Lx64-test-dwarf-expressions.log: Lx64-test-dwarf-expressions$(EXEEXT)
+	@p='Lx64-test-dwarf-expressions$(EXEEXT)'; \
+	b='Lx64-test-dwarf-expressions'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+run-check-namespace.log: run-check-namespace
+	@p='run-check-namespace'; \
+	b='run-check-namespace'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+run-ptrace-mapper.log: run-ptrace-mapper
+	@p='run-ptrace-mapper'; \
+	b='run-ptrace-mapper'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+run-ptrace-misc.log: run-ptrace-misc
+	@p='run-ptrace-misc'; \
+	b='run-ptrace-misc'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+run-coredump-unwind.log: run-coredump-unwind
+	@p='run-coredump-unwind'; \
+	b='run-coredump-unwind'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+run-coredump-unwind-mdi.log: run-coredump-unwind-mdi
+	@p='run-coredump-unwind-mdi'; \
+	b='run-coredump-unwind-mdi'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+run-ia64-test-dyn1.log: run-ia64-test-dyn1
+	@p='run-ia64-test-dyn1'; \
+	b='run-ia64-test-dyn1'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+.test.log:
+	@p='$<'; \
+	$(am__set_b); \
+	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+@am__EXEEXT_TRUE@.test$(EXEEXT).log:
+@am__EXEEXT_TRUE@	@p='$<'; \
+@am__EXEEXT_TRUE@	$(am__set_b); \
+@am__EXEEXT_TRUE@	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+@am__EXEEXT_TRUE@	--log-file $$b.log --trs-file $$b.trs \
+@am__EXEEXT_TRUE@	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+@am__EXEEXT_TRUE@	"$$tst" $(AM_TESTS_FD_REDIRECT)
 
 distdir: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
@@ -1167,6 +2058,9 @@ install-strip:
 	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
 	fi
 mostlyclean-generic:
+	-test -z "$(TEST_LOGS)" || rm -f $(TEST_LOGS)
+	-test -z "$(TEST_LOGS:.log=.trs)" || rm -f $(TEST_LOGS:.log=.trs)
+	-test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
 
 clean-generic:
 
@@ -1251,19 +2145,20 @@ uninstall-am:
 
 .MAKE: check-am install-am install-strip
 
-.PHONY: CTAGS GTAGS all all-am check check-TESTS check-am clean \
+.PHONY: CTAGS GTAGS TAGS all all-am check check-TESTS check-am clean \
 	clean-checkPROGRAMS clean-generic clean-libtool \
-	clean-noinstPROGRAMS ctags distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
-	installcheck installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am
+	clean-noinstPROGRAMS cscopelist-am ctags ctags-am distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am recheck tags tags-am uninstall \
+	uninstall-am
 
 
 @REMOTE_ONLY_TRUE@perf:
diff --git a/tests/check-namespace.sh.in b/tests/check-namespace.sh.in
index d2e6efb..5ed94fd 100644
--- a/tests/check-namespace.sh.in
+++ b/tests/check-namespace.sh.in
@@ -88,6 +88,8 @@ filter_misc () {
 }
 
 check_local_unw_abi () {
+    match _UL${plat}_apply_reg_state
+    match _UL${plat}_reg_states_iterate
     match _UL${plat}_create_addr_space
     match _UL${plat}_destroy_addr_space
     match _UL${plat}_get_fpreg
@@ -97,12 +99,13 @@ check_local_unw_abi () {
     match _UL${plat}_get_reg
     match _UL${plat}_get_save_loc
     match _UL${plat}_init_local
+    match _UL${plat}_init_local2
     match _UL${plat}_init_remote
     match _UL${plat}_is_signal_frame
-    match _UL${plat}_handle_signal_frame
     match _UL${plat}_local_addr_space
     match _UL${plat}_resume
     match _UL${plat}_set_caching_policy
+    match _UL${plat}_set_cache_size
     match _UL${plat}_set_reg
     match _UL${plat}_set_fpreg
     match _UL${plat}_step
@@ -123,6 +126,7 @@ check_local_unw_abi () {
     case ${plat} in
 	arm)
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_is_fpreg
 	    match _UL${plat}_search_unwind_table
 	    match _UL${plat}_dwarf_search_unwind_table
@@ -132,20 +136,24 @@ check_local_unw_abi () {
 	    match _UL${plat}_dwarf_search_unwind_table
 	    match _UL${plat}_dwarf_find_unwind_table
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_setcontext
 	    ;;
 	ia64)
 	    match _UL${plat}_search_unwind_table
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    ;;
 	x86)
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_is_fpreg
 	    match _UL${plat}_dwarf_search_unwind_table
 	    match _UL${plat}_dwarf_find_unwind_table
 	    ;;
 	x86_64)
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_is_fpreg
 	    match _UL${plat}_dwarf_search_unwind_table
 	    match _UL${plat}_dwarf_find_unwind_table
@@ -154,10 +162,29 @@ check_local_unw_abi () {
 	ppc*)
 	    match _U${plat}_get_func_addr
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_is_fpreg
 	    match _UL${plat}_dwarf_search_unwind_table
 	    match _UL${plat}_dwarf_find_unwind_table
 	    ;;
+        tilegx)
+            match _U${plat}_is_fpreg
+	    match _UL${plat}_dwarf_search_unwind_table
+	    match _UL${plat}_dwarf_find_unwind_table
+            match _UL${plat}_local_addr_space_init
+            match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
+            match ${plat}_lock
+            ;;
+	s390x)
+	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
+	    match _U${plat}_is_fpreg
+	    match _UL${plat}_dwarf_search_unwind_table
+	    match _UL${plat}_dwarf_find_unwind_table
+	    match _U${plat}_setcontext
+	    ;;
+
 	*)
 	    match _U${plat}_is_fpreg
 	    match _UL${plat}_dwarf_search_unwind_table
@@ -172,6 +199,8 @@ check_local_unw_abi () {
 }
 
 check_generic_unw_abi () {
+    match _U${plat}_apply_reg_state
+    match _U${plat}_reg_states_iterate
     match _U${plat}_create_addr_space
     match _U${plat}_destroy_addr_space
     match _U${plat}_flush_cache
@@ -183,13 +212,14 @@ check_generic_unw_abi () {
     match _U${plat}_get_reg
     match _U${plat}_get_save_loc
     match _U${plat}_init_local
+    match _U${plat}_init_local2
     match _U${plat}_init_remote
     match _U${plat}_is_signal_frame
-    match _U${plat}_handle_signal_frame
     match _U${plat}_local_addr_space
     match _U${plat}_regname
     match _U${plat}_resume
     match _U${plat}_set_caching_policy
+    match _U${plat}_set_cache_size
     match _U${plat}_set_fpreg
     match _U${plat}_set_reg
     match _U${plat}_step
@@ -199,6 +229,7 @@ check_generic_unw_abi () {
 	arm)
 	    match _U${plat}_is_fpreg
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_search_unwind_table
 	    match _U${plat}_dwarf_search_unwind_table
 	    match _U${plat}_dwarf_find_unwind_table
@@ -207,12 +238,14 @@ check_generic_unw_abi () {
 	    match _U${plat}_dwarf_search_unwind_table
 	    match _U${plat}_dwarf_find_unwind_table
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    ;;
 	ia64)
 	    match _U${plat}_search_unwind_table
 	    match _U${plat}_find_dyn_list
 	    if [ $plat = $build_plat ]; then
 		match _U${plat}_get_elf_image
+		match _U${plat}_get_exe_image_path
 		case $os in
 		    linux*)
 			match _U${plat}_get_kernel_table
@@ -222,23 +255,42 @@ check_generic_unw_abi () {
 	    ;;
 	x86)
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_is_fpreg
 	    match _U${plat}_dwarf_search_unwind_table
 	    match _U${plat}_dwarf_find_unwind_table
 	    ;;
 	x86_64)
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_is_fpreg
 	    match _U${plat}_dwarf_search_unwind_table
 	    match _U${plat}_dwarf_find_unwind_table
 	    ;;
 	ppc*)
 	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
 	    match _U${plat}_get_func_addr
 	    match _U${plat}_is_fpreg
 	    match _U${plat}_dwarf_search_unwind_table
 	    match _U${plat}_dwarf_find_unwind_table
 	    ;;
+        tilegx)
+            match _U${plat}_dwarf_search_unwind_table
+	    match _U${plat}_dwarf_find_unwind_table
+            match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
+            match _U${plat}_is_fpreg
+            match _U${plat}_local_addr_space_init
+            match ${plat}_lock
+            ;;
+	s390x)
+	    match _U${plat}_is_fpreg
+	    match _U${plat}_get_elf_image
+	    match _U${plat}_get_exe_image_path
+	    match _U${plat}_dwarf_search_unwind_table
+	    match _U${plat}_dwarf_find_unwind_table
+	    ;;
 	*)
 	    match _U${plat}_is_fpreg
 	    match _U${plat}_dwarf_search_unwind_table
diff --git a/tests/crasher.c b/tests/crasher.c
index 24c7805..9df5709 100644
--- a/tests/crasher.c
+++ b/tests/crasher.c
@@ -87,6 +87,11 @@ write_maps(char *fname)
 #endif
 
 #ifdef __GNUC__
+#ifndef __clang__
+// Gcc >= 8 became too good at inlining aliase c into b when using -O2 or -O3,
+// so force -O1 in all cases, otherwise a frame will be missing in the tests.
+#pragma GCC optimize "-O1"
+#endif
 int c(int x) NOINLINE ALIAS(b);
 #define compiler_barrier() asm volatile("");
 #else
diff --git a/tests/flush-cache.S b/tests/flush-cache.S
index 6d51449..3ee4726 100644
--- a/tests/flush-cache.S
+++ b/tests/flush-cache.S
@@ -77,7 +77,21 @@ flush_cache:
 	.globl flush_cache
 flush_cache:
 	bx    lr
+#elif defined(__tilegx__)
+        .text
+        .globl flush_cache
+flush_cache:
 
+        andi r0, r0, -64
+1:      {
+         flush r0 ;
+         addi  r0, r0, 64
+        }
+        {
+         bgtz r1, 1b ;
+         addi r1, r1, -64
+        }
+        jrp   lr
 #else
 # error Need flush_cache code for this architecture.
 #endif
diff --git a/tests/mapper.c b/tests/mapper.c
index 905f319..b47ae78 100644
--- a/tests/mapper.c
+++ b/tests/mapper.c
@@ -39,6 +39,9 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 #if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
 # define MAP_ANONYMOUS MAP_ANON
 #endif
+#if !defined(MAP_NORESERVE)
+# define MAP_NORESERVE 0
+#endif
 
 int
 main (void)
@@ -52,7 +55,11 @@ main (void)
   for (n = 0; n < 30000; ++n)
     {
       if (mmap (NULL, 1, (n & 1) ? PROT_READ : PROT_WRITE,
-		MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE,
+		MAP_PRIVATE | MAP_ANONYMOUS
+#ifdef MAP_NORESERVE
+		| MAP_NORESERVE
+#endif
+		,
 		-1, 0) == MAP_FAILED)
 	{
 	  printf ("Failed after %ld successful maps\n", n - 1);
diff --git a/tests/run-coredump-unwind-mdi b/tests/run-coredump-unwind-mdi
index 6b7f0c1..d0a315b 100755
--- a/tests/run-coredump-unwind-mdi
+++ b/tests/run-coredump-unwind-mdi
@@ -5,4 +5,4 @@
 # it is tested using the coredump accessors. For more info about MiniDebugInfo
 # see e.g. http://fedoraproject.org/wiki/Features/MiniDebugInfo
 
-./run-coredump-unwind -minidebuginfo
+${0%/*}/run-coredump-unwind -minidebuginfo
diff --git a/tests/test-coredump-unwind.c b/tests/test-coredump-unwind.c
index 5254708..5349823 100644
--- a/tests/test-coredump-unwind.c
+++ b/tests/test-coredump-unwind.c
@@ -137,7 +137,7 @@ static void verror_msg_helper(const char *s,
   if (flags & LOGMODE_STDIO)
     {
       fflush(stdout);
-      used += write(STDERR_FILENO, msg, used + msgeol_len);
+      write(STDERR_FILENO, msg, used + msgeol_len);
     }
   msg[used] = '\0'; /* remove msg_eol (usually "\n") */
   if (flags & LOGMODE_SYSLOG)
@@ -314,7 +314,7 @@ main(int argc UNUSED, char **argv)
   while (*argv)
     {
       char *colon;
-      long vaddr = strtol(*argv, &colon, 16);
+      unsigned long vaddr = strtoul(*argv, &colon, 16);
       if (*colon != ':')
         error_msg_and_die("Bad format: '%s'", *argv);
       if (_UCD_add_backing_file_at_vaddr(ui, vaddr, colon + 1) < 0)
diff --git a/tests/test-flush-cache.c b/tests/test-flush-cache.c
index 592162c..1611cf4 100644
--- a/tests/test-flush-cache.c
+++ b/tests/test-flush-cache.c
@@ -46,6 +46,7 @@ f257 (void)
     for (i = 0; i < n; ++i)
       printf ("[%d] ip=%p\n", i, buffer[i]);
 
+  unw_set_cache_size (unw_local_addr_space, 1023, 0);
   unw_flush_cache (unw_local_addr_space, 0, 0);
 
   if (verbose)
diff --git a/tests/test-ptrace.c b/tests/test-ptrace.c
index 942b0db..e7c7883 100644
--- a/tests/test-ptrace.c
+++ b/tests/test-ptrace.c
@@ -182,6 +182,11 @@ main (int argc, char **argv)
 
       /* automated test case */
       argv = args;
+
+      /* Unless the args array is 'walked' the child
+         process is unable to access it and dies with a segfault */
+      fprintf(stderr, "Automated test (%s,%s,%s,%s)\n",
+              args[0],args[1],args[2],args[3]);
     }
   else if (argc > 1)
     while (argv[optind][0] == '-')
@@ -303,9 +308,17 @@ main (int argc, char **argv)
 	    {
 	      do_backtrace ();
 #if HAVE_DECL_PTRACE_SINGLESTEP
-	      ptrace (PTRACE_SINGLESTEP, target_pid, 0, pending_sig);
+	      if (ptrace (PTRACE_SINGLESTEP, target_pid, 0, pending_sig) < 0)
+          {
+            panic ("ptrace(PTRACE_SINGLESTEP) failed (errno=%d)\n", errno);
+            killed = 1;
+          }
 #elif HAVE_DECL_PT_STEP
-	      ptrace (PT_STEP, target_pid, (caddr_t)1, pending_sig);
+	      if (ptrace (PT_STEP, target_pid, (caddr_t)1, pending_sig) < 0)
+          {
+            panic ("ptrace(PT_STEP) failed (errno=%d)\n", errno);
+            killed = 1;
+          }
 #else
 #error Singlestep me
 #endif
diff --git a/tests/test-reg-state.c b/tests/test-reg-state.c
new file mode 100644
index 0000000..ac713ea
--- /dev/null
+++ b/tests/test-reg-state.c
@@ -0,0 +1,133 @@
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2003-2004 Hewlett-Packard Co
+	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+This file is part of libunwind.
+
+Copyright (c) 2003 Hewlett-Packard Co.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include "compiler.h"
+
+#include <libunwind.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/mman.h>
+#include <sys/resource.h>
+
+#define panic(args...)				\
+	{ fprintf (stderr, args); exit (-1); }
+
+int verbose;
+
+struct cb_data
+{
+  unw_word_t ip;
+  void* reg_state;
+  size_t len;
+};
+
+static int
+dwarf_reg_states_callback(void *token,
+			  void *rs,
+			  size_t size,
+			  unw_word_t start_ip, unw_word_t end_ip)
+{
+  struct cb_data *data = token;
+  if (start_ip <= data->ip && data->ip < end_ip)
+    {
+      data->reg_state = mmap(NULL, size, PROT_READ | PROT_WRITE,
+			     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+      memcpy(data->reg_state, rs, size);
+      data->len = size;
+    }
+  return 0;
+}
+
+static void
+do_backtrace (void)
+{
+  unw_cursor_t cursor;
+  unw_word_t ip, sp;
+  unw_context_t uc;
+  int ret;
+
+  unw_getcontext (&uc);
+  if (unw_init_local (&cursor, &uc) < 0)
+    panic ("unw_init_local failed!\n");
+
+  do
+    {
+      unw_get_reg (&cursor, UNW_REG_IP, &ip);
+      unw_get_reg (&cursor, UNW_REG_SP, &sp);
+
+      if (verbose)
+	printf ("%016lx (sp=%016lx)\n", (long) ip, (long) sp);
+
+      struct cb_data data = {.ip = ip, .reg_state = NULL};
+      ret = unw_reg_states_iterate(&cursor, dwarf_reg_states_callback, &data);
+      if (ret > 0)
+	{
+	  ret = unw_apply_reg_state (&cursor, data.reg_state);
+	  munmap(data.reg_state, data.len);
+	}
+      if (ret < 0)
+	{
+	  unw_get_reg (&cursor, UNW_REG_IP, &ip);
+	  panic ("FAILURE: unw_step() returned %d for ip=%lx\n",
+		 ret, (long) ip);
+	}
+    }
+  while (ret > 0);
+}
+
+int
+consume_some_stack_space (void)
+{
+  unw_cursor_t cursor;
+  unw_context_t uc;
+  char string[1024];
+
+  memset (&cursor, 0, sizeof (cursor));
+  memset (&uc, 0, sizeof (uc));
+  return sprintf (string, "hello %p %p\n", &cursor, &uc);
+}
+
+int
+main (int argc, char **argv UNUSED)
+{
+  struct rlimit rlim;
+
+  verbose = argc > 1;
+
+  if (consume_some_stack_space () > 9999)
+    exit (-1);	/* can't happen, but don't let the compiler know... */
+
+  rlim.rlim_cur = 0;
+  rlim.rlim_max = RLIM_INFINITY;
+  setrlimit (RLIMIT_DATA, &rlim);
+
+  do_backtrace ();
+  return 0;
+}
diff --git a/tests/test-static-link-gen.c b/tests/test-static-link-gen.c
index 3246416..d61e7a5 100644
--- a/tests/test-static-link-gen.c
+++ b/tests/test-static-link-gen.c
@@ -43,6 +43,7 @@ static void *funcs[] =
     (void *) &unw_get_accessors,
     (void *) &unw_flush_cache,
     (void *) &unw_set_caching_policy,
+    (void *) &unw_set_cache_size,
     (void *) &unw_regname,
     (void *) &unw_get_proc_info,
     (void *) &unw_get_save_loc,
diff --git a/tests/test-static-link-loc.c b/tests/test-static-link-loc.c
index 4e47e45..1c7aa03 100644
--- a/tests/test-static-link-loc.c
+++ b/tests/test-static-link-loc.c
@@ -61,6 +61,7 @@ static void *funcs[] =
     (void *) &unw_get_accessors,
     (void *) &unw_flush_cache,
     (void *) &unw_set_caching_policy,
+    (void *) &unw_set_cache_size,
     (void *) &unw_regname,
     (void *) &unw_get_proc_info,
     (void *) &unw_get_save_loc,
diff --git a/tests/x64-test-dwarf-expressions.S b/tests/x64-test-dwarf-expressions.S
new file mode 100644
index 0000000..f275625
--- /dev/null
+++ b/tests/x64-test-dwarf-expressions.S
@@ -0,0 +1,78 @@
+.global DW_CFA_expression_testcase
+
+.extern recover_register
+
+.text
+
+# CFI expressions were added in DWARF v3 to allow compilers to specify memory
+# locations or register values using DWARF programs. These programs are simple
+# stack-based operations which allow the compiler to encode integer mathematics
+# and other complex logic. CFI expressions are therefore more powerful than the
+# conventional register + offset schemes.
+#
+# These tests capture a bug we have fixed in libunwind. CFI expression programs
+# always start with the current CFA pushed onto the stack. This file contains a
+# pair of routines which test CFI expression parsing. Specifically they test
+# DW_CFA_expression logic, which uses DWARF expressions to compute the address
+# where a non-volatile register was stored.
+#
+# Main calls DW_CFA_expression_testcase, which sets up known state in a
+# non-volatile (caller-saved) register. We use r12 for this purpose. After this
+# DW_CFA_expression_testcase then calls DW_CFA_expression_inner, which clobbers
+# r12 after stashing its value on the stack. This routine contains a DWARF3 CFI
+# expression to restore the value of r12 on unwind which should allow libunwind
+# to recover clobbered state. DW_CFA_expression_inner calls recover_register to
+# retrieve the cached register value. This function recovers the register value
+# by using libunwind to unwind the stack through DW_CFA_expression_inner and up
+# to the call site in DW_CFA_expression_testcase. If our expression is correct,
+# libunwind will be able to restore r12 from the stack.
+#
+# BE CAREFUL WITH rdi, rsi, rax HERE! The arguments to recover_register are
+# passed in via rdi, rsi and I just let them flow through unchanged. Similarly
+# RAX flows back unchanged. Adding any function calls to the below may clobber
+# these registers and cause this test to fail mysteriously.
+
+
+########################################################
+# Test: Restoring a register using a DW_CFA_expression #
+# which uses implicit CFA pushed onto stack.           #
+########################################################
+
+.type DW_CFA_expression_testcase STT_FUNC
+DW_CFA_expression_testcase:
+  .cfi_startproc
+  push %r12
+  .cfi_adjust_cfa_offset 8
+  # Move our sentinel (known) value into non-volatile (Callee-saved) r12
+  mov $111222333, %r12
+  .cfi_rel_offset %r12, 0
+  call DW_CFA_expression_inner
+  pop %r12
+  .cfi_restore %r12
+  .cfi_adjust_cfa_offset -8
+  ret
+  .cfi_endproc
+.size DW_CFA_expression_testcase,.-DW_CFA_expression_testcase
+
+.type DW_CFA_expression_inner STT_FUNC
+DW_CFA_expression_inner:
+  .cfi_startproc
+  push %r12
+  .cfi_adjust_cfa_offset 8
+  # !! IMPORTANT BIT !! The test is all about how we parse the following bytes.
+  # Now we use an expression to describe where our sentinel value is stored:
+  # DW_CFA_expression(0x10), r12(0x0c), Length(0x02),        (preamble)
+  # DW_OP_lit16(0x40), DW_OP_minus(0x1c)                     (instructions)
+  # Parsing starts with the CFA on the stack, then pushes 16, then does a minus
+  # which is eqivalent to a=pop(), b=pop(), push(b-a), leaving us with a value
+  # of cfa-16 (cfa points at old rsp, cfa-8 is our rip, so we stored r12 at
+  # cfa-16).
+  xor %r12, %r12                             # Trash r12
+  .cfi_escape 0x10, 0x0c, 0x2, 0x40, 0x1c   # DW_CFA_expression for recovery
+  call recover_register
+  pop %r12
+  .cfi_restore %r12
+  .cfi_adjust_cfa_offset -8
+  ret
+  .cfi_endproc
+.size DW_CFA_expression_inner,.-DW_CFA_expression_inner
-- 
2.7.4

